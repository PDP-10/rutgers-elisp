


                                ELISP

                        A Large Address Space
                          Implementation of

                                 LISP

                               for the

                             DECSYSTEM-20







                          Copyright (c) 1981
                          Charles L. Hedrick

This  software  is  furnished  under  an agreement for mutual software
exchange, and may be used and copied only in accordance with the terms
of such agreement and  with  the  inclusion  of  the  above  copyright
notice.  This software or any other copies thereof may not be provided
or  otherwise  made  available  to  any  other person.  No title to an
ownership of the software is hereby transferred.

The information in this software is subject to change  without  notice
and  should  not  be  construed  as a commitment by Charles Hedrick or
Rutgers University.

Note:    The  following  are  trademarks  of  the  Digital   Equipment
Corporation:  DECSYSTEM-20, Tops-20, Tops-10, PDP-10
                                                                     i


                          Table of Contents


1. What is ELISP?                                                    1

2. Historical notes and Acknowledgments                              3

3. The scope of this Manual                                          4

3.1. Summary of Chapters in the Descriptive Section                  5

4. The basic syntax of Lisp                                          8

5. The Basic Semantics of Lisp                                      12

5.1. Quote                                                          15
5.2. Function constants: LAMBDA forms                               16
5.3. A preliminary description of EVAL                              17

6. Other function types and forms                                   20

6.1. FEXPR                                                          20
6.2. LEXPR                                                          21
6.3. MACRO                                                          22
6.4. SUBR's                                                         23
6.5. LABEL                                                          24
6.6. FUNARG                                                         24

7. Behavior of the Interpreter                                      25

7.1. Functions that Invoke the Interpreter                          28

8. Functions Dealing with Lists and CONS Cells                      30

8.1. Constructing Lists Incrementally - Adding a member             35
8.2. Constructing a Whole List at Once                              36
8.3. Combining Existing Lists                                       37
8.4. Modifying Existing Lists                                       37
8.5. Getting Parts of a List                                        38
8.6. Testing Lists or Finding Properties of Them                    39
8.7. A-lists                                                        40
8.8. Template instantiation facility                                40

9. Tests, loops, and other program control; Errors                  42

9.1. Basic Control Constructs                                       42
9.2. Mapping functions                                              43
9.3. PROG                                                           44
9.4. Non-local Transfers of Control                                 44
9.5. The Single Stepper                                             44
                                                                    ii


10. Boolean functions (Predicates)                                  45

10.1. AND, OR, and NOT                                              45
10.2. Comparisons                                                   45
10.3. Types and Properties                                          47
10.4. Membership and Subset Tests                                   48
10.5. Functions for Treating Integers as Bits                       49

11. I/O                                                             50

11.1. Basic output functions                                        51
11.2. Nicer looking output                                          52
11.3. Basic input function                                          55
11.4. Dealing with individual characters                            56
11.5. How to modify the syntax: Readmacros                          57
11.6. More modifications of the syntax:  MODCHR                     58
11.7. Loading and saving definitions from files                     59
     11.7.1. How LOADF and SAVEF keep track of files and            60
             functions
     11.7.2. Summary of functions                                   61
11.8. Basic file I/O                                                62
11.9. More general file I/O                                         65
11.10. Terminal handling                                            66
11.11. I/O Functions Present only for Compatibility                 67

12. Atoms                                                           68

12.1. Tests for Atoms                                               69
12.2. The PNAME                                                     70
12.3. Values                                                        70
12.4. Function definitions                                          71
12.5. Property lists                                                72
12.6. Interning                                                     72

13. Numbers                                                         73

13.1. Tests                                                         73
13.2. Basic Arithmetic Operations                                   74
13.3. Other Numerical Functions                                     74
13.4. The arithmetic package                                        74
13.5. Numerical I/O - A Couple of Oddities                          76

14. Characters and Strings                                          77

15. Properties                                                      78

16. Arrays and vectors                                              79

17. Structures                                                      83
                                                                   iii


18. System functions and the Garbage Collector                      86

18.1. Functions for building your own EMACS interface               86

19. The Prettyprinter                                               88

19.1. Simple use of the prettyprinter                               88
19.2. Prettyprint Commands                                          89
19.3. Printmacros                                                   90
19.4. Comments                                                      92

20. The Help System                                                 94

20.1. Creating help                                                 94
20.2. Functions for use with the help system                        95

21. Debugging Facilities                                            96

21.1. Introduction                                                  96
21.2. The single stepper                                           101
21.3. BREAK1                                                       101
21.4. WHAT YOU CAN DO IN A BREAK                                   103
     21.4.1. Break Commands                                        103
     21.4.2. Context Commands                                      105
     21.4.3. Backtrace Commands                                    108
     21.4.4. Breakmacros                                           109
21.5. BREAK PACKAGE                                                110
     21.5.1. How To Set A Break                                    110
     21.5.2. BREAK                                                 110
     21.5.3. TRACE                                                 111
     21.5.4. BREAKIN                                               111
     21.5.5. UNBREAK                                               113
     21.5.6. UNTRACE                                               113
     21.5.7. BREAK0 [FN WHEN COMS]                                 113
21.6. ERROR PACKAGE                                                114
     21.6.1. Introduction                                          114
     21.6.2. Commands                                              115

22. The LISP Editor                                                117

22.1. Contents                                                     117
22.2. Introduction                                                 117
22.3. Commands for the New User                                    123
22.4. Attention Changing Commands                                  126
22.5. Local Attention-Changing Commands                            126
22.6. Commands That Search                                         130
22.7. Search Algorithm                                             132
22.8. search commands                                              133
22.9. Location Specification                                       135
22.10. Commands That Save and Restore the Edit Chain               138
                                                                    iv


22.11. Commands That Modify Structure                              140
22.12. Implementation of Structure Modification Commands           140
22.13. The A,B,: Commands                                          142
22.14. Form Oriented Editing and the Role of UP                    144
22.15. Extract and Embed                                           145
22.16. The MOVE Command                                            147
22.17. Commands That "Move Parentheses"                            149
22.18. TO and THRU                                                 151
22.19. Commands That Print                                         154
22.20. Commands That Evaluate                                      155
22.21. Commands That Test                                          157
22.22. Macros                                                      158
22.23. Miscellaneous Commands                                      160
22.24. UNDO                                                        163
22.25. Editdefault                                                 165
22.26. Editor Functions                                            166

23. The Compiler                                                   170

23.1. The Special Variable Problem                                 170
23.2. The Function Declaration Problem                             172
23.3. Special Considerations Involving MACRO's                     173
23.4. Summary - How to Use the Compiler                            174
23.5. Special forms for the compiler                               175
23.6. Other problems with compilation                              176

24. The Evaluation Context Stack                                   178

24.1. A-lists as Contexts                                          179

25. Descriptions of the Individual Functions                       180

26. Notes for hackers                                              258

26.1. Use of DDT                                                   258
26.2. Writing assembly language functions                          259
                                                                     v


                            List of Tables


Table 21-1:   Break Package Command Summary
                                                                     1


                          1. What is ELISP?



ELISP  is  an  implementation of Rutgers/UCI Lisp for Tops-20 systems.
It uses extended addressing, which gives  it  a  much  larger  address
space  than conventional PDP-10 Lisps.  ELISP runs only on Model B KL-
10 processors running Tops-20 release 4 or later.    That  is  because
extended  addressing  is  only  implemented  for  those  systems.   In
particular, ELISP does not run on Tops-10, on older 2040's and  2050's
(those  with  Model  A  CPU's),  or  on  2020's. The assembly-language
portion of Lisp has been completely reimplemented.  The parts  written
in Lisp have been kept unchanged to the extent that this is possible.

Since  ELISP  is based on Stanford's Lisp 1.6, this means that it is a
shallow-binding Lisp.  It stores  atom  bindings  in  a  "value  cell"
associated  with  the  atom,  saving old bindings on a pushdown stack.
List cells take two words, each containing one object.  All objects in
this implementation consist of 3 fields:

   - high order bit is used by the garbage collector for marking.
     It is normally off (for extended addressing to work).

   - next 5 bits are a type code, used internally by the system.

   - last 30 bits are the data for the object.    In  most  cases
     this  is  the address of the object itself.  However in some
     cases the actual object fits in 30 bits, and no  pointer  is
     needed.  E.g. we have 30-bit integer constants.

Atoms   consist  of  7-word  blocks  of  memory,  with  the  following
structure:

     value cell - read by EVAL, set by SET and SETQ

     pointer to property list - read by GET and PLIST, set by PUTPROP

     string pointer to pname - read by PRINT and EXPLODE, set by  READ
          and READLIST

     function  definition,  or  NIL  if  none - read by FUNDEF, set by
          ALIAS

     other internal information involving function definitions  -  set
          by ALIAS, not directly visible to the user

In  Lisp 1.6, the property list was accessible as the CDR of the atom,
and the rest of these items were on the property list.    This  is  no
longer true in ELISP.

This  version of Lisp is somewhat more type oriented than older Lisps.
Older Lisps represented numbers by funny structures made out  of  CONS
cells,  etc.  Here there are typed pointers, so these funny structures
are not needed.  The major way this will be visible is that characters
and I/O channels are  separate  types,  which  can't  be  read  in  or
                                                                     2


printed.    They  are  for  internal  use only.  All you can do with a
channel is save it for later use in  SELECTIN,  SELECTOUT,  or  CLOSE.
Note  that  NIL may be used where a channel is called for.  It will be
interpreted as the user's terminal (actually  the  monitor's  "primary
input" or "primary output").
                                                                     3


               2. Historical notes and Acknowledgments



This version of Lisp is based on the work of many other people.

It began its life at the Artificial Intelligence Project at MIT.

John Allen and Lynn Quam, then at Stanford University, rewrote most of
it,  forming  Lisp  1.6,  with the help of others, including Whitfield
Diffie and Marilyn Mullins.

UCI Lisp was formed by adding a large number  of  user  facilities  to
Lisp  1.6,  improving  its  structure at the same time.  This work was
done at the University of California at  Irvine.    This  project  was
under  the  direction  of Robert Bobrow.  Daryle Lewis did much of the
work of preparing that version.  Other major participants were Richard
Burton, Jeff Jacobs, Bill Earl, Whitfield Diffie, Rodger,  Knaus,  and
Alan Bell.

Many  of  the  facilities of UCI Lisp were imported from BBN Lisp (now
called Interlisp), so the designers, implementers, and documentors  of
BBN  Lisp  should  get  considerable  credit  for the user facilities.
Particularly important are Daniel Bobrow and Warren Teitelman.

Rutgers/UCI Lisp was produced by Rick Lefaivre of Rutgers  University.
It  consists  of  a  number of bug fixes and internal improvements, as
well as a few new user functions.

Elisp involves a complete recoding of the assembly  language  part  of
Lisp.  This recoding was done by Charles Hedrick.  The user facilities
and  many  of  the  functions are Lisp code that was simply moved from
R/UCI Lisp without change.  The compiler was developed by John S. Hall
at Rutgers.  It is a somewhat modified version of  the  Standard  Lisp
compiler  from  the University of Utah.  We have received considerable
help from the people at Utah, particularly Martin Griss.

The help system was supplied by Michael Smith  at  the  University  of
Texas.
                                                                     4


                     3. The scope of this Manual



This manual has two pieces:

   - a   descriptive/tutorial   section,   describing  the  major
     features of  the  system,  and  refering  to  the  functions
     releveant to each feature

   - a  reference section, describing all of the functions, tags,
     and other objects, in alphabetical order

The descriptive/tutorial section comes first, and consists of a number
of chapters organized by topic.  In general, the  chapters  describing
the  language  itself  come  first,  and then the chapters on the user
environment, such as debugging and editing facilities.  The  reference
section  comes  second,  and  consists  of  sections  describing  each
function,  organized  alphabetically.    This  section  includes  only
functions  designed  to  be  called  from  user programs, not internal
functions within the user environment facilities.

This manual is designed to be used in any of the following ways:

   - If you want to learn about Lisp, or some particular topic in
     it, you  should  read  the  appropriate  chapter(s)  in  the
     descriptive/tutorial section.  The first two chapters, which
     cover  the  basic  syntax and semantics, are prerequisite to
     everything else.  The other chapters are  designed  to  make
     sense independently.

   - If  you  need some a function to do something, you should be
     able to find it by using  the  descriptive  section.    This
     section  is  organized  in  a  sort  of tree structure, with
     actual functions forming the leaves of the tree.  By looking
     at the descriptions at each level of the tree, you should be
     able to find the section which is likely to  list  functions
     that  will  do  what  you  need.   Note that the descriptive
     section does not always give enough detail about a  function
     for  you  to  be  able  to  use  it.   Once you have found a
     function that seems relevant, you should look it up  in  the
     alphabetical  reference section, to find the exact arguments
     and other details.  In a number of cases, the same  function
     is  listed  in more than one place, if it appears that users
     might look for it under more than one  category.    The  top
     level of the tree is the following chapter summary.

   - If  you  want to know what a given function does, look it up
     in the alphabetical  reference  section.    Howver  in  some
     cases,  you  may  need to look in the appropriate chapter in
     the descriptive section to get enough background information
     to understand what the function is about.
                                                                     5


3.1. Summary of Chapters in the Descriptive Section


This  summary  forms the top node of the summary tree.  If you need to
find a piece of information,  this  section  should  give  you  enough
guidance  that  you  will  be  able  to  find the chapter it is in.  A
similar summary near the beginning of each chapter will guide  you  to
the specific section in the chapter.

     The  basic syntax of Lisp - This is primarily a tutorial chapter,
          introducing the new user to the way programs  are  expressed
          in  Lisp.   However it is also useful as reference material,
          because it documents the precise syntax of  atoms,  numbers,
          and the other basic constituents of Lisp.

     The  basic  semantics  of  Lisp  -  This  is primarily a tutorial
          chapter, introducing the way  functions  and  other  objects
          work  in  Lisp.  It is essentially an explanation of the way
          EVAL works.   Experienced  Lisp  programmers  will  probably
          prefer to look up EVAL in the reference section.

     Other function types and forms - This finishes the description of
          functional objects in Lisp, describing types of objects that
          are  not used as commonly, and are probably not of immediate
          interest to beginners.    This  includes  FEXPR's,  LEXPR's,
          MACRO's,   compiled   forms,   and   the  LABEL  and  FUNARG
          constructs.

     Behavior of the Interpreter - This is an overall  description  of
          the  way  the Lisp system interacts with the user.  It is of
          interest to both beginners and those familiar  with  another
          version of Lisp who want to know how this version works.  It
          includes  descriptions  of  the basic READ-EVAL-PRINT loop -
          with  which  the  user  normally  interacts,  the  interrupt
          characters,  how  to  set  up  your own top level, how to do
          automatic initialization through a  file  or  function,  and
          behavior of the system after certain errors.

     Functions  and  Predicates  Dealing with Lists and CONS - This is
          the first of the chapters  describing  the  functions.    It
          describes  all  of  the  functions  designed to be used with
          lists and CONS cells, both constructed them and using them.

     Tests,  loops,  and  other  program  control;  Error  handling  -
          describes  forms  that  are  used  for program control, e.g.
          tests and loops.  Error  handling  will  be  included  here,
          since  error  handling  in  Lisp  is  essentially  non-local
          program control.

     Boolean functions (Predicates) - describes all of  the  functions
          that   return   True   or  False,  including  basic  Boolean
          functions, comparisons, and tests of various sorts.

     I/O -  describes  all  aspects  of  I/O  and  terminal  handling,
          including  both  normal program I/O and functions for saving
                                                                     6


          and restoring your functions.

     Atoms  -  describes the attributes present in a literal atom, and
          functions that deal with these attributes.    This  includes
          the  functions  for defining functions and setting variables
          to values, since both functions  and  variables  are  atoms.
          There is a separate chapter on property lists.

     Numbers - describes the kinds of numbers present in Lisp, and all
          functions that are designed to manipulate and test numbers.

     Characters and Strings - describes the functions designed to deal
          with characters and strings.

     Properties  - describes the functions designed to define and test
          properties.  These functions essentially allow  you  to  use
          Lisp as a relational database system.

     Arrays  and  vectors - describes the representations intended for
          storing data structures with several fields.    These  allow
          you  to organize data in a structured way, similar to Pascal
          or ADA.

     System functions  and  the  Garbage  Collector  -  functions  for
          getting  information  from  the  operating  system  or other
          environment.  Also those for controlling details of the  way
          the Lisp system operates.

     The Prettyprinter - This chapter begins those describing the user
          environment.    It  describes  a  system  for getting nicely
          structured printouts of functions and other Lisp  structure.
          This  system  can  be  modified by the user to print his own
          special forms.

     The Help System - This chapter describes the  HELP  function  and
          its various associated pieces.  There is builtin help on all
          Lisp functions.  You can use these facilities to supply help
          for systems you are building up.

     Debugging  Facilities  - How to stop at a specified point in your
          program, to find out what is going on when you stop, to step
          through your program expression by expression, and to  trace
          the behavior of your program.

     The  LISP  Editor  -  Describes  a  list  structure editor, which
          understands  the  structure  of  Lisp,  and  contains   many
          powerful and specialized commands for manipulating such Lisp
          functions.   If you prefer to use a display editor, there is
          also an interface to EMACS.  See the function  EDIT  in  the
          reference section.

     The Compiler - Explains how to compile your program.  Compilation
          is  used primarily with debugged code, to speed up execution
          and cut down on space used by the program.
                                                                     7


     The  Evaluation  Context Stack - Describes a facility that allows
          the user to look around and manipulate the execution context
          of his program.  This facility is for experts only.
                                                                     8


                     4. The basic syntax of Lisp



This  manual  is not really designed to teach you Lisp from the ground
up.  However if you are trying to use it that  way  anyway,  you  will
probably  want to only skim this chapter, and concentrate first on the
next chapter, the one on the Basic  Semantics  of  Lisp.    After  you
finish  it,  you  might  want  to  come  back  and  read this one more
carefully.

Lisp is an expression-oriented language.  Expressions  are  made  from
"atoms", parentheses, and dots.  E.g. to add A to B, we might have

    (PLUS A B)

PLUS,  A,  and  B  are atoms, and they are put together into a "list".
Normally the first atom in the list is a function, and  the  rest  are
operands.  Expressions can also be used as operands:

    (PLUS (TIMES A B) OLDVALUE)

I  will  describe  the  syntax "bottom-up", that is beginning with the
atoms.

There are several types of  atoms.    The  most  common  are  "literal
atoms".  When people talk about atoms this is normally what they mean.
An  atom usually represents a function or variable name. Basically you
can put anything into an atom name as long as it  isn't  a  delimiter,
and  as  long  as  the resulting atom doesn't look like a number.  The
following characters are delimiters:

    ( ) [ ] .  / " space tab end-of-line

The end of line characters are

    cr lf form-feed vertical-tab escape

Everything else is considered either a letter or a digit.

The following characters should not be used as the first character  in
an atom name as they produce side-effects: # ' ` and comma will not be
discussed  in this chapter.  # is discussed in the chapter on vectors,
and ' ` and comma are discussed in the chapter on lists.

   - Atom names are made up of sequences of letters  and  digits,
     provided that it doesn't look like a number.

   - See below for numbers.  The following sequences of things at
     the  beginning of an object will cause it to be treated as a
     number:
                                                                     9


         digit
         sign digit
         decimal-pt digit
         sign decimal-pt digit

     / can be used as a "quote" character.  The next character is
     considered  to be a letter, no matter what it normally would
     be.

Lisp considers upper case and lower case to be different.    That  is,
the  variables AAA and aaa are different.  All built-in Lisp functions
and variables are in upper case.   However  by  default  the  variable
*RAISE  is  set  to  T.  The effect of this is to cause all lower case
letters that you type to be turned into upper case.  So if  you  typed
aaa,  Lisp  would  see  it  as  AAA.  Note that this setting of *RAISE
applies only to what is typed at the terminal.  Unless you make  other
arrangements,  lower case read from files will still be interpreted as
lower case.  (If you are reading a file in  DSKIN,  LOADF,  or  COMPL,
*RAISEDSK is used instead of *RAISE.)

In addition to literal atoms, there are also:

     integer  -  An integer is a sequence of digits, possibly preceded
          by a sign, + or -, and possibly followed by a  character  to
          indicate  what  base  it is in. 123. is decimal, and 123Q is
          octal.  123 alone is  interpreted  in  the  current  default
          radix, which is usually decimal.  (See BASE and IBASE.)

     real - A real number has the following syntax

              sign digits decimal-point digits E integer

          Examples are

              1.23, 123E-2, .234, -.234

          All of these components are optional.  For something to be a
          legal  number, there must be digits somewhere, either before
          or after the decimal point.  For something to be  recognized
          as a real number, there must be either some digits after the
          decimal   point   or   an  E. Real  numbers  are  stored  as
          double  precision.  They  are  printed  to  18   significant
          figures, with rounding at the last digit and trailing zeroes
          suppressed.

     strings  -  a  string  is  a  series  of  characters in "quotes".
          Currently strings aren't good for much except printing out.

     I/O channels - these are only generated  by  the  functions  that
          open  files.   You can't do anything to them other than pass
          them to other functions that want I/O channels.

Please note that Lisp numbers may be mixed however you like.  That  is
you  can  add integers and reals together, and you can also compare an
integer and a real.  In most cases, when you combine  two  numbers  of
                                                                    10


the  same  type, you get a new one of that type.  But when you combine
an integer and a real, you get a real.

Atoms are put together into "S-expressions" by using  parentheses  and
dots.    An entire chapter is devoted to Functions and Predicates that
deal with Lists.  In that chapter, the structure and  notation  of  S-
expressions  is  described  in detail, complete with diagrams.  If you
are trying to learn Lisp for the first time, at  the  moment  all  you
need  to  know  is  that Lisp expressions consist of lists of atoms in
parentheses, and that the parentheses must always balance.  An example
is the following expression, which when evaluated with add  2  and  3:
(PLUS   2  3).    The  following  discussion  gives  a  more  detailed
description of the syntax of S-expressions.

The most basic form of S-expression is the "dotted pair", e.g.

    (A . B)

The first item of the dotted pair is called the  CAR  and  the  second
item  is  called the CDR.  [Note that a dotted pair can be constructed
at runtime by the function CONS,  which  takes  the  CAR  and  CDR  as
arguments  and  returns  a  dotted  pair with the given elements.]  In
principle any S-expression  can  be  constructed  with  dotted  pairs.
However  it is conventional to string together dotted pairs, by having
the CDR of one dotted pair be another dotted pair.  Here is  the  sort
of thing that can happen:

    (A . (B . (C . D)))

This  is  obviously  not  a  very  nice  notation.  Since this sort of
structure is used so commonly, there is a special notation for it:

    (A  B  C  .  D)

This is called a "list".  A list can contain any number of items.   It
you  were to write out the list as dotted pairs, each item in the list
(except the last) would correspond to one dotted pair in the list:

   - the CAR would be the item

   - the CDR would be the next dotted pair

It is also conventional to end lists by the special atom NIL:

    (A . (B . (C . NIL)))

When NIL is the last item in a list, it need  not  be  indicated  when
list notation is used:

    (A  B  C)

Even   with  list  notation,  it  is  sometimes  easy  to  "drown"  in
parentheses.  E.g. (COND ((ZEROP N) 1)(T (CONS NIL (FOO  (SUB1  N)))))
In  order  to  help  you  match  parenthese is such cases, [ and ] are
defined as "superparentheses". A ] matches the most  recent  unmatched
                                                                    11


[.    If  there  are  unmatched  ('s  in  the  way,  they  are  closed
automatically.  E.g. the above might be written

    (COND [(ZEROP N) 1][T (CONS NIL (FOO (SUB1 N])

Finally, there is  the  "ultimate  close  parenthesis".    The  escape
character   (sometimes   labelled   altmode)   will   close  any  open
parentheses.  e.g.

    (COND [(ZEROP N) 1][T (CONS NIL (FOO (SUB1 N$

where $ represents the escape.

Comments can be inserted by using {; } or {;; }.  For example

    (DE BLETCH (A B)
        {;; This is a function to bletchify two arguments.  The
            first argument is the bletchor and the second the
            bletchee}
        (MAPC A B))

{; } and {;; } are expanded to calls on the functions ; and ;;.  These
functions ignore their arguments, and return NIL.  Thus these comments
can be put almost anywhere.  However beware that if you put a  comment
last  in a form, you may cause NIL to be returned rather than what you
had in mind, since the comments are in fact evaluated to produce  NIL.
{;;  }  is the normal form.  {; } causes the comment to be indented to
column 40 if the function is printed by PP.

^Y and ^Z are special comment characters.  Everything  from  there  to
the  next end of line is ignored.  They are legal anywhere.  A comment
can even go in the middle of an atom name.  However we  recommend  the
use  of  the  {;;  }  form  instead  of  ^Y or ^Z.  The reason is that
comments done with {;; } are part of the function, and will be written
out if the function is written out.  Comments done with ^Y and ^Z  are
removed  when  the  function is read in.  So they don't show up if you
later print the function or write it out to a  file.  Note  that  this
form  of  comment  only  work  in  files.  ^Y and ^Z both have special
functions when typed to the terminal.    Because  these  comments  are
ignored  completely,  they  would  not  be  very useful for a terminal
anyway.

It is possible to modify the syntax of Lisp by use of read macros,  or
by  changing the symbol table.  See the sections on the these subjects
in the chapter on I/O.
                                                                    12


                    5. The Basic Semantics of Lisp



This  chapter  will discuss two things: variables and functions.  They
are the basic things from you build Lisp programs.

A variable is an atom that is used to store a value.  Any atom can  be
used as a variable, simply by executing the function SETQ:

    (SETQ A 5)

This  sets A to the value 5.  No particular declation is needed to say
that A is going to be used as a variable.    Every  atom  has  a  spot
inside its atom header in which a value can be stored.  So all that is
needed is to execute something to set it.  SETQ is the most common way
to set a variable.

Now let us look at how variables are used.

    (SETQ B A)

SETQ  expects to find two arguments:  an atom (which it will set), and
a value (which it will set the atom to).  Thus this call to SETQ  will
find  the  value  of A, which is 5, according to the SETQ we just did.
It will then set B to 5.    Note  that  B  and  A  are  being  treated
differently:    A  is  being  "evaluated" and B is not.  That is, SETQ
doesn't care about the previous value of B, but it does need  to  know
the  value of A. The definition of a function includes a specification
of which of its arguments are evaluated and which are not.    Normally
all  arguments  are  evaluated,  but  SETQ is an exception.  From this
example, you can see that when a variable is evaluated, the result  is
the  value  to  which  it  was  most  recently set.  If A had not been
previously set to a value, then  the  above  SETQ  would  generate  an
error.

You can change the value of a variable simply by issuing a new SETQ:

    (SETQ A 3)
    (SETQ B A)
    (SETQ A 5)
    (SETQ C A)

In this case, B ends up with the value 3, and C ends up with the value
5.

So  far  the  only  things  you  have  seen that Lisp can evaluate are
variables and numbers.  Variables evaluate to the  most  recent  value
they were set to.  Numbers and other constants evaluate to themselves.
The third thing that Lisp can evaluate is function calls:

    (SETQ A (PLUS B C))

Notice  that  there  are  no  infix operators, as in languages such as
Fortran or Algol.  There are only  function  calls  and  other  forms.
                                                                    13


(PLUS  B  C)  is  a  call to the function PLUS, which adds numbers.  A
function call is always written this way:  it is a  list  whose  first
element  (CAR)  is  the name of the function.  The rest of the list is
arguments to the function.  In the case of PLUS the arguments are  the
numbers to be added.  Thus this adds B to C. 

Actually,  (PLUS  B  C)  is just a piece of data.  It doesn't become a
function call until it is evaluated.  Just as  evaluating  a  variable
gets  the  value  to which it has been set, evaluating a function call
causes the function actually to be performed.  Of  course  before  the
function  can  be  performed,  its arguments may have to be evaluated.
After all, we don't want to add the letters B and  C  to  each  other.
Rather  we want to treat them as variables, find their values, and add
the values.  As mentioned above, most functions are defined as  having
their arguments evaluated.  So if someone asks for (SETQ A (PLUS B C))
to be evaluated, here is what happens:

    evaluate (SETQ A (PLUS B C)):
    SETQ requires its second argument to be evaluated:
      evaluate (PLUS B C)
      PLUS requires both of its arguments to be evaluated
        evaluate B - from the SETQ above, it will be 3
        evaluate C - from the SETQ above, it will be 5
      now do PLUS - the result is 8
    now do SETQ - A is set to 8.  The result is 8.

Notice  that  SETQ is just a function like any other.  It just happens
to have the effect of setting its first  argument.    Like  all  other
functions, it returns a value, the value to which it set the argument.
Since SETQ returns a value, you can do things like

    (SETQ A (SETQ B 3))

This would set both A and B to 3.

Here is a slightly more complex example:

    (SETQ X (PLUS A (TIMES B 3)))

Notice that each operation must be done as a function call.  You can't
say  anything  like A + B * 3.  As you might guess, this example finds
the value of B, multiplies it by 3, finds the value of A, adds  it  to
the  result of the multiplication, and the sets X to the result of the
addition.

You can also define your own functions.  The most  common  way  to  do
that is with DE:

    (DE DUMB (A B) (SETQ A (PLUS A 2)) (PLUS A B))

DE  stands  for  "Define  Expr".   EXPR is the normal function type in
LISP.  After the DE comes the name of the function being  defined,  in
this  case  DUMB.  Then comes a list of formal parameters.  Here there
are two parameters, A  and  B. Finally  there  are  the  forms  to  be
evaluated,  in  this  case (SETQ A (PLUS A 2)) and (PLUS A B).  If the
                                                                    14


function  is  called,  these  forms  are evaluated one by one, left to
right, and the value of the last is returned.

You call a user-defined function exactly the same way you would call a
built-in Lisp function.  Note that an EXPR function always  takes  its
arguments evaluated.

    (SETQ B 3)
    (SETQ X (DUMB B 5))

When this is evaluated, the following will happen:

    Set B to 3
    evaluate (SETQ X (DUMB B 5)):
      SETQ evaluates its second argument
        evaluate (DUMB B 5)
          DUMB, as an EXPR, evaluates all of its arguments
            evaluate B.  Its current value is 3
            evaluate 5.  Constants evaluate to themselves.
          Bind DUMB's parameters to the values of arguments:
            bind A to 3
            bind B to 5
          Evaluate the forms of the definition:
            (SETQ A (PLUS A 2)) - sets A to 5
            (PLUS A B) - since B is 5, gives 10
          Return the value of the last form: 10
      Set X to the value - 10

In general, here are the steps involved in calling a user function:

    evaluate all the arguments in the function call
       (left to right)
    bind each parameter to the corresponding argument value
    evaluate the forms that define the function
    return the value of the last form evaluated

Let  us  look  a  bit  more  carefully  at  what  is  meant by binding
parameters to argument values.   The  parameters  (A  and  B,  in  the
example  above)  are  simply atoms used as variables.  When Lisp calls
the function, it simply sets the first parameter to the value  of  the
first  argument,  the second to the second, etc.  However one thing is
different about this binding than that done by SETQ:  Any old value is
saved.  The idea is that you should be able to call a function without
knowing the details of how it is written.    Consider  DUMB.    If  we
simply  set  A  and  B to the argument values using SETQ, then any old
values of A and B would be lost.  But this is no  good,  since  anyone
who calls a function would have to know what variables it was going to
klobber.   Thus the function calling mechanism saves the old values of
A and B, and restores them when the function exits.    So  inside  the
function,  B refers to the value of the second parameter, but once you
leave the function, B is restored to 3.   The  new  bindings  stay  in
effect  even if your function calls some other function.  The old ones
are not restored until you exit from the function.

Note that this binding strategy is different  from  Algol,  PL/I,  and
                                                                    15


Pascal.  In  the latter languages, the variables and parameters that a
function can see is determined by where it is defined.   For  example,
consider this Algol code:

    procedure x(a,b);
      integer a,b,c;
      procedure y(p,q);
        integer p,q;
        begin
        a := b
    ...

The  inner  procedure, Y, can access the parameters A and B, because Y
is defined inside X. What A and B refer to is  determined  at  compile
time.  In  Lisp, the meaning of a variable reference is not determined
until it is actually evaluated, at execution time.    A  function  can
refer  to  variables that are defined by other functions that call it.
We say that in Algol and similar languages, variables  and  parameters
are  bound "statically".  In Lisp, parameters are bound "dynamically".
That is, parameter binding is  to  be  thought  of  as  an  executable
process  that takes place at runtime, and lasts until the bindings are
undone when the function exits.



5.1. Quote


The examples above have  carefully  been  chosen  to  deal  only  with
numbers.    That  is  because  numbers  are  obviously  constants, and
evaluate to themselves.  However an atom  can  be  used  as  either  a
constant  or  a  variable.    Let us consider the function CONS, which
constructs dotted pairs:

    (CONS 1 2)

It is obvious what this does:  It returns (1 . 2).    But  suppose  we
want to construct the pair (A . B).  Your first thought might be to do
the following:

    (CONS A B)

Unfortunately  this  won't  work.    Like  most  other functions, CONS
evaluates its arguments.  Thus this will combine the value of  A  with
the  value  of  B, not A and B themselves.  Thus it appears we have no
way to talk about A and B themselves.  For this  purpose  there  is  a
special form, QUOTE.  (QUOTE A) returns A. That is, QUOTE is a trivial
function  with  one  argument.   It doesn't evaluate its argument, and
just returns it unchanged.  So to produce (A . B) we could write

    (CONS (QUOTE A) (QUOTE B))

Since this is so common, (QUOTE x) is abbreviated 'x:

    (CONS 'A 'B)
                                                                    16


Of  course  it would be unusual to quote both arguments to CONS, since
it would be easier just to write '(A . B).  But it  certainly  can  be
useful to quote just one:

    (CONS 'A B)

This CONS's A to the value of B. 



5.2. Function constants: LAMBDA forms


Lisp  has one somewhat unusual thing about it:  it is possible to have
function constants.  When you define a function using DE, you  have  a
function  that is referred to by name.  Conceptually there is not much
difference between doing

    (DE PLUS2 (X) (PLUS X 2))

and

    (SETQ PLUS2 3)

That is, in  each  case  PLUS2  has  been  assigned  as  the  name  of
something,  a  function  in the first case and a number in the second.
But suppose you don't want to do that.  In all languages you can write
the number itself: 3.  But what about the function?   In  Lisp  it  is
possible to write a function constant, without defining it as having a
name.  This is done with a LAMBDA form:

    (LAMBDA (X) (PLUS X 2))

A  LAMBDA  form  is essentially an "anonymous" function, i.e. one that
does not have a name.  Effectively (DE PLUS2 (X) (PLUS X  2))  can  be
thought of as something like

    (SETQ PLUS2 '(LAMBDA (X) (PLUS X 2)))

[Actually  that  would  work,  but  for  historical reasons the method
normally used to assign names to functions is different than a  simple
SETQ.]

A  LAMBDA  form can be used anywhere that a function name can be used.
The following are equivalent:

    (PLUS2 4)

    ((LAMBDA (X) (PLUS X 2)) 4)

The major usefulness of functional constants is that it allows Lisp to
have functions that take other functions as arguments.    For  example
the  function  MAPC  can take 2 arguments:  a function and a list.  It
applies the function to each member of the list.  For example,
                                                                    17


    (MAPC 'PRINT '(1 2 3))

would  print  1, 2, and 3.  But if for some reason you wanted to print
twice each member of a list, you could say

    (MAPC '(LAMBDA (X) (PRINT (PLUS X 2))) '(1 2 3))

Of course you could also do

    (DE PRINT-PLUS-2 (X) (PRINT (PLUS X 2)))

    (MAPC 'PRINT-PLUS-2 '(1 2 3))

but in many cases it is more convenient not to define a named function
if all you are going to do is use it once, in such a construct.

Note that a LAMBDA form must be quoted just like any other  expression
when  it  is  being passed to a function that evaluates its arguments.
Although ' will do perfectly  well,  it  is  traditional  to  use  the
special  form  (FUNCTION  x) to quote functions.  In interpreted code,
FUNCTION and QUOTE are identical.  However the compiler will compile a
form that has been quoted with FUNCTION, so it is  preferable  to  use
FUNCTION.   Since it is so common to quote LAMBDA forms with FUNCTION,
there is a macro that expands to (FUNCTION (LAMBDA ...    It  is  F:L.
Here is how the above example would be written with F:L:

    (MAPC (F:L (X) (PRINT (PLUS X 2))) '(1 2 3))

This is the form in which you will normally see LAMBDA's.



5.3. A preliminary description of EVAL


EVAL  is the heart of Lisp.  It is the function that evaluates things.
When you talk to Lisp from a terminal, you are normally talking  to  a
piece  of code the repeatedly executes (PRINT (EVAL (READ))).  I.e. it
reads something from the terminal, does EVAL of  it,  and  prints  the
results.

     EVAL  first  checks  what it is evaluating.  If it is a number, a
          string, an I/O channel, or various internal  funniness,  the
          thing  evaluates to itself.  This is so that (PLUS 1 2) will
          add 1 and 2, rather than trying to take 1 and 2 as  variable
          names.

     If  the  thing  is  not  something that evaluates to itself, EVAL
          checks to see if it is an atom.  If so, EVAL treats it as  a
          variable  and  tries  to  find a value.  As described above,
          variables are normally given values either  by  SETQ  or  by
          being  the  formal  parameter  of  a  function that has been
          called.

     If it is not one of the above, it must be a list.  In  this  case
                                                                    18


          EVAL  treats  it  as  a function call.  I.e. the first thing
          should be a function, and the rest arguments.  EVAL will  go
          to  great  lengths  to  try to intepret the first thing as a
          function.  What it basically wants is a  LAMBDA.    So  what
          will make it happiest is something like

              ((LAMBDA (A B) (PLUS A B)) 1 2)

     If it doesn't find this, it analyzes the first thing.

               if  it is an atom, EVAL first checks to see if the atom
                    is the name of a function.  If so, it looks up the
                    definition of the function, and applies it.  (User
                    defined functions are  simply  LAMBDA  expressions
                    which have been given names.)

               if  it is an atom, but not the name of a function, EVAL
                    then looks to see if the atom  has  a  value  when
                    considered  as  a  variable.  If so, it starts the
                    examination process all over with this value.

               if it is not an atom, but is an expression, Lisp EVAL's
                    the expression, and then  starts  the  examination
                    process  all  over  with the value returned by the
                    expression.

          By far the most common case is that the first  thing  is  an
          atom,   which   is   defined  as  a  function.    The  other
          possibilities can be useful in some situations, though.

Something should be said  at  this  point  about  the  atoms  NIL  and
T. These  are  somewhat  special.    NIL  is  special for two reasons:
First, it is used to mark the end of  lists.    Thus  taken  alone  it
represents  the  empty  list.    It  is extremely common to initialize
variables that are going to contain lists to NIL.  Second, NIL is used
to represent "false".  All the functions that test  conditions  return
NIL if the test fails.  According to the conventions of Lisp, anything
other than NIL is taken to represent "true".

T is special because it is used by convention to represent "true".  Of
course  anything other than NIL will work, but when there is no reason
to do otherwise, T is usually used.

Because of these special roles,  NIL  and  T  are  used  quite  often.
Because  they are used so commonly as constants, it is inconvenient to
have to quote them all the time.  Thus when the  system  is  generated
NIL  is  set  to  NIL, and T is set to T. I.e. (SETQ NIL 'NIL) (SETQ T
'T).  This allows you to type NIL when you really mean 'NIL and T when
you really mean 'T.  Since NIL is  set  to  itself,  it  evaluates  to
itself.    Similarly  for  T. Because  so many people depend upon this
fact, it is considered illegal to set NIL or T to something else.   In
fact  the interpreter will give you an error message if you attempt to
SETQ NIL or T, or use them as formal parameters of a function.

Something should be said about when the arguments are evaluated.    In
                                                                    19


principle, the arguments are evaluated before any evaluation needed to
find out what the function is.  Consider the following case:

    ((GET 'CURFUN 'GORP) (PLUS X Y))

This will call a function, and pass it X + Y. Which function is called
is determined by evaluating (GET 'CURFUN 'GORP).  The point to be made
is that (PLUS X Y) is done before (GET 'CURFUN 'GORP).

[This   description   does  not  include  FEXPR's,  MACRO's,  and  the
Evaluation Context Stack, all of which will be discussed below.]

In most cases, a Lisp program is simply a set of functions defined  by
DE, DF, and DM which call each other.  To start it all, the user calls
one top-level function himself.
                                                                    20


                  6. Other function types and forms



If  you  don't know Lisp very well, you may want to skip this section.
EXPR's are sufficient for many purposes.  This section  will  describe
some  other  function  types  that  tend  to  be used only for special
purposes.  The ones that the user can define are FEXPR's, LEXPR's, and
MACRO's.  It will also discuss LABEL and  FUNARG,  which  are  special
forms  used  to  form  termporary  function  definitions  and to allow
execution of code in a nonstandard variable binding context.



6.1. FEXPR


An FEXPR differs from an EXPR in  that  EVAL  will  not  evaluate  the
arguments  before  calling  it.  E.g.  SETQ is an FEXPR.  When you say
(SETQ A 'B), EVAL does not evaluate the arguments.  We don't  want  it
to  evaluate them, since doing so would result in passing the value of
A, whereas you need the variable itself, in order to set it. It  would
be fine for it to evaluate the second argument, but you get either all
or  nothing.  What  happens  with  an  FEXPR is that there is a formal
parameter, and it is bound to the entire argument  list,  unevaluated.
So  what  SETQ  sees  is  a  single argument, (A (QUOTE B)). It has to
evaluate the second argument for itself by  calling  EVAL  explicitly.
All  of  the  "special  forms",  such  as  COND,  are also FEXPR's (or
FSUBR's, which are compiled FEXPR's).  Here is an example of  how  one
might write the body of SETQ:

    (LAMBDA (L) (SET (CAR L) (EVAL (CAR (CDR L)))))

Note  that you can't tell an FEXPR from an EXPR by looking at it.  The
bodies are both LAMBDA's.  You can tell them apart  only  by  the  way
names  are  assigned  to them.  To set up the above definition of SETQ
you would use DF instead of DE:

    (DF SETQ (L) (SET (CAR L) (EVAL (CAR (CDR L)))))

DE and DF assign LAMBDA expressions to atoms as function  definitions.
What  they  actually store with the atom is both the LAMBDA expression
and the atom EXPR or FEXPR.  The EXPR or FEXPR tells EVAL  whether  to
interpret the LAMBDA as an EXPR or an FEXPR.  [See ALIAS and FUNDEF if
you  want  to know how the LAMBDA expression and the EXPR or FEXPR are
really associated with the function name.]

Note that the only way to make something an FEXPR  is  to  give  it  a
name.   This is because the EXPR or FEXPR are stored with the function
definition when it is give a name.  If you use a bare LAMBDA, e.g.

    ((LAMBDA (X) (PRINT X)) 'A)

there is no way to specify whether the LAMBDA is to  be  taken  as  an
EXPR  or  an  FEXPR.  In such cases EVAL treats it as an EXPR.  Indeed
                                                                    21


EVAL treats everything as EXPR's unless it is immediately obvious that
they are not.

Consider the expression

    (FOO (PLUS 1 2) BAR)

In  principle, EVAL is supposed to evaluate the arguments, (PLUS 1 2),
and BAR, and then do any  processing  necessary  to  find  a  function
definition  for  FOO.   But this won't work for FEXPR's:  If FOO turns
out to be an FEXPR, it  is  too  late  to  find  this  out  after  the
arguments have been evaluated, since FEXPR's are supposed to get their
arguments in unevaluated form.  Thus there is a special case:

    If  an  expression  begins  with  an atom, and that atom has a
    function definition,  EVAL  will  check  to  see  whether  the
    function  definition  is  an  EXPR,  an  FEXPR,  etc.,  before
    evaluating the arguments.  It will then be able to  treat  the
    arguments  correctly for special cases such as FEXPR's.  Also,
    if the atom is a variable, and the value of that  variable  is
    another  atom,  then  EVAL  will  reconsider that second atom.
    This will be done  as  many  times  as  needed.    However  if
    anything  other than evaluating variables is needed, or if the
    result is not something with a function definition,  then  the
    function   is  treated  as  an  EXPR  and  the  arguments  are
    evaluated.

Consider the following example:

    ((GET CURNODE 'FUNPROP) A B)

This is intended to compute a function  by  looking  up  the  property
FUNPROP  on  CURNODE, and then apply it to A and B. By the rule above,
this function will always be treated as an EXPR, even if it is not.



6.2. LEXPR


An LEXPR is really a special kind of EXPR.  It is defined with DE, and
the indicator used for it is still EXPR.  It differs from an  EXPR  in
that  it  can take a variable number of parameters.  Since it may take
arbitrarily many parameters, parameters can't be  handled  by  binding
them  to  formal  variables.    (How  many  formals would you supply?)
Instead, (ARG 1) is used to get the value of the first argument,  (ARG
2),  the  second,  etc.  There is also (SETARG n new-value) to set the
value of argument N. Instead of a list of formal parameters, an  LEXPR
takes  a  single  atom.    This  atom  will  be bound to the number of
arguments that the user actually supplied.  In fact the way  that  the
system  knows  it  has  an LEXPR is by seeing that there is an atom in
place of the usual formal parameter list.  Here is an example LEXPR:
                                                                    22


    (DE SHOWHOWMANY N
        (PRINC "You have ")
        (PRINC N)
        (PRINC " arguments, the first of which is ")
        (PRINC (ARG 1)))



6.3. MACRO


Macros  are  used  when  you  want  to implement your own piece of the
language, and normal functions don't give you enough power.   A  macro
can  be  thought  of as a little "compiler".  When a macro in invoked,
the expression in which it appears is bound to the  macro's  argument.
Then  the  macro's body is executed.  The result however is Lisp code,
not the final result.  That is why I call it a  "compiler",  since  it
produces  Lisp code.  This Lisp code is then executed to get the final
result.  Please note that the actual macro is only  called  the  first
time  the  expression  involving  it  is  seen. The "compiled code" is
saved, and is used in the future without calling the macro again.  The
body of a macro is simply a LAMBDA.  It is differentiated by the  fact
that  the  tag  MACRO  is used when giving it a name, instead of EXPR.
(Read the description of FEXPR's, in the previous section, for details
on these tags, and how they interact with  EVAL.)  The  LAMBDA  should
have  exactly  one  formal  parameter.  This parameter is bound to the
entire expression in which the macro occured, and  then  the  body  is
evaluated.  This is somewhat similar to an FEXPR, in that it is passed
the  calling  expression,  with  no arguments evaluated.  Note however
that an FEXPR sees only its arguments, where a macro  sees  the  whole
call.

    (FOO A B)

If  FOO  is  an  FEXPR,  its  variable is bound to (A B).  If FOO is a
MACRO, its variable is bound to  (FOO  A  B).    Normally  you  use  a
function  DM  to  define macros.  Here is a simple (and useless) macro
definition:

    (DM MYMAC (L) (LIST 'PRINT (LIST 'QUOTE (CDR L))))

This macro would simply print out its arguments.    Note  the  quotes.
They  are  needed  because  the result of the macro execution is code,
which is evaluated again.

As mentioned above, macros are usually expanded only once.    Here  is
how  this  is  done.    The call to the macro is replaced by a special
construct that contains both the original call and the code generated.
E.g.  suppose you call the above macro.  Here is how  you  call  might
look:

    (MYMAC A B)

This will be replaced by
                                                                    23


    (MACROEXPANSION (PRINT '(A B)) (MYMAC A B))

That  is, if the call occurs within another function, that function is
actually edited so that (MYMAC A B) is replaced  with  the  expression
above.    MACROEXPANSION  is defined as an FEXPR that simply evaluates
its second argument and returns that value.  This is the expansion  of
the  macro.    If  you  want to disable this mechanism, set the global
variable MACROEXPANSION to NIL.  If this flag  is  set  to  NIL,  then
macros  are  expanded each time they are invoked, and the expansion is
thrown away.  This is useful when you are debugging the macro.    With
the  flag  set  to T (the default), it won't do you any good to change
the definition of a macro once it has been called, since the  code  it
has compiled will be stored and the macro will never be used again.



6.4. SUBR's


In  addition  to the types of function described above, there are also
compiled (machine code) functions.  These have identifiers ending with
SUBR.  Here are the correspondences:

    LAMBDA body            compiled code

      EXPR                     SUBR
      LEXPR                   LSUBR
      FEXPR                   FSUBR
      MACRO                   MSUBR


That is, an FSUBR is the compiled form of an FEXPR.   You  should  not
need  to  know how these work, as they are either functions built into
the system, or produced automatically by  the  compiler.  Since  these
things  are  compiled,  the  only information needed is the address at
which the code starts.  Thus they look like

    (SUBR 465134 2)    [the 2 is the number of arguments]
    (FSUBR 476321)     [all FSUBR's take one argument]

ALIAS can be used to assign one of these things to a name. However you
will normally not mess with them directly. Some are already built into
the Lisp system, and others will be produced  by  the  compiler.  Note
that  the  6-digit  numbers shown above are actually a bit misleading.
What is really there is a machine address.  This is an  internal  Lisp
data type, and does not print out as a number.
                                                                    24


6.5. LABEL


LABEL  is  used  when you want to write a LAMBDA that will call itself
recursively, but you do not want to assign it a name with DE.  Here is
the obvious way to do a recursive function:

    (DE FACTORIAL (N)
        (COND ((EQ N 0)  1)
              (T  (TIMES N (FACTORIAL (SUB1 N))))))

Note that this function calls itself.  Suppose you did not want to use
DE, but just write a LAMBDA form applied to some argument.  How  would
you  express  the  recursion?    Here  is  how to write factorial of 5
without ever defining a function

    ((LABEL FACT (LAMBDA (N)
        (COND ((EQ N 0)  1)
              (T  (TIMES N (FACT (SUB1 N))))))) 5)

What  LABEL  does  is  to  assign  the  LAMBDA  expression   to   FACT
temporarily.    Once you exit from the LABEL, the old value of FACT is
restored.  If you find this hard to figure out, don't worry.    Almost
no one uses it.



6.6. FUNARG


In  Lisp  it  is possible to manipulate the context in which variables
will be evaluated (see the chapter "The Evaluation Context Stack"  for
details).    For example, it is possible to specify that all variables
are to be evaluated used their global values.  If that is  done,  then
any  bindings supplied by functions and PROG's will be ignored.  It is
also possible to specify that bindings are to be as they are  in  some
particular  function above the current point in the call tree.  FUNARG
is a way of specifying that a form is to be evaluated in  a  specified
binding context.

The  form  (FUNARG  <functional form> . index) can be used just like a
LAMBDA expression.  However whenever it is invoked the stack is  reset
to  INDEX  before  the  function is interpreted.  The one value of the
index that has some absolute  meaning  is  0:  this  specifies  global
bindings.    Otherwise, the index value probably comes from the second
argument to an FEXPR, or from one of the functions  described  in  the
chapter  on  the  evaluation context stack.  The function *FUNCTION is
useful for constructing FUNARG's with an index specifying the  current
binding context.
                                                                    25


                    7. Behavior of the Interpreter



When  you run this program, you are talking to the Lisp "interpreter".
This is a program that consists of EVAL, plus a  bunch  of  predefined
Lisp  functions.   The code that you actually talk to consists more or
less of the following:

    (PROG NIL
      LOOP  (PRINT (EVAL (READ)))
            (GO LOOP))

That is, it reads an expression from you, calls EVAL to  evaluate  it,
and  prints  the  result.    Then it goes back and does the same thing
again.  This will be modified in the case of errors.  For  details  on
that see the description of ERROR in the list below.

This  means that what you type are simply value Lisp expressions.  You
can use Lisp as a simple desk calculator, e.g. [what you type has  the
* in front of it]

    *123
    123
    *(PLUS 123 234)
    357
    *(SETQ A 5)
    5
    *(PLUS A 3)
    8

But  normally  what  you type is DE and DF, to define functions.  Then
you call the functions:

    *(DE FIBONACCI (N)
          (COND ((EQUAL N 0) 1) ((EQUAL N 1) 1)
                (T (PLUS (FIBONACCI (SUB1 N))
                         (FIBONACCI (SUB1 (SUB1 N)))))))
    FIBONACCI
    *(FIBONACCI 5)
    8

If you want to have a different top level, see  the  function  INITFN.
This lets you define your own top level.

Certain control characters are set up as "interrupt characters".  That
means  that  when  you  type  them, an action will happen immediately.
Thus the characters will work even  if  typed  during  a  computation.
Except  for  ^C  and  ^Y,  if a garbage collection is in progress, the
effect of the character is  delayed  until  the  end  of  the  garbage
collection.   If you are a beginner, we suggest that you at least look
at the descriptions of ^C, ^F, and ^Z.  ^C lets you get out  of  Lisp.
^F  and  ^Z  should  be  used  if  you make a typo while typing a long
expression.
                                                                    26


     ^B  -  enter  the  break  package immediately.  If you are in the
          middle of a long compiled function, you will lose  any  work
          done  so  far in that function, since the break package will
          back up to the nearest point it can make sense out of.    ^H
          is probably better.

     ^C  -  exit from the program.  You can continue it with CONTINUE,
          or restart it at the top level with START.  ^C  followed  by
          START  is  equivalent  to  ^D.    If  you are in the garbage
          collector,  ^C  will  normally  wait   until   the   garbage
          collection  is  finished before letting you out.  However if
          you type enough ^C's (currently 6), eventually it  will  let
          you out no matter what. If you ^C during garbage collection,
          START will leave your core image in a useless state.

     ^D  - stop the current computation and return directly to the top
          level READ-EVAL-PRINT loop.

     ^E - stop the current computation and do (ERR NIL).  This  allows
          your  program  to  trap  ^E's by using ERRSET.  If you don't
          trap ^E, this returns you to the top level.

     ^F - not actually  an  interrupt  character,  but  during  normal
          typein will trigger a call to the editor to allow you to fix
          a  typo during the current typein.  That is, when you finish
          typing this expression, instead of returning it to  Lisp  as
          usual,  first EMACS (or another editor) is called to let you
          modify it.  Note that you must finish off the expression (by
          supplying close paren's, etc.) before  the  editor  will  be
          called.    (This  can  be  moved  to any other character, or
          disabled, by the function EDITCH.)

     ^G - stop the current computation and do (ERR  'ERRORX).    (This
          can be moved to any other control character, or disabled, by
          the function ERRCH.)

     ^H  - enter the break package the next time EVAL is called.  This
          is clean way to do a break, since  you  will  not  lose  any
          work.

     ^Y  -  this  is a panic version of ^C.  It is here mostly for the
          benefit of the developers, since now and then  circumstances
          come  up during debugging where ^C does not work.  ^Y should
          always get you out of the program immediately.  CONTINUE and
          START will work, but START will be a disaster if you are  in
          the  garbage  collector.  Normal people should use ^C except
          in emergencies.

     ^Z - not actually  an  interrupt  character,  but  during  normal
          typein will cause the entire current expression to be thrown
          away,  and  reading  to start again.  This is similar to ^U,
          but instead of throwing away just one line, throws away  the
          entire  current  expression.  This is useful when you make a
          typo in a very long item.  (This can be moved to  any  other
          character, or disabled, by the function REREADCH.)
                                                                    27


All  of  these  except ^C, ^G, ^F, and ^Z can be disabled by using the
function DEBUGINT.

When  you  start  Lisp,  it   will   automatically   read   the   file
ELISP.INIT  from  your  connected  directory.  It can contain any Lisp
expression.  These expressions will be EVAL'ed, but not printed.

This  is  also  as  good  a  point  as  any  to  explain  some  random
conveniences of this interpreter:

     NIL  is very special.  It is used to define the end of lists, and
          is the only thing that is false when truth is being  tested.
          NIL  is in fact both an atom and a list.  If you ask what it
          is, by (ATOM NIL), you will be told that it is an atom.  But
          effectively it is also the empty list. () is in fact NIL.

     NIL evaluates to itself.  That it, you never have to  quote  NIL,
          since EVAL will always give you NIL for it.  So (CONS A NIL)
          is just like (CONS A 'NIL)

     (CAR  NIL) and (CDR NIL) are both NIL.  (If you learning Lisp for
          the first time by reading this manual, you won't  understand
          this.    Never fear, we mention it again later when you will
          understand it.)

     T is often used when you want a value to represent "true".    All
          that  is  actually  important  is  that  it  isn't NIL.  For
          convenience, things are also set up so that T  evaluates  to
          itself.    so  you  can  say (SETQ A T).  It is exactly like
          saying (SETQ A 'T)

When Lisp is talking to the terminal, it will  prompt  you  for  input
with  *.    You must type a carriage return (or other line terminator)
before Lisp will act on your typein.  Until that  point  you  can  use
normal  Tops-20  editing  characters.  You can continue forms onto new
lines.  Lisp will take off only when all the parentheses are balanced.
If you don't want to count parentheses, you can close your  expression
with <escape> or ].  These balance open parentheses.

WARNING:  Because of the use of a copying garbage collector, there can
be  problems  if  you have Lisp variables bound to things that are not
valid Lisp objects.  For this reason, this version  of  Lisp  is  more
particular  than some about what it lets you do.  For example, it will
not let you take CAR or CDR of anything other than a  CONS  cell.  For
example,  (CAR  'A) will result in an error.  The problem is that (CAR
'A) would point into the middle of an internal  Lisp  data  structure.
When  the  next garbage-collection occured, Lisp would not know how to
handle this pointer.  You need to know about this for two reasons:

   - so you understand why more careful type  checking  is  being
     done than is usual.

   - so  you  know  that  odd  effect may happen if you manage to
     bypass the checking.
                                                                    28


I  only  know  of  two ways to bypass the type checking.  The first is
somewhat unlikely.    Some  occurences  of  CAR  and  CDR  inside  the
interpreter  are not checked.  So it is possible that you could manage
to generate an invalid object by using a lambda expression  with  some
pathologically  illegal  syntax.  The second is more likely.  Compiled
code does not check the validity of CAR and CDR.  So if you compile  a
program before it is debugged, you might generate junk.

If  you  do end up with an invalid object, the next garbage collection
will result in a message:

    Bad pointer detected by GC.  Type CONTINUE to proceed.

At this point the program will halt, and you will be back at the  EXEC
command  level.    Most  users  will simply type CONTINUE.  The system
halts in order allow debugging.  Once the system is in production use,
it  will  no  longer  halt,  and  this  message   will   be   modified
appropriately.  If this message occurs, I recommend doing another (GC)
as  soon as you have the opportunity to do so.  The message should not
occur during the second GC, or at least it should  occur  less  often.
Continue doing (GC) until the message no longer occurs, or it is clear
that  the process is not going to converge.  If it stops occuring, you
can assess your core image to see whether there is  any  damage.    In
principle   functions   could   have  lost  their  definitions,  atoms
disappeared, etc. However none of  this  is  very  likely.    I  would
appreciate hearing about any experiences with this problem.



7.1. Functions that Invoke the Interpreter


This  is  a summary only.  Complete definitions of these functions are
given in the alphabetical reference section.

     *EVAL - the basic interpreter.    One  argument,  a  form  to  be
          interpreted.  Returns the result of evaluating it.

     EVAL - allows an optional second argument, to specify the binding
          context.    This argument can be either a number, which is a
          pointer to a binding context in effect further up the  stack
          (See the chapter on the Evaluation Context Stack.), or an A-
          list,  which  allows  you to specify that specific variables
          are to be bound to specific  values  before  evaluating  the
          form, with old values restored afterwards.

     *APPLY - this is used when you are a function and some arguments,
          as  separate  objects.  It is sometimes more convenient than
          making up a form to pass to EVAL, although in principle  you
          can always use *EVAL in place of *APPLY.  E.g. to CONS A and
          B,  you could do either (EVAL '(CONS 'A 'B)) or (APPLY 'CONS
          '(A B)).  In pure Lisp, this is only defined for  EXPR's  or
          bare  LAMBDA  forms.   This version has extended it to allow
          FEXPR's,  MACRO's,  etc.,  but   they   are   not   actually
          recommended.
                                                                    29


     APPLY  -  the  more  general form of APPLY, which allows an extra
          argument as for EVAL.

     APPLY# - the same as *APPLY, for compatibility  with  Rutgers/UCI
          Lisp.
                                                                    30


            8. Functions Dealing with Lists and CONS Cells



This  chapter will discuss the most basic data structure of Lisp:  the
CONS cell, and the functions for dealing with  data  structures  build
from CONS cells.

Before  beginning this discussion, a brief comment on Lisp terminology
is in order.  Almost everything that  you  manipulate  in  Lisp  is  a
pointer.    In this implementation, a pointer consists of a word whose
high-order 6 bits indicate the type of thing to which it  points,  and
whose low-order 30 bits are the address of the thing (except for small
integers,  where  the integer itself is stored in the 30 bits).  If we
say that a certain cell contains the atoms A and  B,  what  we  really
mean  is  that it contains pointers to the atoms A and B. Because Lisp
code always works with pointers, it  is  traditional  to  be  somewhat
sloppy  about  language,  and not bother to mention "pointer to".  The
discussion below will follow this convention. But please note that  it
is  impossible to put an atom or another CONS cell inside a CONS cell.
They wouldn't fit.  So you should  supply  "pointer  to"  when  it  is
missing.

The  CONS cell is the data structure from which dotted pairs and lists
are built.  Each cell can be thought of as a record  containing  space
for two Lisp pointers.  For historical reasons the two components of a
CONS  cell  are  refered to as the CAR and the CDR.  This can be shown
diagramatically as follows:

    _________
    |CAR|CDR|
    |___|___|

The simplest data structure that can be built from  CONS  cells  is  a
single  CONS cells whose CAR and CDR point to atoms.  Such a structure
is also refered to as a "dotted pair", because of the way Lisp  prints
it  out.  For example, a cell whose CAR is the atom A and whose CDR is
the atom B can be thought of thus:

    _________
    | A | B |
    |___|___|

It would print as (A . B) [Remember, what are actually in the cell are
pointers to A and B.]

More complex data structures are built by having the  CAR  and/or  CDR
point to other cells.  The most common such form is the list.  In this
data structure, a number of cells are linked together to form a chain.
The CDR of each cell contains a pointer to the next cell in the chain.
The CAR's contain the data.  Here is a list containing three members:

    _________   _________   _________
    | A | ----> | B | ----> | C |NIL|
    |___|___|   |___|___|   |___|___|
                                                                    31


NIL  is  a  special atom used to terminate lists.  Theoretically, this
list could be printed as three dotted pairs:

    (A . (B . (C . NIL)))

However  because  this  representation  is  so  common,  there  is  an
abbreviated notation for it:

    (A B C)

Whenever  you  see  items  between parentheses, without dots, a linked
list of this sort is meant.

Of course the data item of a list can be another list.  E.g.

    _________   _________   _________
    |   | ----> | B | ----> | C |NIL|
    |_|_|___|   |___|___|   |___|___|
      |
      V
    _________   _________   _________
    | X | ----> | Y | ----> | Z |NIL|
    |___|___|   |___|___|   |___|___|

This would be printed as

    ((X Y Z) B C)

This sort of nesting can go on indefinitely.  Finally, it is perfectly
possible to build data structures  that  do  not  follow  this  simple
pattern.    The  simplest case is one that is just like a list, except
that it does not terminate in NIL.

    _________   _________
    | A | ----> | B | C |
    |___|___|   |___|___|

In this case, it is printed like a normal list, except that the end is
printed as a dotted pair:

    (A B . C)

Finally, here is a structure that doesn't fit the list format at all:

          _________
          |   |   |
          |_/_|_\_|
          /       \
    _________   _________
    | A | B |   | C | D |
    |___|___|   |___|___|

This is a small binary tree.  It would have to be  printed  using  the
basic dotted pair notation:
                                                                    32


    ((A . B) . (C . D))

In  principle, any data structure built from CONS cells can be printed
using dotted pairs.  Except of course if it is circular:

          _________
          |   |   |____
          |_/_|_\_|   |
          /       \   |
    _________   ______|__
    | A | B |   | C | | |
    |___|___|   |___|___|

Attempting to print that would result in infinite recursion:

    ((A . B) (C . ((A . B) (C . ((A . B) (C . ......

In principle, only 5 functions are needed to manipulate any Lisp  data
structure:   CONS, CAR, CDR, RPLACA, and RPLACD.  And the last two are
probably not even needed.  CONS is the basic function for  creating  a
new  cell.   It takes two arguments, which are made the CAR and CDR of
the new cell:

    (CONS 'A 'B) --> (A . B)

Any other structure can be build by multiple calls to CONS.  E.g. here
is how to build a list of three members:

    (DE LIST3 (A B C) (CONS A (CONS B (CONS C NIL))))

CAR and CDR are all that is needed to get to any member  of  any  data
structure.   (CAR X) returns the CAR of X, and (CDR X) returns the CDR
of X. Here is how to combine these to get the third member of a  list:
(CAR  (CDR  (CDR  X))).  You will probably want to look at the diagram
for (A B C) to convince yourself that this would really return C. 

RPLACA and RPLACD are used  for  changing  the  contents  of  existing
cells.  It is quite possible to program without using them at all.  If
you  don't  use  RPLACA  and  RPLACD, then whenever you need to change
something, you simply construct a new copy with the necessary changes.
E.g. here is a function to change the second member of a list:

    (DE NEW2 (ITEM LIST)
             (CONS (CAR LIST)
                   (CONS ITEM (CONS (CDR (CDR LIST))))))

(CDR (CDR LIST)) is the rest of the original  list  after  the  second
member.    This  simply creates two new cells, the first a copy of the
original first cell, the second containing the new second member,  and
pointing  to (CDR (CDR LIST)).  RPLACA and RPLACD let you do this more
directly.  (RPLACA  cell  x)  changes  the  CAR  of  the  cell  to  be
X. (RPLACD  cell x) changes the CDR.  So we could rewrite the function
above as

    (DE NEW2 (ITEM LIST) (RPLACA (CDR LIST) ITEM) LIST)
                                                                    33


(CDR  LIST)  is the second cell in the chain.  This simply changes its
CAR to the new value.  LIST is mentioned at the  end  simply  to  make
NEW2 return the LIST rather than what RPLACA returns.

Note  that  there  is one very serious difference between writing such
functions with CONS and with RPLACA and RPLACD.  If you  use  CONS  to
build  new  list  structure,  then  anyone  who  had  a pointer to the
original list structure is unaffected.  However suppose that the  list
which  you  have  just changed was itself a member of some other list.
When you execute the version using RPLACA, you have changed  not  only
the list you intended to change, but the list that points to it.  That
is, suppose you do the following:

    (SETQ A '((A B C) D E))
    (SETQ B (NEW2 'X (CAR A)))

Before  executing  NEW2,  (CAR A) is the first member of the top list,
i.e. (A B C).  After executing it, the second member is changed to  X,
so B gets set to (A X C).  This is the case no matter which definition
of  NEW2  is  used.   But what is A now?  With the first definition of
NEW2 (using CONS), A is still  ((A  B  C)  D  E).    With  the  second
definition,  it  is  ((A  X  C) D E).  This is because the actual data
structure to which (CAR A) pointed was changed in  place,  whereas  in
the first version it was simply copied with changes.

It  is  perfectly  possible  to  program either way.  You just have to
realize what all the effects are going to be when you use  RPLACA  and
RPLACD.    The  main  advantage  of using them is that it is faster to
simply change a pointer than to copy list  structure  making  changes.
The fact that other lists that pointed to the one you changed are also
changed  may  be  an  advantage  or  a disadvantage depending upon the
design of your program.  In general, beginning programmers tend to get
themselves very confused when they  use  RPLACA  and  RPLACD,  and  we
advise  against  it  unless  you  are  very sure you know what you are
doing.

The strategy of making changes with RPLACA  and  RPLACD  is  known  as
"destructive  changing".  The strategy of making changes by copying is
known as "non-destructive changing".   Many  Lisp  functions  come  in
pairs  that  do the same thing, except that one is destructive and the
other is non-destructive.  The documentation below should always  make
it clear which strategy is being used.

There  is  one  other  basic  difference in strategy when working with
lists, the way you test for equality.  There  are  two  functions  for
checking  whether  things  are equal, EQ and EQUAL.  EQ checks whether
its two arguments are the same pointer.   EQUAL  checks  whether  they
point to similar things.  Consider:

    (SETQ X '(A B C))
    (SETQ Y '(A B C))
    (EQ X Y)
    (EQUAL X Y)

The  EQ  will  return  false (NIL) and the EQUAL will return true (T).
                                                                    34


While  X  and Y are both (A B C), they are in fact different copies of
(A B C).  That is, they are each lists whose first member is A, second
is B, and third is C. But they are different lists.    Thus  they  are
stored  at  different  addresses,  and  EQ shows them to be not equal.
However EQUAL tests (more or less) whether two  lists  look  the  same
when they are printed, and so it will show them as equal.

The  beginner  is  advised  to  use EQUAL for his tests, since he will
probably not be accustomed to keeping track  of  whether  things  that
look  the  same  are in fact identical pointers.  However EQ is faster
than EQUAL (because it does not need to look at  the  structure  being
compared),  and  experienced  Lisp  programmers  often  organize their
programs to use it.  Please note that numbers with the same value  are
not necessarily EQ to each other.  The only things that are guaranteed
to  be  EQ  are atoms and small integers (29 bits or less), and things
that are known to have been created at the same time.  What I mean  by
the latter can be shown easily:

    (SETQ X (CONS 'A 'B))
    (SETQ Y (CONS X 'P))
    (EQ X (CAR Y))

In this case the EQ will return true, since (CAR Y) is known to be the
same  pointer  as  X because of the way Y was constructed.  There is a
tendency for people who use destructive operations to use EQ and those
who use non-destructive operations to use EQUAL.

Before proceeding with detailed descriptions of the functions, let  me
again  remind  you of the special role of NIL.  Because NIL is used to
terminate lists, NIL alone represents the empty list (i.e. a  list  of
length  0).    NIL  and  ()  mean the same thing.  Note that it is not
necessary to quote NIL.  NIL (like  T)  always  evaluates  to  itself.
Also, please recall that functions that test conditions return NIL for
false,  and  anything  non-NIL  is  taken  to  be true.  When there is
nothing better to return, T is conventionally  used  for  true.    But
anything non-NIL will do.

As a special convenience, (CAR NIL) and (CDR NIL) are both NIL.

The  rest  of this chapter will be a summary of the functions that are
available for use with lists and  other  structures  built  from  CONS
cells.  It is organized into the sections containing functions for the
following purposes:

   - constructing  lists  incrementally,  i.e.  for building up a
     list in a loop by adding one element or a few elements at  a
     time.

   - constructing a whole list at once.

   - combining two lists.

   - modifying an existing list.

   - getting to an element of a list.
                                                                    35


   - testing lists or finding properties of them.

   - functions  involving  A-lists  (a special form often used to
     store associations between  items  and  properties,  or  any
     other binary relation)

   - a  special  facility  for  building  up  list  structures by
     instantiating templates.

Details are not given about the functions.  See the reference  section
for precise specifications.



8.1. Constructing Lists Incrementally - Adding a member


These  are  all  functions designed to add one member to a list.  Thus
they are well suited for use inside a loop where you want to  add  one
member at a time to a list.  However you will probably find other uses
for them.

The  classic  way  to  construct  a  list  one  member at a time is by
starting with NIL (the empty list), and adding one member  at  a  time
with CONS:

    (SETQ L NIL)
    (SETQ L (CONS 'A L))
    (SETQ L (CONS 'B L))
    L = (B A)

Note  that  if  you  build up a list using CONS, it ends up in reverse
order. That is, we added first A and the B, and the list ended  up  (B
A).

Here are the other functions intended to help build up lists.

     ATTACH  -  this  can  be  used the same way as CONS to build up a
          list.  However it is destructive.  It is useful  when  other
          data  structures  point  to a list, and you want them to see
          the list with the new member.

     CONS - see above

     ENTER - this can be used the same way as CONS to build up a list,
          but it checks first to see if  the  thing  to  be  added  is
          already part of the list.  If so, it doesn't add it.

     INSERT   -   used   for  lists  that  intended  to  be  in  order
          (numerically, alphabetically, etc.).  Inserts a  new  member
          in  the  proper  place  in  the  list.   You can specify the
          ordering function.  Destructive.

     MAPxxx - this is a loop.  Various options let you build up a  new
          list element by element (or piece by piece) while processing
                                                                    36


          an old one.

     NCONC1  - used to add a member to the end of a list.  Slower than
          TCONC because it has to go through to whole list to find the
          end.  So it is used where you don't  have  the  list  header
          required by TCONC.  Destructive.

     PUSH  -  a  macro  that uses CONS.  (PUSH L X) expands to (SETQ L
          (CONS X L)).   Saves  typing  (and  reduces  the  number  of
          parentheses).

     SUBSET  -  this  is  a  loop that builds up a list by letting you
          select which members of another list you  want.    Selection
          can involve any code you want.

     TCONC  and  LCONC  -  used  to build a list by adding to the end.
          Uses a special list header to keep track of  where  the  end
          is.    This  makes it almost as fast to add to the end as to
          the beginning.  Destructive.

     XCONS - exactly the same as CONS, with  its  arguments  reversed.
          It exists mostly for the convenience of the compiler.



8.2. Constructing a Whole List at Once


The  classic  function here is LIST.  (LIST 'A 'B 'C) returns (A B C).
LIST allows any number of arguments. Here are the others.    See  also
the functions for modifying existing lists.

     LIST - see above

     MAPxxx  - this is a loop.  Various options let you build up a new
          list element by element (or piece by piece) while processing
          an old one.

     MCONS - Similar to LIST, but uses the last argument as the end of
          the list, instead of NIL.  (MCONS 'A 'B 'C) is (A  B  .  C).
          Particularly useful for adding several things to an existing
          list, if the last argument is the existing list.

     NCONS - for building a list with one member.

     SUBSET  -  this  is  a  loop that builds up a list by letting you
          select which members of another list you  want.    Selection
          can involve any code you want.
                                                                    37


8.3. Combining Existing Lists


The  classic  function  here  is  APPEND.  This combines any number of
lists.  It is non-destructive, copying all but the last  list.    Here
are the others:

     APPEND - see above.

     *APPEND - special version of APPEND that allows only 2 arguments.
          Possibly this is slightly faster in this case than APPEND.

     INTERSECTION  - returns a list consisting of only items that were
          part of both original lists.  You can  change  the  function
          used to test whether something is a part of a list.

     LDIFF  -  used  when the second list is a tail of the first, i.e.
          it can be gotten from the first by CDR's.  Returns the  part
          of the first up to the start of the tail.

     MERGE   -   used  for  lists  that  are  sorted,  alphabetically,
          numerically, etc.  Merges two lists to produce a single  one
          that  is  in  order.   You can select the ordering function,
          etc.

     NCONC - similar to APPEND, but destructive.  That is, goes to the
          end of the first list, and modifies its CDR to point to  the
          next one.  NCONC works for any number of lists.

     *NCONC  -  special  version  of  NCONC  that  works  only for two
          arguments.  Possibly this is slightly faster than  NCONC  in
          this case.

     UNION  -  appends  two  lists, but only adds things from one that
          were not already in the other



8.4. Modifying Existing Lists


Actually some of the MAPxxx functions can be useful for producing  new
lists from old ones, as can DO.

     COPY - this copies without change (the null modification)

     DREMOVE  -  destructive version of REMOVE.  Removes a single item
          from a list.  Changes the list  destructively,  uses  EQ  to
          test for the item.

     DREVERSE  -  destructive  version  of  REVERSE.  Reverses the top
          level of a list, in place.

     DSUBST - destructive version of SUBST.  Finds all occurences  (EQ
          to) one thing and changes them destructively to another.
                                                                    38


     LSUBST  -  similar  to  SUBST,  but replacement is a list that is
          "spliced" into the original instead of made a member.

     MAPxxx - this is a loop.  Various options let you build up a  new
          list element by element (or piece by piece) while processing
          an old one.

     REMOVE  -  Removes  a single item from a list, non-destructively.
          Uses EQUAL to look for it.

     SORT - makes a sorted copy of the list.  You can  determined  the
          ordering function, and lots of other things.

     SUBLIS  -  a  multiple SUBST.  Takes a list of changes.  When any
          one is found, changes to corresponding new.

     SUBPAIR - similar to SUBLIS,  but  specifies  the  changes  in  a
          different format.

     SUBSET  -  this  is  a  loop that builds up a list by letting you
          select which members of another list you  want.    Selection
          can involve any code you want.

     SUBST - replace all occurences of one thing with another

     UNMACEXPAND - remove macro expansions from a piece of code.



8.5. Getting Parts of a List


The  classic functions here are CAR and CDR, described above.  Because
it is so common to nest CAR and CDR, e.g. (CAR (CDR (CAR  X))),  there
are  a  number  of  predefined  functions  of  the  form CADDR.  These
represent nested combinations of CAR's and CDR, in the same  order  as
the A's and D's in the name.  E.g. CADDR has A, D, D, so it represents
(CAR  (CDR  (CDR.    All combinations up to 4 A's and D's exist.  Note
that to get the N'th member of a list you use CADDDR, with N-1 D's.

     CAR, CDR, CAAR, ... - see above

     FNTH - similar to NTH, but faster because less error checking.

     LAST - returns the last cell of a list.  Note, this is the  enter
          cell,  not  its  CAR.  So (CAR (LAST is the last item in the
          list.

     NTH - returns the Nth cell of a list.  Again, (CAR  (NTH  is  the
          Nth item.
                                                                    39


8.6. Testing Lists or Finding Properties of Them


The  most  commonly  used  of  these  are  ATOM,  which checks whether
something is a list, EQ and EQUAL which check for equality, and MEMBER
and MEMQ which checks whether something is a member of a list.

     ATOM - true if something is an atom, i.e. not a  list.    Usually
          used  to  stop  loops  or recursive functions that go down a
          list.

     CONSP - true if something is a CONS cell.  This  is  exactly  the
          opposite of ATOM.

     %DEPTH - how many levels deep a list structure is nested.

     EQ - equality - must be the same pointer

     EQUAL  -  equality  - must have the same structure, with the same
          atoms at the bottom.   EQ  used  for  literal  atoms,  tests
          numbers for numeric equality.

     INP  -  checks  whether  something is a member of a list.  Unlike
          MEMBER and MEMQ, checks all levels of the list.

     LENGTH - number of cells in the top level of a list

     MEMB - old name for MEMQ

     MEMBER - checks whether something is a member (at the top  level)
          of a list, using EQUAL.

     MEMBFN - set to MEMBER or MEMQ (usually MEMBER).  Used to control
          checking of duplicates in UNION and INTERSECTION.

     MEMQ - checks whether something is a member (at the top level) of
          a list, using EQ

     NE - not EQUAL

     NEQ - not EQ

     NULL - is it NIL?

     TAILP  - checks whether one list is a "tail" of another, i.e. can
          be gotten from the other by multiple CDR's.

     = - abbreviation for EQUAL
                                                                    40


8.7. A-lists


An  A-list is a list structure used to store binary relations.  It can
be used to store values, properties, or any other association you want
to make.  It is a list of dotted pairs, with  the  CAR  of  each  pair
being the "key" and the CDR the associated value.

     ASSOC  - specifies a key.  Look for something in the A-list whose
          CAR matches (with EQ) the key, and return the item.

     ASSOC# - like ASSOC, but uses EQUAL instead of EQ.

     ASSOC-EQUAL - another name for  ASSOC#,  for  compatibility  with
          older systems.

     SASSOC  -  like  ASSOC,  but  if  the thing is not found, calls a
          specified function

     SUBLIS - uses a A-list to specify changes  to  make  in  a  list.
          Anything  that  matches the CAR of an item is changed to the
          CDR.



8.8. Template instantiation facility


Sometimes it is desirable to  build  up  list  structure  based  on  a
"template".  E.g. here is an example of a macro to define a simple IF-
THEN-ELSE statement:

    (DM IF (L) `[COND (,(CADR L) ,(CADDR L)) (T ,(CADDDR L))])

The  template  is  the  part beginning with the back-quote (`).  Back-
quote can be thought of as causing the template to be  copied  with  a
few  changes.  If no commas occured in the template, there would be no
changes.  In this case back-quote would do  almost  exactly  the  same
thing  as  quote.    You  would  get an unchanged copy of the original
template.  However wherever a comma occurs, the  expression  following
it  is  evaluated,  and  its  value  is  put  in  that position of the
template.  So if L was bound to

    (IF A 3 4)

the result would be

    [COND (A 3) (T 4)]

In addition to single commas,  it  is  also  possible  to  use  double
commas.    A  double  comma  causes  the  following  expression  to be
evaluated and then "spliced into" the template.  Essentially  splicing
removes the outermost set of parentheses from the expression involved.
E.g  here is a macro that lets you write MAPC in a somewhat simplified
form, where only the list and the body of the loop are given.
                                                                    41


    (DM MAPX (FORM) `(MAPC (FUNCTION (LAMBDA (X) ,,(CDDR FORM)))
                           ,(CADR FORM)))

    For example

    (MAPX L (PROCESS X) (PRINT X))

    becomes

    (MAPC (FUNCTION (LAMBDA (X) (PROCESS X) (PRINT X))) L)

Note  that  (CDDR FORM), which is ((PROCESS X) (PRINT X)), was spliced
into the pattern without the outermost parentheses.

Actually ` is a readmacro that expands to a call on BACK-QUOTE.   I.e.
`EXP creates (BACK-QUOTE EXP).  , and ,, are readmacros that expand to
COMMA  and  DOUBLE-COMMA  respectively.   BACK-QUOTE is defined as the
function that does the expansion of the templates.  COMMA and  DOUBLE-
COMMA are simply atoms that appear in the pattern.
                                                                    42


          9. Tests, loops, and other program control; Errors



This  chapter  will  describe forms that are used for program control,
e.g.  tests and loops.  Error handling will be  included  here,  since
error handling in Lisp is essentially non-local program control.

This chapter has the following sections:

     Basic  control  constructs - the most common tests and loops, and
          constructs for  executing  several  expressions  in  various
          special contexts.

     Mapping  functions - functions that perform a certain function on
          each member of a list, for various purposes.

     PROG - if you must have GOTO and RETURN statements

     Non-local transfers of control - how  to  get  out  of  something
          quickly, including error handling

     Functions for implementing a single stepper

This  chapter has not been written yet, but the lists of functions are
there so you can find what you need in the reference section.



9.1. Basic Control Constructs


Basic control constructs -  the  most  common  tests  and  loops,  and
constructs  for  executing  several  expressions  in  various  special
contexts.

Here is a summary of the functions described in this section:

     COND - the basic form for doing IF-THEN-ELSE, and other kinds  of
          tests.

     AND,  OR, and NOT - ways of writing complex tests.  Note that AND
          and OR evaluate from left to  write,  and  stop  when  their
          value  is  determined.  So AND is really like IF x THEN IF y
          THEN IF z ...; and OR is really like IF x OR IF y  OR  IF  z
          ...

     SELECTQ  -  a  way  of  writing tests based on matching one thing
          against several possible values, i.e. something like IF X  =
          A  then ... or if it = B then ... or if it = C, D, or E then
          ... ...

     RPTQ - the simplest loop - does code a specified number of times

     DO - a quite general loop, lets you  increment  a  counter,  have
                                                                    43


          variables CDR down lists, etc.

     PROG1,  PROG2,  PROGN - execute a block of expressions, returning
          the value of the first, second, or last one

     WITH - define some local variables for a block of expressions

     WITHIN, WITHOUT - execute a block of expressions  with  input  or
          output temporarily pointing to a different file

     ELISP:,  UCILISP:   - for writing code that will run on both this
          Lisp and Rutgers/UCI lisp.  Indicates portions of code  only
          to be used on one of these systems.

     NILL - ignore what is inside



9.2. Mapping functions


A  mapping  function is a function that applies some other function to
every member of a list.  For example,

    (MAPC 'PRINT '(A B C))

will apply PRINT to each member of the list (A B C), and thus prints

    A
    B
    C

Various of these functions let you make a list  of  all  the  results,
select  certain  members  of  the list, etc.  Here is a summary of the
mapping functions.

     MAPxxx - a set of functions that apply a given function to  every
          member  of  a  list,  or  to successive CDR's of a list, and
          return either nothing, a list of everything returned by  the
          function calls, or a concatenation of everything returned by
          the  function  calls.  See the entry MAPxxx in the reference
          section.

     EVERY, SOME, NOTEVERY, NOTSOME - check whether a  given  function
          succeeds  (returns  non-NIL)  for every member of a list, at
          least one member of the list, etc.

     SUBSET - returns a  sublist  made  up  of  those  members  of  an
          original  list  for which a given function succeeds (returns
          non-NIL).  I.e. lets you select members of a list.

     MAPATOMS - apply a function to every atom in the system
                                                                    44


9.3. PROG


The  PROG  statement  gives  you  the  equivalent  of blocks in Algol,
Pascal, PL/I, or Ada.  That is, it sets up a context in which you  can
do  GO  to  transfer  control  directly to a specified label.  It also
allows RETURN, which exits from the current block.  Finally,  it  sets
up  local variables (as does WITH).  PROG itself isn't of any use - it
is used because only within a PROG can you do GO and RETURN.

     PROG - sets up a context in which GO and RETURN work.  Also  lets
          you have local variables.

     GO - transfer control to somewhere else within the current PROG.

     RETURN - exit from the current PROG



9.4. Non-local Transfers of Control


These  constructs  allow  you to exit from a particular function, with
control being caught by some other function that called  it,  or  that
called  another  function that called it, etc.  They also let you take
over control if an error occurs, or simulate an error yourself.

See also the following functions, described  in  the  section  on  the
Evaluation  Context  Stack.    They  let  you  return to or execute an
expression in the context of an earlier  binding  context:    RETFROM,
OUTVAL, SPREDO, SPREVAL.

     CATCH  and  THROW  - the non-local control functions designed for
          normal users.

     ERRSET - set up a context in which you will get  control  if  any
          errors happen

     ERR  and  ERROR - simulate an error.  ERROR simulates a real Lisp
          error.  ERR uses the same internal mechanisms as an error to
          get to an error handler if any, but if  you  don't  have  an
          error handler, it doesn't create a real Lisp error.

     *RSET and ERRORX - control details of error processing



9.5. The Single Stepper


     HOOK1,  HOOK2  -  The  user defines these functions, to print out
          what is happening when the user asks for single stepping.

     SSTEP - initiate single step mode
                                                                    45


                  10. Boolean functions (Predicates)



The  functions  described  in  this  section  are  those  designed for
constructing tests.    They  return  values  that  are  most  commonly
interpreted  as  true  or  false.   Please recall that in Lisp, NIL is
means false, and any non-NIL value means true.  Some functions  simply
return  the atom T for true.  Others return useful information that is
guaranteed not to be NIL.  The latter category can obviously  be  used
for things other than tests.

This chapter is divided into the following sections

     functions for combining other tests - AND, OR, NOT

     comparisons - equality, inequality, greater, less, etc.

     types  and  properties  - is it a number, a list, etc.?  Also two
          random properties:  is it = NIL, does it have a value?

     membership and subset tests - is something a member of a list, is
          something a subset of another, a sublist  of  another?    Is
          there  at  least  one,  none,  all,  items  in a list have a
          specified property?

     functions for treating integers as bits - shifting, and combining
          integers with Boolean functions bitwise



10.1. AND, OR, and NOT


     AND - If all of N expressions are true, returns the value of  the
          last.  Otherwise NIL

     OR  -  If  any  of  N  expressions  is  true,  returns its value.
          Otherwise NIL.

     NOT - If the expression is true, returns NIL, else T. 



10.2. Comparisons


This section covers comparisons for equality and inequality,  as  well
as  tests of order, i.e. less, greater, etc.  (These may applicable to
things other than numbers.)

One of the most basic distinctions in Lisp is between  equality  tests
based on EQ and those based on EQUAL.  EQ tests for identical objects,
i.e.  the  same  pointer.    EQUAL  tests  for  objects  that, roughly
speaking, look the same when printed.  For example, (EQUAL  '(A  B  C)
                                                                    46


'(A  B  C)) will return T, but the same test with EQ instead of EQUAL,
will return NIL.  The reason is that when you type '(A B C) twice  you
get  two  different  lists  with  the  same  members.  EQUAL returns T
because they have the same structure, but EQ returns NIL  because  the
actual cells of which the lists are made up are different.

The following things show as being EQ to each other:

     literal atoms - because atoms are stored uniquely.  I.e. there is
          only  one XYZ, so any pointer to it is the same as any other
          pointer to it.

     small integers - because  the  actual  value  is  stored  in  the
          pointer  point  of the object.  Thus two small integers with
          the same value are always look the same.

Other sorts of things will be EQ to each other  only  if  one  can  be
traced to the other historically.  I.e. if you do

    (SETQ X (CONS 'A 'B))
    (SETQ Y X)
    (SETQ Z (CONS X NIL))
    (SETQ P (CAR Z))
    (SETQ Q (CONS 'A 'B))

then  the  following  things are all EQ to each other:  X, Y, and P. X
and Y are EQ because of the (SETQ Y X), which means that Y is the same
pointer as X. P is EQ to them because (CONS X NIL) puts X into the CAR
of the new CONS cell, and (CAR X) just looks at that CAR. Y and P  are
EQ  to X because they go back to it "historically".  I.e. if you trace
where Y and P came from, they are simply the results of moving  around
the  pointer  that was originally in X. Q is different because it is a
CONS cell that was generated separately.   Since  each  call  to  CONS
creates a new cell, this means that Q must be different from any other
CONS  cell,  including  X. This is true even though what is in the CAR
and CDR of those CONS cells is the same, and thus they both  print  as
(A . B).

EQUAL  is  designed  to find things that are equal in a more intuitive
way.  If two things are  EQ,  then  they  are  also  EQUAL.    But  in
addition, EQUAL detects two more kinds of equality:

     CONS  cells  -  if  something is a CONS cell (e.g. the start of a
          list), then EQUAL compares the CAR's and CDR's.  If they are
          EQUAL, then the CONS cells are considered to be EQUAL.  Thus
          in the above example X and Q are  EQUAL  because  they  both
          have  A  as  a  CAR  and  B as a CDR.  This EQUAL test works
          recursively, so more complex list structures  are  EQUAL  if
          they "look the same" in the sense that the structures match,
          and all the atoms in corresponding places are the same.

     numbers  -  the  numbers  are numerically the same.  Integers and
          reals will match if their values are identical, e.g.  0  and
          0.0, or 1 and 1.0
                                                                    47


Note  that  (EQUAL  "abc"  "abc") is still NIL, because strings do not
fall into any of the categories for which either EQ or EQUAL checks.

Here are the various comparison tests:

     EQ - the same object exactly

     EQUAL - similar, i.e. CONS cells are EQUAL  if  their  CAR's  and
          CDR's are, and numbers are checked numerically.

     = - another name for EQUAL

     EQP - numerical equality, currently the same as EQUAL

     EQSTR  -  checks strings (and atoms) to see if they look the same
          (have the same characters in their print names)

     *GREAT, GT, *LESS, LT - compare 2 numbers for  greater  or  less.
          GT and LT are simply different names for *GREAT and *LESS.

     GREATERP,  LESSP  -  as above but allow more than 2 numbers to be
          compared.

     GE, LE - greater than or equal, less than or equal, for numbers

     NE - (NOT (EQP

     NEQ - (NOT (EQ

     LEXORDER  -  uses  alphabetical  order  for  strings  and  atoms,
          numerical values for numbers

     MINUSP,  ZEROP, =0 - for numbers: less than zero, equal zero.  =0
          is another name for ZEROP.



10.3. Types and Properties


Most of the tests in this section check whether  an  object  is  of  a
certain  kind, e.g. a number, a specific kind of number, a CONS cells,
etc.  Two somewhat random tests are also  included  in  this  section:
BOUNDP,  which  shows  whether  a variable has been given a value, and
NULL, which shows whether something is NIL or not.

     CONSP - is it a CONS cell

     ATOM - is it something that would mark the end of  a  list,  i.e.
          anything  other than a CONS cell.  This is the right test to
          use to terminate recursive procedures or loops that look  at
          list  structure.    Note that NIL is an ATOM for purposes of
          this test.

     PATOM - obsolete name for ATOM.
                                                                    48


     LITATOM  -  is it a literal atom, what people usually think of as
          an atom (but the term "atom" properly included other things,
          such as numbers and strings).

     NUMBERP - is it some kind of number?

     INUMP - is it an INUM, i.e. a small integer.  INUM's are  special
          because  any  two  INUM's with the same value are EQ to each
          other.   Currently  numbers  from  -2**29  to  +2**29-1  are
          INUM's,  but we do not guarantee this.  We do guarantee that
          the length of a list is  always  an  INUM,  and  in  general
          anything you can count should be an INUM.

     MINUSP - is it a negative number?

     ZEROP - is it 0 or 0.0?

     STRINGP - is it a string?

     BOUNDP  -  applies only to literal atoms.  T if the atom has been
          bound to a value by  SETQ,  by  being  used  as  the  formal
          parameter in a function, or by appearing as a local variable
          in  WITH  or  PROG.   In compiled code, only shows variables
          that have been declared SPECIAL.

     NULL - is it NIL?  Note that NULL and  NOT  do  the  same  thing.
          However  they  are usually used for different purposes.  NOT
          is used when you are thinking of the thing the object  being
          tested as a Boolean value, i.e. true or false.  NULL is used
          in  other  cases,  such  as testing for an empty list.  Note
          that ATOM is often what you should be  using  when  you  use
          NULL,  since  ATOM is a slightly safer test for the end of a
          list.



10.4. Membership and Subset Tests


The first category of tests checks for whether an item is a member  of
a list, in one way or another.  Other closely related tests are TAILP,
which  checks  whether  one  list  is the tail of another (i.e. can be
gotten from the other by doing several CDR's),  and  INTERSECT,  which
can  be  used  to test whether there is any overlap between two lists,
viewed as sets.

The second category of tests applies some function to every member  of
a list, and tells whether was true, at least once, every time, etc.

     MEMBER  -  checks  whether  an  item  is a member of a list, i.e.
          whether it is EQUAL to something at the top level of a list.

     MEMQ - similar, but uses EQ for checking.

     INP - similar to MEMQ, but  will  find  an  item  anywhere  in  a
                                                                    49


          complex list structure, not just at the top level.

     MEMB - an obsolete name for MEMQ.

     MEMBFN  -  this lets you control whether MEMBER or MEMQ should be
          used for ENTER, INTERSECTION, and UNION.  It is normally set
          to MEMBER.

     TAILP - can one list be gotten from another by doing CDR's?

     INTERSECTION - are there any elements in both lists?  (returns  a
          list of them)

     EVERY,  SOME,  NOTANY, NOTEVERY - applies a specified function to
          items in a list and indicates whether it  returns  true  for
          each one, at least once, never, or not all the time.



10.5. Functions for Treating Integers as Bits


These  functions  are  used  when  you  want to regard an integer as a
string of 36 bits.

     LSH - shifts left or right a specified number of bits.

     BOOLE - combines integers, doing bitwise AND, OR, XOR, etc.   You
          can  specify any of the 16 possible Boolean functions to use
          bitwise.  Allows any number of arguments.
                                                                    50


                               11. I/O



Lisp  I/O  can  be  thought  of as being divided into three conceptual
levels:

   - Individual characters - TYI and TYO

   - S-expressions - READ and PRINT (PRIN1, PRINC, etc.)

   - Entire files - LOADF, SAVEF, DSKIN, DSKOUT

Most users will deal with the last two levels.    Your  programs  will
probably  read data from the terminal using READ and write out results
using PRINT, PRIN1, etc.  When you are dealing at this level, all your
program has to worry about is atoms, lists, etc.  READ takes  care  of
reading  the individual characters "N", "I", and "L", and figuring out
that the identifier "NIL" is meant.  It even  takes  care  of  reading
more  complex things such as reading "(A B (C . D))" and producing the
appropriate list of objects.  Similarly, PRINT takes a Lisp object and
creates the correct representation for it.

Unlike READ and PRINT, which you will probably use for most of the I/O
in your programs, LOADF, SAVEF,  DSKIN,  and  DSKOUT  are  not  really
designed  to be put into programs.  They are intended as functions for
you to call directly from the "top level" of Lisp. LOADF  and    DSKIN
are  used  to  read in function definitions from a disk file.  In case
you change any definitions, or  define  new  functions  interactively,
SAVEF  or  DSKOUT  can be used to save definitions on a disk file.  As
long as this is the only use you are going to make of disk files,  you
may  not  need  to  know  how  how  Lisp handles file I/O, since these
functions take care of all of that for you.

Here, then, is a summary of the way this chapter is organized:

   - Basic output - writing  out  Lisp  objects  with  PRINT  and
     friends

   - Nicer  output - various functions designed to control output
     formats in more detail

   - Basic  input  -  reading  in  Lisp  objects  with  READ  and
     LINEREAD.    How  to  make  lower case characters be handled
     correctly.

   - Character level I/O -  functions  for  reading  and  writing
     single  characters  (in case the functions above aren't good
     enough)

   - Readtable and readmacros - How to customize the behavior  of
     READ  to  fit  your  own tastes or to allow you to turn READ
     into a lexical analyzer for your favorite language.

   - Reading and writing definitions from files -  LOADF,  SAVEF,
                                                                    51


     DSKIN,  DSKOUT,  GETDEF,  and SAVEIMAGE - functions designed
     save and load functions.  FLAP, for loading  compiled  code.
     LOADREL  for  loading  from  .REL  files  produced  by other
     languages.

   - Basic file I/O - how to do I/O (using READ, PRINT, or any of
     the other functions) to files,  printers,  etc.    The  most
     common functions.

   - General file I/O - functions that let you do almost anything
     with files that is possible.

   - Terminal  handling  -  functions  designed  to  control  the
     terminal:  turn on and off echoing, change the prompt,  turn
     on and off the funny control characters

   - Functions present for compatibility with Rutgers/UCI Lisp

In addition, you may find the following functions, which are described
elsewhere, useful:  EXPLODE, EXPLODEC, AEXPLODE, and AEXPLODEC produce
the same output that PRINT would produce, but instead of writing it to
an output device, they return a list of the characters (in one form or
another).    MAKNAM  and  READLIST  take such a list of characters and
produce the Lisp structure that  you  would  get  if  you  read  those
characters from in input device using READ.



11.1. Basic output functions


PRINT  simply  prints  out  a  Lisp data structure, using the notation
described here in the manual.  It makes to attempt to make the  output
look  nice:   It just puts in all the parentheses and dots, and writes
out whatever you pass it.  Thus if LONGLIST is a variable containing a
very long  list,  and  your  program  executes  the  statement  (PRINT
LONGLIST), you are likely to see something like this on your terminal:

    (NOCALL EVALP GOFN EDBRK BKTRACE BKFIND BKTR BKTRV BKPR^Y
    INVAL BKACT CHNMX CHNM1 BKREAD ARGLIST %%MSGFLAG %%BKPO^Y
    S %%CMDL %FROM %TO CHNGDFLG %PRINFN (*FSUBR BKREAD ERRO^Y
    RX))

(^Y  will  not  print  on  the terminal, but will show up if output is
being done to a file.)  Note how PRINT simply puts as many  characters
on  a  line  as  it  thinks will fit.  It quite happily breaks up atom
names in the middle.  It puts ^Y (control-Y) at the end of each  line.
This  is  done in case the output is going to a file, and will be read
back in.  ^Y is a signal that something has been continued to the next
line.  Thus

    (APPLY BANANA  AARD^Y
    VAARK)

is a list with three elements, the third of which is  AARDVAARK.    If
                                                                    52


the  ^Y  were  not there, the end of line would indicate the end of an
atom.  So

    (APPLY BANANA AARD
    VAARK)

would be a list of 4 elements, the last two being AARD and VAARK.  You
can control how long PRINT thinks the line is by using LINELENGTH.

There are several similar functions, to allow you to make output  look
a bit more like you want it to:

     (PRIN1 thing) - prints a Lisp object as just described

     (PRINA  thing  pos)  - Like PRIN1, except if an atom won't fit on
          the line, a  tab  to  position  POS  on  the  next  line  is
          performed  before printing resumes.  POS is optional, with a
          value of 1 assumed if omitted.  This allows you to avoid the
          ^Y's in case you don't like them.

     (PRINT thing) - skips to a new line, does (PRIN1 thing), and then
          outputs a space.

     (PRINC thing) - prints a Lisp object, almost exactly like  PRIN1.
          However PRINC doesn't use / for odd characters in atoms, nor
          does  it  put  " " around strings.  Thus it is most commonly
          used for putting in puncuation.   e.g.  to  print  two  Lisp
          objects  with  a  space between them, you would typically do
          (PRINT thing1) (PRINC " ") (PRIN1 thing2).

     (PRINAC thing pos) is like PRINA but doesn't use / and " "

     (PRINTC thing) - skips to a new line,  does  (PRINC  thing),  and
          then outputs a space.

     (TERPRI) - just skips to a new line



11.2. Nicer looking output


This  is all fairly unexciting if you are trying to print nice looking
output.  Thus there are two other sets of functions  that  you  should
also  consider  using.   These other functions could all be written in
terms of those (indeed they do call PRIN1 and PRINC internally).   The
first  set  of  functions  is  designed to make things look nicer in a
somewhat automated fashion.    The  basic  one  of  these  is  SPRINT.
(SPRINT thing) will print the value of thing using indentation to help
you  make  sense  of it.  It will try to place items so that ^Y is not
needed, although now it then it will have to continue something beyond
the end of a line.  Here is some typical output from SPRINT:
                                                                    53


    (DF DE (F)
            (OR (MEMQ (CAR F) ALLFNS)
                (SETQ ALLFNS (CONS (CAR F) ALLFNS)))
            (ALIAS (CAR F)
                  (APPEND (LIST 'EXPR
                                 'LAMBDA
                                 (CAR (CDR F)))
                           (CDR (CDR F))))
            (CAR F))

Actually  this  example  happens  to be a function definition.  It was
printed with PP (the prettyprinter).    However  SPRINT  is  the  real
intelligence behind PP, and you can use it yourself if you want to.

In the opposite direction, for those who want to control the format of
their  output  a  bit, there are MSG and TTYMSG MSG provides a general
message-printing facility for LISP. It can be  thought  of  as  Lisp's
answer to the Fortran format statement.  It takes as many arguments as
you  like.  Each argument is a specification for some output, both the
output itself and its format.  Here are the  things  that  can  go  as
arguments to MSG:

     "<string>" Print <string> using PRINAC

     +<number> Space <number> (gt 0) spaces

     (T '<n>) Tab to position <n>

     T Move to new line

     -<number> Print <number> blank lines

     0 Get to start of line

     (E <expr>) Evaluate <expr>

     (C <expr>) Evaluate <expr> and print with PRINC

     other Eval and print using PRINA

As an example of the use of MSG, consider the following:

    (MSG 0 "Value of X is:" 5 X T)

which is equivalent to:

    (PROGN (LINES 0)
           (PRINAC '"Value of X is:")
           (SPACES 5)
           (PRINA X)
           (TERPRI))

Here  is  a summary of the various functions available for letting you
control your output format:
                                                                    54


     BASE  -  a  variable  -  set  it  to some number between 2 and 10
          inclusive, to cause that base to be  used  by  all  routines
          that  print  integers.  (Real  numbers  will  continue to be
          printed in decimal.)

     *NOPOINT - a variable - controls whether a dot or "Q" is used  to
          show the radix unambiguosly for base 10 and 8 respectively.

     *NOPOINTDSK  -  a  special  version  of  *NOPOINT used by DSKOUT,
          SAVEF, and COMPL.

     MSG - a general-purpose function for formatting output, described
          above.

     TAB - move to a specified position on the line

     SPACES - print a specified number of spaces (blanks)

     LINES - print a specified number of lines (0 is useful because it
          gets to a new line, but does  nothing  if  you  are  already
          there).

     *PG* - put out a page mark (form feed)

     LINELENGTH  -  set  or  return  the  maximum number of characters
          allowed on a line.  Negative numbers for no limit, but  this
          is not recommended if you intend to use the prettyprinter.

     CHRCT,  CHRPOS  -  two  ways  of finding out where you are on the
          current line (CHRPOS is position from the  start,  CHRCT  is
          number  of  characters  left  on  the line before you get to
          LINELENGTH).

     PRINTLEV - print lists, stopping at a certain  depth  of  nesting
          (useful  for  brief  overviews  of complex structure, or for
          possibly circular  lists).    Goes  to  a  new  line  before
          printing.

     PRINLEV  - similar to PRINTLEV, but doesn't go to a new line, and
          what it returns is undefined.

     SPRINT - prettyprint an object (see the chapter  devoted  to  the
          prettyprinter)

     %PRINFN  -  a  variable - set to the function to be used by BREAK
          and TRACE for output.  This lets you define your own  format
          for them.  Initially PRINTLEV.

     /#%INDENT - global variable used to keep trace of indentation for
          printing TRACE output.  You will need this if you write your
          own  function  to  use  for %PRINFN. The "/" is not actually
          part of the variable name.  It is simply #%INDENT.   However
          in  most  cases you will have to "quote" the # with a slash,
          since # is normally a read macro.
                                                                    55


     %PRINFNTOP  -  a  variable  -  set to the function to be used for
          printing by the top level of lisp.   This  lets  you  define
          your own format for this output.  Initially set to PRIN1.



11.3. Basic input function


There is much less variety in Lisp input, since there is no particular
reason to want to be able to control formats there.  For all practical
purposes,  READ  is  the  only  function you are likely to use in your
program.  Each time you call  READ,  you  will  get  one  complete  S-
expression,  i.e.  an object with balances parentheses.  E.g.  suppose
you type the input

    (TOP ABOVE NODE1) (NODE1 ABOVE NODE23)

This would take 2 calls to READ.  The first would  return  (TOP  ABOVE
NODE1), and the second would return (NODE1 ABOVE NODE23).

Here are the basic input functions:

     IBASE  -  a  variable  -  the can be set to a number from 2 to 10
          inclusive.  It controls the base used to interpret  integers
          read  in,  unless a specific radix point is typed after them
          (dot for decimal, and "Q" for  octal).    Real  numbers  are
          always interpreted as decimal.

     *RAISE  -  a variable - if non-NIL, lower case letters are turned
          into upper case except inside strings (and  if  quoted  with
          /).

     *RAISEDSK  - a variable - used instead of *RAISE in DSKIN, LOADF,
          and COMPL

     READ - read (and return) one Lisp  expression  from  the  current
          input channel.

     RDNAM  -  just  like READ, but any atoms that it comes across are
          not INTERN'ed.  INTERN'ing is the process that  is  used  to
          make  sure  that  there  is only one atom with a given name.
          Anything that looks like an atom is looked up  in  a  symbol
          table.    If  an atom with the same spelling already exists,
          the existing one is returned.  Otherwise, the  new  atom  is
          added  to  the  symbol table.  When RDNAM is used, atoms are
          not processed in this way.  So each time RDNAM comes  across
          the  characters  "FOOBAR",  a  new  and  different  atom  is
          created.  This speeds things up slightly, but  creates  lots
          of garbage atoms.  It is probably a bad idea.

     LINEREAD  -  used  to  read command lines.  It returns everything
          that the user types on one line,  as  a  list.    There  are
          provisions for continuation lines.
                                                                    56


     READL - another name for LINEREAD.



11.4. Dealing with individual characters


If  you  find  that  the  functions listed above don't give you enough
control, you can always "roll your  own".    (TYI)  returns  the  next
character  from the input.  What it really gives you is a number which
is the ASCII code for that character.  (READCH) does the  same  thing,
but returns the character as an atom.  That is if what is there is the
letter A, (TYI) will return 65, and READCH will return the atom A. 

(TYO  char)  writes  one  character.  CHAR should be a number, as with
TYI.

Those who use TYI and TYO may find it useful to look at the  functions
EXPLODE,  EXPLODEC,  AEXPLODE,  AEXPLODEC,  READLIST,  MAKNAM, and the
various string functions (which will described in a separate chapter).
These functions allow you to combine characters into higher-level Lisp
objects.  E.g. suppose you have read in the characters  A,  B,  and  C
(you  will really have 65, 66, and 67, their ASCII codes).  If you now
want to turn those into the Lisp  atom  ABC,  you  can  do  that  with
READLIST  or MAKNAM.  READLIST takes a list of characters and produces
an internal Lisp object.  Similarly, the variants of  EXPLODE  take  a
Lisp structure and produce a list of characters.  EXPLODE and EXPLODEC
give  you  a  list  of single-character atoms.  AEXPLODE and AEXPLODEC
give you a list of numbers, as used by TYI and TYO.  The  ones  ending
in C act like PRINC, i.e. they don't put in / and " ".

Here is a summary of the functions for single-character I/O:

     TYI - read a character, return as a number

     READCH - read a character, return as an atom

     UNTYI  -  "unread  a  character", i.e. set things so the next TYI
          will read this character, instead of doing  physical  input.
          You  can  only  unread  one  character.   This allows you to
          "peek" ahead one character, and then  put  it  back.    More
          bizaare  effects  are  available  if  you put back something
          else.

     PEEKC - return the next character, but UNTYI it.  Thus  the  next
          TYI will get it again.

     TYO - write a character, specified as a number

     TYOA  -  write a character, and if it does not fit on the current
          line, go to a specific column on the next line.  (TYO  would
          simply go to the start of the next line.)
                                                                    57


11.5. How to modify the syntax: Readmacros


It  is  possible  to  add  to  the  syntax  of  the  language by using
readmacros.  If this is your first  exposure  to  Lisp,  you  probably
should  skip  this section.  A Readmacro specifies some Lisp code that
will be executed whenever READ sees a certain character.    This  lets
you cause selected characters to have special effects.

More  precisely,  a  readmacro  is  a LAMBDA expression that is called
whenever READ sees a certain character.  That character is replaced by
the value that the LAMBDA expression  returns.    For  example,  '  is
really  a readmacro:  (LAMBDA NIL (LIST 'QUOTE (READ))) This reads one
s-expression and wraps (QUOTE ) around the value it reads.    Consider
reading the expression (A 'B C).  When READ sees the ', it invokes the
readmacro definition.  The (READ) reads one s-expression, in this case
B. The  LIST  then  makes up (QUOTE B).  This is the value returned by
the LAMBDA.  It is used by READ in place of  the  '.    That  is,  the
original  expression  is  seen as (A (QUOTE B) C).  Note that the B is
actually read by the readmacro, not by the top level of READ.  {,  the
start of comment character, is a somewhat more complex readmacro.

In  addition  to normal read macros, there are "splice macros".  These
are useful only in the middle of lists.    The  value  of  the  LAMBDA
function  is  "spliced" into the list, rather than simply being made a
member of the list.  E.g. if ' were a splice  macro,  then  (A  'B  C)
would  be  (A  QUOTE  B  C)  rather than (A (QUOTE B) C).  Of course a
splice macro must return a list.

A readmacro is defined by putting the LAMBDA function on the  property
list  of  the character involved, with the property name READMACRO (or
SPLICEMACRO for splicemacros).  E.g.  The atom ' (which would have  to
be typed /') has a property READMACRO whose value is (LAMBDA NIL (LIST
'QUOTE (READ))).

The functions DRM and DSM may be used to define read macros and splice
macros  respectively.    For  example, the following would define ' as
shown above:

     (DRM /' (LAMBDA NIL (LIST 'QUOTE (READ)))

DRM and DSM also set some bits in the read table which are  needed  in
order to cause the scanner to know that the character is a read macro.

Please  note  that  making  something  a readmacro does not change its
syntactic properties.  READ will only recognize readmacros  in  places
where  a new atom can begin.  So if you decided to make # a readmacro,
READ would recognize (A #B C) as a readmacro call, but not (A  B#  C).
B#  would  be taken to be an atom name.  Of course B # would work.  If
you want a readmacro to break an atom name, then you must  modify  the
character  to  be a break character.  One way to do this (explained in
the next section) is

     (MODCHR <char> (MODCHR 40Q NIL))
                                                                    58


This makes <char> have the same syntactic properties as a space (whose
ASCII code is 40Q).

Functions described in this section are:

     READMACRO - a property name

     SPLICEMACRO - a property name

     DRM - a function for defining read macros

     DSM - a function for defining splice macros



11.6. More modifications of the syntax:  MODCHR


READ  is  table-driven.  That is, there is a table inside Lisp, having
one entry for each character.  Lisp's interpretation of a character is
determined by what appears in its table entry.  Thus it is possible to
have X and Y act like left and right parentheses just by  copying  the
table entries for the parentheses to X and Y. MODCHR is used to return
the current table entry for a character, and set up a new one.

Current the table has the following entries for each character:

     Syntactic  class.    There is a separate class for each character
          that has a special meaning in Lisp's syntax.  Currently  the
          table  contains  a  small integer indicating which class the
          character falls  into.    But  this  representation  is  not
          guaranteed.   (It is also possible that bits will be defined
          for various syntactic properties.)

     Readmacro.  This is a bit indicating  that  the  character  is  a
          readmacro.  Note that the readmacro definition itself is not
          stored  in the table.  Thus if you copy the table entry of a
          readmacro to another character, you will also have  to  give
          the  new  character a READMACRO property.  DRM automatically
          sets this bit.

     Splicemacro.  This is a bit indicating that the  character  is  a
          splicemacro.  This is similar to the readmacro bit.

The  only  practical  thing you can do with this table is copy entries
from one character to another, using MODCHR.  So you  should  consider
the values returned by MODCHR to be numbers whose meaning is secret.

Here are functions involving the read table:

     MODCHR  -  sets  or  returns  all  the  bits  that  control how a
          character is treated

     SETCHR - sets or returns only the bits that make  a  character  a
          read macro or splice macro.  To make something a read macro,
                                                                    59


          you  must  give  it  a  READMACRO property, and set the read
          macro bit with MODCHR or SETCHR.

     DELIM - returns T if a  character  is  a  delimiter  (i.e.  would
          terminate reading an atom name)



11.7. Loading and saving definitions from files


As  mentioned  above,  LOADF and SAVEF are designed to help you manage
files containing definitions of Lisp functions (and data, if stored as
variable values).  Here is a small example of such a file:

    (DE FACT (N) (COND [(ZEROP N) 1.]
                       [T (TIMES N (FACT (SUB1 N)))]))

    (DE FIB (N)
     (COND [(ZEROP N) 1.]
           [(EQUAL N 1.) 1.]
           [T (PLUS (FIB (SUB1 N)) (FIB (DIFFERENCE N 2.)))]))


The first thing to notice is that this file simply  contains  function
definitions using DE, just as you would type them at the terminal.  To
read  in such a file, you would type the command (LOADF "NUM.LSP"), or
whatever the name of the file was.  You can put any Tops-20 file  name
inside  the " ".  In fact you can load more than one file, e.g. (LOADF
"NUM.LSP" "ARITH.LSP").  LOADF simply reads each S-expression  in  the
file  (using  READ)  and  executes  it  as if you had typed it in on a
terminal.   Thus  it  results  in  having  FIB  and  FACT  defined  as
functions.

SAVEF  is  the  reverse function:  It writes things out.  The simplest
call is simply (SAVEF).    This  writes  out  any  file  containing  a
function that has changed.  If any new functions have been defined, it
will  ask  which  file  they are to be put in.  It is also possible to
specify that only one file is to be  saved,  e.g.  (SAVEF  "new.lsp").
This  would  write  out all of the functions that originally came from
NEW.LSP, or that have been assigned to it by previous calls  to  SAVEF
or  FILES?.  Finally, you can specify exactly what you want to go in a
file.  To write out  the  definitions  of  FIB  and  FACT  to  a  file
"new.lsp",  you  might say (SAVEF "new.lsp" (PP FIB FACT)).  The first
argument to SAVEF is a file name.  After that, there can be any number
of other arguments. They are simply executed as if you typed  them  on
your  terminal, but with output redirected to the file.  (PP FIB FACT)
will "prettyprint" the definitions of FIB and FACT.  So  that  results
in  a  file  almost  like  the  one  shown above.  (See chapter 19 for
details on PP, the prettyprint.)

DSKIN and DSKOUT are similar to LOADF and SAVEF.  However they do  not
maintain  the  data needed by SAVEF and FILES? to automatically decide
what files to save.   They  are  used  by  systems  that  need  to  do
something  more  complex  than what is done automatically by LOADF and
                                                                    60


SAVEF.    These  functions  also use a list of what goes in your file,
e.g. TESTFNS.  However they do not construct this list  automatically.
It  is  assumed  that your program keeps these lists up to date.  Thus
DSKIN does not construct TESTFNS, nor does it add the name of the file
read to ALLFILES.  DSKIN is otherwise exactly like LOADF.   DSKOUT  is
similar  to  SAVEF.    If  given  with  one argument, it normally uses
<name>FNS as a list of things to put in the file.  Since DSKIN is  not
able  to  recreate  <name>FNS when reading in the file, DSKOUT puts it
into the file.  Other differences between DSKOUT  and  SAVEF  are  the
fact that DSKOUT with no arguments is meaningless (since FILES? has no
data for use with DSKOUT), and the fact that if there is no <name>FNS,
one is constructed using (SORT (APPEND ALLFNS ALLVALS ALLSTRS)).



11.7.1. How LOADF and SAVEF keep track of files and functions


We  will  now  discuss the way SAVEF knows what to write out onto each
file.  The system maintains two sorts of lists of functions.

   - When you read a file with LOADF, it remembers the  functions
     and  variables that were read from this file.  This makes it
     easy to write out a new version of the file, and  make  sure
     that  the  same  functions  get put in the new version.  The
     contents of the file is remembered on a list whose  name  is
     made  from  the  file  name with FNS tacked on the end.  For
     example, if you read the file TEST.LSP, the contents of  the
     file is put into the variable TESTFNS.

   - When  you  define  a function interactively, with DE, DF, or
     DM, or when you edit an existing  function,  with  EDIT,  or
     EDITF,  the  name  of the function is put on a special list,
     ALLFNS.  This makes it easy to write out all functions  that
     you  have  added or modified interactively.  ALLVALS is used
     in a similar way for all variables defined by DV  or  edited
     via   EDIT   or  EDITV.    ALLSTRS  is  used  for  structure
     definitions edited by EDIT.

If you use SAVEF with no arguments or  only  one  argument  (the  file
name),  it uses these special lists to specify what to output.  If you
give only one argument to SAVEF, it will  normally  use  the  list  of
functions   associated  with  the  file.    E.g.  if  you  say  (SAVEF
"TEST.LSP"), SAVEF will print what is specified on the  list  TESTFNS.
This should be a specification of what was read from TEST.LSP the last
time it was LOADF'ed.  If you call SAVEF with no argument, it uses the
function  (FILES?) to find out which files contain functions that have
changed, and then does a normal one-argument SAVEF on each such  file.
FILES?  will  also ask you where to put any new functions that did not
come from a file.

If you supply extra arguments (THINGS-TO-WRITE), of course  they  will
be  used  in  preference  to  these  defaults.  Non-atomic expressions
appearing in SAVEF are evaluated, while atoms are passed to PPL.
                                                                    61


The  precise  format of the lists such as TESTFNS is somewhat complex.
It is a list of prettyprint commands designed to  produce  an  updated
version of the file that was last read in.  Here is what LOADF puts in
the list for each thing that is read in from the file:

     (DE X args defn) [also DF and DM] - (F: X) - this is a command to
          the prettyprinter that makes it print the current definition
          of  X. Thus  if  X has been updated, you will get the newest
          value.  Function definitions in the old UCI  DEFPROP  format
          will be treated as if they were DE, DF, or DM.

     (DS  X fields) - (ST: X) - this is a command to the prettyprinter
          that makes it print the current definition of X. Thus  if  X
          has been updated, you will get the newest value.

     (DV  X  value)  - (V: X) - this is a command to the prettyprinter
          that makes it print the current value of X. Thus  if  X  has
          been updated, you will get the newest value.  If you want to
          get  the  value  as  it was in the file, and not any updated
          values, use DEFV instead of DV.

     (ELISP: -forms-), (NOCOMPILE -forms-) - the forms  are  processed
          recursively,  and  a prettyprint command is made up to print
          them as specified here, with  ELISP:  or  NOCOMPILE  wrapped
          around them.

     others  -  the forms will be printed exactly as read.  If the CAR
          of the form happens to be something with a  special  meaning
          to  the  prettyprinter,  (FORMS:  thing)  will  be  used, to
          supress the special action.

FILES? uses an additional list, ALLFILES.  This is a  list  of  dotted
pairs, e.g. (("PS:<HEDRICK>TEST.LSP" . TESTFNS)).  Each pair is a file
name and the variable listing what is on that file.  This list is used
whenever  a  function  needs  to  know  all  of the files known to the
system.  The list is constructed by LOADF.   The  exact  structure  of
this  list  is  subject  to change without notice.  Use NEWFILE to add
things to it, rather than editing it directly.



11.7.2. Summary of functions


Here  are  the  functions  involved  with  loading  and  saving   your
functions:

     LOADF  -  loads  everything  in a file, creates <name>FNS to show
          what came from the file.

     GETDEF - lets you select a few functions from a file that is  set
          up to be DSKIN'ed.  Faster than DSKIN'ing the whole file, if
          you just need one or two functions from it.

     SAVEF  -  save selected functions, or all changed functions, in a
                                                                    62


          file, in source form.

      FILES? - returns a list of files that need to be rewritten, i.e.
          that  contain  functions that have changed.  Also asks about
          new functions that do not yet appear on a file.

     NEWFILE - adds a file to ALLFILES.  Use this if you want SAVEF to
          be able to put new functions  on  a  file  that  the  system
          hasn't seen yet.  It will be created at the next SAVEF.

     DSKIN - like LOADF, but does not construct <name>FNS

     DSKOUT  -  save selected functions in a file, in source form.  In
          case a variable <name>FNS is used, its  value  is  also  put
          into the file.

     SAVEIMAGE  - save your entire core image.  This saves all of your
          function definitions, variable values, etc.  It uses a  very
          large amount of disk space.  Under release 4 of Tops-10, you
          must  use  this  function from Lisp where you would normally
          type the SAVE command to the EXEC, since SAVE will not  work
          with extended addressing core images.

     FLAP  -  load  a  file containing compiled code.  DSKIN will call
          FLAP when it detects a file  containing  compiled  code,  so
          users will normally not call FLAP directly.

     LOADREL  -  load  a  .REL  file.    This is a file produced by an
          assembler or  a  compiler  for  another  language,  such  as
          Fortran or Pascal.

     GETSYM,  *GETSYM - make functions loaded by LOADREL be accessible
          to Lisp.



11.8. Basic file I/O


Lisp file I/O is organized around "channels".  A channel is an  object
that contains information about a file, including where Lisp is in the
file  and  all  other  state information needed to continue I/O on it.
You need not worry about what information exactly  is  in  a  channel,
since  you  can't  get  to  any  of  it directly.  Channels are simply
objects that get passed to various functions to allow them to do  I/O.
E.g.  to  write  the contents of the expression S onto a file "S.LSP",
you might do the following:

    (SETQ CHAN (OPENOUT "S.LSP"))
    (SELECTOUT CHAN)
    (PRINT S)
    (SELECTOUT NIL T)

The channel object that you are using is created  by  OPENOUT.  Indeed
channels  are  always created by functions that open files.  Input and
                                                                    63


output  functions  do  not  take channels as arguments.  Rather, PRINT
outputs on the "current channel", and  you  use  SELECTOUT  to  change
that.    The  first  call  to  SELECTOUT  selects the channel you just
opened.  Thus (PRINT S) will write out the value  of  S  to  the  file
"S.LSP".    Since  that  is  all you want on the file, you use another
SELECTOUT. NIL can be used  instead  of  a  channel  to  indicate  the
terminal.    Thus the second SELECTOUT returns output to the terminal.
The optional extra argument (T) specifies that the previously selected
channel (the one associated with "S.LSP") should be closed.  You  must
close an output channel before you will be able to see the output.

Reading can be done in a similar fashion:

    (SETQ INCHAN (OPENIN "DATA.FILE"))
    (SELECTIN INCHAN)
    (SETQ DATA (READ))
    (SELECTIN NIL T)

OPENIN  opens the file "DATA.FILE" for input, returning a channel that
refers to that file.  SELECTIN makes  it  the  current  channel.  Thus
(READ)   reads   one   S-expression   from  that  file.    The  second
SELECTIN returns input to the terminal, closing the channel.    It  is
perfectly  possible  to  move input among several files.  In that case
you use SELECTIN with only one argument.  You specify T only when  you
are  finished  with  the  input  file  and  want  to  close it.  It is
important to close the file eventually, since there is a limit to  the
number of files that can be open at one time.

Note   that  SELECTIN  and  SELECTOUT  return  the  channel  that  was
previously selected for input or output respectively.  Thus you  could
save that and restore it by a later SELECTIN or SELECTOUT.

Actually  SELECTIN  and  SELECTOUT  are  usually  not  the best way of
selecting input or output.  If an error occurs during them, under some
circumstances the files involve may not be properly closed.  Also, you
may have to save the previous channel and reselect  it.    WITHIN  and
WITHOUT  are  used  for selecting a channel temporarily, and restoring
the old selection automatically.  E.g.

    (WITHIN SPECIALCHAN (GET-INPUT))

will set the current input channel to SPECIALCHAN, and leave it  there
during  execution  of (GET-INPUT).  When (GET-INPUT) exits, even if by
ERROR, THROW, etc., the input channel that was in  effect  before  the
WITHIN  will be restored.  WITHIN is in fact like a PROGN, except that
the input channel is rebound during its execution.  In  addition,  you
may  put  a T after the channel.  This causes the channel to be closed
when the WITHIN exits.  E.g.

    (WITHIN (OPENIN "SUBFILE") T (PROCESSFILE))

WITHOUT is similar, but selects the output channel.

TTYIN and TTYOUT are like WITHIN and WITHOUT, but select the  terminal
(channel NIL).  E.g.
                                                                    64


    (TTYOUT (PRINT "We are now in debug mode"))

TTYMSG  is a special version of MSG that always works on the terminal.
It is equivalent to an MSG inside a TTYOUT.

Sometimes you want to know whether a file exists, but don't want to do
any I/O using it at the moment.  (LOOKUP "ISIT") will return the  full
file  name  ("PS:<HEDRICK>ISIT..1") if the file ISIT exists, or NIL if
it does not.

The examples  above  have  shown  the  most  commonly  used  file  I/O
functions:

     (OPENIN  file1  file2  file3  ...)  -->  channel - open a file or
          series of files.

     (SELECTIN channel closeprevious?) - select current input channel

     (WITHIN channel [T] forms) -  execute  forms,  like  PROGN,  with
          input channel selected temporarily during the execution

     (OPENOUT file) --> channel

     (SELECTOUT channel closeprevious?)

     (WITHOUT  channel  [T]  forms)  - execute forms, like PROGN, with
          output channel selected temporarily during the execution

     (TTYIN [T] forms) - execute  forms,  with  terminal  selected  as
          input

     (TTYOUT  [T]  forms)  -  execute forms, with terminal selected as
          output

     (TTYMSG ...) - equivalent to (TTYOUT (MSG ...))

     (LOOKUP file) --> NIL or the full file name, as a string

Note that it is possible to specify more than one input file.    Input
moves  from  one  to  the  other automatically when the end of each is
reached.  When the end of  the  last  one  is  reached,  an  error  is
generated.    You  can  trap  that  error  by  using  ERRSET.  See the
reference section, under READ and ERRSET, for details.

File names should always be specified  as  strings  in  new  programs.
However  for  compatability  with  the  older  Rutgers/UCI  Lisp, some
functions allow dotted pairs, two-element lists, and  separate  device
names.  The functions that understand the old conventions are:  INPUT,
OUTPUT,  LOADF,  SAVEF,  DSKIN, DSKOUT.  INPUT and OUTPUT are obsolete
versions of OPENIN  and  OPENOUT.    They  return  atoms  rather  than
channels.    They  should  not  be used in new programs.  If a file is
opened with INPUT or OUTPUT, it must be selected  with  INC  or  OUTC,
which are the obsolete equivalents of SELECTIN and SELECTOUT.
                                                                    65


11.9. More general file I/O


The  functions  shown above are sufficient for most purposes.  However
some users will want to take full advantage of the facilities  of  the
operating  system.   For them we have a more general set of functions.
You are refered to the reference section for details.   The  functions
are

     OPENF  -  a  generalization of OPENIN and OPENOUT.  Allows you to
          specify whether a new version  is  to  be  created,  whether
          wildcards  are to be allowed, whether the file is to be open
          for input, output, both, or append, (or not opened at  all),
          to open a file for binary I/O, allows you to handle your own
          errors, and allows you to specify whether multiple files are
          to  be  treated  as  a  single  logical  file or whether the
          program will set the end of file for each one.

     CLOSEF - closes a file.  Normally this makes the channel  useless
          in  the  future.    However  there is an option by which the
          channel retains the name of the  file,  and  can  be  opened
          again without specifying a file name.

     NEXTF  -  advances  to  the  next file if a list of filenames was
          given, or wildcards were used.  The file need not be  opened
          to use this.  (e.g. the DIR function lists your directory by
          doing NEXTF repeatedly without opening any of the files)

     RENAMEF - renames a file

     DELETEF - deletes a file

     CURPOS - returns the current position in a file

     SETPOS - changes the current position in a file, i.e. does random
          access

     BINOUT - output byte or word in "binary" mode

     BININ - input byte or word in "binary" mode

     DIR  -  returns  a  list  of  all  files  matching  a  given file
          specification.  By default gives a list  of  files  in  your
          directory.

     TYPE - type a file on your terminal

The  following function are current available to get information about
files.  They are defined only for Tops-20.  They should be replaced by
functions that are more general.

     JFNS - returns the name of a file, or any  of  its  pieces  (e.g.
          device,  directory, extension).  Can accept either a channel
          or a string.  This should be used if you ever  have  a  file
          spec  in  a  string  and  want to find one piece of it.  You
                                                                    66


          should never parse a file name yourself.

     GTFDB  -  returns  a  word  from  the file descriptor block.  The
          available words contain information about file  size,  dates
          and times of creation and access, etc.



11.10. Terminal handling


The  following functions act directly on the terminal.  In addition to
the functions in this section, there  are  some  facilities  that  are
useful  for  outputting  "funny" characters to the terminal.  When the
current output is the terminal, BINOUT will output in binary mode.  If
you have a lot of binary output to do, it may be worth your  while  to
open a channel with (OPENF "TTY:" '(OLD OUT 8)).  This specifies 8-bit
mode, so this channel will bypass all normal character processing.

     DDTIN - sets or clears a mode where each character is sent to the
          program immediately, rather than waiting for a whole line to
          be typed.

     TTYECHO - turns echo on and off

     ERRCH  -  sets the character to be used for ^G (i.e. that returns
          you to the top level of Lisp).    Or  disable  this  feature
          completely.

     REREADCH - sets the character to be used for ^Z (i.e. that throws
          away the current expression and starts reading another).  Or
          disable this feature completely.

     EDITCH  -  sets the character to be used for ^F (i.e. that causes
          the editor to be invoked on the thing  you  are  now  typing
          when  you  finish  typing  it).    Or  disables this feature
          completely.

     READCONTEXT - used to establish a context for ^Z and ^F, in  case
          you want to write your own reading routines.

     DEBUGINT  -  turn off or on the control character interrupts (^B,
          H, etc.), except ^G, which is controlled by  ERRCH,  and  ^Z
          and ^F, which are not really interrupts.

     PROMPT  - set and read the prompt character.  Somewhat temporary,
          as it is reset to the permanent prompt when control  reaches
          the top level.

     INITPROMPT - set and read the permanent prompt character.

     READP - see if there is any input waiting from the user

     CLRBFI - clear any characters typed ahead
                                                                    67


     TALK - turn output back on, in case the user has typed ^O



11.11. I/O Functions Present only for Compatibility


The  following functions are present only for compatibility with older
versions of Lisp.  They use the old format for file  names  (which  is
different for different functions), and the old form of channel (which
is an atom).

     INC

     INPUT

     OUTC

     OUTPUT

     UGETI

     UGETO
                                                                    68


                              12. Atoms



This  chapter  will  describe  the structure of literal atoms, and the
functions that apply to them.   Literal  atoms  (usually  referred  to
simply  as  "atoms")  are in some sense the most "primitive" Lisp data
type, because they can't be broken up by  CAR  and  CDR,  or  anything
else.    Lists and other data structures typically have atoms as their
members, i.e. they have pointers to atoms.

Actually atoms do have some internal structure.  To be specific,  they
have the following attributes:

     Print  name  (PNAME) - This is the string of characters which are
          printed when you print the atom.  Typically people think  of
          the  atom  as being the same as this name.  Indeed Lisp goes
          to great pains to make sure that there can be only one  atom
          with  a  given name, in order to make it reasonable to think
          of them this way.   The  internal  data  structure  used  to
          represent an atom always contains a pointer to such a string
          of characters.

     Value  -  At  atom  can  be  used as a variable.  To use one as a
          variable, you only need to give it a value,  either  setting
          the  value  directly  by  SETQ,  or  by using it as a formal
          parameter in a function, or as a local variable in a PROG or
          a WITH.  The internal data structure used  to  represent  an
          atom  always  includes room for a value.  This is refered to
          as the "value cell".  When you have not yet given a value to
          an atom, this fact is represented by having a special object
          in its value cell.  The Lisp interpreter understands that if
          it finds this object as a  value,  that  really  means  that
          there  is  no  value at all.  The function (UNBOUND) returns
          this object in case you ever need it.

     Function definition - An atom can be defined as a function.  This
          is completely separate from being used as a  variable.    In
          fact  the same atom can be both a variable and a function at
          the same time.  There is  a  separate  "function  definition
          cell"  included  in the internal representation for an atom.
          When the atom is  not  defined  as  a  function,  this  cell
          contains NIL.

     Property  list  -  The  property list is a list of attributes and
          values associated with the atom.   These  normally  have  no
          particular  significance to the system, and you can use them
          to build an arbitrary relational data base.  See the chapter
          on properties.  The  internal  representation  for  an  atom
          always  includes a pointer to a property list.  It is NIL if
          the atom has no properties.

As mentioned above, the system goes to some pain  to  make  sure  that
there is only one atom with a given name.  Suppose you type
                                                                    69


    (EQ 'XYZ 'XYZ)

You  have  two separate sequences of the letters XYZ.  The system will
make sure that both refer to the same atom.  To do  this,  the  system
keeps  a  list  of  all of the atoms.  Whenever it seems a sequence of
letters that is supposed to represent an atom, it first looks at  this
list  to  see  whether it has already seen an atom with that name.  If
so, the existing atom is used.  If not, a new one is created with that
name, and added to the list.  This list is called the oblist,  and  is
stored  as the value of the variable OBLIST.  It is not a simple list,
but is stored is a form that allows hashing to be used  to  speed  the
lookup.    You  should never change OBLIST yourself, nor is its format
guaranteed to remain constant.  There is a function,  MAPATOMS,  which
allows  you  to  access  everything  on  OBLIST  in  a  manner that is
guaranteed to work all the time.

The process of looking up a new atom to see whether it already  exists
is  called  interning.    Under  certain  unusual  circumstances it is
possible to bypass interning, and thus get two  atoms  with  the  same
print  name.    In  this case, you may call the function INTERN to see
whether an atom with the same name already exists, and use it  instead
of some possibly duplicate atom.

The functions described in this section are organized as follows:

     Tests showing whether something is an atom

     Functions  involving the PNAME, and creating atoms - these either
          get the PNAME in some form or create new  atoms  with  given
          PNAME's.

     Functions involving values - setting and looking at values

     Functions  involving  function  definitions  -  looking  at them,
          defining an atom as a function,  saving  and  restoring  old
          definitions

     Functions  involving  the  property  list  -  this gives only the
          lowest level primitives involving the property  list.    For
          the  functions normally used in programming, see the chapter
          on properties

     Functions involving interning



12.1. Tests for Atoms


     LITATOM - checks whether something is a  literal  atom,  i.e.  an
          atom of the sort described in this chapter.

     ATOM  -  checks whether something is an atom in the general sense
          of being anything other than a CONS cell
                                                                    70


12.2. The PNAME


The  following  functions  involve  the  PNAME.  This section includes
functions that create atoms with a given PNAME.

     xEXPLODEx - this is a family  of  functions:  EXPLODE,  EXPLODEC,
          AEXPLODE,  and AEXPLODEC.  All of them return the print name
          of an atom, as a list of characters.   EXPLODE  will  insert
          /'s  where  they  would  be  printed if you printed the atom
          (i.e.  before  special  characters).    EXPLODEC  will  not.
          AEXPLODE and AEXPLODEC return the list as a list of numbers,
          instead of characters.  They are the numerical values of the
          characters.

     READLIST  - will create an atom given a list of characters.  I.e.
          this is the inverse of EXPLODE.

     MAKNAM - similar to READLIST,  but  the  new  atom  will  not  be
          interned,  i.e.  it  may  be  have the same print name as an
          existing atom.

     GENSYM - create a new atom with a more or less random name.   The
          names  look  like  G0001,  G0002,  etc.,  i.e.  they  ascend
          numerically from some starting point.  These atoms  are  not
          interned.

     CSYM - set the starting point for the names used by GENSYM.



12.3. Values


     SETQ  -  the  normal  way  of  giving a value to a variable.  The
          variable is specified directly.  E.g. (SETQ X 'Y) gives  the
          value Y to the variable X. 

     DEFV  -  similar  to  SETQ,  but returns the atom rather than the
          value.  This  may  make  it  slightly  nicer  for  use  when
          initializing  variables  at  the  top  level  of  a program.
          Traditionally it is not used inside functions.

     DV - similar to DEFV, but also adds the atom to the list ALLVARS,
          which is used by DSKOUT or SAVEF when you save your work.

     SET - similar to SETQ, but evaluates the first  argument.    This
          lets you choose a variable by doing some computation.  E.g.

               (SET (COND ((FOO) 'X) (T 'Y)) 'Z)

          will  set  either  X or Y to Z, depending upon the result of
          (FOO).

     *EVAL - normal way of finding the value of something, including a
                                                                    71


          variable.

     EVAL,  EVALV - find the value of something, allows you to specify
          a binding context.  EVALV is specialized to  work  only  for
          variables,  so  it is substantially more efficient than EVAL
          when a binding context is specified.

     BOUNDP - indicates whether an atom has  something  in  its  value
          cell (other than the special indicator indicating that it is
          unbound).

     UNBOUND  - returns the special indicator used to indicate that an
          atom is unbound



12.4. Function definitions


Normally the user does not need to know the  form  in  which  function
definitions are stored.  DE, DF, and DM have been described above, and
are  the normal way of defining functions.  What is actually stored in
the function definition cell is a list whose first member  is  a  flag
indicating the kind of definition.  The flags defined are EXPR, FEXPR,
MACRO,  SUBR,  FSUBR, and MSUBR.  The chapter on the semantics of Lisp
describes the difference between EXPR's, FEXPR's, and MACRO's.   SUBR,
FSUBR,  and MSUBR indicate compiled forms of functions.  The flags are
CONS'ed onto the actual function definition.  In  the  case  of  EXPR,
FEXPR,  and  MACRO,  this  is normally a LAMBDA.  A typical definition
would be (EXPR LAMBDA (X) (PRINT X)).  In the case of SUBR, FSUBR, and
MSUBR, the rest of the list is system-dependent information giving the
machine  address  at  which  the  compiled  definition   starts,   and
information  about  the  arguments.    The  user should not attempt to
create or modify definitions having any of the tags  SUBR,  FSUBR,  or
MSUBR.

     ALIAS  -  put  a  definition in the function definition cell.  It
          must be in the form just described.  NIL means to remove any
          current  definition.    ALIAS  does  some  analysis  of  the
          definition,  to  speed  up  interpreted execution.  For this
          reason any time you modify the definition, you  should  call
          ALIAS  (or  DE,  DF,  or DM) to reestablish it.  This is the
          case even if  you  did  destructive  operations  (RPLACA  or
          RPLACD)  to  an  existing  definition, since you changes may
          change some of  the  properties  that  ALIAS  finds  in  its
          analysis.

     FUNDEF - returns the contents of the function definition cell

     DE, DF, DM, DRM, DSM - the normal way to define a function

     SAVE, UNSAVE - save and restore an old function definition.  Used
          when  you need to redefine something temporarily and want to
          be able to restore the previous definition.
                                                                    72


     *EXPAND  -  a  function  particularly  useful  in defining simple
          macros.



12.5. Property lists


The property list is a list with attributes  and  values  alternating.
There  is  a  separate  chapter  which will give the details.  In this
section we show only the lowest  level  functions  (which  you  should
actually try to avoid using):

     PLIST - return the entire property list, as a list

     RPLACPLIST  -  sets a list to be the property list, replacing the
          entire previous property list.



12.6. Interning


     INTERN - see whether there is already an atom with the same  name
          as  this.  If so returns the old one, otherwise returns what
          you passed it, and adds it to the list of known atoms.

     REMOB - removes an atom from the list of known atoms

     OBLIST - the list of known atoms.  It is very dangerous  for  you
          to  do  anything  with  this  list.    If  you do, we do not
          guarantee that your program will continue to work in  future
          versions of ELISP.
                                                                    73


                             13. Numbers



13.1. Tests


This  section includes all of the Boolean functions involving numbers.
It also includes NUMTYPE, which tells you  what  kind  of  number  you
have.

     NUMTYPE - returns one of FLONUM, FIXNUM, INUM

     EQUAL - numerically equal

     EQP  -  numerically  equal.  At the moment is identical to EQUAL,
          but it may make your program easier to transport if you  use
          this  when  testing numbers, since in Maclisp EQUAL does not
          work for numbers of different types.

     GE - greater than or equal to

     *GREAT - greater than

     GREATERP - greater than, allows more than 2 arguments

     GT - another name for *GREAT

     INUMP - is this an INUM?

     LE - less than or equal to

     *LESS - less than

     LESSP - less than, allows more than 2 arguments

     LT - another name for *LESS

     LEXORDER - compares atoms and strings, also,  using  alphabetical
          order

     MINUSP - is it a negative number?

     NE - NOT EQP

     NUMBERP - is it a number of some kind?

     ZEROP - is it 0 or 0.0?

     = - another name for EQUAL

     =0 - another name for ZEROP
                                                                    74


13.2. Basic Arithmetic Operations


     *PLUS,  *DIF,  *TIMES,  *QUO  -  the big 4, used only for pair of
          numbers

     + - * // - other names for the big 4, for pairs of numbers

     PLUS, DIFFERENCE, TIMES, QUOTIENT - the big 4, allowing more than
          2 arguments

     DIVIDE - integer division

     REMAINDER - remainder after integer division

     ADD1, SUB1 - special for X+1, X-1

     +I, -I - other names for ADD1, SUB1

     INCR, DECR - (INCR X) means (SETQ X (ADD1 X))



13.3. Other Numerical Functions


     ABS - absolute value

     FIX - convert to integer by truncation

     GCD  -  greatest  common  divisor  of  two   integers   (Euclid's
          algorithm)

     LSH - shift left or right specified number of bits

     *MAX, *MIN - maximum or minimum of two numbers

     MAX, MIN - maximum or minimum of any number of numbers



13.4. The arithmetic package


There  is  a  special  package  which loads various functions from the
Fortran library.  To use these functions, you must first do

    (DSKIN "ELISP:EARITH.LSP")



If you get odd results, such as illegal memory reference, please  make
sure  that  ELISP:ELISP.REL  refers  to  version  corresponding to the
version of ELISP you are using.  E.g. if you are using NEW:ELISP, make
sure that your logical definition of ELISP:  includes NEW:.
                                                                    75


Once  you have done it, the following functions are available.  Unless
otherwise stated, they allow any kind of number as their argument, and
return a real number.

     SQRT - square root

     LOG - natural log

     LOG10 - log to base 10

     SIN - sine, radians

     COS - cosine, radians

     SIND  -  sine,  degrees.  Calculated  only  to  single  precision
          accuracy.

     COSD  -  cosine,  degrees.    Calculated only to single precision
          accuracy.

     ACOS - arc cosine, radians.  Calculated only to single  precision
          accuracy.

     ASIN  -  arc  sine, radians.  Calculated only to single precision
          accuracy.

     ATAN - arc tangent, radians.

     SINH - hyperbolic sine.   Calculated  only  to  single  precision
          accuracy.

     COSH  -  hyperbolic  cosine.  Calculated only to single precision
          accuracy.

     TANH - hyperbolic tangent.  Calculated only to  single  precision
          accuracy.

     EXP - exponential (E to the specified power)

     FLOAT - returns floating point version of number

     RANDOM - returns a random number between 0 and .9999999...  Takes
          no arguments.  Calculated only to single precision accuracy.

     SETRAN - sets the seed for the random number generator.  Takes an
          integer as argument, returns NIL.  The seed must be < 2**31.

     SAVRAN  -  returns  the  current value of the seed for the random
          number generator as an integer.  Takes no arguments.
                                                                    76


13.5. Numerical I/O - A Couple of Oddities


     BASE - base used for output, 2 to 10

     IBASE - base used for input, 2 to 10

     *NOPOINT  -  controls whether to use trailing . or Q on output to
          make base unambiguous

     *NOPOINTDSK - special version of *NOPOINT used by DSKOUT,  SAVEF,
          and COMPL.
                                                                    77


                      14. Characters and Strings



     xEXPLODEx - EXPLODE, EXPLODEC, AEXPLODE, AEXPLODEC produce a list
          of characters that would be printed if you printed this Lisp
          object.  xEXPLODE is as it would be printed with PRIN1 (i.e.
          /'s  used  where  appropriate),  xEXPLODEC is as it would be
          printed with PRINC (without /'s). EXPLODEx produces  a  list
          of   characters,  i.e.  atoms  whose  print  names  are  the
          characters.    AEXPLODEx  produces  a  list   of   numerical
          representations of the characters.

     NTHCHAR, ANTHCHAR - n-th character of a string (actually of print
          representation  of anything).  Negative means n-th from end.
          ANTHCHAR returns numerical code for the character

     ASCII - take numerical code, produce character

     CHRVAL - take char, produce numerical code

     CONCAT - concatenate 2  strings  (actually  anything  -  produces
          strings  of  chararacters  that would be used to print them,
          with EXPLODE, and concatenates these strings).    Returns  a
          string.

     *STCONCAT,  STCONCAT  - concatenates strings (allows only strings
          or atoms - uses atom's print name as string).   Much  faster
          than  CONCAT.  *STCONCAT allows only two arguments, STCONCAT
          any number.

     EQSTR - tests whether two strings are equal

     FLATSIZE, FLATSIZEC - number of characters in  list  produced  by
          EXPLODE or EXPLODEC, but doesn't really do the EXPLODE.

     JFNS  -  return  the name of the file open on a channel.  You can
          select any part of the file name.  Also allows a  file  name
          given as a string.  This is useful because you can use it to
          select out one part of a file name.

     MODCHR - change the read table for a character

     SETCHR  - change only the read macro bits in read table entry for
          a character

     READLIST, MAKNAM - takes a list of characters (e.g.  produced  by
          EXPLODE)  and  returns  the  object  that  READ  would  have
          returned if the characters had been read in.    MAKNAM  does
          not intern any atoms it may read.

     STRINGP - is it a string?

     SUBSTRING  -  search  for  a  string as being a piece of a larger
          string
                                                                    78


                            15. Properties



     GET - look up a property - the most basic retrieval function

     PUTPROP,  PUT - add or change a property - the most basic storage
          function.   PUT  is  simply  a  shorter  name  for  PUTPROP.
          However  for reasons of compatibility with other versions of
          Lisp, some sites have chosen to redefine  PUT  to  have  its
          arguments in the opposite order from PUTPROP, so be careful.

     DEFPROP - used to add or change a property.  Automatically quotes
          all  its  arguments, so this is commonly used when typing in
          properties at the top level.

     REMPROP - removes a property and its value

     ADDPROP - used with properties whose values are lists.    Adds  a
          new item to a list specified by atom and property name.

     PUTLIST - puts the same property on several atoms

     DEFLIST  -  similar  to  PUTLIST,  but more convenient if you are
          typing in properties at the top level.  Automatically quotes
          all its arguments.

     DEFP - copies one or more properties from one atom to another

     GETL - see if any of a list of properties is there

     PLIST - return the entire property list

     REMPROPS - removes all properties on a list from an atom

     RPLACPLIST - sets the entire property list of an atom

     SAVE/UNSAVE - saves and restores the current value of a  function
          definition.  Uses a special property SAVE.

     GETALL,  GETLALL  -  special  versions  of  GET and GETL used for
          converting old Rutgers/UCI  Lisp  programs,  where  function
          definitions are stored as properties.
                                                                    79


                        16. Arrays and vectors



Any  data  structure  can be built with CONS cells.  However some data
structures waste a lot of space if you  build  them  that  way.    For
example,  a  simple  list is about half wasted space, since there is a
pointer to the next cell in the list for each data item.  Also, if you
are going to want to access random elements within the data structure,
a list can be inefficient in time also.  To find the 10th element of a
list, you must normally start at the beginning and do 9 CDR's.

Arrays and vectors are an attempt to avoid  both  of  these  problems.
They  use  contiguous  blocks  of  memory.   Thus a vector of length 3
consists of three contiguous words, each of which can store  one  Lisp
pointer.  This is similar to a list with three elements, except that

   - It takes half the space, since there are no CDR's

   - You can access any element directly.

The  price  you  pay  for  this  is that the normal Lisp functions for
processing lists do not apply.  Thus about all you can do  is  examine
or change the Nth element of a vector or array.

The  functions  described  in  this chapter are for dealing with "raw"
arrays and vectors, where indexing is done by index number.  For  many
applications  it  is more convenient to treat a vector as a collection
of named fields, and access each one by name.  The next  chapter  will
describe how they may be done.  You might want to look at that chapter
first,  although the data structures in this chapter are in some sense
more "basic".  (Indeed structures are implemented using vectors.)

The difference between a vector and an array is that a vector consists
of Lisp pointers and  an  array  does  not.    That  is,  the  garbage
collector  looks  at the contents of a vector, but not at the contents
of an array.  This means that the components of a vector must be legal
Lisp objects, stored exactly one per word.  However an  array  can  be
used  any  way  you  wish,  except that Lisp objects should not be put
there (since the next time a garbage collection occurs,  the  pointers
will  become  invalid).   ELISP supplies a set of functions that allow
you to put various kinds of data into arrays.

The normal printed representation for an array looks  exactly  like  a
list,  but has a # in front of it.  (There must not be a space between
the # and the open parenthesis.)  E.g. here is  a  vector  with  three
elements:    #(A B C).  As with all other Lisp notation, this notation
can nest with others.  E.g Here is a list whose second  element  is  a
vector:  (X #(1 2) Y).

Here are the basic functions for vectors:

     (MAKEVECTOR  n) - returns a vector of size N. The components will
          be 0 through N-1.
                                                                    80


     (GETVECTOR v n) - returns the Nth component of the vector V. 

     (SETVECTOR v n x) - sets the Nth component of the vector V to the
          value X. 

     (VECTORP x) - T if X is a vector, else NIL

     (VECTORLENGTH  x)  -  the  length  of  the vector (i.e. number of
          entries

Note that a vector can be used like any other Lisp object.  I.e.   you
can  have  a  list of vectors, a vector of lists, a vector of vectors,
etc.

Here are the basic functions for arrays.  Note that there  is  nothing
that  requires  you  to use the same functions for a given array.  You
can set up a whole word in an array  using  SETIARRAY,  and  then  get
individual bytes from the same word using GETBARRAY.

     (MAKEARRAY n) - returns an array of N words.  The components will
          be  0  through  N-1 if you choose to regard it as made up up
          full-word objects.  For other objects, it depends upon their
          size.

     (MAKECARRAY n) - a special version of  MAKEARRAY  that  allocates
          the  array  in  the section normally used for compiled code.
          This may be necessary for generating arguments to  the  (not
          yet implemented) JSYS function.

     (GETIARRAY  a  n)  -  returns  the  Nth word of the array A as an
          integer.  N starts from 0.

     (SETIARRAY a n x) - sets the Nth word of the array A. X should be
          an integer.

     (GETRARRAY a n) - returns the Nth pair of words of the array A as
          a real number.  Note that 0 means the  first  two  words,  1
          means  the  second  two  words,  etc.   This is because real
          numbers is ELISP are always double precision.

     (SETRARRAY a n x) - sets the Nth pair of words of the array  A. X
          should be real.

     (GETBARRAY  a  n  b)  - returns the Nth byte of the array A (with
          byte size B) as an integer.  Bytes  are  packed  into  words
          left  justified,  with  no partial bytes.  So if B is 9, you
          get 4 9-bit bytes per word (words are 36  bits).    In  this
          case,  values  of  N  from  0  to 3 refer to the first word,
          values from 4 to 7 refer to the second,  etc.    Byte  sizes
          larger than 30 may give odd results.

     (SETBARRAY a n b x) - sets the Nth byte of the array A (with byte
          size B).  X should be an integer.  Byte sizes larger than 30
          may give odd results.
                                                                    81


The  difference  between  putting  an  integer  into  an  array  (with
SETIARRAY) and into a vector is in the exact  representation.    In  a
vector,  what  is  stored  is  the  usual  Lisp  representation of the
integer.  This is either an INUM, for small integers, or a pointer  to
a  word  containing  the  value.    In an array, what is stored is the
integer itself, as a 36-bit quantity.  Thus storage in an array may be
more compact.  In a vector, an extra word will  be  needed  for  large
numbers.

The  methods  described  so  far  assume dynamically generated arrays.
That is, each time you call MAKEVECTOR or MAKEARRAY, a new  vector  or
array  is  generated.    You must save away the value returned in some
variable, since it will be garbage-collected if nothing points to  it.
There  is  also  a  set of facilities that corresponds more closely to
Algol arrays.  These facilities are controlled by the ARRAY  function.
When  you call ARRAY, space is allocated for an array of the specified
size.  This space is allocated more or less permanently.  I.e. it will
never be garbage collected away from  you  (although  it  is  in  fact
garbage-collected  space).   Also, as in Algol, you can declare arrays
with more than one dimension (up to 5), and with  lower  bounds  other
than 0.  Here is a typical call to ARRAY:

    (ARRAY CHARTAB T 6 '(1 . 128))

This  creates  an  array CHARTAB.  The T is a type code indicating the
kind of data.  T means that it consists of Lisp objects.   (Internally
a  vector  is  used.)    Everything  after  the  T indicates dimension
information.  This is a two-dimensional array.  The first dimension is
6 (i.e. lower bound defaults to 0, upper  bound  6),  and  the  second
dimension has a lower bound of 1 and an upper bound of 128.

When  you  have declared an Algol array using ARRAY, you have two ways
to access elements of the array.  To get elements, you use  the  array
name  as  a  function.    In  the  above example, (CHARTAB 6 100) gets
element [6,100] of the array.  To set elements, you  use  STORE,  e.g.
(STORE  (CHARTAB  6  100) 'A) will store A into element [6,100] of the
array CHARTAB.  The functions mentioned above, such as  GETVECTOR  and
SETVECTOR,  will  not work with Algol arrays, since you don't have the
actual vector accessible to you.    (The  vector  object  is  actually
stored inside the function.)

You  can  have the same sorts of data in an Algol array as in a normal
vector or array.  Here are the legal types,  and  the  codes  used  in
ARRAY to declare them:

    T        Lisp object of any type
    NIL      real number (double precision)
    36       integer
    0<n<31   byte of specified size

E.g.  (ARRAY CHARS 7 '(1 . 256)) would declare CHARS to be an array of
7-bit bytes, indexed from 1 to 256.  Note that  ARRAY  will  calculate
the size of the needed array for you.  E.g. in the example just shown,
it will calculate the number of words needed to store 256 7-bit bytes.
You need only worry about the logical array bounds.
                                                                    82


The  ARRAY  declaration  actually  declares several functions for each
array that you define.  The first is a function with the same name  as
the  array.    It  is  used  for getting elements from the array.  The
others are used to implement STORE. (Their precise names and functions
are intentionally not documented, as  they  are  subject  to  change.)
These  functions  are  always  defined in machine code.  I.e. they are
effectively compiled.  The subscript calculations are done using open-
coded arithmetic, so they are more efficient than if you defined  them
youself.   Thus each array you declare uses two kinds of space:  space
from the normal Lisp "heap" taken up by the array itself,  and  binary
program space for the accessing functions.
                                                                    83


                            17. Structures



Often  you need a collection of related but non-homogeneous data.  For
example, if you are keeping information  about  people,  you  probably
want  their  name,  social  security  number, age and sex.  You can of
course keep this in a list or vector, but if you keep it  as  a  list,
you  must remember that the CAR is the name, the CADR is the ssn, etc.
And if you keep it as a vector, you must remember that  element  0  is
the  name,  element  1  the ssn, etc.  Clearly for many purposes it is
better to be able to refer to these items  by  name.    This  is  what
structures  do.    A structure is in fact simply a vector with special
macros defined to let you deal with the elements by name.

Here is how you  might  declare  a  structure  for  keeping  the  data
mentioned above:

    (DS PERSON NAME SSN AGE (SEX 'M))

This  declares  a PERSON as a 4-element vector, with components having
names as shown.  Each component can  contain  any  legal  Lisp  value.
(SEX  'M)  shows  how  to  specify  "default  values".   You can use a
specification of the form (FIELD-NAME DEFAULT-VALUE)  in  place  of  a
simple  field  name.    The  default  is used when an instance of this
structure is created, as we will see shortly.

When you declare a structure,  you  automatically  get  the  following
macros declared to help you use it:

     MAKE-xxx  -  where XXX is the name of the structure, in this case
          MAKE-PERSON.  This is what you use to create an instance  of
          the  structure,  i.e. one vector.  In the simplest case, you
          can simply say (MAKE-PERSON).  This will create a  4-element
          vector.    The  initial  values in the fields are undefined,
          except that the SEX field is set to M, since  you  specified
          that as the default value.  It is possible to specify values
          to  be  put  in one or more fields when you create a record.
          To do this, use alternating pairs of fields and values, e.g.

              (MAKE-PERSON NAME "Hedrick" AGE (PLUS AGE1 FUDGE))

          The fields can be specified in any  order.    You  need  not
          specify them all.  Here is how the system determines what is
          initially  in the fields:  Any field that you specify in the
          MAKE-xxx call is given the value specified.  For fields  not
          specified in the MAKE-xxx call, the default values specified
          in  the  DS statement are used.  If any field is not defined
          in  either  place,  their  initial  values  are   undefined.
          (Actually  in Elisp they are initialized to NIL, however for
          compatibility with Common  Lisp  we  suggest  that  you  not
          depend  upon  this.)    We  do not specify in what order the
          various   initializations   are   done   (again,   to   ease
          transportation to Common Lisp).
                                                                    84


     field-name  -  The field names are all defined as macros.  E.g to
          refer to the NAME field of the record X, you  would  specify
          (NAME X).

     STORE-field-name  - A macro is defined for each field name to let
          you store into it.  E.g. to change the NAME field of  record
          X to "JoSH", you would use (STORE-NAME X "JoSH").

Note that the general STORE macro can also be used to change the value
of  a  field, in case you prefer this syntax.  STORE This is sort of a
generalized SETQ, which allows  you  to  use  (field-name  record)  to
specify  what  is to be changed.  E.g. to increment the AGE field, one
might say

    (STORE (AGE X) (ADD1 (AGE X)))

The function STRUCTUREP can be used to see whether a particular object
is a structure.  It is NIL if the object is not a structure.  If it is
a structure, then the structure type (e.g. PERSON) is returned.

At the moment, instances of structures print out as vectors.  Thus the
example above would print as #(PERSON "Hedrick" NIL 32 M).  Note  that
the  first  component  is  set  to  the structure type, to allow error
checking (although this is not implemented at the moment).

The rest of this discussion  is  directed  at  people  who  need  more
control over structures, or who need to know how they are implemented.
This section requires you to know two things about the implementation.
The first thing you have to know is that a structure is implemented as
vectors, the first element of which is the structure type.  The second
thing  you  have  to  know  is how the system remembers the details of
structures.  This is done by an entry on  the  property  list  of  the
structure name.  E.g.  to find the definition of the structure PERSON,
you  would  do  (GET  'PERSON  'STRUCTURE-FIELDS).   The format of the
STRUCTURE-FIELDS property is a list of triples, one  for  each  field.
Each  triple  consists of (FIELD-NAME INDEX DEFAULT-VALUE).  The field
name is the name used in the definition for this field.  The index  is
its position in the vector.  Since the structure name is always stored
at  position 0, the first field has index 1.  The default value is the
value that will go into the field when MAKE-xxx is  done,  unless  the
user  specifies  a value at that time.  If no default was defined, NIL
appears in the triple (and is in fact used as the default).

Sometimes you need to  create  structures  dynamically.    DS  is  not
convenient,  because  it  is  an  FEXPR, i.e. it does not evaluate its
arguments.  For such cases, you may find  it  useful  to  use  CREATE-
STRUCTURE.    This  function  has  two  arguments:    the  name of the
structure type to be created, and a list of the fields,  in  the  form
just  described  (i.e.  a  list of triples).  The main disadvantage of
using CREATE-STRUCTURE is that references to the  structures  and  its
fields  can't  be  compiled.    Since  CREATE-STRUCTURE  is  called at
runtime, there is no way the compiler can know what you are  going  to
define.    Note  that  most  of  the  things defined with you define a
structure are macros.  In compiled  code,  any  macros  used  must  be
defined when you compile the program.  Thus you are probably not going
                                                                    85


to  be  able  to  compile  programs  containing  static  references to
structures defined with CREATE-STRUCTURE.   However  if  your  program
creates code and then EVAL's it, such things will work correctly.  (It
is  hard  to  see  why  else  you  would  want  to  create  structures
dynamically.)

Please note that there is a difference in implementation of  structure
functions  in  interpreted  and compiled code.  In interpreted code, a
reasonable amount of error-checking is done.  If you attempt to  refer
to  a  field,  and  the  object  you  are  working  with is not of the
structure type for which the field is defined, you will get  an  error
message.    Such checks have their costs.  We must verify (1) that the
object is a vector; (2) that it is at least 1 element  long;  and  (3)
that  the first element is the right structure type code.  In compiled
code, we assume that such checks are not  desired.    Thus  all  field
references  compile  as  single instructions.  This is consistent with
the long-established practice of not checking CAR and CDR in  compiled
code to see whether the object involved is a CONS cell.

Here is a summary of all the functions used with structures:

     DS - normal way to define a structure

     CREATE-STRUCTURE  -  define  a  structure  dynamically  (i.e. the
          program decides on the name  an  fields).    See  above  for
          problems with compiled code.

     MAKE-xxx  -  where  XXX  is  the name of the structure. Create an
          instance of the structure.

     field-name - refer to a field in an instance of a structure.

     STORE-field-name - change the value of a field in an instance  of
          a structure.

     STORE - another way to change the value of a field in an instance
          of  a  structure.    Differences  from STORE-xxx only in the
          syntax.

     STRUCTUREP - see whether an  object  is  a  structure.    If  so,
          returns the structure type.

     STRUCTURE-FIELDS  - property used to store the list of fields for
          a structure type.
                                                                    86


            18. System functions and the Garbage Collector



18.1. Functions for building your own EMACS interface


The  functions  %EDITOR-xxx  can  be  used  to  build  your  own EMACS
interface, in case you don't like the way EDIT works.  These functions
are explained in full in the reference section.  They work by creating
things that act like normal Lisp channels,  but  refer  to  the  EMACS
buffer.  That is, %EDITOR-WRITE-CHANNEL returns an object such that if
you  set  output  to it, PRINT goes into the EMACS buffer.  The output
channel is set up in such a way that as you write more characters into
it, the system automatically expands the EMACS buffer.    However  you
have  to be a bit careful about these.  The assumption is that you are
going to do %EDITOR-WRITE-CHANNEL, write everything you want to write,
and then do %EDITOR-CLIP-BUFFER.  At this point  the  channel  becomes
unusable.   You should not continue to write after doing %EDITOR-CLIP-
BUFFER.  Nor should you call  EMACS  (%EDITOR-RUN-FORK)  before  doing
%EDIT-CLIP-BUFFER,  since  various  internal  status  variables may be
disturbed by EMACS.  Similarly, once you do %EDITOR-READ-CHANNEL,  you
should read all you intend to read before calling EMACS.

Note  that  the channel is set up by %EDITOR-WRITE-CHANNEL will insert
characters at the current EMACS position ("point").  If  you  want  to
write  into  a  new buffer, do %EDITOR-CLEAR-BUFFER before getting the
output channel.

     DATE - current date, as list of  month,  day,  year  as  numbers.
          Year is last two digits.

     DEBUGINT - turn on and off the interrupts for ^D, ^H, etc.

     DTIME - time since midnight in milliseconds

     *EDIT - pass a form to EMACS to edit, return edited version

     EDIT  -  Edit a function definition or variable value with EMACS.
          Is an FEXPR, so you don't need to quote it.  e.g. (EDIT FOO)
          will edit the function FOO.

     %EDITOR-xxx - functions for building your own EMACS interface

     ELISP.INIT - this file is read automatically when ELISP starts

     ERRCH - lets you select another character to be used  instead  of
          ^G  to  generate  an  interrupt.    Can  also  turn  it  off
          completely.

     EXIT - return to the EXEC

     GC - force a garbage collection now

     GCTRIGGER - lets you determine how often a GC will happen
                                                                    87


     GCLEFT - tells you how close you are to a GC

     GCGAG  -  turn  on  or  off  flag controlling whether the garbage
          collector prints statistics each time it runs

     GCTIME - milliseconds spend garbage collecting in this core image

     INITFN - set up a function to be run every time you  get  to  the
          top level

     INITPROMPT - set the permanent prompt given to the user when Lisp
          is  ready to read from the terminal.  PROMP is reset to this
          whenever you return to the top level of Lisp

     PROMPT - set the current prompt.   This  will  be  reset  to  the
          INITPROMPT next time you return to the top level of Lisp.

     METER  -  very  high  precision  runtime  and  counts  of  memory
          references, but very system-dependent units.

     MYDIR - your connected directory, as string

     MYUSER - your user name, as string

     SAVEIMAGE - saves your entire core image as an .EXE file.

     SPEAK - number of words of heap space used in  this  core  image.
          Since  CONS  cells  take  two  words  each,  if you did only
          CONS's, this would be twice the number of CONS's.  But  this
          space is used for all other dynamic data also, so it will be
          more than just CONS's.

     TIME - CPU time used by the current process, in milliseconds

     TIMER  -  use  this to execute a function and print statistics on
          time and other resources it used.

     UPTIME - number of milliseconds since the  operating  system  was
          last   reloaded.     Useful  because  it  is  monontonically
          increasing, unlike DTIME, which goes to zero at midnight.

     TTYPAUSE - turn on and off TERM PAUSE END-OF-PAGE.
                                                                    88


                        19. The Prettyprinter



Because  of  the  nature of Lisp syntax, it is important to be able to
get prettyprinted listings  of  function  definitions.  Prettyprinting
reformats  the function, using indentation and other graphical devices
to show syntactic structure.   Without  prettyprinting,  you  tend  to
drown  in parentheses.  With it, Lisp code as about as easy to read as
Algol or Pascal code.  This section will describe the  overall  design
of  the  prettyprinter.  If you are satisfied with the normal formats,
then all you need to know is how to use PP, PPL, DSKOUT, or  SAVEF  to
prettyprint  your functions.  However if you want to change the output
format, or if you are implementing a complex system on  top  Lisp  and
want  the prettyprinter to format your constructs properly, you should
read all of this section carefully.

The LISP prettyprint package provides a powerful facility for printing
functions in readable form  and  creating  formatted  symbolic  files.
Among   its   more   sophisticated  capabilities  are  a  "printmacro"
mechanism, two levels of user commenting, and a "prettyprint  command"
facility for controlling the printing process.



19.1. Simple use of the prettyprinter


The  two  most common ways people use the prettyprinter are by calling
PP, DSKOUT, or SAVEF.  PP is normally used to output the definition of
a function (or other object) on your terminal.  E.g.

    (PP FUNC1 FUNC2)

will print the definitions of FUNC1 and FUNC2 on your terminal.    For
details  on  how  PP  decides what to print, and for printing lists of
functions, see PP, PPL, and PRETTYPROPS in the alphabetical  listings.
Briefly,  PPL  is  similar  to  PP,  except  you can give it a list of
functions.  PRETTYPROPS is a global variable  that  controls  what  is
printed  when you ask PP to print FUNC1.  Usually PRETTYPROPS contains
entries that ask for any function, macro definition, or  value  to  be
printed.   However you can get other properties to be printed, and you
can make different properties  and  functional  forms  be  printed  in
different ways.

DSKOUT  or  SAVEF  are  normally  used  to  output  the  definition of
functions (or other objects) to a file.  E.g.

    (DSKOUT "funcs.lsp" FUNC1 FUNC2)

will prettyprint the definitions  of  FUNC1  and  FUNC2  to  the  file
FUNCS.LSP.

If you ever want to "roll your own" prettyprinting facilities, you can
use  the function SPRINT.  (SPRINT x 3) evaluates the expression X and
                                                                    89


prettyprints  it  starting  in  column  3.    PP  and  PPL  are simply
convenient ways  of  calling  SPRINT.    They  automatically  look  up
function definitions, etc., and then print them using SPRINT.

The  rest  of  this  chapter  describes more sophisticated uses of the
prettyprinter.



19.2. Prettyprint Commands


Prettyprint commands may  be  used  as  arguments  to  PP  or  in  PPL
prettyprint lists to perform a variety of special formatting tasks.  A
prettyprint  command  is  simply an expression whose CAR is a function
name with a non-NIL PPCOM property.  Such  expressions  are  evaluated
when  encountered  by  PP,  thus  providing  a mechanism for "grabbing
control" during the prettyprint process.  The user may define his  own
prettyprint  commands,  or may use the following functions supplied by
the system.   Note  that  in  addition  to  appearing  as  prettyprint
commands in PPL lists, these expressions may be used in other contexts
as well.

(*PG*)
          Outputs  a page eject; may be used to place various sections
          of a large symbolic file on different pages.  

(F: fn1 fn2 . . .)
          Prettyprints any functional attributes of each FN,  ignoring
          all other properties.  Actually, F:  simply sets PRETTYPROPS
          to  (EXPR FEXPR MACRO) and passes its arguments on to PP, so
          each FN may be anything which can normally  be  used  as  an
          argument  to  PP  (including  another  prettyprint command).
          PRETTYPROPS is restored after printing is completed.  

(P: props x1 x2 . . .)
          PRETTYPROPS is set to PROPS, the X's are passed  on  to  PP,
          and  PRETTYPROPS  is  restored.    For example, F:  could be
          defined as

              (P: (EXPR FEXPR MACRO) fn1 fn2 . . .)

(ST: x1 x2 . . .)
          Prettyprints any structure definitions of the X's,  ignoring
          all other properties.  

(V: x1 x2 . . .)
          Useful  for printing values.  Each X may be either an atomic
          symbol VAR or a list of the form (var val).  Each  VAR  will
          be printed as a DV expression, with a value of VAL if given,
          or  the  current  value of the variable if only the variable
          name was given (unbound variables are printed with  a  value
          of NIL).  

(MBD: fn x1 x2 . . .)
                                                                    90


          Passes  the  X's  on  to  PP in such a way that they will be
          prettyprinted inside of an expression starting with FN.  For
          example,  to  prettyprint  F1  and  F2  inside  of  a  PROGN
          expression  (perhaps so they will not be compiled) one could
          do:

              (MBD: PROGN F1 F2)

(FORMS: x1 x2 . . .)
          Each Xi is passed directly to SPRINT - may be used to  print
          atoms   and  prettyprint  command  expressions  which  would
          normally be handled specially by PP.  

(E: e1 e2 . . .)
          The Ei's are simply evaluated.  For example,  the  inclusion
          of  the  following  in  a  prettyprint list could be used to
          change the base in the middle of a print:

              (E: (SETQ BASE 10.))



19.3. Printmacros


SPRINT normally operates by formatting the  expression  being  printed
using  indentation  to  produce  "pretty"  output.  It is occasionally
desirable to have  certain  subexpressions  printed  in  some  special
format  for  increased readability.  Such a capability is provided via
the use of printmacros.  Any function may be flagged as  a  printmacro
by placing the macro definition on the property list of the atom under
the  indicator  PRINTMACRO.    Whenever  an  atom with such a property
appears as the first element in a  list  being  prettyprinted,  SPRINT
takes  special  action,  such  action  depending  on  the value of the
PRINTMACRO property:

   - If the value is a string and the expression  is  a  list  of
     exactly  two  elements, the string is simply PRINCed and the
     CADR of the original expression is SPRINTed.  This serves as
     an inverse for READMACROs of the '<e> -> (QUOTE  <e>)  type.
     For example,

         (DEFPROP QUOTE "'" PRINTMACRO)
         (DEFPROP THV "$?" PRINTMACRO)

     (the QUOTE printmacro is in fact already present in LISP).

   - If  the value is the special atomic symbol BRACKETS then the
     expression is printed by SPRINT in the  normal  way,  except
     that each top-level non-atomic argument will be printed with
     brackets [...] instead of the usual parentheses (...).  This
     gives  the  user  one more method of producing more readable
     output.  COND, SELECTQ, AND, OR, and CATCH  are  initialized
     as printmacros of this type.  To disable the use of brackets
     for  these  functions simply REMPROP the PRINTMACRO property
                                                                    91


     from their property lists.

   - If  the value of the PRINTMACRO property is neither a string
     nor the atomic symbol BRACKETS it is assumed to  be  a  true
     printmacro  function  (or,  more  typically,  the  name of a
     function).  This function  will  be  passed  the  expression
     being  printed as its only argument, and may print it in any
     format it wishes (calling SPRINT  recursively  if  desired).
     If  the  printmacro  function  decides  that  the expression
     should be printed in normal form by SPRINT (i.e.,  it  is  a
     "conditional"  printmacro),  it may simply print nothing and
     return the atomic symbol SPRINT.  SPRINT will then print the
     expression as if no printmacro property were  present  (note
     that  this  special  case is necessitated by the fact that a
     recursive call on SPRINT with the original expression  would
     cause  the  printmacro  function  to  be reinvoked).  If the
     printmacro function returns anything  else,  SPRINT  assumes
     that  it  has  printed  the  entire  expression,  and simply
     proceeds.  As an example of a printmacro function, one might
     do the following in lieu  of  defining  QUOTE  as  a  string
     printmacro:

         (DEFPROP QUOTE
            (LAMBDA (E)
               (COND [(AND [CONSP (CDR E)] [NULL (CDDR E)])
                      (PRINC "'")
                      (SPRINT (CADR E) (CHRPOS))]
                     [T 'SPRINT]))
            PRINTMACRO)

     In other words, if the expression is of the form (QUOTE <x>)
     print it as '<x>; otherwise print it in normal list form.

To  make  the writing of printmacro functions easier several auxiliary
formatting functions are provided.  Documentation of  these  functions
assumes  that you are printing a function call.  Thus it refers to the
"function", the "first argument" etc.  If you are printing some  other
S-expression,  treat  these  are CAR, CADR, etc.  See the alphabetical
list of functions for details.

     PP-FORMAT - general purpose formatting function.  By its  various
          flags  and  parameters,  allows  you  to  specify any of the
          available formats.

     PP-MISER - special case of PP-FORMAT.  Produces  a  format  where
          the  first  n  arguments  (N  is  the  value of the PP-MISER
          property of the function being printed) are on one line, and
          the rest are put under the first argument.

     PP-LABELS -  special  case  of  PP-FORMAT.    Produces  a  format
          designed  for  PROG's,  i.e. with normal expressions aligned
          under the first argument and atoms indented to the  left  as
          labels.    Puts the first n arguments (N is the value of the
          PP-LABELS property of the function  begin  printed)  on  one
          line.
                                                                    92


     PP-SPECIAL  - special case of PP-FORMAT.  Produces a format where
          the first n arguments (N is  the  value  of  the  PP-SPECIAL
          property of the function being printed) are on one line, and
          the rest are put under either the function name or the first
          argument, depending upon how much space there is.



19.4. Comments


One  of  the major disadvantages of many LISP systems is the lack of a
usable commenting facility.  This has been remedied in  RUCI  LISP  by
the  addition of two levels of comments, indicated by ; and ;;.  These
atoms are defined as macros which expand to NIL; expressions  starting
with  ;  or  ;;  may  be placed in function definitions anywhere a NIL
could be placed without harm, e.g., at the top level  of  LAMBDAs  and
PROGs  (when  the function is subsequently compiled, these expressions
will disappear).  ; and ;; are also defined as printmacros which cause
the expression to be printed in block form as a comment.   ;  comments
are  intended  to be used for detailed descriptions of code - they are
printed starting in column 40.  ;; comments are intended to  serve  as
top-level  descriptions  of  functions  or segments of code - they are
printed at the current level of indentation.

In order to cause comments to be stored as compactly  as  possible,  a
new  readmacro  character  ("{",  or  left  brace) is used for reading
comments:

    {; This is a comment.}

causes everything from the ";" up to the "}" to be read as  a  string,
so the above comment will be stored internally as

    (; "This is a comment.")

In  addition  to  being  more compact, the use of {...} allows special
characters such as periods and  commas  (and  lower-case  letters,  if
*RAISE=T)  to  appear  in  comments without having to "slashify" them.
The comment printer knows about such packed comments, and prints  them
correctly.    The  prettyprinter  will print all comments in this form
unless the variable COMMENTSTR is set to NIL.  Packed comments may  be
converted to lists for easier editing via the new UNPACK edit command.

Comment  atoms  are flagged by placing the function name PP-COMMENT on
the property list of the  atom  under  the  PRINTMACRO  property,  and
putting  either  T (print at current indentation level) or the desired
starting print column on the property list under the property COMMENT.
The user may thus disable ; or ;; as comment atoms by  removing  these
two  properties,  or may change the starting column or add new comment
atoms if desired.

Note that comments are intended primarily to comment symbolic files  -
when  printing to the terminal all comments appear simply as *COMMENT*
unless the special variable COMMENTFLG is non-NIL.  The functions  PP;
                                                                    93


and  PPL;,  and  the  edit  commands  P; and PP;, may be used to print
function definitions with comments on the terminal (i.e.,  they  first
set COMMENTFLG to T).
                                                                    94


                         20. The Help System



This  chapter  describes  the HELP function and its various associated
pieces.  There is builtin help on all  Lisp  functions.  You  can  use
these facilities to supply help for systems you are building up.

The  major  function  for the end-user is HELP.  To find out about the
function COND, you would type (HELP COND).  Builtin help is  available
for  all of the Lisp functions described in the alphabetical reference
section.  Some functions have several options.  In this case  you  can
give  more  than  one  keyword,  to select which option you want.  For
example, there are several kinds of DO loop.  (HELP DO) would  provide
general  information on DO.  (HELP DO WHILE) would provide help on the
specific DO WHILE form.

There are two other functions intended for the end-user.  One of  them
is  EXAMPLE.  It works just like HELP, but supplies examples of how to
use a function (assuming that there are examples in the database).  At
the moment the only builtin example is (EXAMPLE HELP).    However  you
can  supply  examples  for  systems that you are documenting using the
HELP system.

Finally there is HELPM.  This is designed for contexts in which  there
are  several  systems  (called  "modules"  in the documentation).  For
example, you might have the Lisp system  itself,  the  language  FUZZY
which  is  built  in  Lisp, and the system AIMDS implemented in FUZZY.
Someone who is creating a help system for this situation could  define
FUZZY  and AIMDS as "modules", and make any help relating them be part
of that module.  Thus there might be help on FILES in Lisp, in  FUZZY,
and  in  AIMDS.  If the user simply types (HELP FILES) he will be told
that there is help in all three of these modules, and asked which ones
he is interested in.  HELPM lets him specify a particular  module,  to
avoid  this  ambiguity.    The builtin help for Lisp is in the default
module, NIL.

You will often be able to find out information  even  about  functions
for  which  help  has  not been specifically provided.  If not help is
available through the normal methods (an index into files supplied  by
the  implementor),  the  help  system will still try to help.  It will
look to see whether the topic is a function.  If so, it will print all
of the comments in the definition, and indicate the type  of  function
and  number of arguments.  If not, it will look to see whether it is a
variable, and give some information on that.



20.1. Creating help


The description above gives you enough information  to  use  the  HELP
facility.  This section is designed to tell you how to create help for
programs that you are writing.  The help system requires two files:  a
help  file and an index file.  The help file is simply the text of all
                                                                    95


the  help messages.  It consists of a sequence of help entries. A help
entry begins with a control-K. This is followed by either a keyword or
a list of keywords under which the following text is to be indexed. In
order for queries like (HELP DO UNTIL) to work the key needs to be DO-
UNTIL. A help entry is terminated by the  next  control-K,  indicating
another entry, or an end of file.

The help index file is designed to be DSKIN'ed to your core image, and
contains  information  to  allow the help system to know where to find
help for a given function.  Any function  for  which  help  is  to  be
available  has a property HELP-FILE-INFO whose value is a list of help
messages.  Each member of this list indicates the module to which  the
message  applies,  the  file name in which the text is stored, and the
starting and ending byte numbers of the text.

The  function  HELP:CREATE-INDEX-FILE  will  create  the  index   file
automatically, given the name of the help file.



20.2. Functions for use with the help system


     HELP - prints out help on a topic.  If help is available for more
          than one module, asks the user to select.

     HELPM - prints out help for a specified module only.

     HELP:CREATE-INDEX-FILE  -  used  to create an index file when you
          want to supply your own help
                                                                    96


                       21. Debugging Facilities



21.1. Introduction


Debugging  a  collection of LISP functions involves isolating problems
within  particular  functions  and/or  determining  when   and   where
incorrect  data  are being generated and transmitted.  In the UCI LISP
system, there are six facilities which aid the user in monitoring  his
program:

   - ERRORX  - the Error Package, which takes control whenever an
     error occurs in a program  and  which  allows  the  user  to
     examine  the  state  of  the  world  (see  section on 'ERROR
     PACKAGE')

   - SSTEP - the single stepper, which allows the user  to  watch
     the  evaluation  of  his  program  expression by expression,
     looking at values and stopping where desired.

   - ^B and ^H - interrupts which allow the user  to  temporarily
     interrupt his computation and examine its progress.

   - BREAK,  TRACE, and BREAKIN - three facilities that allow the
     user to (temporarily) modify selected  function  definitions
     so that he can follow the flow of control in his programs.

All  of  these  facilities  except for the single stepper use the same
system function, BREAK1, as the user interface.

BREAK, BREAKIN and TRACE together are called the Break Package.  BREAK
and TRACE can be used on compiled and  system  functions  as  well  as
EXPR's,   FEXPR's  and  MACRO's.    BREAKIN  can  be  used  only  with
interpreted functions.

BREAK modifies the definition of a function FN, so  that  if  a  break
condition  (defined  by the user) is satisified, the process is halted
temporarily on a call to FN.  The user can then interrogate the  state
of  the machine, perform any computations, and continue or return from
the call.

TRACE modifies a definition of a function FN so that  whenever  FN  is
called, its arguments (or some other values specified by the user) are
printed.  When the value of FN is computed it is printed also.

BREAKIN  allows  the  user to insert a breakpoint inside an expression
defining a function.  When the breakpoint is reached and  if  a  break
condition  (defined by the user) is satisfied, a temporary halt occurs
and the user can again investigate the state of the computation.

The  three  examples  on  pages  98  through  100   illustrate   these
facilities.    In the first example, the user traces the function FACT
using the single stepper.    Each  time  Lisp  needs  to  evaluate  an
                                                                    97


expression, the expression is displayed, and the user is prompted with
"S>".    In this case, the user typed carriage return each time.  This
causes the computation to continue, and  the  next  expression  to  be
typed  out.  When a value is determined for an expression, it is typed
back in the form EXPRESSION ==> VALUE.

In the second example, the user traces the  function  FACTORIAL  using
TRACE.    TRACE  redefines FACTORIAL so that it calls BREAK1 in such a
way that it prints some information, in this case  the  arguments  and
value  of  FACTORIAL,  and then goes on with the computation.  When an
error occurs on the fifth recursion,  BREAK1  reverts  to  interactive
mode,  and  a  full  break  occurs.  The situation is then the same as
though the user had originally performed (BREAK FACTORIAL) instead  of
(TRACE  FACTORIAL),  and  the user can evaluate various LISP forms and
direct the course of the computation.  In this case, the user examines
the variable N, instructs BREAK1 to change L to 1 and continue.  The >
command, following an UNBOUND ATOM or UNDEFINED FUNCTION error,  tells
BREAK1 to use the next expression instead of the atom which caused the
error.  The > command does a destructive replacement of, in this case,
1 for L, and saves an edit step by correcting the typo in the function
definition.    The rest of the tracing proceeds without incident.  The
function UNTRACE restores FACTORIAL to its original definition.

In the third example, the user has written Ackermann's function.    He
then  uses  BREAK  to  place  a  call to BREAK1 around the body of the
function.  He indicates that ACK is to be broken when M equals  N  and
that  before the break occurs, the arguments to ACK are to be printed.
While calculating (ACK 2 1), ACK is called twice when  M  =  N. During
the  first  of  these  breaks,  the user prints out a backtrace of the
function names and variable bindings.  He  continues  the  computation
with a GO which causes the value of (ACK 1 1), 3, to be printed before
the  break is released.  The second break is released with an OK which
does not print the result of (ACK 1 1).  The function UNBREAK with  an
argument  T  restores  the  latest  broken  or  traced function to its
original definition.

For further information on how to use BREAK, TRACE  and  BREAKIN,  see
the section on The Break Package.
                                                                    98



    *(de fact (n) (cond ((zerop n) 1)
                         (t (times n (fact (sub1 n]
    FACT

    *(sstep (fact 1))

    (SSTEP (FACT 1))
    S>

    (FACT 1)
    S>

    (COND ((ZEROP N) 1) (T (MACROEXPANSION & &)))
    S>

    (ZEROP N)
    S>
    (ZEROP N) ==> NIL

    (MACROEXPANSION (*TIMES N (FACT &)) (TIMES N (FACT &)))
    S>

    (*TIMES N (FACT (SUB1 N)))
    S>

    (FACT (SUB1 N))
    S>

    (SUB1 N)
    S>
    (SUB1 N) ==> 0

    (COND ((ZEROP N) 1) (T (MACROEXPANSION & &)))
    S>

    (ZEROP N)
    S>
    (ZEROP N) ==> T
    (COND (& 1) (T &)) ==> 1
    (FACT (SUB1 N)) ==> 1
    (*TIMES N (FACT &)) ==> 1
    (MACROEXPANSION (*TIMES N &) (TIMES N &)) ==> 1
    (COND (& 1) (T &)) ==> 1
    (FACT 1) ==> 1
    (SSTEP (FACT 1)) ==> 1
    1

    *
                                                                    99



         *(DE FACTORIAL (N)
              (COND ((ZEROP N) L)
                    (T (TIMES N (FACTORIAL (SUB1 N))))))
         FACTORIAL

         *(TRACE FACTORIAL)
         (FACTORIAL)

         *(FACTORIAL 4)
         ENTER FACTORIAL:
         !     N = 4
         !  ENTER FACTORIAL:
         !  !     N = 3
         !  !  ENTER FACTORIAL:
         !  !  !     N = 2
         !  !  !  ENTER FACTORIAL:
         !  !  !  !     N = 1
         !  !  !  !  ENTER FACTORIAL:
         !  !  !  !  !     N = 0
         L
         UNBOUND VARIABLE - EVAL

         L Broken:

         1:N
         0

         1:> 1

         !  !  !  !  FACTORIAL = 1
         !  !  !  FACTORIAL = 1
         !  !  FACTORIAL = 2
         !  FACTORIAL = 6
         FACTORIAL = 30
         30

         *(UNTRACE FACTORIAL)
         (FACTORIAL)

         *(FACTORIAL 4)
         30
                                                                   100



         *(DE ACK (M N)
              (COND ((ZEROP M) (ADD1 N))
                    ((ZEROP N) (ACK (SUB1 M) 1))
                    (T (ACK (SUB1 M) (ACK M (SUB1 N))))))
         ACK

         *(BREAK (ACK (EQ N M) (ARGS)))
         (ACK)

         *(ACK 2 1)
            M = 1
            N = 1

         ACK Broken:

         1:BKFV

         ACK
             M = 2
             N = 0
         ACK
             M = 2
             N = 1
         ACK

         1:GO

         3

            M = 1
            N = 1

         (ACK BROKEN)

         1:OK

         5

         *(UNBREAK T)

         (ACK)
                                                                   101


21.2. The single stepper


The  single  stepper  allows  you  to watch every expression that Lisp
evaluates.  The single stepper is essentially  two  "hooks"  in  EVAL.
The  first  hook  allows  you  to  see  every  expression before it is
evaluated.  The second hook allows you to see  the  results  of  every
expression  once evaluation is finished.  When the first hook displays
an expression to be evaluated, it gives you the following choices:

   - S or carriage return - STEP - evaluation of that  expression
     proceeds,  and the system remains in single step mode.  Thus
     you will continue to see evaluation of any subparts  of  the
     expression.

   - X  -  EXECUTE  -  evaluation  of  that  expression  proceeds
     silently.  You will not see evaluation of  any  subparts  of
     it.    However you will see the results, and single stepping
     will continue from the time when the results are returned.

   - G - GO - evaluation  proceeds  silently.    I.e  the  system
     leaves  single step mode and proceeds normally.  However any
     expressions  for  which  single  stepping  is  currently  in
     progress will still have their values displayed.

   - B  - BREAK - the Break Package will be called on the current
     expression.

   - Anything else - is evaluated in the context of  the  current
     expression, and its value is printed.

To single step a function, call (SSTEP expression).  This is an FSUBR,
so EXPRESSION will not be evaluated.  E.g.  (SSTEP (FACT 4)).

Actually you can redefine the user interface for the stepper.  See the
documentation for HOOK1 and HOOK2.



21.3. BREAK1


The heart of the debugging package is a function called BREAK1.  BREAK
and  TRACE  redefine your functions in terms of BREAK1.  When an error
occurs control is passed to BREAK1.  The DDT  break  feature  is  also
implemented using BREAK1.

Whenever LISP types a message of the form (-- BROKEN) followed by 'n:'
the  user  is then 'talking to' BREAK1, and he is 'in a break.' BREAK1
allows the user to interrogate the state of the world and  affect  the
course  of  the  computation.    It  uses  the prompt character ':' to
indicate it is ready to accept input(s) for evaluation,  in  the  same
way  as  the  top level of LISP uses '*'.  The n before the ':' is the
level number which indicates how many levels of BREAK1  are  currently
open.  The user may type in an expression for evaluation and the value
                                                                   102


will be printed out, followed by another ':'.  Or the user can type in
one  of the commands described below which are specifically recognized
by BREAK1 (for summary of commands see Table 21-1, page 116.

Since BREAK1 puts all of the power of LISP at the user's  command,  he
can  do  anything he can do at the top level of LISP.  For example, he
can define new functions or edit existing ones, set breaks,  or  trace
functions.    The  user may evaluate an expression, see that the value
was incorrect, call the editor, change a function,  and  evaluate  the
expression again, all without leaving the break.

It  is important to emphasize that once a break occurs, the user is in
complete control of the flow of the computation, and  the  computation
will  not  proceed without specific instruction from him.  Only if the
user gives one of the commands that exits  from  the  break  (GO,  OK,
RETURN,  FROM?=, EX) will the computation continue.  If the user wants
to abort the computation, this also can be done (using ^ or ^^).

Note that BREAK1 is just another LISP function, not a  special  system
feature  like  the  interpreter  or  the  garbage  collector.   It has
arguments and returns a value, the same as any other function.  A call
to BREAK1 has the form

    (BREAK1 BRKEXP BRKWHEN BRKFN BRKCOMS BRKTYPE)

The arguments to BREAK1 are:  BRKWHEN is  a  LISP  function  which  is
evaluated to determine if a break will occur.  If BRKWHEN returns NIL,
BRKEXP  is  evaluated  and  returned  as  the  value  of  the  BREAK1.
Otherwise a break occurs.  BRKFN is the name  of  the  function  being
broken and is used to print an identifying message.  BRKCOMS is a list
of  command  lines  (as returned by LINEREAD) which are executed as if
they had been typed in from  the  teletype.    The  command  lines  on
BRKCOMS  are  executed before commands are accepted from the teletype,
so that if one of the commands on BRKCOMS causes  a  return,  a  break
occurs  without the need for teletype interaction.  BRKTYPE identifies
the type of the break.  It is used primarily by the error package  and
in all cases the user can use NIL for this argument.

The  value  returned by BREAK1 is called 'the value of the break.' The
user can specify this value explicitly by  using  the  RETURN  command
described  below.    In most cases, however, the value of the break is
given implicitly, via a GO  or  OK  command,  and  is  the  result  of
evaluating 'the break expression,' BRKEXP.

BRKEXP  is,  in  general,  an expression equivalent to the computation
that would have taken place had no break occurred.   In  other  words,
one  can  think  of  BREAK1 as a fancy EVAL, which permits interaction
before and after evaluation.  The break expression then corresponds to
the argument to  EVAL.    For  BREAK  and  TRACE,  BRKEXP  is  a  form
equivalent  to  that  of  the  function  being  traced or broken.  For
errors, BRKEXP is the form which caused the error.   For  DDT  breaks,
BRKEXP is the next form to be evaluated.
                                                                   103


21.4. WHAT YOU CAN DO IN A BREAK



21.4.1. Break Commands


You can get into a break in any of the following ways:

   - An  error  occurs in your program.  For example, you call an
     undefined function.  When any error (other than major system
     catastrophe) happens, the system  automatically  starts  the
     break package for you.  This is probably the most common way
     to end up in a break.

   - You have asked for a break by BREAK, TRACE, or BREAKIN.

   - You type ^H during execution of your program.  This causes a
     break  to  occur at the next time EVAL is called.  This is a
     "clean" point for the system, so you will neither  lose  any
     context information, nor will anything be executed more than
     one  if you proceed from the break with "OK".  If you are in
     the middle of a lot of compiled code, there may  be  a  wait
     before the break happens, since EVAL is not used by compiled
     code.

   - You  type  ^B during execution of your program.  This causes
     an immediate break.  The  disadvantage  is  that  the  break
     package  is  not  necessarily  being  called at a convenient
     time.  It will have to back up to the most  recent  call  to
     EVAL  in  order  to make sense of what is going on.  Thus if
     you proceed with OK, some work may be done again.  ^H is the
     recommended way to get a break.

Once in a break, in addition to evaluating expressions, the  user  can
ask BREAK1 to perform certain useful actions by giving it atomic items
as  "break  commands".   The following commands can be typed in by the
user or may be put on the list BRKCOMS.  TABLE 21-1  (page  116  is  a
summary of these commands.)

All  printing in BREAK1 is done by calling (%PRINFN expr).  %PRINFN is
an atom (not a function) which  should  evaluate  to  the  name  of  a
printing  function  of  one  argument.   %PRINFN is initialized to use
PRINTLEV because it can print circular lists, which quite often result
from errors.  PRINTLEV only prints lists to a depth of 6.  This  depth
parameter  may be changed by setting the value of %LOOKDPTH.  PRINTLEV
is necessarily slow and if you are not printing  circular  structures,
traces  can  be speeded up greatly by changing the value of %PRINFN to
PRIN1.

GO
          Releases the break and allows the  computation  to  proceed.
          BREAK1  evaluates  BRKEXP,  its  first  argument, prints the
          value, and returns it as the value of the break.  BRKEXP  is
          the  expression  set  up by the function that called BREAK1.
                                                                   104


          For  BREAK or TRACE, BRKEXP is equivalent to the body of the
          definition of the broken function.  For the  error  package,
          BRKEXP  is  the expression in which the error occurred.  For
          DDT breaks, it is the next form to be evaluated.

OK
          Same as GO except that the value of BRKEXP is not printed.

EVAL
          Causes BRKEXP to be evaluated.  The break is maintained  and
          the  value  of  the  evaluation  is printed and bound on the
          variable  !VALUE.    Typing  GO  or  OK   will   not   cause
          reevaluation of BRKEXP following EVAL but another EVAL will.
          EVAL  is  a useful command when the user is not sure whether
          or not the break will produce the correct value  and  wishes
          to be able to do something about it if it is wrong.

RETURN form
          The form is evaluated and its value is returned as the value
          of  the  break.  For example, one might use the EVAL command
          and follow this with RETURN (REVERSE !VALUE).

FROM?= form
          This permits the user to release the break and return  to  a
          previous context with form to be evaluated.  For details see
          context commands.

> [or ->] expr
          For use either with UNBOUND ATOM error or UNDEFINED FUNCTION
          error.    Replaces  the expression containing the error with
          expr (not the value of expr) e.g.,

              ? FOO1
              ? undefined function

              FOO1 Broken:
              1:> FOO

          changes FOO1 to FOO and continues  the  computation.    Expr
          need not be atomic, e.g.,

              ? FOO
              ? unbound atom

              FOO Broken:
              1:> (QUOTE FOO)

          For  UNDEFINED  FUNCTION  breaks,  the  user  can  specify a
          function and its first argument, e.g.,

              ? MEMBERX
              ? Undefined function

              MEMBERX Broken:
              1:> MEMBER X
                                                                   105


          Note  that  in  the  some  cases  the  form  containing  the
          offending atom will not be  on  the  stack  (notably,  after
          calls  to  APPLY) and in these cases the function definition
          will not be changed.  In most cases, however, > will correct
          the function definition.

USE x FOR y
          Causes all occurrences of y in the  form  on  the  stack  at
          LASTPOS (for Error breaks, unless a F command has been used,
          this  form  is  the one in which the error occurred.)  to be
          replaced (RPLACA'ed) by x. Note:    This  is  a  destructive
          change  to  the s-expression involved and will, for example,
          permanently change the definition of a function and  make  a
          edit step unnecessary.

^
          Calls  ERR  and  aborts  the break.  This is a useful way to
          unwind to a higher level break.  All other errors, including
          those encountered while executing  the  GO,  OK,  EVAL,  and
          RETURN commands, maintain the break.

^^
          This returns control directly to the top level of LISP.

ARGS
          Prints  the names and the current values of the arguments of
          BRKFN.  In most cases, these are the arguments of the broken
          function.



21.4.2. Context Commands


All information pertaining to the evaluation of forms in LISP is  kept
on  the  special  push down stack.  Whenever a form is evaluated, that
form is placed on the special push down stack.  Whenever a variable is
bound, the old binding is saved on the special push down stack.    The
context  (the  bindings of free variables) of a function is determined
by its position in the stack.  When a break occurs, it is often useful
to explore the contexts of other  functions  on  the  stack.    BREAK1
allows this by means of a context pointer, LASTPOS, which is a pointer
into  the  special  push down stack.  BREAK1 contains commands to move
the context pointer and to evaluate atoms or  expressions  as  of  its
position in the stack.  For the purposes of this document, when moving
through the stack, "backward" is considered to be toward the top level
or, equivalently, towards the older function calls on the stack.

F [or &] arg1 arg2 ... argN
          Resets the variable LASTPOS, which establishes a context for
          the  commands  ?=,  USE,  EX  and  FROM?=, and the backtrace
          commands described below.  LASTPOS  is  the  position  of  a
          function  call  on  the  special  push  down  list.    It is
          initialized to the function just before the call to BREAK1.
                                                                   106


          F  takes  the  rest  of  the  teletype  line  as its list of
          arguments.  F first resets LASTPOS to the function call just
          before  the  call  to  BREAK1,  and  then  for  each  atomic
          argument,  F searches backward for a call to that atom.  The
          following atoms are treated specially:

F [or &]
                    When used as the first argument causes LASTPOS not
                    to  be  reset  to  above  BREAK1   but   continues
                    searching from the previous position of LASTPOS.

Numbers
                    If  negative, move LASTPOS back (i.e.  towards the
                    top level) that  number  of  calls,  if  positive,
                    forward.

-
                    Search  forward  instead  of backward for the next
                    atom

              Example:

              If the special push-down stack looks like

                      BREAK1          (13)
                      FOO             (12)
                      SETQ            (11)
                      COND            (10)
                      PROG             (9)
                      FIE              (8)
                      COND             (7)
                      FIE              (6)
                      COND             (5)
                      FIE              (4)
                      COND             (3)
                      PROG             (2)
                      FUM              (1)

              then
                   F FIE COND     will set LASTPOS to to (7)
                   F & COND       will then set LASTPOS to (5)
                   F FUM _ FIE    will stop at (4)
                   F & 2          will then move LASTPOS to (6)
                   F              will reset LASTPOS to (12)

          If F cannot successfully complete a search for  argN  or  if
          argN  is  a number and F cannot move the number of functions
          asked, "argN?"  is  typed.    In  either  case,  LASTPOS  is
          restored  to  its  value  before  the F command was entered.
          Note:  It is possible to move past  BRKEXP  (i.e.  into  the
          break package functions) when searching or moving forward.

          When  F  finishes,  it  types  the  name  of the function at
          LASTPOS.
                                                                   107


          F  can  be used on BRKCOMS.  In which case, the remainder of
          the list is treated as the list of arguments. (i.e.  (F  FOO
          FIE FOO)

EDIT arg1 arg2 ... argN
          EDIT  uses its arguments to reset LASTPOS in the same manner
          as the F command.  The form at LASTPOS is then given to  the
          LISP  Editor.    This commands can often times save the user
          from the trouble  of  calling  EDITF  and  the  finding  the
          expression that he needs to edit.

?= arg1 arg2 ... argN
          This  is a multi-purpose command.  Its most common use is to
          interrogate the value(s) of  the  arguments  of  the  broken
          function,  (ARGS is also useful for this purpose.)  e.g.  if
          FOO has three arguments (X Y Z), then typing ?= to  a  break
          of FOO, will produce:

              n:?=
                X =   value of X
                Y =   value of Y
                Z =   value of Z

          ?= takes the rest of the teletype line as its arguments.  If
          the  argument  list  to  ?= is NIL, as in the above case, it
          prints all of the arguments of the function at LASTPOS.   If
          the user types

          ?= X (CAR Y)

          he  will  see the value of X, and the value of (CAR Y).  The
          difference between  using  ?=  and  typing  X  and  (CAR  Y)
          directly  into  BREAK1 is that ?= evaluates its inputs as of
          LASTPOS.  This provides a  way  of  examining  variables  or
          forms as of a particular point on the stack.  For example,

              F FOO FOO
              ?= X

          will  allow the user to examine the value of X in an earlier
          call to FOO.

          ?=   also   recognizes   numbers   as   referring   to   the
          correspondingly numbered argument.  Thus

              :F FIE
              :?= 2

          will  print the name and value of the second argument of FIE
          (providing FIE is not compiled).

          ?= can also be used on BRKCOMS, in which case the  remainder
          of  the list on BRKCOMS is treated as the list of arguments.
          For example, if BRKCOMS is ((EVAL)  (?=  X  (CAR  Y))  GO)),
          BRKEXP  will  be  evaluated,  the  values  of  X and (CAR Y)
                                                                   108


          printed,  and  then the function exited with its value being
          printed.

FROM?= [form]
          FROM?= exits from the break by undoing the special push down
          stack back to LASTPOS.  If  FORM  is  NIL  or  missing,  re-
          evaluation continues with the form on the push down stack at
          LASTPOS.   If FORM is not NIL, the function call on the push
          down stack at LASTPOS is replaced  by  FORM  and  evaluation
          continues  with  FORM.   FORM is evaluated in the context of
          LASTPOS.  There is no way of recovering  the  break  because
          the push down stack has been undone.  FROM?= allows the user
          to,  among  other  things,  return a particular value as the
          value of any function call on the stack.  To return 1 as the
          value of the previous call to FOO:

              :F FOO
              :FROM?= 1

          Since form is evaluated after it is placed on the  stack,  a
          value of NIL can be returned by using (QUOTE NIL).

EX
          EX  exits  from  the  break  and  re-evaluates  the  form at
          LASTPOS.  EX is equivalent to FROM?= NIL.



21.4.3. Backtrace Commands


The backtrace commands print information about function calls  on  the
special  push  down  list.   The information is printed in the reverse
order that the calls were made.  All backtraces start at LASTPOS.

BKF
          BKF gives a backtrace of the names  of  functions  that  are
          still pending.

BKE
          BKE  gives  a  backtrace  of  the  expressions  which called
          functions still pending (i.e.  It prints the function  calls
          themselves instead of only the names as in BKF).

BK
          BK gives a full backtrace of all expressions still pending.

All of the backtrace commands may be suffixed by a 'V' and/or followed
by  an  integer.    If  the integer is included, it specifies how many
blocks are to be printed.  The limiting point of a block is a function
call.  This form is useful when working on a Data Point.    Using  the
integer  feature  in  conjunction  with  the  F  command,  which moves
LASTPOS, the user can display any contiguous part  of  the  backtrace.
If  a  'V'  is  included, variable bindings are printed along with the
expressions in the backtrace.
                                                                   109


Example:

     BKFV would print the names and variable bindings of the functions
          called before LASTPOS.

     BKV 5
          would  print  everything  (expressions  and variables) for 5
          blocks before LASTPOS.

The output of the backtrace commands deserves some explanation.  Right
circular lists are only printed up  to  the  point  where  they  start
repeating  and  are closed with '...]' instead of a right parenthesis.
Lists are only printed to a depth of 2.    /#/  Is  a  notation  which
represents  "the  previous expression".  For example, (SETQ FIE (FOO))
would appear in a BK backtrace as

    (FOO)
    (SETQ FIE /#/)



21.4.4. Breakmacros


Whenever an atomic command is encountered by BREAK1 that it  does  not
recognize,  either  via  BRKCOMS  or  the teletype, it searches (using
ASSOC) the list BREAKMACROS to see if the atom has been defined  as  a
break  macro.   The form of BREAKMACROS definitions is (... (atom args
ttyline1 ttyline2 ...  ttylineN) ...  ).  ATOM is  the  command  name.
ARGS  is the argument(s) for the macro.  The arguments of a breakmacro
are assigned values from the remainder of the command  line  in  which
the  macro is called.  If ARGS is atomic, it is assigned the remainder
of the command line as its value.  If ARGS is a list, the elements  of
the  rest of the command line are assigned to the variables, in order.
If there are more variables in ARGS then items  in  the  rest  of  the
command line, a value of NIL is filled in.  Extra items on the command
line  are  ignored.    The  TTYLINEs  are  the  body of the breakmacro
definition and are lists of break commands or forms to  be  evaluated.
If  the  atom  is  defined  as a macro, (i.e. is found on BREAKMACROS)
BREAK1 assigns values to the  variables  in  ARGS,  substitutes  these
values  for  all  occurrences of the variables in TTYLINEs and appends
the TTYLINEs to the front of BRKCOMS.  When BREAK1 is ready to  accept
another  command,  if BRKCOMS is non-NIL it takes the first element of
BRKCOMS and processes it exactly as if it had been a line  input  from
the  teletype.   This means that a macro name can be defined to expand
to any arbitrary collection of expressions that the  user  could  type
in.   If the command is not contained in BREAKMACROS, it is treated as
a function or variable as before.

Example:  a command PARGS to print the arguments of  the  function  at
LASTPOS could be defined by evaluating:

(NCONC BREAKMACROS (QUOTE ((PARGS NIL (?=)))))

A  command FP which finds a place on the SPD stack and prints the form
                                                                   110


there can be defined by:

(NCONC BREAKMACROS (QUOTE (FP X (F .  X) ((PRINT (SPDLRT LASTPOS))))))



21.5. BREAK PACKAGE



21.5.1. How To Set A Break


The  following  functions  are useful for setting and unsetting breaks
and traces.

Both  BREAK  and  TRACE  use  a  function  BREAK0  to  do  the  actual
modification of function definitions.  When BREAK0 breaks a SUBR or an
FSUBR,  it  prints a message of the form (--- .  ARGUMENT LIST?).  The
user should respond with a list of arguments for  the  function  being
broken.   (FSUBR's take only one argument and BREAK0 checks for this.)
The arguments on this list are actually bound during the calls to  the
broken  function  and  care should be taken to insure that they do not
conflict with free variables.  For LSUBR's, the atom N?   Is  used  as
the  argument.   It is possible to prettyprint and edit functions that
are traced or broken.  BROKENFNS is a list of the functions  currently
broken.  TRACEDFNS is a list of the functions currently traced.



21.5.2. BREAK


BREAK  is  an FEXPR.  For each atomic argument, it breaks the function
named each time it is called.  For each list in the form (fn1 IN fn2),
it breaks only those occurrences of FN1 which appear  in  FN2.    This
feature  is  very  useful  for breaking a function that is called from
many places, but where one is only  interested  in  the  call  from  a
specific  function,  e.g.  (RPLACA  IN FOO), (PRINT IN FIE), etc.  For
each list not in this form, it assumes that the CAR is a  function  to
be  broken;  the  CADR  is  the  break condition; (When the fuction is
called, the break condition is evaluated.  If  it  returns  a  non-NIL
value, the break occurs.  Otherwise, the computation continues without
a  break.)    and  the CDDR is a list of command lines to be performed
before an interactive  break  is  made  (see  BRWHEN  and  BRKCOMS  of
BREAK1).  For example,

    (BREAK FOO1 (FOO2 (GREATERP N 5) (ARGS)))

will  break  all calls to FOO1 and all calls on FOO2 when N is greater
than 2 after first printing the arguments of FOO2.

    (BREAK ((FOO4 IN FOO5) (MINUSP X)))

will break all calls to FOO4 made from FOO5 when X is negative.
                                                                   111


    Examples:
         (BREAK FOO)
         (BREAK ((GET IN FOO) T (GO)))
         (BREAK (SETQ (EQ N 1) ((PRINT (QUOTE N=1)))(?= M)))



21.5.3. TRACE


TRACE  is  an FEXPR.  For each atomic argument, it traces the function
named (see form on page 1.3) each time it is called.  For each list in
the form (fn1 IN fn2), it traces only those calls to  FN1  that  occur
within  FN2.   For each list argument not in this form, the CAR is the
function to be traced, the CADR is the trace condition, and  the  CDDR
is a list of variables (or forms) the user wishes to see in the trace.

For  example,  (TRACE  (FOO1 T Y) (SETQ IN FOO3)) will cause both FOO1
and SETQ IN FOO3 to be traced.  SETQ's argument will  be  printed  and
the value of Y will be printed for FOO1.

TRACE  uses  the global variable /#%INDENT to keep its position on the
line.  The printing of output  by  TRACE  is  printed  using  %PRINFN.
TRACE can therefore be pretty printed by:

    (SETQ %PRINFN (QUOTE PRETPRIN))
    (DE PRETPRIN (FORM)
        (SPRINT FORM (*PLUS 10 /#%INDENT)))

    Examples:
         (TRACE FOO)
         (TRACE *TIMES (SELECTQ IN DOIT))
         (TRACE (EVAL IN FOO))
         (TRACE (TRY (GREATERP M N) X (*PLUS N M)))

Note:   The user can always call BREAK0 himself to obtain combinations
of options of BREAK1 not directly available with BREAK and TRACE  (see
section  on  BREAK0 below).  These functions merely provide convenient
ways of calling BREAK0, and will serve for most uses.



21.5.4. BREAKIN


BREAKIN enables the user to insert a break, i.e., a call to BREAK1, at
a specified location in an interpreted function.  For example, if  FOO
calls  FIE, inserting a break in FOO before the call to FIE is similar
to breaking FIE.  However, BREAKIN can be used to insert breaks before
or after  prog  labels,  particular  SETQ  expressions,  or  even  the
evaluation of a variable.  This is because BREAKIN operates by calling
the  editor  and  actually  inserting  a call to BREAK1 at a specified
point inside of the function.

The user specifies where the break is to be inserted by a sequence  of
                                                                   112


editor  commands.    These  commands are preceded by BEFORE, AFTER, or
AROUND, which BREAKIN uses to determine what to do once the editor has
found the specified point, i.e., put the call to  BREAK1  BEFORE  that
point,  AFTER  that point, or AROUND that point.  For example, (BEFORE
COND) will insert a break before the first occurrence of COND,  (AFTER
COND  2  1)  will insert a break after the predicate in the first COND
clause, (AFTER BF (SETQ X F)) after the last place X  is  set.    Note
that (BEFORE TTY:), (AROUND TTY:)  or (AFTER TTY:)  permit the user to
type  in  commands to the editor, locate the correct point, and verify
it for himself using the P command, if he desires.  Upon exit from the
editor with OK, the break is inserted.  (A STOP command typed to  TTY:
produces  the  same  effect  as  an  unsuccessful  edit command in the
original specification, e.g., (BEFORE CONDD).    In  both  cases,  the
editor aborts, and BREAKIN types (NOT FOUND).)

for  BREAKIN  BEFORE  or AFTER, the break expression is NIL, since the
value of the break is usually not of interest.   For  BREAKIN  AROUND,
the  break  expression will be the indicated form.  When in the break,
the user can use the EVAL command to evaluate that form, and  see  its
value,  before  allowing  the computation to proceed.  For example, if
the user inserted a break after a COND predicate, e.g., (AFTER  (EQUAL
X  Y)),  he would be powerless to alter the flow fo computation if the
predicate were not  true,  since  the  break  would  not  be  reached.
However,  by  breaking (AROUND (EQUAL X Y)), he can evaluate the break
expression, i.e., (EQUAL X Y), see its value  and  evaluate  something
else if he wished.

The  message  typed for a BREAKIN break identifies the location of the
break as well as the function, e.g.,

    ((FOO (AFTER COND 2 1)) BROKEN).

BREAKIN is an FEXPR which has a maximum of four arguments.  The  first
argument  is  the  function to be broken in.  The second argument is a
list of editor commands, preceded by BEFORE, AFTER, or  AROUND,  which
specifies  the  location  inside  the  function at which to break.  If
there is no second argument, a value  of  (BEFORE  TTY:)  is  assumed.
(See  earlier  discussion.)    The  third and fourth arguments are the
break condition and the list of commands to be  performed  before  the
interactive   break   occurs,   (BRKWHEN   and   BRKCOMS  for  BREAK1)
respectively.  If there is no third argument, a value of T is  assumed
for  BRKWHEN  which  causes  a  break  each  time the BREAKIN break is
executed.  If the fourth argument  is  missing,  a  value  of  NIL  is
assumed.  For example,

    (BREAKIN FOO (AROUND COND))

inserts a break around the first call to COND in FOO.

It  is possible to insert multiple break points, with a single call to
BREAKIN by using a list of the form ((BEFORE ...) ...   (AROUND  ...))
as  the  second  argument.    It  is also possible to BREAK or TRACE a
function which has been modified by BREAKIN, and conversely to BREAKIN
a function which is broken or  traced.    UNBREAK  restores  functions
which have been broken in.
                                                                   113


    Examples:
        (BREAKIN FOO (AROUND TTY:) T (?= M N) ((*PLUS X Y)))
        (BREAKIN FOO2 (BEFORE SETQ) (EQ X Y))



21.5.5. UNBREAK


UNBREAK  is  an FEXPR.  It takes a list of functions modified by BREAK
or BREAKIN and restores them to their original state.  It's  value  is
the list of functions that were "unbroken".

(UNBREAK T) will unbreak the function most recently broken.

(UNBREAK) will unbreak all of the functions currently broken (i.e. all
those on BROKENFNS).

If  one of the functions is not broken, UNBREAK has a value of (fn NOT
BROKEN) for that function and no changes are made to fn.

Note:  If a function is both traced and broken in, either  UNTRACE  or
UNBREAK will restore the original function definition.



21.5.6. UNTRACE


UNTRACE  is  an FEXPR.  It takes a list of functions modified by TRACE
and restores them to their original state.  It's value is the list  of
functions that were "untraced".

(UNTRACE T) will unbreak the function most recently traced.

(UNTRACE) will untrace all of the functions currently traced (i.e. all
those on TRACEDFNS).

If  one of the functions is not traced, UNTRACE has a value of (fn NOT
BROKEN) for that function and no changes are made to fn.



21.5.7. BREAK0 [FN WHEN COMS]


BREAK0 is an EXPR.   It  sets  up  a  break  on  the  function  FN  by
redefining FN as a call to BREAK1 with BRKEXP a form equivalent to the
definition  of  FN,  and  WHEN,  FN  and  COMS  as BRKWHEN, BRKFN, and
BRKCOMS, respectively (see BREAK1).  BREAK0 also adds FN to the  front
of the list BROKENFNS.  It's value is FN.

If FN is non-atomic and of the form (fn1 IN fn2), BREAK0 first calls a
function  which  changes the name of fn1 wherever it appears inside of
fn2 to that of a new function, fn1-IN-fn2, which is initially  defined
                                                                   114


as  fn1.    Then  BREAK0  proceeds  to  break on fn1-IN-fn2 exactly as
described above.  This procedure is useful for breaking on a  function
that  is  called from many places, but where one is only interested in
the call from a specific function, e.g. (RPLACA  IN  FOO),  (PRINT  IN
FIE),  etc.   This only works in interpreted functions.  If fn1 is not
found in fn2, BREAK0 returns the value (fn1 NOT FOUND IN fn2).

If FN is non-atomic and not of the above form, BREAK0  is  called  for
each member of FN using the same values for WHEN and COMS specified in
this  call to BREAK0.  This distributivity permits the user to specify
complicated break conditions without excessive retyping, e.g.,

    (BREAK0 (QUOTE (FOO1 ((PRINT PRIN1)IN (FOO2 FOO3))))
            (QUOTE (EQ X T))
            (QUOTE ((EVAL) (?= Y Z) OK)))

will break on FOO1, PRINT-IN-FOO2, PRINT-IN-FOO3,  PRIN1-IN-FOO2,  and
PRIN1-IN-FOO3.

If  FN  is non-atomic, the value of BREAK0 is a list of the individual
values.

For example, BREAK0 can be used to trace the  changing  of  particular
values by SETQ in the following manner:

    *(SETQ VARLIST (QUOTE (X Y FOO)))
    *(BREAK0 (QUOTE SETQ) (QUOTE (MEMQ (CAR XXXX) VARLIST))
    *        (QUOTE ((TRACE) (?=)(UNTRACE))))
    (SETQ ARGMENTS?)*(XXXX)

SETQ will be traced whenever CAR of its argument (SETQ is an FSUBR) is
a member of VARLIST.  (*** See in addition the new function TRACEV.)



21.6. ERROR PACKAGE



21.6.1. Introduction


When  an  error  occurs  during  the  evaluation of a LISP expression,
control is turned over to the Error Package.  The I/O is forced to the
TTY (channel NIL) but will be restored to its previous channels if the
user continues the evaluation.  The idea behind the error  package  is
that  it  may  be  possible  to 'patch up' the form in which the error
occurred and continue.  Or, at least, that you can find the  cause  of
the error more easily if you can examine the state of the world at the
time  of  the  error.   Basically, what the Error Package does is call
BREAK1 with BRKEXP set to the form in which the error occurred.   This
puts  the  user  'in  a  break'  around  the  form  in which the error
occurred.  BREAK1 acts just like the top level of the interpreter with
some added commands (see section on BREAK1).  The main difference when
you are in the Error Package is that the variable bindings  that  were
                                                                   115


in  effect  when the error occurred are still in effect.  Furthermore,
the expressions that were in  the  process  of  evaluation  are  still
pending.    While  in  the Error Package, variables may be examined or
changed, and functions may be defined or edited just as if you were at
the top level.  In addition, there are several ways in which  you  can
abort  or continue from the point of error.  In particular, if you can
patch up the error, you can continue by typing OK.  If you can't patch
the error, ^ will get you out of the break.  When you are in the error
package, the prompt character is  ':'  and  is  preceded  by  a  level
number.    Note:  if you don't want the error package invoked for some
reason, it can be turned off by evaluating (*RSET  NIL).    Similarly,
(*RSET T) will turn the error package back on.



21.6.2. Commands


There  are  several  atoms which will cause special actions when typed
into BREAK1 (the  error  package).    These  actions  are  useful  for
examining  the  push down stack (e.g.  backtraces), changing forms and
exiting from the break in various ways.  Table I (on  the  next  page)
gives  a  summary of the actions.  For a complete description, see the
section on 'What You Can Do In A Break'.
                                                                   116


              Table 21-1:  Break Package Command Summary

              (for complete description see pp. 103-109)



      Command         Action

      GO              Evaluates BRKEXP, prints its value,
                      and continues with this value

      OK              Same as GO but no print of value

      EVAL            Reevaluate BRKEXP and print its value.
                      Its value is bound to !VALUE

      RETURN xx       Evaluate xx and continue with its value

      ^               Escape one level of BREAK1

      ^^              Escape to the top level

      > [->] expr     After an error, use expr for the erring atom

      FROM?=  form    Continues by re-evaluating form at LASTPOS

      EX              Same as FROM?= NIL

      USE x FOR y     Substitutes x for y in form at LASTPOS
                      (destructively)

      F [&] a1..aN    Resets LASTPOS (stack context)

      EDIT A1..An     Resets LASTPOS and gives the form at LASTPOS
                      to the LISP Editor

      ?= f1 ... fN    Evaluates forms fI as of LASTPOS

      ARGS            Prints arguments of the broken function

      BKF             Backtrace Function Names

      BKE             Backtrace Function Calls

      BK              Backtrace Expressions


      Note:  All of the backtrace commands can be combined with a
      'V'  or followed  by  an  integer.   The 'V' will cause the
      values of variables to be printed.   The integer will limit
      the  trace to  that number of blocks.   For example,  BK 3,
      BKEV, BKFV 5 and BKEV are all legitimate commands.
                                                                   117


                         22. The LISP Editor



22.1. Contents


    118 CURRENT EXPRESSION, P, &, PP, EDIT CHAIN, 0, ^,
    120 (n), (n e1, ..., em), (-n e1, ..., em), N, F, R, NX, RI,
    123 UNDO, BK, BF, <, <P, &, --, @ (AT-SIGN),
    125 UP, B, A, :, DELETE, MBD, XTR, UP, ..., n, -n,
    128 0, !0, ^, NX, BK, (NX n), (BK n), !NX, (NTH n),
    130 PATTERN MATCH, &, *ANY*, --, ==, ...,
    132 SEARCH ALGORITHM, MAXLEVEL, UNFIND, F, (F pat n),
    133 (F pat T), (F pat N), (F pat), FS, F=, ORF, BF, (BF pat T),
    135 LOCATION SPECIFICATION, IF, $$, $, LC, LCL, SECOND, THIRD,
    136 (_ pat), BELOW, NEX, (NTH $), .., MARK, _, __, <, UNFIND,
    139 <P, S, (n), (n e1, ..., em), (-n e1, ..., em), N,
    142 B, A, :, DELETE, INSERT, REPLACE, DELETE, $$, UPFINDFLG,
    145 XTR, EXTRACT, MBD, EMBED, MOVE, BI, BO, LI, LO, RI, RO,
    151 THRU, TO, R, SW, P, ?, E, I, $$, COMS, COMSQ,
    157 IF, LP, LPQ, ORR, MACROS, M, BIND, USERMACROS,
    160 NIL, TTY:, OK, STOP, SAVE, REPACK, MAKEFN,
    163 UNDO, TEST, ??, !UNDO, UNBLOCK, EDITDEFAULT, EDITL,
    166 EDITF, EDITE, EDITV, EDITP, EDITFNS, EDIT4E,
    168 EDITFPAT, EDITFINDP

The   LISP  editor  allows  rapid,  convenient  modification  of  list
structures.  Most often it  is  used  to  edit  function  definitions,
(often  while  the function itself is running) via the function EDITF,
e.g., (EDITF FOO).  However, the editor can also be used to  edit  the
value of a variable, via EDITV, to edit special properties of an atom,
via  EDITP,  or  to edit an arbitrary expression, via EDITE.  It is an
important feature which allows good on-line  interaction  in  the  UCI
LISP system.

This  chapter  begins with a lengthy introduction intended for the new
user.  The reference portion begins on page 126.



22.2. Introduction


Let us introduce some of the basic editor commands, and give a  flavor
for  the  editor's  language structure by guiding the reader through a
hypothetical editing session.  Suppose we are  editing  the  following
incorrect definition of APPEND

    (LAMBDA(X)
     Y
     (COND ((NUL X) Z)
           (T (CONS (CAR) (APPEND (CDR X Y))))))

We call the editor via the function EDITF:
                                                                   118


    *(EDITF APPEND)
    EDIT:
    #

The  editor  responds  by  typing  EDIT:  followed  by #, which is the
editor's ready character, i.e., it signifies that the editor is  ready
to  accept commands.  (In other words, all lines beginning with # were
typed by the user, the rest by the editor.)

At any given moment,  the  editor's  attention  is  centered  on  some
substructure  of  the  expression  being edited.  This substructure is
called the current expression, and it is what the user  sees  when  he
gives  the  editor  the  command P, for print.  Initially, the current
expression is the top level one, i.e.,  the  entire  expression  being
edited.  Thus:

    #P
    (LAMBDA (X) Y (COND & &))
    #

Note that the editor prints the current expression, using PRINTLEV, to
a  depth  of  2,  i.e.,  sublists  of  sublists are printed as &.  The
command ?  Will print the current expression as  though  PRINTLEV  was
given a depth of 100.

    #?
    (LAMBDA (X) Y (COND ((NUL X) Z) (T (CONS (CAR) (APPEND (CDR
    X Y))))))
    #

and the command PP will prettyprint the current expression.

A  positive  integer  is  interpreted  by  the  editor as a command to
descend into the  correspondingly  numbered  element  of  the  current
expression.  Thus:

    #2
    #P
    (X)
    #

A  negative integer has a similar effect, but counting begins from the
end of the current expression and proceeds backward, i.e.,  -1  refers
to  the  last element in the expression, -2 the next to the last, etc.
For either positive integer or negative integer, if there is  no  such
element,  an  error occurs.  'Editor errors' are not the same as 'LISP
errors' , i.e., they never cause breaks or even go through  the  error
machinery  but are direct calls to ERR indicating that a command is in
some way faulty.  What happens next depends on the  context  in  which
the  command  was  being executed.  For example, there are conditional
commands which branch on errors.  In most situations, though, an error
will cause the editor to type the faulty command followed by a ?   And
wait  for  more  input.    In  this  case, the editor types the faulty
command followed by a ?, and then another #. The current expression is
never changed when a command causes an error. thus:
                                                                   119


    #P
    (x)
    #2
    2  ?
    #1
    #P
    X
    #

A  phrase  of  the  form  'the  current expression is changed' or 'the
current  expression  becomes'  refers  to  a  shift  in  the  editor's
ATTENTION, not to a modification of the structure being edited.

When  the  user  changes the current expression by descending into it,
the old current expression is not lost.  Instead, the editor  actually
operates  by maintaining a chain of expressions leading to the current
one.  The current expression is simply the last  link  in  the  chain.
Descending adds the indicated subexpression onto the end of the chain,
thereby making it be the current expression.  The command 0 is used to
ascend  the  chain;  it  removes  the  last link of the chain, thereby
making the previous link be the current expression.  Thus:

    #P
    X
    #0 P
    (X)
    #0-1 P
    (COND (& Z) (T &))
    #

Note the use of several commands on a  single  line  in  the  previous
output.  The editor operates in a line buffered mode.  Thus no command
is  actually  seen  by  the  editor,  or  executed  until  the line is
terminated, either by a carriage return, or an escape (alt-mode).

In our editing session, we will  make  the  following  corrections  to
APPEND:  delete  Y  from  where  it  appears,  add Y to the end of the
argument list, (These two  operations  could  be  thought  of  as  one
operation,  i.e.,  move Y from its current position to a new position,
and in fact there is a MOVE command in the editor.  However,  for  the
purposes  of  this  introduction,  we  will  confine  ourselves to the
simpler edit commands.)  change NUL to NULL, change  Z  to  Y,  add  X
after CAR, and insert a right parenthesis following CDR X. 

First  we  will delete Y. By now we have forgotten where we are in the
function definition, but we want to be at the "top,"  so  we  use  the
command  ^,  which  ascends through the entire chain of expressions to
the top level expression, which then becomes the  current  expression,
i.e., ^ removes all links except the first one.

    #^ P
    (LAMBDA (X) Y (COND & &))
    #

Note that if we are already at the top, ^ has no effect, i.e., it is a
                                                                   120


NOP.  However, 0 would generate an error.  In other words, ^ means "go
to the top," while 0 means "ascend one link."

The basic structure modification commands in the editor are

          (n)
                    n>1  deletes  the  corresponding  element from the
                    current expression.

          (n e1,...,em)
                    n,m>1 replaces the  nth  element  in  the  current
                    expression with e1,...,em.

          (-n e1,...,em)
                    n,m>1  inserts e1,...,em before the nth element in
                    the current expression.

Thus:

    #P
    (LAMBDA (X) Y (COND & &))
    #(3)
    #(2 (X Y))
    #P
    (LAMBDA (X Y) (COND & &))
    #

All structure modification done by the editor  is  destructive,  i.e.,
the  editor  uses RPLACA and RPLACD to physically change the structure
it was given.  Note that all three of the above commands perform their
operation with respect to the  nth  element  from  the  front  of  the
current  expression;  the  sign  of  n  is used to specify whether the
operation is replacement or insertion.   Thus,  there  is  no  way  to
specify deletion or replacement of the nth element from the end of the
current  expression,  or insertion before the nth element from the end
without counting out that element's position from  the  front  of  the
list.    Similarly,  because  we  cannot  specify  insertion  after  a
particular element, we cannot attach  something  at  the  end  of  the
current  expression  using  the  above  commands.  Instead, we use the
command N (for NCONC).  Thus we could have performed the above changes
instead by:

    #P
    (LAMBDA (X) Y (COND & &))
    #(3)
    #2 (N Y)
    #P
    (X Y)
    #^ P
    #(LAMBDA (X Y) (COND & &))
    #

Now we are ready to change NUL to  NULL.    Rather  than  specify  the
sequence of descent commands necessary to reach NULL, and then replace
it  with  NULL, i.e., 3 2 1 (1 NULL), we will use F, the find command,
                                                                   121


to find NULL:

    #P
    (LAMBDA (X Y) (COND & &))
    #F NUL
    #P
    (NUL X)
    #(1 NULL)
    #0 P
    ((NULL X) Z)
    #

Note that F is special in that it corresponds to TWO inputs.  In other
words, F says to the editor, "treat your next command as an expression
to  be  searched  for." The search is carried out in printout order in
the current expression.  If the target expression is not found  there,
F  automatically  ascends  and  searches  those portions of the higher
expressions that would  appear  after  (in  a  printout)  the  current
expression.    If the search is successful, the new current expression
will be the structure where the expression was found, (If  the  search
is  for  an  atom,  e.g.,  F  NUL,  the current expression will be the
structure containing the atom.  If the search is for a list,  e.g.,  F
(NUL  X),  the  current  expression will be the list itself.)  and the
chain will be the same as one resulting from the appropriate  sequence
of  ascent  and descent commands.  If the search is not successful, an
error occurs, and neither the current  expression  nor  the  chain  is
changed:    (F  is  never  a  NOP,  i.e.,  if  successful, the current
expression after the search will never be  the  same  as  the  current
expression   before   the  search.    Thus  F  EXPR  repeated  without
intervening commands that change the edit chain can be  used  to  find
successive instances of EXPR.)

    #P
    ((NULL X) Z)
    #F COND P

    COND  ?
    #P
    #((NULL X) Z)
    #

Here   the  search  failed  to  find  a  COND  following  the  current
expression, although of course a  COND  does  appear  earlier  in  the
structure.    This last example illustrates another facet of the error
recovery mechanism:  to avoid further confusion when an error  occurs,
all  commands  on  the line beyond the one which caused the error (and
all commands that may have been  typed  ahead  while  the  editor  was
computing) are forgotten.

We  could  also have used the R command (for Replace) to change NUL to
NULL.  A command of the form (R e1 e2) will replace all occurrances of
e1 in the current expression by e2.  There must be at least  one  such
occurrence  or the R command will generate an error.  Let us use the R
command to change all Z's (even though there is only one) in APPEND to
Y:
                                                                   122


    #^ (R Z Y)
    #F Z

    Z  ?
    #PP
    (LAMBDA(X Y)
     (COND ((NULL X) Y)
           (T (CONS (CAR) (APPEND (CDR X Y))))))
    #

The  next  task is to change (CAR) to (CAR X).  We could do this by (R
(CAR) (CAR X)), or by:

    #F CAR
    #(N X)
    #P
    (CAR X)
    #

The expression we now want to change is the next expression after  the
current expression, i.e., we are currently looking at (CAR X) in (CONS
(CAR X) (APPEND (CDR X Y))).  We could get to the APPEND expression by
typing  0  and  then 3 or -1, or we can use the command NX, which does
both operations:

    #P
    (CAR X)
    #NX P
    (APPEND (CDR X Y))
    #

Finally, to change (APPEND (CDR X Y)) to (APPEND (CDR X) Y), we  could
perform  (2  (CDR  X)  Y),  or  (2  (CDR  X)) and (N Y), or 2 and (3),
deleting the Y, and then 0 (N Y).    However,  if  Y  were  a  complex
expression  we would not want to have to retype it.  Instead, we could
use a command which effectively inserts and/or removes left and  right
parentheses.    There are six of these BI, BO, LI, LO, RI, and RO, for
Both In, Both Out, Left In, Left Out, Right In, and  Right  Out.    Of
course,  we  will  always  have the same number of left parentheses as
right parentheses, because the parentheses are just a notational guide
to structure that is provided by our print program.  (Herein lies  one
of  the  principal  advantages  of  a LISP oriented editor over a text
editor:  unbalanced parentheses errors are not possible.)  Thus,  left
in, left out, right in, and right out actually do not insert or remove
just  one  parenthesis,  but  this is very suggestive of what actually
happens.

In this case, we would like a right parenthesis to appear following  X
in  (CDR  X  Y).   Therefore, we use the command (RI 2 2), which means
insert a right parentheses after the  second  element  in  the  second
element (of the current expression):
                                                                   123


    #P
    (APPEND (CDR X Y))
    #(RI 2 2)
    #P
    (APPEND (CDR X) Y)
    #

We  have  now  finished  our editing, and can exit from the editor, to
test APPEND, or we could test it while still inside of the editor,  by
using the E command:

    #E (APPEND (QUOTE (A B)) (QUOTE (C D E)))
    (A B C D E)

The E command causes the next input to be given to EVAL.

We prettyprint APPEND, and leave the editor.

    #PP
    (LAMBDA(X Y)
     (COND ((NULL X) Y)
           (T (CONS (CAR X) (APPEND (CDR X) Y)))))
    #OK
    APPEND
    *



22.3. Commands for the New User


This  manual  is  intended  primarily  as  a reference manual, and the
remainder of this chapter  is  organized  and  presented  accordingly.
While  the  commands  introduced in the previous scenario constitute a
complete set, i.e.,  the  user  could  perform  any  and  all  editing
operations  using  just  those  commands, there are many situations in
which knowing the right command(s)  can  save  the  user  considerable
effort.    We include here as part of the introduction a list of those
commands which are not only frequently applicable  but  also  easy  to
use.    They  are  not  presented in any particular order, and are all
discussed in detail in the reference portion of the chapter.

          UNDO
                    Undoes the  last  modification  to  the  structure
                    being  edited, e.g., if the user deletes the wrong
                    element, UNDO will restore it.   The  availability
                    of   UNDO  should  give  the  user  confidence  to
                    experiment with any and all editing  commands,  no
                    matter  how complex, because he can always reverse
                    the effect of the command.

          BK
                    Like NX, except makes the  expression  immediately
                    before the current expression become current.
                                                                   124


          BF
                    Backwards   Find.      Like   F,  except  searches
                    backwards, i.e., in inverse print order.

          <
                    Restores the current expression to the  expression
                    before  the last "big jump", e.g., a find command,
                    an ^, or another <.   For  example,  if  the  user
                    types  F  COND,  and  then F CAR, < would take him
                    back to the COND.  Another < would take  him  back
                    to the CAR.

          <P
                    Like  <  except  it restores the edit chain to its
                    state as of the last print, either by P, ?, or PP.
                    If the edit chain has not been changed  since  the
                    last  print, <P restores it to its state as of the
                    printing before that one,  i.e.,  two  chains  are
                    always saved.

Thus if the user types P followed by 3 2 1 P, <P will take him back to
the  first  P,  i.e.,  would be equivalent to 0 0 0.  Another <P would
then take him back to the second P, i.e., he can use <P to  flip  back
and forth between two current expressions.

          &,--
                    The search expression given to the F or BF command
                    need  not  be a literal S-expression.  Instead, it
                    can be a pattern.    The  symbol  &  can  be  used
                    anywhere  within  this  pattern  to match with any
                    single element of a list, and -- can  be  used  to
                    match  with  any  segment of a list.  Thus, in the
                    incorrect definition of  APPEND  used  earlier,  F
                    (NUL  &) could have been used to find (NUL X), and
                    F (CDR --) or F (CDR & &), but not F (CDR  &),  to
                    find (CDR X Y).

Note  that  &  and -- can be nested arbitrarily deeply in the pattern.
For example, if there are many places where the varaible X is  set,  F
SETQ may not find the desired expression, nor may F (SETQ X &). It may
be necessary to use F (SETQ X (LIST --)). However, the usual technique
in  such a case is to pick out a unique atom which occurs prior to the
desired expression and perform two  F  commands.    This  "homing  in"
process  seems  to be more convenient than ultra-precise specification
of the pattern.

          @ (at-sign)
                    Any atom ending in @ (at-sign) in a  pattern  will
                    match  with the first atom or string that contains
                    the same  initial  characters.    For  example,  F
                    VER@  will  find  VERYLONGATOM.  @  can  be nested
                    inside of the pattern, e.g., F (SETQ VER@ (CONS --
                    )).  If the search is successful, the editor  will
                    print  =  followed  by the atom which matched with
                    the @-atom, e.g.,
                                                                   125


                        #F (SETQ VER@ &)
                        =VERYLONGATOM
                        #

Frequently the user will want to replace the entire current expression
or insert something before it.  In order to do this using a command of
the  form  (n e1,...,em) or (-n e1,...,em), the user must be above the
current expression.  In other words, he would  have  to  perform  a  0
followed by a command with the appropriate number.  However, if he has
reached  the current expression via an F command, he may not know what
that number is.  In this case, the user would  like  a  command  whose
effect  would  be  to  modify  the  edit  chain  so  that  the current
expression  became  the  first  element  in  a  new,  higher   current
expression.    Then  he  could  perform  the  desired operation via (1
e1,...,em) or (-1 e1,...,em).  UP is provided for this purpose.

          UP
                    After UP operates, the old current  expression  is
                    the  first  element of the new current expression.
                    Note that if the current expression happens to  be
                    the  first  element in the next higher expression,
                    then UP is exactly the same as 0.   Otherwise,  UP
                    modifies  the  edit  chain so that the new current
                    expression is  a  tail  (Throughout  this  chapter
                    'tail'  means  'proper  tail')  of the next higher
                    expression:

                        #F APPEND
                        (APPEND (CDR X) Y)
                        #UP P
                        ... (APPEND & Y))
                        #0 P
                        (CONS (CAR X) (APPEND & Y))
                        #

                    The ...  is used by the editor  to  indicate  that
                    the  current  expression  is  a  tail  of the next
                    higher expression as opposed to being  an  element
                    (i.e.,  a  member)  of the next higher expression.
                    Note:  if the  current  expression  is  already  a
                    tail, UP has no effect.

          (B e1,...,em)
                    Inserts  e1,...,em  before the current expression,
                    i.e., does an UP and then a -1.

          (A e1,...,em)
                    Inserts e1,...,em after  the  current  expression,
                    i.e.,  does an UP and then either a (-2 e1,...,em)
                    or an (N e1,...,em), if the current expression  is
                    the last one in the next higher expression.

          (: e1,...,em)
                    Replaces  current  expression  by e1,...,em, i.e.,
                    does an UP and then a (1 e1,...,em).
                                                                   126


          DELETE
                    Deletes  current  expression,  i.e., equivalent to
                    (:).

Earlier, we introduced the RI command in the APPEND example.  The rest
of the commands in this family:, BI,  RO,  LI,  LO,  and  RO,  perform
similar  functions and are useful in certain situations.  In addition,
the commands MBD and XTR can be used to combine the effects of several
commands of the BI-BO family.   MBD  is  used  to  embed  the  current
expression  in  a  larger  expression.    For  example, if the current
expression is (PRINT bigexpression), and the user wants to replace  it
by  (COND  (FLG  (PRINT bigexpression))), he can acomplish this by (LI
1), (-1 FLG), (LI 1), and (-1 COND), or by a single MBD command.

XTR is used to extract an expression from the current expression.  For
example, extracting the PRINT expression from the above COND could  be
accomplished  by  (1),  (LO 1), and (LO 1) or by a single XTR command.
The new user is encouraged to include XTR and MBD in his repertoire as
soon as he is familiar with the more basic commands.



22.4. Attention Changing Commands


Commands to the editor fall into three classes:  commands that  change
the current expression (i.e., change the edit chain) thereby "shifting
the  editor's  attention,"    commands that modify the structure being
edited, and miscellaneous commands, e.g.,  exiting  from  the  editor,
printing, evaluating expressions.

Within  the  context of commands that shift the editor's attention, we
can distinguish among (1) those commands whose operation depends  only
on  the  structure of the edit chain, e.g., 0, UP, NX; (2) those which
depend on the contents of the structure, i.e., commands  that  search;
and  (3)  those  commands  which simply restore the edit chain to some
previous state, e.g., <, <P.  (1) and (2) can also be  thought  of  as
local, small steps versus open ended, big jumps.  Commands of type (1)
are  discussed on pp.  126-130; type (2) on pp.  130-138; and type (3)
on pp.  138-139.



22.5. Local Attention-Changing Commands


          UP
                    (1) If a P command would cause the editor to  type
                    ...    before typing the current expression, i.e.,
                    the current expression  is  a  tail  of  the  next
                    higher expression, UP has no effect; otherwise

                    (2)  UP  modifies  the  edit chain so that the old
                    current expression (i.e., the one at the  time  UP
                    was  called)  is  the  first  element  in  the new
                                                                   127


                    current expression.  (If the current expression is
                    the first element in the next higher expression UP
                    simply   does   a   0.    Otherwise  UP  adds  the
                    corresponding tail to the edit chain.

Examples:  The current expression in each  case  is  (COND  ((NULL  X)
(RETURN Y))).

    1.      #1 P
            COND
            #UP P
            (COND (& &))

    2.      #-1 P
            ((NULL X) (RETURN Y))
            #UP P
            ... ((NULL X) (RETURN Y)))
            #UP P
             ... ((NULL X) (RETURN Y)))


    3.      #F NULL P
            (NULL X)
            #UP P
            ((NULL X) (RETURN Y))
            #UP P
            ... ((NULL X) (RETURN Y)))

The  execution  of  UP is straightforward, except in those cases where
the current expression appears more  than  once  in  the  next  higher
expression.   For example, if the current expression is (A NIL B NIL C
NIL) and the user performs 4 followed by UP,  the  current  expression
should  then  be  ...  NIL C NIL.)  UP can determine which tail is the
correct one because the commands that descend save the last tail on an
internal editor variable, LASTAIL.    Thus  after  the  4  command  is
executed,  LASTAIL  is  (NIL  C  NIL).    When  UP is called, it first
determines if the current expression is a  tail  of  the  next  higher
expression.    If it is, UP is finished.  Otherwise, UP computes (MEMB
current-expression next-higher-expression) to obtain a tail  beginning
with the current expression.  (The current expression should always be
either  a  tail or an element of the next higher expression.  If it is
neither,  for  example  the  user  has  directly   (and   incorrectly)
manipulated  the  edit chain, UP generates an error.)  If there are no
other  instances  of  the  current-expression  in  the   next   higher
expression,  this  tail is the correct one.  Otherwise UP uses LASTAIL
to select the correct tail.  (Occasionally the user can get  the  edit
chain  into  a  state  where LASTAIL cannot resolve the ambiguity, for
example if there were two non-atomic structures in the same expression
that were EQ, and the user descended more than one level into  one  of
them  and  then  tried  to  come  back out using UP.  In this case, UP
selects the first tail and prints LOCATION UNCERTAIN to warn the user.
Of course, we  could  have  solved  this  problem  completely  in  our
implementation  by  saving  at  each  descent both elements and tails.
However, this would be a costly solution to a  situation  that  arises
infrequently,  and  when  it  does,  has  no detrimental effects.  The
                                                                   128


LASTAIL solution is cheap and resolves 99% of the ambiguities.

          n (n>0)
                    Adds  the nth element of the current expression to
                    the front of the edit chain, thereby making it  be
                    the  new current expression.  Sets LASTAIL for use
                    by  UP.    Generates  an  error  if  the   current
                    expression  is not a list that contains at least n
                    elements.

          -n (n>0)
                    Adds the nth element from the end of  the  current
                    expression to the front of the edit chain, thereby
                    making  it  be  the  new current expression.  Sets
                    LASTAIL for use by UP.  Generates an error if  the
                    current  expression is not a list that contains at
                    least n elements.

          0 
                    Sets edit chain to  CDR  of  edit  chain,  thereby
                    making  the  next  higher  expression  be  the new
                    current expression.  Generates an error  if  there
                    is  no  higher expression, i.e., CDR of edit chain
                    is NIL.

Note that 0 usually corresponds to going back to the next higher  left
parenthesis,  but  not always.  For example, if the current expression
is (A B C D E F G), and the user performs

    # UP P
    ... C D E F G)
    #3 UP P
    ... E F G)
    #0 P
    ... C D E F G)

If the intention is to go back to the next  higher  left  parenthesis,
regardless  of any intervening tails, the command !0 can be used.  (!0
is pronounced bang-zero.)

          !0
                    Does repeated 0's until it reaches a  point  where
                    the  current  expression is not a tail of the next
                    higher expression, i.e., always goes back  to  the
                    next higher left parenthesis.

          ^ 
                    Sets  edit  chain  to  LAST of edit chain, thereby
                    making the top level  expression  be  the  current
                    expression.  Never generates an error.

          NX
                    Effectively  does  an UP followed by a 2, (Both NX
                    and BK operate by performing a !0 followed  by  an
                    appropriate  number, i.e.  There won't be an extra
                                                                   129


                    tail  above  the  new current expression, as there
                    would be  if  NX  operated  by  performing  an  UP
                    followed  by  a  2.)    thereby making the current
                    expression be the next expression.   Generates  an
                    error if the current expression is the last one in
                    a list.  (However, !NX described below will handle
                    this case.)

          BK
                    Makes  the  current  expression  be  the  previous
                    expression  in   the   next   higher   expression.
                    Generates  an  error  if the current expression is
                    the first expression in a list.

For example, if the current expression is (COND ((NULL X) (RETURN Y)))

    # RETURN P
    (RETURN Y)
    #BK P
    (NULL X)

          (NX n) n>0
                    Equivalent to n NX commands, except  if  an  error
                    occurs, the edit chain is not changed.

          (BK n) n>0
                    Equivalent  to  n  BK commands, except if an error
                    occurs, the edit chain is not changed.

Note: (NX -n) is equivalent to (BK n), and vice versa.

          !NX
                    Makes current expression be the next expression at
                    a higher level, i.e., goes through any  number  of
                    right parentheses to get to the next expression.

    For example:

    #PP
    (PROG (UF)
          (SETQ UF L)
     LP   (COND ((NULL (SETQ L (CDR L))) (ERR NIL))
                ((NULL (CDR (MEMQ# (CAR L) (CADR L))))
                 (GO LP)))
          (EDITCOM (QUOTE NX))
          (SETQ UNFIND UF)
          (RETURN L))
    #F CDR P
    (CDR L)
    #NX
                                                                   130



    NX  ?
    #!NX P
    (ERR NIL)
    #!NX P
    ((NULL &) (GO LP))
    #!NX P
    (EDITCOM (QUOTE NX))
    #

!NX  operates  by doing 0's until it reaches a stage where the current
expression is not the last expression in the next  higher  expression,
and  then  does  a  NX.    Thus  !NX  always goes through at least one
unmatched right parenthesis, and the new current expression is  always
on  a  different  level,  i.e.,  !NX  and  NX always produce different
results.  For example using the previous current expression:

    #F CAR P
    (CAR L)
    #!NX P
    (GO LP)
    #<P P
    (CAR L)
    #NX P
    (CADR L)
    #

          (NTH n) n>0
                    Equivalent to n followed by UP, i.e., moves to the
                    list starting with the nth element of the  current
                    expression.   ((NTH 1) is a NOP.)  Causes an error
                    if current expression does not  have  at  least  n
                    elements.

A  generalized  form of NTH using location specifications is described
on page 137



22.6. Commands That Search


All of the editor commands that search use the same  pattern  matching
routine.    (This  routine  is  available to the user directly, and is
described later in this chapter in the section on "Editor Functions.")
We will therefore begin our discussion of searching by describing  the
pattern match mechanism.  A pattern PAT matches with X if

   - PAT is EQ to X (or EQSTR if strings).

   - PAT is &.

   - PAT is a number and EQUAL to X. 

   - If  (CAR  pat)  is  the  atom  *ANY*, (CDR pat) is a list of
                                                                   131


     patterns,  and  PAT  matches  X  if  and  only if one of the
     patterns on (CDR pat) matches X. 

   - If PAT is a literal atom or string, and (NTHCHAR pat -1)  is
     @,  then  PAT  matches with any literal atom or string which
     has the same initial characters as PAT, e.g.   VER@  matches
     with VERYLONGATOM, as well as "VERYLONGSTRING".

   - If (CAR pat) is the atom --, PAT matches X if

        * (CDR pat)=NIL, i.e.  PAT=(--), e.g., (A --) matches (A)
          (A  B  C) and (A .  B) In other words, -- can match any
          tail of a list.

        * (CDR pat) matches with some tail of X, e.g.  (A -- (&))
          will match with (A B C (D)), but not (A B C D), or (A B
          C (D) E).  However, note that (A -- (&) --) will  match
          with  (A B C (D) E).  In other words, -- will match any
          interior segment of a list.

   - If (CAR pat) is the atom ==, PAT matches X if  and  only  if
     (CDR  pat)  is EQ to X. (This pattern is for use by programs
     that call the editor as a subroutine, since  any  non-atomic
     expression in a command type in by the user obviously cannot
     be EQ to existing structure.)

   - Otherwise if X is a list, PAT matches X if (CAR pat) matches
     (CAR x), and (CDR pat) matches (CDR x).

When  searching,  the pattern matching routine is called only to match
with elements in the structure, unless the pattern begins with :::, in
which case CDR  of  the  pattern  is  matched  against  tails  in  the
structure.  (In this case, the tail does not have to be a proper tail,
e.g.   (:::  A --) will match with the element (A B C) as well as with
CDR of (X A B C), since (A B C) is a tail of (A B  C).)  Thus  if  the
current expressiion is (A B C (B C)),

    #F (B --)
    #P
    (B C)
    #0 F (::: B --)
    #P
    ... B C (B C))
    #F (::: B --)
    #P
    (B C)
    #
                                                                   132


22.7. Search Algorithm


Searching  begins  with  the  current expression and proceeds in print
order.  Searching  usually  means  find  the  next  instance  of  this
pattern,  and  consequently  a match is not attempted that would leave
the edit chain unchanged.  (However, there is a version  of  the  find
command which can succeed and leave the current expression unchanged.)
At  each  step, the pattern is matched against the next element in the
expression currently being searched, unless the  pattern  begins  with
:::  in which case it is matched against the corresponding tail of the
expression.    (EQ  pattern  tail-of-expression)=T  also  indicates  a
successful match, so that a search for FOO will find the FOO in (FIE .
FOO).  The only exception to this occurs  when  PATTERN=NIL,  e.g.,  F
NIL.  In this case, the pattern will not match with a null tail (since
most lists end in NIL) but will match with a NIL element.

If  the  match  is  not  successful, the search operation is recursive
first in the CAR direction and then in the CDR direction, i.e., if the
element under examination is a list, the  search  descends  into  that
list  before attempting to match with other elements (or tails) at the
same level.  (There is also a version of the find command  which  only
attempts  matches  at  the  top level of the current expression, i.e.,
does not descend into elements, or ascend to higher expressions.)

However, at no point is the total recursive depth of the  search  (sum
of number of CARs and CDRs descended into) allowed to exceed the value
of  the  variable MAXLEVEL.  At that point, the search of that element
or tail is abandoned, exactly as though the element or tail  had  been
completely  searched without finding a match, and the search continues
with the next element or tail for which the recursive depth  is  below
MAXLEVEL.    This  feature  is  designed  to enable the user to search
circular list structures (by  setting  MAXLEVEL  small),  as  well  as
protecting   him   from  accidentally  encountering  a  circular  list
structure in the course of normal editing.  MAXLEVEL is initially  set
to 300.  If a successful match is not found in the current expression,
the  search  automatically  ascends to the next higher expression, and
continues searching there on the next expression after the  expression
it  just finished searching.  If there is none, it ascends again, etc.
This process continues until the entire edit chain has been  searched,
at  which  point  the search fails, and an error is generated.  If the
search fails the edit  chain  is  not  changed  (nor  are  any  CONSes
performed.)

If  the  search  is  successful, i.e., an expression is found that the
pattern matches, the edit chain is set to the value it would have  had
had  the  user  reached  that  expression  via  a  sequence of integer
commands.

If the expression that matched was a list, it will be the  final  link
in  the  edit  chain,  i.e.,  the  new  current  expression.    If the
expression that matched is not a list, e.g., is an atom,  the  current
expression  will  be  the  tail  beginning with that atom, (Except for
situations where match is with Y in (X .  Y), Y atomic  and  not  NIL.
In  this  case,  the  current expression will be (X .  Y).) i.e., that
                                                                   133


atom  will  be  the  first  element in the new current expression.  In
other words, the search effectively does an UP.  (Unless UPFINDFLG=NIL
(initially set to T).  For discussion, see page 144).



22.8. search commands


All of the commands below set LASTAIL for use by UP,  set  UNFIND  for
use  by  <,  and do not change the edit chain or perform any CONSes if
they are unsuccessful or aborted.

          F pattern
                    i.e. two commands: the F informs the  editor  that
                    the  next  command  is  to  be  interpreted  as  a
                    pattern.  This is the most common and useful  form
                    of  the  FIND  command.    If successful, the edit
                    chain always changes, i.e. F  pattern  means  find
                    the next instance of PATTERN.

                    If  the  pattern  is omitted, the previous F or BF
                    pattern is used.

                    If (MEMB PATTERN CURRENT-EXPRESSION)  is  true,  F
                    does not proceed with a full recursive search.  If
                    the value of the MEMB is NIL, F invokes the search
                    algorithm described earlier.

Thus  if  the  current expression is (PROG NIL LP (COND (-- (GO LP1)))
... LP1 ...), F LP1 will find the PROG label not the LP1 inside of the
GO expression, even though the latter appears first (in  print  order)
in  the  current expression.  Note that 1 (making the atom PROG be the
current expression), followed by F LP1 would find the first LP1.

          FP pattern
                    Same as F pattern, followed by P. 

          (F pattern N)
                    Same as F PATTERN, i.e. Finds the Next instance of
                    PATTERN, except that the MEMB check of  F  PATTERN
                    is not performed.

          (F pattern T)
                    Similar  to  F PATTERN, except may succeed without
                    changing edit chain, and does not perform the MEMB
                    check.

Thus if the current expression is (COND ...), F COND will look for the
next COND, but (F COND T) will "stay here".

          (F pattern n) N >= 1
                    Finds  the  nth  place   that   PATTERN   matches.
                    Equivalent to (F PATTERN T) followed by (F PATTERN
                    N)  repeated  N  -  1  times.    Each time PATTERN
                                                                   134


                    successfully  matches,  N is decremented by 1, and
                    the search continues, until N  reaches  0.    Note
                    that  the  pattern  does  not have to match with N
                    identical expressions; it  just  has  to  match  N
                    times.    Thus  if the current expression is (FOO1
                    FOO2 FOO3), (F FOO@ 3) will find  FOO3.    If  the
                    pattern  does  not  match successfully N times, an
                    error is generated and the edit chain is unchanged
                    (even if the PATTERN matched N - 1 times).

          (F pattern) or

          (F pattern NIL)
                    Only matches with elements at the top level of the
                    current expression,  i.e.,  the  search  will  not
                    descend  into  the current expression, nor will it
                    go outside of the current expression.  May succeed
                    without changing edit chain.

For example, if the current expression is (PROG NIL (SETQ  X  (COND  &
&))  (COND  &)  ...)   F (COND --) will find the COND inside the SETQ,
whereas (F (COND --)) will find the top level COND, i.e.,  the  second
one.

          (FS pattern[1] ...  pattern[n])
                    Equivalent   to   F   pattern[1]   followed  by  F
                    pattern[2] ...  followed by F pattern[n], so  that
                    if F pattern[m] fails, edit chain is left at place
                    pattern[m-1] matched.

          (F= expression x)
                    Equivalent  to  (F  (==  .   expression) x), i.e.,
                    searches for a structure  EQ  to  expression,  see
                    p. 2.22.

          (ORF pattern[1] ...  pattern[n])
                    Equivalent    to    (F   (*ANY*   pattern[1]   ...
                    pattern[n]) N), i.e., searches for  an  expression
                    that  is  matched  by  either  pattern[1]  or  ...
                    pattern[n].  See p. 2.22.

          BF pattern
                    Backwards Find.  Searches in reverse print  order,
                    beginning  with  expression immediately before the
                    current expression (unless the current  expression
                    is  the  top  level  expression,  in which case BF
                    searches the entire expression, in reverse order.)

                    BF uses the same pattern match routine as  F,  and
                    MAXLEVEL  and  UPFINDFLG have the same effect, but
                    the searching begins at the end of each list,  and
                    descends  into  each  element before attempting to
                    match that element.  If unsuccessful,  the  search
                    continues  with  the  next previous element, etc.,
                    until the front of the list is reached,  at  which
                                                                   135


                    point BF ascends and backs up, etc.

For  example,  if  the current expression is (PROG NIL (SETQ X (SETQ Y
(LIST Z))) (COND ((SETQ W --) --)) --) F LIST followed by BF SETQ will
leave the current expression as (SETQ Y (LIST  Z)),  as  will  F  COND
followed by BF SETQ

          (BF pattern T)
                    Search  always  includes current expression, i.e.,
                    starts at end  of  current  expression  and  works
                    backward, then ascends and backs up, etc.

Thus  in  the previous example, where F COND followed by BF SETQ found
(SETQ Y (LIST Z)), F COND followed by (BF SETQ T) would find the (SETQ
W --) expression.

          (BF pattern)

          (BF pattern NIL)
                    pattern.



22.9. Location Specification


Many of the  more  sophisticated  commands  described  later  in  this
chapter  use  a  more  general  method of specifying position called a
LOCATION SPECIFICATION.  A LOCATION SPECIFICATION is a  list  of  edit
commands  that are executed in the normal fashion with two exceptions.
First, all commands not recognized by the editor  are  interpreted  as
though  they  had  been  preceded  by F. (Normally such commands would
cause errors.) For example, the  location  specification  (COND  2  3)
specifies the 3rd element in the first clause of the next COND.  (Note
that  the  user  could  always write (F COND 2 3) for (COND 2 3) if he
were not sure whether or not COND was the name of an atomic command.)

Secondly, if an error occurs while evaluating one of the  commands  in
the location specification, and the edit chain had been changed, i.e.,
was  not  the same as it was at the beginning of that execution of the
location specification, the location  operation  will  continue.    In
other  words,  the  location operation keeps going unless it reaches a
state where it detects that it is 'looping', at which point  it  gives
up.  Thus, if (COND 2 3) is being located, and the first clause of the
next  COND contained only two elements, the execution of the command 3
would cause an error.  The search would then continue by  looking  for
the  next  COND.  However, if a point were reached where there were no
further CONDs, then the first command, COND, would  cause  the  error;
the edit chain would not have been changed, and so the entire location
operation would fail, and cause an error.

The  IF command and the $$ function provide a way of using in location
specifications arbitrary predicates applied to elements in the current
expression.  IF and $$ will  be  described  in  detail  later  in  the
chapter,  along  with  examples  ilustrating  their  use  in  location
                                                                   136


specifications.

Throughout  this  chapter,  the  meta-symbol  $  is  used  to denote a
location specification.  Thus $ is a list of commands  interpreted  as
described  above.    $  Can  also  be  atomic,  in  which  case  it is
interpreted as (LIST $).

          (LC .  $) 
                    Provides a way of explicitly invoking the location
                    operation, e.g.  (LC COND 2 3)  will  perform  the
                    search described above.

          (LCL .  $) 
                    Same  as  LC  except search is confined to current
                    expression, i.e., the edit chain is rebound during
                    the search so it  looks  as  if  the  editor  were
                    called  on  just  the  current  expression.    For
                    example, to find a COND containing a  RETURN,  one
                    might  use  the  location specification (COND (LCL
                    RETURN) <) where the < would reverse  the  effects
                    of  the  LCL  command,  and make the final current
                    expression be the COND.

          (SECOND .  $) 
                    Same as (LC .  $) Followed by another (LC  .    $)
                    Except  that  if  the  first  succeeds  and second
                    fails, no change is made to the edit chain.

          (THIRD .  $) 
                    Similar to second.

          (_ pattern)
                    Ascends the edit chain looking for  a  link  which
                    matches  PATTERN.  in  other words, it keeps doing
                    0's until it  gets  to  a  specified  point.    If
                    PATTERN  is  atomic,  it is matched with the first
                    element of each link, otherwise  with  the  entire
                    link.  (If pattern is of the form (IF expression),
                    EXPRESSION  is  evaluated at each link, and if its
                    value is NIL, or the evaluation causes  an  error,
                    the ascent continues.)

    For example:
       #PP
      (PROG NIL
            (COND ((NULL (SETQ L (CDR L)))
                   (COND (FLG (RETURN L))))
                  ((NULL (CDR (MEMB (CAR L (CADR L)))))
                   (GO LP))))
      #F CADR
      #(_ COND)
      #P
      (COND (& &) (& &))
      #
                                                                   137


Note  that  this  command  differs  from BF in that it does not search
inside of each link, it simply ascends.  Thus in the above example,  F
CADR  followed  by BF COND would find (COND (FLG (RETURN L))), not the
higher COND.

                    If no match is found, an error  is  generated  and
                    the edit chain is unchanged.

          (BELOW com x)
                    Ascends   the   edit  chain  looking  for  a  link
                    specified by COM, and stops x  links  below  that,
                    i.e.    BELOW  keeps  doing 0's until it gets to a
                    specified point, and then backs off N 0's.  (X  is
                    evaluated, e.g., (BELOW com (*PLUS X Y)))

          (BELOW com)
                    Same as (BELOW com 1)

For  example,  (BELOW  COND) will cause the COND clause containing the
current expression to become the new current expression.  Thus if  the
current  expression is as shown above, F CADR followed by (BELOW COND)
will make the new expression be ([NULL (CDR (FMEMB (CAR L) CADR L] (GO
LP)), and is therefore equivalent to 0 0 0 0.

                    BELOW operates by evaluating X and then  executing
                    COM,  or  (_  com) if COM is not a recognized edit
                    command, and measuring  the  length  of  the  edit
                    chain  at that point.  If that length is M and the
                    length of the current edit chain is N, then  BELOW
                    ascends  n-m-y  links  where  Y  is  the  value of
                    X. Generates an error  if  COM  causes  an  error,
                    i.e.,  it  can't find the higher link, or if n-m-y
                    is negative.

The BELOW command is useful for locating a substructure by  specifying
something  it  contains.    For example, suppose the user is editing a
list of lists, and wants to find a sublist that contains a FOO (at any
depth).  He simply executes F FOO (BELOW <).

          (NEX x)
                    Same as (BELOW x) followed by NX.

For example, if the user is deep inside of a SELECTQ  clause,  he  can
advance to the next clause with (NEX SELECTQ).

          NEX
                    Same as (NEX _).

The  atomic  form  of  NEX  is  useful  if the user will be performing
repeated executions of (NEX x).  By simply MARKing  (see  p. 138)  the
chain corresponding to X, he can use NEX to step through the sublists.

          (NTH $)
                    Generalized  NTH  command.    Effectively performs
                    (LCL .  $), Followed by (BELOW <), followed by UP.
                                                                   138


In  other  words,  NTH  locates  $,  using  a search restricted to the
current expression, and then backs up to the current level, where  the
new  current  expression  is  the  tail  whose first element contains,
however deeply, the expression that was the terminus of  the  location
operation.  For example:

    #P
    (PROG (& &) LP (COND & &) (EDITCOM &) (SETQ UNFIND UF)
    (RETURN L))
    #(NTH UF)
    #P
    ... (SETQ UNFIND UF) (RETURN L))
    #

                    If  the  search  is unsuccessful, NTH generates an
                    error and the edit chain is not changed.

Note that (NTH n) is just a special case of (NTH $), and in  fact,  no
special  check  is  made  for  $  a number; both commands are executed
identically.

          (pattern :: .  $) 
                    E.g., (COND ::    RETURN).    Finds  a  COND  that
                    contains a RETURN, at any depth.  Equivalent to (F
                    pattern N), (LCL . $) followed by (_ pattern).

For  example,  if  the current expression is (PROG NIL (COND ((NULL L)
(COND (FLG (RETURN L))))) --), then (COND ::  RETURN) will make  (COND
(FLG  (RETURN  L)))  be  the  current expression.  Note that it is the
innermost  COND  that  is  found,  because  this  is  the  first  COND
encountered  when ascending from the RETURN.  In other words, (pattern
:: $) is not equivalent to (F  pattern  N),  followed  by  (LCL  .  $)
followed by <.

Note  that  $  is  a location specification, not just a pattern.  Thus
(RETURN :: COND 2 3) can be used to find the RETURN which  contains  a
COND whose first clause contains (at least) three elements.  Note also
that  since $ permits any edit command, the user can write commands of
the form (COND ::  (RETURN :: COND)), which will locate the first COND
that contains a RETURN that contains a COND.



22.10. Commands That Save and Restore the Edit Chain


Three facilities are available for saving the current edit  chain  and
later  retrieving  it.  The commands are MARK, which marks the current
chain for future reference, _, (An atomic command; do not confuse with
the list command (_ pattern).) which returns to the last mark  without
destroying  it, and __, which returns to the last mark and also erases
it.

          MARK
                    Adds the current edit chain to the  front  of  the
                                                                   139


                    list MARKLIST.

          _ 
                    Makes  the  new  edit  chain  be  (CAR  MARKLIST).
                    Generates an error if MARKLIST is  NIL,  i.e.,  no
                    MARKS  have  been  performed,  or  all  have  been
                    erased.

          __ 
                    Similar to _  but  also  erases  the  MARK,  i.e.,
                    performs (SETQ MARKLST (CDR MARKLST)).

If  the  user did not prepare in advance for returning to a particular
edit chain, he may still be able to return to that chain with a single
command by using < or <P.

          < 
                    Makes the edit  chain  be  the  value  of  UNFIND.
                    Generates an error if UNFIND=NIL.

UNFIND  is  set to the current edit chain by each command that makes a
"big jump", i.e., a command that usually performs more than  a  single
ascent  or  descent, namely ^, _, __, !NX, all commands that involve a
search, e.g., F, LC, ::,  BELOW,  et  al  and  <  and  <P  themselves.
(Except  that  UNFIND  is not reset when the current edit chain is the
top level expression, since this could always be returned to via the ^
command.)

For example, if the user types F COND, and then F CAR,  <  would  take
him back to the COND.  Another < would take him back to the CAR, etc.

          <P
                    Restores  the  edit  chain  to its state as of the
                    last print operation, i.e., P, ?, or PP.   If  the
                    edit   chain   has  not  changed  since  the  last
                    printing, <P restores it to its state  as  of  the
                    printing  before  that  one,  i.e., two chains are
                    always saved.

For example, if the user types P followed by 3 2 1 P, <P  will  return
to the first P, i.e., would be equivalent to 0 0 0.  (Note that if the
user  had  typed  P followed by F COND, he could use either < or <P to
return to the P, i.e., the  action  of  <  and  <P  are  independent.)
another  <P  would  then take him back to the second P, i.e., the user
could use <P to flip back and forth between the two edit chains.

          (S var .  $) 
                    Sets var (using SETQ) to  the  current  expression
                    after  performing  (LC  .   $).  Edit chain is not
                    changed.

Thus (S FOO) will set FOO to the current expression, (S FOO -1 1) will
set FOO to the first element  in  the  last  element  of  the  current
expression.
                                                                   140


22.11. Commands That Modify Structure


The basic structure modifications commands in the editor are:

          (n)
                    n>1  deletes  the  corresponding  element from the
                    current expression.

          (n e1 ...  em)
                    n,m>1 replaces the  nth  element  in  the  current
                    expression with e1 ...  em.

          (-n e1 ...  em)
                    n,m>1  inserts  e1 ...  em before the n element in
                    the current expression.

          (N e1 ...  em)
                    m>1 attaches e1 ...  em at the end of the  current
                    expression.

As mentioned earlier:

All structure modificaton done by the editor is destructive, i.e., the
editor  uses  RPLACA  and RPLACD to physically change the structure it
was given.

However, all structure modification is undoable, see UNDO p. 163

All of the above commands generate errors if the current expression is
not a list, or in the case of the first three commands,  if  the  list
contains  fewer  than n elements.  In addition, the command (1), i.e.,
delete the first element, will cause an error if  there  is  only  one
element, since deleting the first element must be done by replacing it
with the second element, and then deleting the second element.  Or, to
look  at it another way, deleting the first element when there is only
one element would require changing a list to an atom (i.e.    to  NIL)
which  cannot be done.  (However, the command DELETE will work even if
there is only one element in the current  expression,  since  it  will
ascend to a point where it can do the deletion.)



22.12. Implementation of Structure Modification Commands


Note:    Since  all  commands  that  insert, replace, delete or attach
structure use the same low level editor functions,  the  remarks  made
here are valid for all structure changing commands.

For  all  replacement,  insertion, and attaching at the end of a list,
unless the command was typed in directly to the editor, copies of  the
corresponding  structure are used, because of the possibility that the
exact same command, (i.e.  same list structure) might be  used  again.
(Some  editor commands take as arguments a list of edit commands, e.g.
                                                                   141


(LP  F FOO (1 (CAR FOO))).  In this case, the command (1 (CAR FOO)) is
not considered to have been "typed in"  even  though  the  LP  command
itself  may  have been typed in.  Similarly, commands originating from
macros, or commands given to the editor as arguments to EDITF,  EDITV,
et  al,  e.g.  (EDITF FOO F COND (N --)) are not considered typed in.)
Thus if the program constructs the command (1 (A B  C))  via  (LIST  1
FOO),  and  gives this command to the editor, the (A B C) used for the
replacement will NOT be EQ to FOO.  (The user can circumvent  this  by
using  the I command, which computes the structure to be used.  In the
above example, the form of the command would be (I 1 FOO), which would
replace the first element with the value of FOO itself.  See p. 155.

The rest of this section is  included  for  applications  wherein  the
editor is used to modify a data structure, and pointers into that data
structure  are stored elsewhere.  In these cases, the actual mechanics
of structure modification must be known in order to predict the effect
that various commands  may  have  on  these  outside  pointers.    For
example,  if  the  value of FOO is CDR of the current expression, what
will the commands (2), (3), (2 X Y Z), (-2 X Y Z), etc., do to FOO?

Deletion of the first element in the current expression  is  performed
by  replacing  it  with  the  second  element  and deleting the second
element by patching around it.  Deletion of any other element is  done
by  patching  around  it, i.e., the previous tail is altered.  Thus if
FOO is EQ to the current expression which is (A B C D), and FIE is CDR
of FOO, after executing the command (1), FOO will be (B C D) (which is
EQUAL but not EQ to FIE).  However, under the same initial conditions,
after executing (2) FIE will be unchanged, i.e., FIE will still be  (B
C  D)  even though the current expression and FOO are now (A C D).  (A
general solution of the problem  just  isn't  possible,  as  it  would
require  being  able  to  make  two  lists  EQ to each other that were
originally different.  Thus if FIE is CDR of the  current  expression,
and FUM is CDDR of the current expression, performing(2) would have to
make FIE be EQ to FUM if all subsequent operations were to update both
FIE and FUM correctly.  Think about it.)

Both  replacement  and insertion are accomplished by smashing both CAR
and CDR of the corresponding tail.   Thus,  if  FOO  were  EQ  to  the
current  expression, (A B C D), after (1 X Y Z), FOO would be (X Y Z B
C D).  Similarly, if FOO were EQ to the current expression, (A B C D),
then after (-1 X Y Z), FOO would be (X Y Z A B C D).

The N command is accomplished by smashing the last CDR of the  current
expression  a  la  NCONC.    Thus,  if  FOO were EQ to any tail of the
current expression, after executing an N  command,  the  corresponding
expressions would also appear at the end of FOO.

In  summary,  the  only  situation in which an edit operation will not
change an external pointer occurs when the external pointer  is  to  a
proper  tail  of  the data structure, i.e., to CDR of some node in the
structure, and the operation is deletion.  If  all  external  pointers
are  to  elements  of  the structure, i.e., to CAR of some node, or if
only insertions, replacements, or attachments are performed, the  edit
operation  will  always have the same effect on an external pointer as
it does on the current expression.
                                                                   142


22.13. The A,B,: Commands


In  the (n), (n e1 ...  em), and (-n e1 ...  em) commands, the sign of
the integer is used to indicate the operation.  As a result, there  is
no  direct way to express insertion after a particular element, (hence
the necessity for a separate N command).  Similarly, the  user  cannot
specify  deletion  or replacement of the NTH element from the end of a
list without first converting n to the corresponding positive integer.
Accordingly, we have:

          (B e1 ...  em)
                    Inserts e1 ...  em before the current  expression.
                    Equivalent to UP followed by (-1 e1 ...  em).

For  example,  to  insert  FOO  before the last element in the current
expression, perform -1 and then (B FOO).

          (A e1 ...  em)
                    Inserts e1 ...  em after the  current  expression.
                    Equivalent to UP followed by (-2 e1 ...  em) or (N
                    e1  ...    em)  or  (N  e1  ...   em) whichever is
                    appropriate.

          (:  e1 ...  em)
                    Replaces the current expression by  e1  ...    em.
                    Equivalent to UP followed by (1 e1 ...  em).  

          DELETE or (:)
                    Deletes  the current expression, or if the current
                    expression is a tail, deletes its first element.

DELETE first tries to delete the current expression by  performing  an
UP  and  then  a  (1).    This works in most cases.  However, if after
performing UP, the new current expression contains only  one  element,
the  command  (1)  will  not  work.   Therefore DELETE starts over and
performs a BK, followed by UP, followed by (2).  For example,  if  the
current expression is (COND ((MEMB X Y)) (T Y)), and the user performs
-1, and then DELETE, the BK-UP-(2) method is used, and the new current
expression will be ...  ((MEMB X Y)))

However,  if  the next higher expression contains only one element, BK
will not work.  So in this case, DELETE performs UP,  followed  by  (:
NIL), i.e., it REPLACES the higher expression by NIL.  For example, if
the  current  expression  is  (COND  ((MEMB  X Y)) (T Y)) and the user
performs F MEMB and then DELETE, the new current  expression  will  be
...   NIL (T Y)) and the original expression would now be (COND NIL (T
Y)).  The rationale behind this is  that  deleting  (MEMB  X  Y)  from
((MEMB  X  Y)) changes a list of one element to a list of no elements,
i.e., () or NIL.  Note that 2 followed by DELETE would DELETE ((MEMB X
Y)) NOT replace it by NIL.

If the current expression is a tail, then B,  A,  and  :    will  work
exactly  the  same  as  though  the  current expression were the first
element in that tail.  Thus if the current expression were ...  (PRINT
                                                                   143


Y)  (PRINT Z)), (B (PRINT X)) would insert (PRINT X) before (PRINT Y),
leaving the current expression ...(PRINT X) (PRINT Y) (PRINT Z)).

The following forms of the A, B, and : commands incorporate a location
specification:

          ERT e1 ...  em BEFORE .  $) 
                    Similar to (LC.  $) followed by (B e1 ...  em).

    #P
    (PROG (W Y X) (SELECTQ ATM  & NIL) (OR & &) (PRIN1 &))
    #(INSERT LABEL BEFORE PRIN1)
    #P
    (PROG (W Y X) (SELECTQ ATM & NIL) (OR & &) LABEL (PRIN1 &))
    #

                    Current edit chain is not changed, but  UNFIND  is
                    set  to  the edit chain after the B was performed,
                    i.e., < will make the edit  chain  be  that  chain
                    where the insertion was performed.

          (INSERT e1 ...  em AFTER .  $) 
                    Similar  to INSERT BEFORE except uses A instead of
                    B. 

          (INSERT e1 ...  em FOR .  $) 
                    Similar to INSERT BEFORE except uses : for B. 

          (REPLACE $ WITH e1 ...  em)
                    Here $ is  the  segment  of  the  command  between
                    REPLACE  and WITH.  Same as (INSERT e1 ...  em FOR
                    .  $).  (BY can be used for WITH.)

Example: (REPLACE COND -1 WITH (T (RETURN L)))

          (CHANGE $ TO e1 ...  em)
                    Same as REPLACE WITH

          (DELETE .  $) 
                    Does a (LC .  $) followed by DELETE.  Current edit
                    chain  is  not   changed   (Unless   the   current
                    expression  is  no longer a part of the expression
                    being edited, e.g., if the current  expression  is
                    ...    C)  and  the  user performs (DELETE 1), the
                    tail, (C), will have been cut off.  Similarly,  if
                    the  current  expression  is  (CDR Y) and the user
                    performs (REPLACE WITH (CAR X)).), but  UNFIND  is
                    set  to  the  edit  chain  after  the  DELETE  was
                    performed.

Example: (DELETE -1), (DELETE COND 3)

Note that  if  $  is  NIL  (empty),  the  corresponding  operation  is
performed  here  (on the current edit chain), e.g., (REPLACE WITH (CAR
X)) is equivalent to (:(CAR X)).  For added readability, HERE is  also
                                                                   144


permitted,  e.g., (INSERT (PRINT X) BEFORE HERE) will insert (PRINT X)
before the current expression (but not change the edit chain).

Note also that $ does not  have  to  specify  a  location  WITHIN  the
current  expression,  i.e., it is perfectly legal to ascend to INSERT,
REPLACE, or DELETE.  For example (INSERT (RETURN)  AFTER  ^  PROG  -1)
will  go to the top, find the first PROG, and insert a (RETURN) at its
end, and not change the current edit chain.

Finally, the A, B, and : commands, (and consequently INSERT,  REPLACE,
and  CHANGE), all make special checks in E1 thru Em for expressions of
the form ($$ .   coms).    In  this  case,  the  expression  used  for
inserting  or  replacing  is  a  copy  of the current expression after
executing coms, a list of edit commands.  (The execution of coms  does
not change the current edit chain.)  For example, (INSERT ($$ F COND -
1  -1) AFTER3) [not (INSERT F COND -1 ($$ -1 ) AFTER 3), which inserts
four elements after the third element, namely F, COND, -1, and a  copy
of the last element in the current expression] will make a copy of the
last form in the last clause of the next COND, and insert it after the
third element of the current expression.

  Note  that  ## can also be used for $$, for compatibility with older
versions.  However, you will have to "quote" the first # sign as it is
also a read macro, i.e. type them as /##.



22.14. Form Oriented Editing and the Role of UP


The UP that is performed before A, B, and : commands (and therefore in
INSERT, CHANGE,  REPLACE,  and  DELETE  commands  after  the  location
portion  of the operation has been performed.), makes these operations
form-oriented.  For example, if  the  user  types  F  SETQ,  and  then
DELETE,  or  simply  (DELETE  SETQ),  he  will  delete the entire SETQ
expression, whereas (DELETE X) if X is a variable,  deletes  just  the
variable   X. In  both  cases,  the  operation  is  performed  on  the
corresponding FORM and  in  both  cases  is  probably  what  the  user
intended.    Similarly,  if  the  user types (INSERT (RETURN Y) BEFORE
SETQ), he means before the SETQ expression, not before the atom  SETQ.
(*There  is some ambiguity in (INSERT expr AFTER functionname), as the
user  might  mean  make  expr  be  the  function's   first   argument.
Similarly,  the  user  cannot  write (REPLACE SETQQ WITH SETQ) meaning
change the name of the function.  The user must in these  cases  write
(INSERT  expr AFTER functionname 1), and (REPLACE SETQQ 1 WITH SETQ).)
A consequent of this procedure is that a pattern of the form (SETQ Y -
-) can be viewed as simply an elaboration and  further  refinement  of
the  pattern  SETQ.   Thus (INSERT (RETURN Y) BEFORE SETQ) and (INSERT
(RETURN Y) BEFORE (SETQ Y --)) perform the  same  operation  (assuming
the  next  SETQ is of the form (SETQ Y-)).)  and, in fact, this is one
of the motivations behind making the current expression after F  SETQ,
and F (SETQ Y --) be the same.

Occasionally,  however,  a  user may have a data structure in which no
special significance or meaning is attached to the position of an atom
                                                                   145


in  a  list,  as  LISP attaches to atoms that appear as CAR of a list,
versus those appearing elsewhere in a list.  In general, the user  may
not  even  know  whether a particular atom is at the head of a list or
not.  Thus, when he writes (INSERT expression  AFTER  FOO),  he  means
after  the  atom  FOO, whether or not it is CAR of a list.  By setting
the variable UPFINDFLG to NIL (Initially, and usually, set to T.)  the
user can suppress the implicit UP that follows searches for atoms, and
thus achieve the desired effect.  With UPFINDFLG = NIL then  following
F  FOO,  for example, the current expression will be the atom FOO.  In
this case, the A, B, and : operations will operate with respect to the
atom FOO.  If the user intends the operation  to  refer  to  the  list
which FOO heads, he simply uses instead the pattern (FOO --).



22.15. Extract and Embed


Extraction  involves  replacing the current expression with one of its
subexpressions (from any depth).

          (XTR .  $) 
                    Replaces the original current expression with  the
                    expression that is current after performing (LCL .
                    $).

For example, if the current expression is (COND ((NULL X) (PRINT Y))),
(XTR PRINT), or (XTR 2 2) will replace the COND by the PRINT.

                    If  the  current  expression after (LCL .  $) is a
                    tail of a higher expression, its first element  is
                    used.

For  example,  if the current expression is (COND ((NULL X) Y) (T Z)),
then (XTR Y) will replace the COND with Y. 

                    If the extracted expression is a list, then  after
                    XTR  has  finished, the current expression will be
                    that list.

Thus, in the first example, the current expression after the XTR would
be (PRINT Y).

                    If the extracted expression is not a list, the new
                    current expression will  be  a  tail  whose  first
                    element is that non-list.

Thus,  in  the  second  example,  the current expression after the XTR
would be ...  Y followed by whatever followed by COND.

If the current  expression  initially  is  a  tail,  extraction  works
exactly  the  same  as  though  the  current expression were the first
element in that tail.  Thus is the current expression is  (XTR  PRINT)
will  replace  the COND by the PRINT, leaving (PRINT Y) as the current
expression.
                                                                   146


The extract command can also incorporate a location specification.

          (EXTRACT $1 FROM $2)
                    ($1  is  the  segment  between  EXTRACT and FROM.)
                    Performs (LC .  $2) And then (XTR .  $1).  Current
                    edit chain is not changed, but UNFIND  is  set  to
                    the edit chain after the XTR was performed.

Example:  If  the  current  expression is (PRINT (COND ((NULL X) Y) (T
Z))) then following (EXTRACT Y FROM COND), the current expression will
be (PRINT Y).  (EXTRACT 2 -1 FROM COND), (EXTRACT Y FROM 2),  (EXTRACT
2 -1 FROM 2) will all produce the same result.

While  extracting  replaces the current expression by a subexpression,
embedding replaces the current expression with one containing it as  a
subexpression.

          (MBD x)
                    X  is  a  list,  substitutes  (a la SUBST, i.e., a
                    fresh copy is  used  for  each  substitution)  the
                    current expression for all instances of the atom *
                    in x, and replaces the current expression with the
                    result of that substitution.

Example:  If the current expression is (PRINT Y), (MBD (COND ((NULL X)
*)  ((NULL  (CAR  Y))  *  (GO  LP)))  would  replace  (PRINT  Y)  with
(COND((NULL X) (PRINT Y)) ((NULL (CAR Y)) (PRINT Y) (GO LP))).

          (MBD e1 ...  em)
                    Equivalent to (MBD (e1 ...  em *)).

Example:  If the current expression is (PRINT Y), then  (MBD  SETQ  X)
will replace it with (SETQ X (PRINT Y)).

          (MBD x)
                    X atomic, same as (MBD (x *)).

Example:    If  the current expression is (PRINT Y), (MBD RETURN) will
replace it with (RETURN (PRINT Y)).

All three forms of MBD  leave  the  edit  chain  so  that  the  larger
expression is the new current expression.

If the current expression initially is a tail, embedding works exactly
the  same  as  though the current expression were the first element in
that tail.  Thus if the current expression were  ...(PRINT  Y)  (PRINT
Z)), (MBD SETQ X) would replace (PRINT Y) with (SETQ X (PRINT Y)).

The embed command can also incorporate a location specification.

          (EMBED $ IN .  x)
                    ($  is the segment between EMBED and IN.) Does (LC
                    .  $) and then (MBD .  x).    Edit  chain  is  not
                    changed, but UNFIND is set to the edit chain after
                    the MBD was performed.
                                                                   147


Example:   (EMBED PRINT IN SETQ X), (EMBED 3 2 IN RETURN), (EMBED COND
3 1 IN (OR * (NULL X))).

WITH can be used for IN, and SURROUND can be  used  for  EMBED,  e.g.,
(SURROUND NUMBERP WITH (AND * (MINUSP X ))).



22.16. The MOVE Command


The  MOVE  command allows the user to specify (1) the expression to be
moved, (2) the place it is to be moved to, and (3) the operation to be
performed there, e.g., insert it before,  insert  it  after,  replace,
etc.

          (MOVE $1 TO com . $2)
                    ($1  is  the  segment between MOVE and TO.)  Where
                    COM is BEFORE,  AFTER,  or  the  name  of  a  list
                    command,  e.g.,  :,  N, etc.  Performs (LC .  $1),
                    Obtains the current expression there (or its first
                    element, if it is a tail), let us call this  expr;
                    MOVE  then  goes  back  to  original  edit  chain,
                    performs (LC .  $2), Peforms (com expr), then goes
                    back to $1 and deletes expr.  Edit  chain  is  not
                    changed.    UNFIND is set to edit chain after (com
                    expr) was performed.

For example, if the current expression is (A B C D), (MOVE 2 TO  AFTER
4) will make the new current expression be (A C D B).  Note that 4 was
executed  as  of  the original edit chain, and that the second element
had not yet been removed.

As the following examples taken from actual  editing  will  show,  the
MOVE  command  is  an  extremely versatile and powerful feature of the
editor.

    #?
    (PROG (L) (EDLOC (CDDR C)) (RETURN (CAR L)))
    #(MOVE 3 TO : CAR)
    #?
    (PROG (L) (RETURN (EDLOC (CDDR C))))
    #


    #P
    ... (SELECTQ OBJPR & &) (RETURN &) LP2 (COND & & ))
    #(MOVE 2 TO N 1)
    #P
    ... (SELECTQ OBJPR & & &) LP2 (COND & &))
    #
                                                                   148



    #P
    (OR (EQ X LASTAIL) (NOT &) (AND & & &))
    #(MOVE 4 TO AFTER (BELOW COND))
    #P
    (OR (EQ X LASTAIL) (NOT &))
    #< P
    ... (& &) (AND & & &) (T & &))
    #


    #P
    ((NULL X) (COND & &))
    #(-2 (GO DELETE))
    #(MOVE 3 TO N (_ PROG))
    #P
    ((NULL X) (GO DELETE))
    #< P
    (PROG (&) (COND & & &) (COND & & &) (COND & &))
    #(INSERT DELETE BEFORE -1)
    #P
    (PROG (&) (COND & & &) (COND & & &) DELETE (COND & &))
    #

Note  that  in  the  last  example, the user could have added the prog
label DELETE and moved the COND in one operation by performing (MOVE 3
TO N (_ PROG) (N DELETE)).  Similarly, in the  next  example,  in  the
course  of  specifying $2, the location where the expression was to be
moved to, the user also performs  a  structure  modification,  via  (N
(T)),  thus  creating  the  structure that will receive the expression
being moved.

    #P
    ((CDR &) (SETQ CL &) (EDITSMASH CL & &))
    #(MOVE 3 TO N 0 (N (T)) -1]
    #P
    ((CDR &) (SETQ CL &))
    #< P
    (T (EDITSMASH CL & &))
    #

If $2 is NIL, or (HERE), the  current  position  specifies  where  the
operation  is to take place.  In this case, UNFIND is set to where the
expression that was moved was  originally  located,  i.e.,  $1.    For
example:

    #P
    (TENEX)
    #(MOVE ^ F APPLY TO N HERE)
    #P
    (TENEX (APPLY & & ))
    #
                                                                   149



    #P
    (T (PRIN1 C-EXP))
    #(MOVE BF PRIN1 TO N HERE)
    #P
    (T (PRIN1 C-EXP) (PRIN1 &))
    #

Finally,  if  $1  is  NIL, the MOVE command allows the user to specify
some place the current expression is to be moved to.   In  this  case,
the  edit  chain  is  changed,  and  is  the  chain  where the current
expression was moved to; UNFIND is set to where it was.

    #P
    (SELECTQ OBJPR (&) (PROGN & &))
    #(MOVE TO BEFORE LOOP)
    #P
    ...(SELECTQ OBJPR & &) LOOP (RPLACA DFPRP &) (RPLACD DFPRP &))
    #



22.17. Commands That "Move Parentheses"


The commands presented in this section permit modification of the list
structure itself, as opposed to modifying components thereof.    Their
effect  can  be  described  as  inserting or removing a single left or
right parenthesis, or pair of left and right parentheses.  Of  course,
there  will  always  be  the  same number of left parentheses as right
parentheses in any list structure, since the parentheses  are  just  a
notational guide to the structure provided by PRINT.  Thus, no command
can  insert  or remove just one parenthesis, but this is suggestive of
what actually happens.

In all six commands, n and m are used to specify an element of a list,
usually of the current expression.  In practice, n and m  are  usually
positive   or  negative  integers  with  the  obvious  interpretation.
However, all six commands use the generalized NTH command, p. 137,  to
find  their element(s), so that nth element means the first element of
the tail found by performing (NTH n).  In other words, if the  current
expression  is  (LIST  (CAR X) (SETQ Y (CONS W Z))), then (BI 2 CONS),
(BI X -1), and (BI X Z) all specify the exact same operation.

All six commands generate an error if the element is not found,  i.e.,
the NTH fails.  All are undoable.

          (BI n m)
                    Both in, inserts a left parentheses before the nth
                    element  and  after the mth element in the current
                    expression.  Generates an error if the mth element
                    is not contained in the nth tail,  i.e.,  the  mth
                    element must be "to the right" of the nth element.

Example:    If the current expression is (A B (C D E) F G), then (BI 2
                                                                   150


4) will modify it to be (A (B (C D E) F) G).

          (BI n)
                    Same as (BI n n).

Example:  If the current expression is (A B (C D E) F G), then (BI -2)
will modify it to be (A B (C D E) (F) G).

          (BO n)
                    Both  out.   Removes both parentheses from the nth
                    element.  Generates an error if nth element is not
                    a list.

Example:  If the current expression is (A B (C D E) F G), then (BO  D)
will modify it to be (A B C D E F G).

          (LI n)
                    Left in, inserts a left parenthesis before the nth
                    element  (and  a matching right parenthesis at the
                    end of the current expression),  i.e.,  equivalent
                    to (BI n -1).

Example:   If the current expression is (A B (C D E) F G), then (LI 2)
will modify it to be (A (B (C D E) F G)).

          (LO n)
                    Left out, removes a left parenthesis from the  nth
                    element.    All elements following the nth element
                    are deleted.  Generates an error if nth element is
                    not a list.

Example:  If the current expression is (A B (C D E) F G), then (LO  3)
will modify it to be (A B C D E).

          (RI n m)
                    Right  in,  inserts  a right parenthesis after the
                    mth element of the nth element.  The rest  of  the
                    nth  element  is  brought  up  to the level of the
                    current expression.

Example: If the current expression is (A (B C D E) F G), (RI 2 2) will
modify it to be (A (B C) D E F G).  Another way of thinking  about  RI
is  to  read  it  as "move the right parenthesis at the end of the nth
element IN to after the mth element."

          (RO n)
                    Right out, removes the right parenthesis from  the
                    nth  element,  moving it to the end of the current
                    expression.    All  elements  following  the   nth
                    element  are  moved  inside  of  the  nth element.
                    Generates an error if nth element is not a list.

Example: If the current expression is (A B (C D E) F G), (RO  3)  will
modify  it  to be (A B (C D E F G)).  Another way of thinking about RO
is to read it as "move the right parenthesis at the  end  of  the  nth
                                                                   151


element OUT to the end of the current expression."



22.18. TO and THRU


EXTRACT,  EMBED,  DELETE,  REPLACE, and MOVE can be made to operate on
several contiguous elements, i.e., a segment of a list, by  using  the
TO or THRU command in their respective location specifications.

          ($1 THRU $2)
                    Does  a  (LC .  $1), Followed by an UP, and then a
                    (BI 1 $2), thereby grouping  the  segment  into  a
                    single  element,  and finally does a 1, making the
                    final current expression be that element.

For example, if the current expression is (A (B (C D) (E) (F G H) I) J
K), following (C THRU G), the current expression will be ((C D) (E) (F
G H)).

          ($1 TO $2)
                    Same as THRU except  last  element  not  included,
                    i.e., after the BI, an (RI 1 -2) is performed.

If  both  $1  and  $2  are numbers, and $2 is greater than $1, then $2
counts from the beginning of the current expression, the same  as  $1.
In  other words, if the current expression is (A B C D E F G), (3 THRU
4) means (C THRU D), not (C THRU F).  In this case, the  corresponding
BI command is (BI 1 $2-$1+1).

THRU  and  TO  are not very useful commands by themselves, and are not
intended to be used "solo", but in conjunction  with  EXTRACT,  EMBED,
DELETE,  REPLACE, and MOVE.  After THRU and TO have operated, they set
an internal editor flag informing the above commands that the  element
they  are  operating on is actually a segment, and that the extra pair
of parentheses should be  removed  when  the  operation  is  complete.
Thus:

    #P
    (PROG NIL (SETQ A &) (RPLACA & &) (PRINT &) (RPLACD & &))
    #(MOVE (3 THRU 4) TO BEFORE 5) P
    (PROG NIL (PRINT &) (SETQ A &) (RPLACA & &) (RPLACD & &))
    #

Note  that  when  specifing  $2  in the MOVE, 5 was used instead of 6.
This is because the $2 is located after $1  is.    The  THRU  location
groups  items  together  and  thus changes the numeric location of the
following items.
                                                                   152


    #P
    (PROG NIL (PRIN1 &) (PRIN1 &) (SETQ IND &) (SETQ VAL &)
    (PRINT &))
    #(MOVE (5 THRU 7) TO BEFORE 3)
    #P
    (PROG NIL (SETQ IND &) (SETQ VAL &) (PRINT &) (PRIN1 &)
    (PRIN1 &))
    #(DELETE (SETQ THRU PRI@))
    = PRINT
    #P
    (PROG NIL (PRIN1 &) (PRIN1 &))
    #


    #P
    ... LP (SELECTQ & & &) (SETQ Y &) OUT (SETQ FLG &) (RETURN Y))
    #(MOVE (1 TO OUT) TO N HERE)
    #P
    ... OUT (SETQ FLG &) (RETURN Y) LP (SELECTQ & & &) (SETQ Y &))
    #

    #PP
    (PROG (TEMP1 TEMP2)
          (COND ((NOT (MEMQ REMARG LISTING))
                 (SETQ TEMP1 (ASSOC REMARG NAMEDREMARKS))
                 (SETQ TEMP2 (CADR TEMP1)))
                (T (SETQ TEMP1 REMARG)))
          (NCONC LISTING REMARG)
          (RETURN (CONS TEMP1 TEMP2)))

    #(EXTRACT (SETQ THRU CADR) FROM COND) PP
    (PROG (TEMP1 TEMP2)
          (SETQ TEMP1 (ASSOC REMARG NAMEDREMARKS))
          (SETQ TEMP2 (CADR TEMP1))
          (NCONC LISTING REMARG)
          (RETURN (CONS TEMP1 TEMP2)))
    #

TO and THRU can also be used directly with XTR.  (Because XTR involves
a  location  specification  while A,B,:, and MBD do not.)  Thus in the
previous example, if the current expression had been the  COND,  e.g.,
the  user  had  first performed F COND , he could have used (XTR (SETQ
THRU CADR)) to perform the extraction.

          ($1 TO), ($1 THRU)
                    Both same as ($1 THRU -1), i.e., from $1 thru  the
                    end of the list.

    #P
    (VAL (RPLACA DFPRP &) (RPLACD & &) (RPLACA VARS &) (RETURN &))
    #(MOVE (2 TO) TO N (_ PROG))
    #(N (GO VAR))
    #P
    (VAL (GO VAR))
    #
                                                                   153




    #P
    (T (COND &) (EDITSMASH CL & &) (COND &))
    #(-2 (GO REPLACE))
    #(MOVE (COND TO) TO N ^ PROG (N REPLACE))
    #P
    (T (GO REPLACE))
    #< P
    (PROG (&) (COND & & &) (COND & & &) DELETE (COND & &) REPLACE
    (COND &) (EDITSMASH CL & &) (COND &))
    #


    #PP
    (LAMBDA(CLAUSALA X)
     (PROG (A D)
           (SETQ A CLAUSALA)
      LP   (COND ((NULL A) (RETURN NIL)))
           (SERCH X A)
           (RUMARK (CAR A))
           (NOTICECL (CAR A))
           (SETQ A (CDR A))
           (GO LP)))

    #(EXTRACT (SERCH THRU NOT@) FROM PROG) P
    = NOTICECL
    (LAMBDA (CLAUSALA X) (SERCH X A) (RUMARK &) (NOTICECL &))
    #(EMBED (SERCH TO) IN (MAP [FUNCTION (LAMBDA (A) *] CLAUSALA]

    #PP
    (LAMBDA(CLAUSALA X)
     (MAP (FUNCTION
           (LAMBDA(A)
            (SERCH X A)
            (RUMARK (CAR A))
            (NOTICECL (CAR A))))
          CLAUSALA))

          (R x y)
                    Replaces  all  instances  of x by y in the current
                    expression, e.g., (R CAADR CADAR).   Generates  an
                    error if there is not at least one instance.

R  operates  by  performing  a  DSUBST.  The current expression is the
third argument to DSUBST, i.e., the expression being substituted into,
and y is the first argument to  DSUBST,  i.e.,  the  expression  being
substituted.  R computes the second argument to DSUBST, the expression
to  be substituted for, by performing (F x T).  The second argument is
then the  current  expression  at  that  point,  or  if  that  current
expression  is  a list and x is atomic, then the first element of that
current expression.  Thus x can be the S-expression (or  atom)  to  be
substituted for, or can be a pattern which specifies that S-expression
(or atom).
                                                                   154


For  example, if the current expression is (LIST FUNNYATOM1 FUNNYATOM2
(CAR  FUNNYATOM1)),  then  (R  FUN@  FUNNYATOM3  )   will   substitute
FUNNYATOM3  for  FUNNYATOM1  throughout  the current expression.  Note
that FUNNYATOM2, even though it would have matched  with  the  pattern
FUN@, is NOT replaced.

Similarly, if (LIST(CAR X) (CAR Y)) is the first expression matched by
(LIST  --), then (R (LIST --) (LIST (CAR Y) (CAR Z))) is equivalent to
(R (LIST (CARX) (CARY)) (LIST (CAR  Y)  (CAR  Z))),  i.e.,  both  will
replace  all instances of (LIST (CAR X) (CAR Y)) by (LIST (CAR Y) (CAR
Z)).  Note that other forms beginning with LIST will not be  replaced,
even  though  they  would  have matched with (LIST --).  To change all
expressions of the form (LIST --) to (LIST (CAR Y) (CAR Z)), the  user
should perform (LP (REPLACE (LIST --) WITH (LIST (CAR Y) (CAR].

          (SW n m)
                    Switches  the  nth and mth elements of the current
                    expression.

For example, if the current expression is (LIST (CONS (CAR X) (CAR Y))
(CONS (CDR Y))), (SW 2 3) will modify it to be  (LIST  (CONS  (CDR  X)
(CDR  Y))  (CONS  (CAR X) (CAR Y))).  The relative order of n and m is
not important, ie, (SW 3 2) and (SW 2 3 ) are equivalent.

                    SW uses the generalized NTH command  to  find  the
                    nth and mth elements, a la the BI-BO commands.

Thus  in  the  previous  example,  (SW CAR CDR) would produce the same
result.



22.19. Commands That Print


          PP
                    Prettyprints the current expression.

          P
                    Prints current expression as though PRINTLEV  were
                    given a depth of 2.

          (P m)
                    Prints mth element of current expression as though
                    PRINTLEV were given a depth of 2.

          (P 0)
                    Same as P

          (P m n)
                    Prints mth element of current expression as though
                    PRINTLEV were given a depth of n. 

          (P 0 n)
                    Prints  current  expression  as  though PRINTLEVEL
                                                                   155


                    were given a depth of n. 

          ? 
                    Same as (P 0 100)

Both  (P  m)  and  (P  m  n) use the general NTH command to obtain the
corresponding element, so that m does not have to be  a  number,  e.g.
(P COND 3) will work.

All  printing  functions  print  to  the  teletype,  regardless of the
primary output file.  No  printing  function  ever  changes  the  edit
chain.  All record the current edit chain for use by <P, p. 2.37.



22.20. Commands That Evaluate


          E
                    Only  when  typed  in,  (i.e., (INSERT D BEFORE E)
                    will treat E as a pattern) causes  the  editor  to
                    call the LISP interpreter giving it the next input
                    as argument.

    Example:
    #E (BREAK FIE FUM)
    (FIE FUM)
    #E (FOO)
    (FIE BROKEN)
    1:

          (E x)
                    Evaluates  X,  i.e., performs (EVAL x), and prints
                    the result on the teletype.

          (E x T)
                    Same as (E x) but does not print.

The (E x) and (E x T) commands are mainly intended for use  by  MACROS
and  subroutine calls to the editor; the user would probably type in a
form for evaluation using the more convenient format of the (atomic) E
command.

          (I c x1 ...  xn)
                    Same as (c y1 ...  yn) where yi=(EVAL xi).

Example:  (I 3 (GETD (QUOTE FOO)) will replace the 3rd element of  the
current expression with the definition of FOO.  (The I command sets an
internal  flag  to indicate to the structure modification commands not
to copy expression(s) when inserting, replacing, or attaching.)  (I  N
FOO  (CAR  FIE))  will attach the value of FOO and CAR of the value of
FIE to the end of the current expression.  (I F= FOO  T)  will  search
for an expression EQ to the value of FOO.

                    If c is not an atom, it is evaluated as well.
                                                                   156


Example:  (I (COND ((NULL FLG) (QUOTE -1)) (T 1)) FOO), if FLG is NIL,
inserts  the  value  of  FOO  before  the first element of the current
expression, otherwise replaces the first element by the value of FOO.

          ($$ com[1] com[2] ... com[n])
                    is an FSUBR (not a command).  Its  value  is  what
                    the  current  expression  would be after executing
                    the edit commands com[1] ...  com[n] starting from
                    the present edit chain.  Generates an error if any
                    of com[1] thru com[n] cause errors.   The  current
                    edit   chain  is  never  changed.    (Recall  that
                    A,B,:,INSERT, REPLACE,  and  CHANGE  make  special
                    checks  for  $$  forms in the expressions used for
                    inserting or replacing, and use a copy of $$  form
                    instead  (see  p. 2.44).    thus, (INSERT ($$ 3 2)
                    AFTER 1) is equivalent to (I INSERT (COPY ($$ 3  2
                    )) (QUOTE AFTER) 1).)

Example:  (I  R  (QUOTE  X)  ($$ (CONS :: Z))) replaces all X's in the
current expression by the first CONS containing a Z. 

Note that ## may also be used in place of $$, for  compatibility  with
older  systems.    However  in  many  cases  you will probably have to
"quote" the first # sign, e.g. type /##, so $$ is more convenient

The I command is not very convenient  for  computing  an  entire  edit
command  for  execution,  since  it  computes the command name and its
arguments separately.  Also, the I command cannot be used  to  compute
an  atomic  command.   The following two commands provide more general
ways of computing commands.

          (COMS x1 ...  xn)
                    Each xi is evaluated and its value executed  as  a
                    command.

For  example,  (COMS  (COND  (X  (LIST  1 X)))) will replace the first
element of the current expression with the  value  of  X  if  non-NIL,
otherwise do nothing.  (NIL as a command is a NOP, see p. 160)

          (COMSQ com[1] ...  com[n])
                    Executes com[1] ...  com[n].

COMSQ  is  mainly  useful  in  conjunction with the COMS command.  For
example, suppose the user wishes to compute an entire list of commands
for evaluation, as opposed to computing each command one at a time  as
does  the COMS command.  He would then write (COMS (CONS (QUOTE COMSQ)
x)) where x computed the list of commands, e.g.,

    (COMS (CONS (QUOTE COMSQ) (GET FOO (QUOTE COMMANDS)))).
                                                                   157


22.21. Commands That Test


          (IF x)
                    Generates an error unless the value of (EVAL x) is
                    true,  i.e.,  if (EVAL x) causes an error or (EVAL
                    x)=NIL, IF will cause an error.

For some editor commands, the  occurrence  of  an  error  has  a  well
defined  meaning,  i.e., they use errors to branch on as COND uses NIL
and  non-NIL.    For  example,  an  error  condition  in  a   location
specification  may  simply mean "not this one, try the next." Thus the
location specification

    (*PLUS (E (OR (NUMBERP ($$ 3)) (ERR NIL)) T))

specifies the first *PLUS whose second argument is a number.   The  IF
command,  by  equating  NIL  to  error, provides a more natural way of
accomplishing  the  same  result.    Thus,  an   equivalent   location
specification is (*PLUS (IF (NUMBERP ($$ 3)))).

The  IF command can also be used to select between two alternate lists
of commands for execution.

          (IF x coms1 coms2)
                    If (EVAL x) is true, execute coms1;  if  (EVAL  x)
                    causes an error or is equal to NIL, execute coms2.

For  example, the command (IF (NULL A) NIL (P)) will print the current
expression provided A=NIL.

          (IF x coms1)
                    If (EVAL x)  is  true,  execute  coms1;  otherwise
                    generate an error.

          (LP .  coms)
                    Repeatedly  executes  coms,  a  list  of commands,
                    until an error occurs.

For example, (LP F PRINT (N T)) will attach a T at the  end  of  every
PRINT  expression.  (LP F PRINT (IF ($$ 3) NIL ((N T)))) will attach a
T at the end of each print expression which does not  already  have  a
second  argument.    (i.e.  The form ($$ 3) will cause an error if the
edit command 3 causes an error, thereby selecting ((N T)) as the  list
of commands to be executed.  The IF could also be written as (IF (CDDR
($$)) NIL ((N T))).)

                    When  an  error  occurs,  LP prints n OCCURRENCES,
                    where  n  is  the  number  of   times   COMS   was
                    successfully  executed.  The edit chain is left as
                    of the last complete successful execution of COMS.

          (LPQ .  Coms)
                    Same as LP but does not print n OCCURRENCES.
                                                                   158


In  order  to prevent non-terminating loops, both LP and LPQ terminate
when the number of iterations reaches MAXLOOP, initially set to 30.

          (ORR coms[1] ...  Coms[n])
                    ORR  begins  by  executing  coms[1],  a  list   of
                    commands.    If  no error occurs, ORR is finished.
                    Otherwise, ORR restores  the  edit  chain  to  its
                    original   value,   and   continues  by  executing
                    coms[2], etc.    If  none  of  the  command  lists
                    execute  without  errors, i.e., the ORR "drops off
                    the end", ORR generates an error.  Otherwise,  the
                    edit  chain  is  left  as of the completion of the
                    first command list which executes  without  error.
                    (NIL  as  a  command  list is perfectly legal, and
                    will always execute successfully.    Thus,  making
                    the last 'argument' to ORR be NIL will insure that
                    the  ORR never causes an error.  Any other atom is
                    treated as (atom), i.e., the example  given  below
                    could be written as (ORR NX !NX NIL).)

For  example,  (ORR  (NX)  (!NX)  NIL) will perform a NX, if possible,
otherwise a !NX, if possible, otherwise do nothing.  Similarly, DELETE
could be written as (ORR (UP (1)) (BK UP (2)) (UP (: NIL))).



22.22. Macros


Many of the more sophisticated branching commands in the editor,  such
as ORR, IF, etc., are most often used in conjunction with edit macros.
The  macro feature permits the user to define new commands and thereby
expand the editor's repertoire.  (However, built  in  commands  always
take  precedence  over  macros,  i.e.,  the editor's repertoire can be
expanded, but not  modified.)  Macros  are  defined  by  using  the  M
command.

          (M c .  coms)
                    For  c  an atom, M defines c as an atomic command.
                    (If a  macro  is  redefined,  its  new  definition
                    replaces  its  old.)  Executing c is then the same
                    as executing the list of commands COMS.

For example, (M BP BK UP P) will define BP as an atomic command  which
does  three  things,  a  BK,  an UP, and a P. Note that macros can use
commands defined by macros as well  as  built  in  commands  in  their
definitions.    For example, suppose Z is defined by (M Z -1 (IF (NULL
($$)) NIL (P))), i.e.  Z does a -1, and then if the current expression
is not NIL, a P. Now we can define ZZ by (M ZZ -1 Z), and  ZZZ  by  (M
ZZZ -1 -1 Z) or (M ZZZ -1 ZZ).

Macros  can  also  define  list  commands,  i.e.,  commands  that take
arguments.

          (M (c) (arg[1] ...  arg[n]) .  coms)
                                                                   159


                    C  an  atom.    M  defines  c  as  a list command.
                    Executing (c e1 ...   en)  is  then  performed  by
                    substituting  e1  for  arg[1],  ...  en for arg[n]
                    throughout COMS, and then executing COMS.

For example, we could define a more general BP by (M (BP) (N)  (BK  N)
UP P).  Thus, (BP 3) would perform (BK 3), followed by an UP, followed
by a P. 

A  list  command  can  be defined via a macro so as to take a fixed or
indefinite number of 'arguments'.  The form given  above  specified  a
macro  with  a fixed number of arguments, as indicated by its argument
list.  If  the  'argument  list'  is  atomic,  the  command  takes  an
indefinite number of arguments.

          (M (c) args .  coms)
                    Name,  args  both  atoms,  defines  c  as  a  list
                    command.  executing (c e1 ...  en) is performed by
                    substituting (e1  ...    en),  i.e.,  CDR  of  the
                    command,   for  args  throughout  coms,  and  then
                    executing coms.

For example, the command SECOND, p. 136, can be defined as a macro  by
(M  (2ND)  X  (ORR  ((LC .  X) (LC .  X)))).  Note that for all editor
commands, 'built in' commands as well as commands defined  by  macros,
atomic  definitions  and  list definitions are completely independent.
In other words, the existence of an atomic definition for c in no  way
affects  the  treatment of c when it appears as CAR of a list command,
and the existence of a list definition for c in  no  way  affects  the
treatment  of  c  when it appears as an atom.  in particular, c can be
used as the name of either an atomic command, or a  list  command,  or
both.    In the latter case, two entirely different definitions can be
used.

Note also that once c is defined as an  atomic  command  via  a  macro
definition,  it  will  not  be  searched  for  when used in a location
specification, unless c is preceded by an F. Thus  (INSERT  --  BEFORE
BP) would not search for BP, but instead perform a BK, an UP, and a P,
and then do the insertion.  The corresponding also holds true for list
commands.

Occasionally, the user will want to employ the S command in a macro to
save  some  temporary  result.    For example, the SW command could be
defined as

(M (SW) (N M) (NTH N) (S FOO 1) MARK 0 (NTH M) (S FIE 1) (I 1 FOO)  __
(I 1 FIE))

(A  more elegant definition would be (M (SW) (N M) (NTH N) MARK 0 (NTH
M) (S FIE 1) (I 1 ($$ _ 1)) __ (I 1 FIE)), but this  would  still  use
one free variable.)

Since SW sets FOO and FIE, using SW may have undesirable side effects,
especially  when  the  editor  was  called from deep in a computation.
Thus we must always be careful to  make  up  unique  names  for  dummy
                                                                   160


variables  used  in edit macros, which is bothersome.  Furthermore, it
would be impossible to define a command that called itself recursively
while setting free variables.  The BIND command solves both problems.

          (BIND . coms)
                    Binds  three   dummy   variables   #1,   #2,   #3,
                    (initialized  to  NIL), and then executes the edit
                    commands COMS.  Note that these bindings are  only
                    in  effect  while the commands are being executed,
                    and that BIND can be  used  recursively;  it  will
                    rebind  #1,  #2,  and  #3 each time it is invoked.
                    (BIND is implemented by (PROG (#1 #2 #3) (EDITCOMS
                    (CDR COM))) where  COM  corresponds  to  the  BIND
                    command,   and  EDITCOMS  is  an  internal  editor
                    function which executes a list of commands.)

thus we could now write SW safely as

    (M (SW) (N M) (BIND (NTH N) (S #1 1) MARK 0 (NTH M) (S #2 1)
    (I 1 #1) __ (I 1 #2))).

User macros are stored on a list USERMACROS.  (USERMACROS is initially
NIL.)  thus if the user wants to save his macros, he should  save  the
value of USERMACROS.  (The user probably should also save the value of
EDITCOMSL).



22.23. Miscellaneous Commands


          NIL
                    Unless preceded by F or BF, is always a NOP.

          TTY:
                    Calls  the  editor recursively.  The user can then
                    type in commands, and have  them  executed.    The
                    TTY:    command  is  completed when the user exits
                    from the lower editor.  (See OK and STOP below.)

The TTY:  command is extremely useful.  It enables the user to set  up
a   complex  operation,  and  perform  interactive  attention-changing
commands part way through it.  For example  the  command  (MOVE  3  TO
AFTER  COND  3  P TTY:) allows the user to interact, in effect, within
the MOVE command.  Thus he can verify for  himself  that  the  correct
location  has been found, or complete the specification "by hand".  In
effect, TTY: says "I'll tell you what  you  should  do  when  you  get
there."

The  TTY:    command  operates  by printing TTY:  and then calling the
editor.  The initial edit chain in the lower editor is  the  one  that
existed  in  the  higher  editor  at  the  time  the TTY:  command was
entered.  Until the user exits from the lower  editor,  any  attention
changing  commands  he  executes  only  affect the lower editor's edit
chain.  (Of course, if the user performs  any  structure  modification
                                                                   161


commands  while under a TTY:  command, these will modify the structure
in both editors, since it is the  same  structure.)    When  the  TTY:
command finishes, the lower editor's edit chain becomes the edit chain
of the higher editor.

          OK
                    Exits from the editor.

          STOP
                    Exits  from  the editor with an error.  Mainly for
                    use in conjunction with  TTY:  commands  that  the
                    user wants to abort.

Since all of the commands in the editor are ERRSET protected, the user
must  exit  from  the  editor  via  a command.  STOP provides a way of
distinguishing between a successful and unsuccessful (from the  user's
standpoint)  editing  session.   For example, if the user is executing
(MOVE 3 TO AFTER COND TTY:), and he exits from the lower  editor  with
an OK, the MOVE command will then complete its operation.  If the user
wants  to  abort  the  MOVE  command,  he  must make the TTY:  command
generate an error.  He does this by exiting from the lower editor with
a STOP command.  In this case, the higher editor's edit chain will not
be changed by the TTY: command.

          SAVE
                    Exits from the editor and saves the 'state of  the
                    edit'    on    the    property    list    of   the
                    function/variable being edited under the  property
                    EDIT-SAVE.    If the editor is called again on the
                    same  structure,  the   editing   is   effectively
                    "continued,"    i.e.,  the  edit chain, mark list,
                    value of UNFIND and UNDOLST are restored.

    For example:

    #P
    (NULL X)
    #F COND P
    (COND (& &) (T &))
    #SAVE
    FOO

     .
     .
     .

    *(EDITF FOO)
    EDIT
    #P
    (COND (& &) (T &))
    #< P
    (NULL X)
    #

SAVE  is  necessary  only  if  the  user  is  editing  many  different
                                                                   162


expressions;  an exit from the editor via OK always saves the state of
the edit of that call to the editor.  (On the  property  list  of  the
atom  EDIT, under the property name LASTVALUE.  OK also remprops EDIT-
SAVE from the property list of the  function/variable  being  edited.)
Whenever  the editor is entered, it checks to see if it is editing the
same expression as the last one edited.  In this case, it restores the
mark list, the undolst, and sets UNFIND to be the edit chain as of the
previous exit from the editor.  For example:

    *(EDITF FOO)
    EDIT
    #P
    (LAMBDA (X) (PROG & & LP & & & &))
       .
       .
       .
    #P
    (COND & &)
    #OK
    FOO
    #
       .
       .            Any number of inputs except for
       .            calls to the editor.
    *(EDITF FOO)
    EDIT
    #P
    (LAMBDA (X) (PROG & & LP & & & &))
    #< P
    (COND & &)
    #

The user can always continue editing, including undoing changes from a
previous editing session, if

   - No other expressions have been edited  since  that  session;
     (since  saving  takes  place at exit time, intervening calls
     that were exited via  STOP  will  not  affect  the  editor's
     memory of this last session.) or

   - It was ended with a SAVE command.

          REPACK
                    Permits the 'editing' of an atom or string.
                                                                   163


    For example:

    #P
    ... "THIS IS A LOGN STRING")
    #REPACK
    EDIT
    2#P
    (/" T H I S /  I S /  A /  L O G N /  S T R I N G /")
    2#(SW G N)
    2#OK
    "THIS IS A LONG STRING"
    #

REPACK  operates  by  calling  the editor recursively on UNPACK of the
current expression, or if it  is  a  list,  on  UNPACK  of  its  first
element.   If the lower editor is exited successfully, i.e.  via OK as
opposed to STOP, the list of atoms is  made  into  a  single  atom  or
string,  which  replaces  the atom or string being 'repacked.' The new
atom or string is always printed.

          (REPACK $)
                    Does (LC .  $) followed by REPACK, e.g.    (REPACK
                    THIS@).

          (MAKEFN form args n m)
                    Makes  (CAR form) an EXPR with the nth through mth
                    elements  of  the  current  expression  with  each
                    occurance  of an element of (CDR form) replaced by
                    the  corresponding  element  of  args.    The  nth
                    through  mth  elements  are replaced by form.  For
                    example:

    #P
    ... (SETQ A NIL) (SETQ B T) (CONS C D))
    #(MAKEFN (SETUP C D) (W X) 1 3) P
    SETUP
    ... (SETUP C D))
    #E (PP SETUP)
    (DEFPROP SETUP
     (LAMBDA(W X) (SETQ A NIL) (SETQ B T) (CONS W X))
    EXPR)
    #

          (MAKEFN form args n)
                    Same as (MAKEFN form args n n).



22.24. UNDO


Each command that causes structure modification automatically adds  an
entry  to  the front of UNDOLST containing the information required to
restore all pointers that were changed by the command.
                                                                   164


          UNDO
                    Undoes  the  last,  i.e.,  most  recent, structure
                    modification command that has not yet been undone,
                    (Since   UNDO   and   !UNDO    causes    structure
                    modification,  they  also add an entry to UNDOLST.
                    However, UNDO and !UNDO  entries  are  skipped  by
                    UNDO,  e.g.,  if  the user performs an INSERT, and
                    then an MBD, the first UNDO will undo the MBD, and
                    the second will undo the  INSERT.    However,  the
                    user  can  also specify precisely which command he
                    wants undone.  In this case, he can undo  an  UNDO
                    command,  e.g.,  by  typing  UNDO  UNDO, or undo a
                    !UNDO command, or undo a command other  than  that
                    most  recently  _ performed.)  and prints the name
                    of that command, e.g., MBD UNDONE. The edit  chain
                    is  then  exactly  what it was before the 'undone'
                    command had been  performed.    If  there  are  no
                    commands to undo, UNDO types NOTHING SAVED.

          !UNDO
                    Undoes  all  modifications  performed  during this
                    editing session, i.e., this call  to  the  editor.
                    As  each  command is undone, its name is printed a
                    la UNDO.  If there is nothing to be undone,  !UNDO
                    prints NOTHING SAVED.

Whenever  the  user continues an editing session as described on pages
161-162, the undo information of the previous session(s) is  protected
by  inserting  a  special  blip,  called an undo-block on the front of
UNDOLST.  This undo-block will terminate the  operation  of  a  !UNDO,
thereby  confining  its  effect  to  the  current  session,  and  will
similarly prevent an UNDO command from operating on commands  executed
in the previous session.

Thus,  if  the  user  enters  the  editor  continuing  a  session, and
immediately executes an UNDO  or  !UNDO,  UNDO  and  !UNDO  will  type
BLOCKED,  instead  of  NOTHING SAVED.  Similarly, if the user executes
several commands and then undoes them all,  either  via  several  UNDO
commands  or  a  !UNDO  command,  another UNDO or !UNDO will also type
BLOCKED.

          UNBLOCK
                    Removes an undo-block.   If  executed  at  a  non-
                    blocked  state,  i.e.,  if  UNDO  or  !UNDO  could
                    operate, types NOT BLOCKED.

          TEST
                    Adds an undo-block at the front of UNDOLST.

Note that TEST together with !UNDO  provide  a  'tentative'  mode  for
editing, i.e., the user can perform a number of changes, and then undo
all of them with a single !UNDO command.

          ?? 
                    Prints  the  entries  on UNDOLST.  The entries are
                                                                   165


                    listed  in  the  reverse order of their execution,
                    i.e., the most recent entry first.  For example:

    #P
    (CONS (T &) (& &))
    #(1 COND) (SW 2 3) P
    (COND (& &) (T &))
    #??
    SW (1 --)
    #



22.25. Editdefault


Whenever a command is not recognized,  i.e.,  is  not  'built  in'  or
defined as a macro, the editor calls an internal function, EDITDEFAULT
to  determine  what  action  to  take.  If a location specification is
being executed, an internal flag  informs  EDITDEFAULT  to  treat  the
command as though it had been preceded by an F. 

If the command is atomic and typed in directly, the procedure followed
is as given below.

   - If  the  command is one of the list commands, i.e., a member
     of EDITCOMSL, and there is  additional  input  on  the  same
     teletype  line,  treat  the  entire  line  as  a single list
     command.  (Uses LINEREAD.  Thus the line can  be  terminated
     by  carriage return, right parenthesis or square bracket, or
     a list.) Thus, the user may omit parentheses  for  any  list
     command  typed  in  at  the  top level (which is not also an
     atomic command, e.g., NX, BK).  For example:

         #P
         (COND (& &) (T &))
         #(XTR 3 2)
         #MOVE TO AFTER LP
         #

     If the command is on the list EDITCOMSL  but  no  additional
     input is on the teletype line, an error is generated, e.g.,

         #P
         (COND (& &) (T &))
         #MOVE


         MOVE ?
         #

   - If the last character in the command is P, and the first n-1
     characters  comprise  the command __, _, UP, ^, NX, BK, !NX,
     UNDO, or REDO, assume that the user intended  two  commands,
     e.g.,
                                                                   166


         #P
         (COND (& &) (T &))
         #2 NXP
         (T (CONS X Y))

   - Otherwise, generate an error.



22.26. Editor Functions


          (EDITL L coms atm marklst mess)
                    EDITL  is  the  editor.  Its first argument is the
                    edit chain, and its value is an edit chain, namely
                    the value of L at the time EDITL is exited.  (L is
                    a special variable, and so can be examined or  set
                    by edit commands.  For example, ^ is equivalent to
                    (E (SETQ L(LAST L)) T).)

                    Coms  is  an  optional  list  of  commands.    For
                    interactive editing, coms is NIL.  In  this  case,
                    EDITL  types  EDIT:  and then waits for input from
                    the teletype.  (If mess is not NIL EDITL types  it
                    instead  of EDIT:.  For example, the TTY:  command
                    is essentially (SETQ L (EDITL L NIL NIL NIL (QUOTE
                    TTY:))).)  Exit occurs only via an  OK,  STOP,  or
                    SAVE command.

                    If  coms is NOT NIL, no message is typed, and each
                    member  of  coms  is  treated  as  a  command  and
                    executed.   If an error occurs in the execution of
                    one of the commands, no error message is printed ,
                    the rest of the commands are  ignored,  and  EDITL
                    exits  with an error, i.e., the effect is the same
                    as though a STOP command had been  executed.    If
                    all  commands  execute successfully, EDITL returns
                    the current value of L. 

                    Marklst is the list of marks.

                    On calls from  EDITF,  Atm  is  the  name  of  the
                    function  being  edited;  on calls from EDITV, the
                    name of the variable, and calls  from  EDITP,  the
                    atom  of  which some property of its property list
                    is being edited.  The property list of atm is used
                    by the SAVE command for saving the  state  of  the
                    edit.  Thus SAVE will not save anything if atm=NIL
                    i.e., when editing arbitrary expressions via EDITE
                    or EDITL directly.

          (EDITF x)
                    FSUBR function for editing a function.  (CAR x) is
                    the name of the function, (CDR x) an optional list
                    of  commands.   For the rest of the discussion, fn
                                                                   167


                    is (CAR x), and coms is (CDR x).

                    If  x  is NIL, fn is set to the value of LASTWORD,
                    coms is set to NIL, and the value of  LASTWORD  is
                    printed.

                    The value of EDITF is fn.

   - In the most common case, fn is an non-compiled function, and
     EDITF  simply  performs  (EDITE (CADR (GETL fn (QUOTE (FEXPR
     EXPR MACRO)))) coms fn) and sets LASTWORD to fn.

   - If fn is not an editable function, but has  a  value,  EDITF
     assumes  the  user meant to call EDITV, prints =EDITV, calls
     EDITV and returns.

   - Otherwise, EDITF generates an fn NOT EDITABLE error.

          (EDITE expr coms atm)
                    Edits an  expression.    Its  value  is  the  last
                    element  of  (EDITL (LIST expr) coms atm NIL NIL).
                    Generates an error if expr is not a list.

          (EDITV editvx)
                    FSUBR function,  similar  to  EDITF,  for  editing
                    values.    (CAR  editvx) specifies the value, (CDR
                    editvx) is an optional list of commands.

                    If editvx is NIL, it is set to the value of (NCONS
                    EDITV) and the value of EDITV is printed.

If (CAR editvx) is a list, it is evaluated  and  its  value  given  to
EDITE,  e.g.    (EDITV (CDR (ASSOC (QUOTE FOO) DICTIONARY)))). In this
case, the value of EDITV is T. 

However, in most cases, (CAR editvx) is a variable, e.g.  (EDITV FOO);
and EDITV calls EDITE on the value of the variable.

If the value of (CAR  editvx)  is  atomic  then  EDITV  prints  a  NOT
EDITABLE error message.

When  (if)  EDITE  returns,  EDITV  sets  the  variable  to  the value
returned, and sets EDITV to the name of the variable.

The value of EDITV is the name of the variable whose value was edited.

          (EDITP x)
                    FSUBR  function,  similar  to  EDITF  for  editing
                    property lists.  Like EDITF, LASTWORD is used if x
                    is NIL.  EDITP calls EDITE on the property list of
                    (CAR  x).  When (if) EDITE returns, EDITP RPLACD's
                    (CAR x) with the value returned, and sets LASTWORD
                    to (CAR x).

                    The value of EDITP is the atom whose property list
                                                                   168


                    was edited.

          (EDITFNS x)
                    FSUBR  function,  used to perform the same editing
                    operations on  several  functions.    (CAR  x)  is
                    evaluated  to obtain a list of functions.  (CDR x)
                    is a list of edit commands.  EDITFNS maps down the
                    list  of  functions,  prints  the  name  of   each
                    function, and calls the editor (via EDITF) on that
                    function.

For example, (EDITFNS FOOFNS (R FIE FUM)) will change every FIE to FUM
in each of the functions on FOOFNS.

                    The  call  to  the  editor is ERRSET protected, so
                    that if the editing  of  one  function  causes  an
                    error, EDITFNS will proceed to the next function.

Thus  in  the above example, if one of the functions did not contain a
FIE, the R command would cause an error, but  editing  would  continue
with the next function.

                    The value of EDITFNS is NIL 

          (EDIT4E pat y)
                    Is  the  pattern match routine.  Its value is T if
                    pat matches  y. See  pp.  130  for  definition  of
                    'match'.

Note:    before each search operation in the editor begins, the entire
pattern is scanned for atoms or strings that end in at-signs.    These
are replaced by patterns of the form

    (CONS (QUOTE /@) (EXPLODEC atom)).

Thus  from  the standpoint of EDIT4E, pattern type 5, atoms or strings
ending in at-signs, is really "If car[pat] is the  atom  @  (at-sign),
PAT will match with any literal atom or string whose initial character
codes (up to the @) are the same as those in cdr[pat]."

If  the user wishes to call EDIT4E directly, he must therefore convert
any patterns which contain atoms or strings ending in at-signs to  the
form recgnized by EDIT4E.  This can be done via the function EDITFPAT.

          (EDITFPAT pat flg)
                    Makes  a  copy  of pat with all patterns of type 5
                    converted to the form expected  by  EDIT4E.    Flg
                    should be passed as NIL (flg=T is for internal use
                    by the editor).

          (EDITFINDP x pat flg)
                    Allows a program to use the edit find command as a
                    pure  predicate  from outside the editor.  X is an
                    expression, pat a pattern.  The value of EDITFINDP
                    is T if the  command  F  pat  would  succeed,  NIL
                                                                   169


                    otherwise.    EDITFINDP  calls EDITFPAT to convert
                    pat to the form expected by EDIT4E, unless  flg=T.
                    Thus,  if  the  program  is  applying EDITFINDP to
                    several  different  expressions  using  the   same
                    pattern,   it  will  be  more  efficient  to  call
                    EDITFPAT once, and then call  EDITFINDP  with  the
                    converted pattern and flg=T.

          (EDITRACEFN com)
                    Is  available  to help the user debug complex edit
                    macros,  or  subroutine  calls  to   the   editor.
                    EDITRACEFN is to be defined by the user.  Whenever
                    the  value  of  EDITRACEFN  is non-NIL, the editor
                    calls the  function  EDITRACEFN  before  executing
                    each  command  (at  any  level),  giving  it  that
                    command as its argument.

For example, defineing EDITRACEFN as

    (LAMBDA (C) (PRINT C) (PRINT (CAR L)))

will print each command  and  the  corresponding  current  expression.
(LAMBDA  (C)  (BREAK1  T  T  NIL  NIL  NIL)) will cause a break before
executing each command.

                    EDITRACEFN  is  initially  equal   to   NIL,   and
                    undefined.
                                                                   170


                           23. The Compiler



Lisp functions are compiled for two reasons:

   - Compiled  code runs faster (from 5 to 20 times, according to
     one estimate).

   - Compiled  code  uses  less  space,  and  need  not   garbage
     collected.

For  many  people  the  second  reason is at least as important as the
first.

In the ideal case, all you have to do to compile a Lisp program is  to
run  the  compiler (usually called ELISPC) and say (COMPL "filename"),
where "FILENAME" is the name of the file in which your Lisp  functions
are  stored.    The result of this compilation is a file with the same
name, but the extension .FLAP.  You can load this file using DSKIN  or
LOADF  just  as you would any other file.  However at the moment, this
is not likely to work for most people.  Fortunately,  the  only  thing
most  people  are  likely  to  need  to  do  is  to  add  a  "SPECIAL"
declaration,  and  the  compiler  will  usually  tell  you  what  this
declaration should look like.  (Since it can go that far, you may ask,
why  not let it produce its own declaration without bothering you?  We
are working on that.)  We will first  give  a  description  of  why  a
SPECIAL  declaration  is  needed,  and then give you the heuristic for
producing one from the compiler's error messages.

Note that the compiler obeys the flag *RAISEDSK, so if you want  lower
case in your source file to be treated as upper case, set *RAISEDSK to
T before calling COMPL.



23.1. The Special Variable Problem


Here  is what is going on with "special variables": As you may recall,
in Lisp variables are bound dynamically.  That is,  the  following  is
perfectly legal:

    (DE TOP (X) (BOTTOM))

    (DE BOTTOM NIL (PRINT X))

BOTTOM  can  refer to the variable X because it is bound by TOP before
calling BOTTOM.  Unfortunately, for reasons  of  efficiency,  compiled
functions normally use static binding.  That is, a variable bound in a
function is accessible only within that function.  So if the above two
functions were compiled, BOTTOM would complain that X was unbound.

If  you want to refer to a variable in one function and it is bound in
another, you must specifically ask the compiler to use dynamic binding
                                                                   171


for that variable.  You do that with a special declaration:

    (SPECIAL X VAR !FILENAMES)

This  declares the variables X, VAR, and !FILENAMES to be special.  It
should go at the top level of  your  program  (i.e.  not  inside  some
function  definition)  somewhere.    In  the  interpreter,  SPECIAL is
ignored, since all variables are bound dynamically there.

You should develop the habit of thinking of your variables  as  coming
in  two types:  global and local.  A local variable is accessible only
inside the function in which it is bound (by being an argument  or  by
being  mentioned  in  a  PROG).  A global variable is one that will be
accessed more generally.  Global variables in this sense are the  ones
that  need  SPECIAL  declarations.   Many people make a habit of using
some special naming convention for special variables, such as starting
the name with an exclamation point.

The good news is that in many cases the compiler will  tell  you  what
all  of  your  special  variables  are.   Whenever it finds a function
refering to a variable that is not local to that  function,  it  gives
you a message such as

    *** XVARS declared fluid in TOPPROC

where  XVARS  is  the  variable  name  and  TOPPROC is the name of the
function in which it was found.  Usually you can just collect  all  of
the  variable names and make a special declaration from them.  However
there are some cases  where  the  compiler  will  not  detect  that  a
variable should be special.

   - If you call EVAL in your program, the compiler does not look
     at  the  argument  to  EVAL.    If  it  contains a non-local
     variable, that variable should be declared SPECIAL.

   - As a special case of the above, FEXPR's often have pieces of
     Lisp code as arguments, and call EVAL to execute them.  Code
     that is passed to FEXPR's should be examined  for  non-local
     variable  references.  Note that FEXPR's that are built into
     the system,  such  as  the  MAPxxx  functions,  are  handled
     specially by the compiler and do not have this problem.

   - In  general,  any piece of Lisp code that is quoted with a '
     will not be looked at by the  compiler.    If  it  has  non-
     locals,  they must be special.  Code that is quoted with the
     special form FUNCTION will be compiled by the compiler,  and
     is  treated  as  if it were part of the function in which it
     appears.
                                                                   172


23.2. The Function Declaration Problem


In  addition  to  knowing  about special variables, there is one other
major kind of  knowlege  needed  by  the  compiler:    knowlege  about
functions.    Whenever  it compiles a call to a function, the compiler
must know what kind of function it is (EXPR, FEXPR,  MACRO),  and  how
many arguments it requires.  For this reason, the compiler is designed
as  a two pass compiler.  The first pass goes over the whole file, and
all other files on which it depends, in order to find out what all the
functions are. Thus in pass two, it knows  how  to  call  all  of  the
functions.

Note  that  for this strategy to work, the compiler must scan not only
the file  that  is  being  compiled,  but  also  any  file  containing
functions  that  are going to be called from it.  For this reason, the
compiler produces a file with extension .LDC  containing  declarations
for  all  functions  in the file.  That is, if you compile COMPLR.LSP,
the compiler will automatically produce a file  COMPLR.LDC  containing
declarations  of all functions defined in COMPLR.LSP.  This allows the
compiler to quickly find the definitions of these functions when it is
compiling any other file  designed  to  be  used  with  the  functions
defined in COMPLR.LSP.

To be more concrete, here is the way the declaration mechanism works:

   - When  compiling  a  file,  say  NEW.LSP, the first thing the
     compiler does is to look at the whole file and make  a  list
     of  all  functions declared in it.  It writes a file NEW.LDC
     containing all of these declarations, and remembers them  in
     memory.

   - While  doing  this  first pass, the compiler makes a list of
     any files required by the file it is compiling.   These  are
     files mentioned in DSKIN or REQUIRE statements.

   - Once  it  has  finished  the  first  pass  on the file being
     compiled, it goes over the list of all  files  mentioned  in
     DSKIN  or  REQUIRE.  For each one, it looks for a .LDC file.
     If it finds one, it takes the  declarations  from  the  .LDC
     file.  If not, it runs pass one over the file itself to find
     all declarations (and make a .LDC file for future use).

   - During  this  scan  of  other  files,  any  DSKIN or REQUIRE
     statements that it finds there cause the files mentioned  to
     be added to the list of files to be scanned.

The  net  result of this strategy is that the compiler will know about
all relevant functions, as long as you make sure to mention any  files
associated  with  the  file, either in a DSKIN or a REQUIRE statement.
REQUIRE is a special statement used just for this purpose.  It has  no
effect  if  you  try  to  execute it.  It is just a declaration to the
compiler that this file uses functions declared in another file.

Note that the compiler keeps track of the files that it has looked at,
                                                                   173


so  you  need  not  worry  about causing an endless loop by having two
files mention each other.



23.3. Special Considerations Involving MACRO's


If you use MACRO's, you are  probably  going  to  have  to  give  some
thought  to  compilation.   The problem is that macros are executed by
the compiler during compilation.  If you define a macro in a file  you
are  compiling,  that  macro  definition  will  be saved and processed
properly during compilation.  The difficulty occurs if  executing  the
macro  calls any functions or macros that are not built into Lisp.  It
is not enough that such functions also  occur  in  the  file  you  are
compiling.  The  compiler  does not actually load the functions in the
file it is compiling.  You will have to take  special  precautions  to
make  sure  that  any such functions or macros are DSKIN'ed as well as
compiled by the compiler.

Let us consider an example:

    (DM XMAC (L) (CONS 'XYZ (CDR L)))

    (DM YMAC (L) (XMAC L))

    (DE FOO (X) (YMAC X))

If you compile this, the following things need to happen:

   - XMAC will be compiled and put into the LAP file as an MSUBR

   - YMAC will be compiled and put into the LAP file as an MSUBR.
     Since YMAC uses XMAC, this compilation process will actually
     EXECUTE the macro XMAC.  This will work.

   - FOO will be compiled and put into the LAP file  as  a  SUBR.
     Since  FOO uses YMAC, this compilation process will actually
     EXECUTE the macro YMAC.  This will not work.

It is important to realize that the process  of  compiling  this  file
requires  the compiler to actually interpret the macros XMAC and YMAC.
The macro XMAC is no  problem,  because  it  uses  only  builtin  Lisp
functions,  namely  CONS  and  CDR.  However the macro YMAC uses XMAC,
which will not be defined.  You may wonder how  it  can  be  that  the
compiler  can  find XMAC when compiling YMAC, but can't find XMAC when
attempting to evaluate YMAC.  The answer is that this is a  difference
between  compilation  and  evaluation.  When the compiler sees XMAC in
the source file, it remembers it for later use in compilation, but  it
does not actually add it to the core image as a macro, as would happen
if  the  file had been read with DSKIN.  Thus if XMAC occurs in a form
being compiled, it will be expanded.  But if it occurs in a form being
executed, it will not be found.  So in order for the above file to  be
compiled  properly,  you  must  define  XMAC  in the core image before
compiling the file.  You need not define YMAC, since  it  is  expanded
                                                                   174


but  never  executed.    Here  would  be  one  way  to  organize  this
compilation:

    File X.LSP:

       (DM XMAC (L) (CONS 'XYZ (CDR L)))

    File FOO.LSP:

       (DSKIN "X.LSP")

       (DM YMAC (L) (XMAC L))

       (DE FOO (X) (YMAC X))

    Compilation process:

       (DSKIN "X.LSP")
       (COMPL "FOO.LSP")

    Loading an interpreted copy:

       (DSKIN "FOO.LSP")


In many cases, it is more  convenient  to  put  all  macros  into  the
separate  file,  and  not  worry  about  exactly which ones need to be
defined in the core image for execution to work.   Indeed  many  users
load  a  file  containing  all of their macros in their ELISP.INIT and
ELISPC.INIT files.  If you do that,  then  you  will  never  have  any
problem.



23.4. Summary - How to Use the Compiler


Look at the file to be compiled.

   - If it uses functions declared in other files, make sure that
     these   other  files  are  mentioned  in  DSKIN  or  REQUIRE
     statements.

   - Make sure that any special variables are declared in SPECIAL
     declarations.

   - If it uses any macros, make sure that you load all functions
     needed for the macros to execute.

Once you have done this, run the compiler (ELISPC.EXE) and type

    (COMPL "PROG.LISP")

where of course you use the name  of  your  own  file.    When  it  is
finished, COMPL will return NIL.  At that point, you will find two new
                                                                   175


files:    PROG.FLAP and PROG.LDC.  PROG.LDC contains declarations, and
is used by the compiler as described above.  PROG.FLAP is  the  actual
output  of the compiler.  The .FLAP file contains both text and binary
data.  It is meaningful only to the FLAP  function,  which  is  called
automatically by DSKIN when it detects a FLAP file.

The  intention  is that the .FLAP file will produce the same effect as
the original file if  you  load  it  with  DSKIN.    That  is,  (DSKIN
"PROG.FLAP")  will  define  the  same functions as (DSKIN "PROG.LSP"),
except that they will now be compiled.  Anything in the original  file
that  was  not  a  function  definition will simply be copied into the
.FLAP file.  The major differences you should observe after loading  a
.FLAP file are the following:

   - Your program should run faster

   - You will no longer be able to edit the functions, since they
     have  now  been compiled to machine language.  However TRACE
     and BREAK should still work.  Note that  when  you  TRACE  a
     compiled  function,  the  system  will ask you for a list of
     argument names for the function.

Should you want to debug a function that has been compiled, we suggest
that you read its definition  from  the  original  source  file  using
GETDEF.



23.5. Special forms for the compiler


The  following  forms can be used to control what is compiled and what
is interpreted.

     (DECLARE exp1 exp2 ...) - This is used for things that  you  only
          want  the compiler to see.  That is DECLARE is equivalent to
          NILL in the interpreter, causing  the  forms  inside  to  be
          ignored,  but  in the compiler the (DECLARE and ) vanish and
          the forms inside are looked at normally.

     (NOCOMPILE exp1 exp2 ...) - This is used for things that you only
          want the interpreter to see.  This is, it is  equivalent  to
          PROGN  in the interpreter, but it is treated as a comment by
          the compiler.  Note that nothing is put into the .LAP file.

     (PROGN exp1 exp2 ...) - This is a slightly less  extreme  version
          of NOCOMPILE.  Things inside a PROGN are not compiled by the
          compiler, but the PROGN with everything in it is copied into
          the .LAP file without being compiled.

The  following forms are compiler declarations of various sorts.  They
are all ignored by the interpreter.

     (REQUIRE file1 file2 ...) - This  tells  the  compiler  that  the
          current  file  is  designed to be used with these files.  It
                                                                   176


          will  look for .LDC files for them, or scan them if they are
          not found.

     (SPECIAL var1 var2 ...) - This declares variables as special

There are two additional forms that were used by Rutgers/UCI Lisp  and
are  now  obsolete:  NOCALL  and  NOUUO.   These are legal but have no
effect.



23.6. Other problems with compilation


In addition to the major problems mentioned  above,  there  are  other
more  minor  problems  with  compiling  code.    The following list is
probably not complete, but will be added  to  as  cases  come  to  our
attention:

   - GO  -  In  the interpreter, the argument to GO is repeatedly
     evaluated until an atom is found.  Thus  you  can  have  (GO
     (CAR  X)) and if (CAR X) is the name of a label, the program
     goes there.  CAR X can even return  another  piece  of  Lisp
     code,  in  which case it will again be evaluated.  This goes
     on until an atom is found.  It is hard to  know  how  to  do
     this in the compiler.  Thus it will evaluate the argument to
     GO  at most once.  So (GO LOOP) will work if LOOP is a label
     in the PROG.  And (GO (CAR X)) will work if (CAR X) gives an
     atom which is a label in the PROG.  But no more  evaluations
     that this will be done.

   - GO  and RETURN - these are legal only inside PROG's.  In the
     interpreter, you can sometimes get away with doing a GO or a
     RETURN from a function  that  is  called  by  a  PROG.    In
     compiled  code,  this will not work, and these forms must be
     used only within a PROG.

   - ARG and SETARG - these are legal only inside  LEXPR's.    In
     the  interpreter, you can sometimes get away with using them
     in a function that is called by an LEXPR.  In compiled code,
     this will not work, and these forms must be used only within
     an LEXPR.

   - odd functional forms - ELISP allows a fairly  large  variety
     of  things  to appear as the CAR of a function call.  By far
     the most common is the name of a function, e.g. (CONS A  B),
     where CONS is a function name.  Such a form is compiled into
     a  direct  call  to  the  function mentioned.  Anything else
     requires more work.  A Lambda form, e.g.

         ((LAMBDA (X) (CONS X 'A)) Y)

     is also handled reasonably efficiently.  The lambda form  is
     compiled and then a call to the compiled form is used.  What
     is harder to handle is things that return functions. E.g
                                                                   177


         ((CAR X) Y)

     where  (CAR  X)  is  supposed to evaluate to either a lambda
     form or the name of a  function.    Obviously  the  function
     evaluation  here  must  be  done  at run time.  Thus this is
     compiled as a call to APPLY:

         (APPLY (CAR X) (LIST Y))

     If (CAR X) returns a form, it will of course be interpreted,
     not compiled.  So if it contains any  references  to  global
     variables,  they  must be declared SPECIAL.  Finally we have
     the case of

         (FOO X Y)

     where FOO is a variable that is  bound  to  the  name  of  a
     function.    The  problem  is  that  the compiler can't tell
     whether FOO is being used  as  a  variable,  or  is  just  a
     function  that  it  doesn't  know  about.  If FOO is a local
     variable, then it is obviously being used as a variable, and
     the compiler compiles this as

         (APPLY FOO (LIST X Y))

     However if FOO is not a local variable,  then  the  compiler
     must  make an assumption. In fact it compiles the call as if
     FOO were a function.  Since it  doesn't  know  the  function
     type  or  number of arguments, the compiler assumes it is an
     EXPR with 2 arguments (the number actually supplied).  If it
     turns out at runtime that there is no function FOO, then the
     interpreter intervenes and in effect calls APPLY internally.
     This will find the function definition if FOO is in  fact  a
     variable  bound  to  a  function  (assuming that it has been
     declared SPECIAL).  Again, if FOO evaluates to a Lisp  form,
     it  will be interpreted, and any global variables used in it
     must have been declared SPECIAL. It  should  be  clear  that
     there  is somewhat more overhead to a call of this sort than
     to a normal function call.  If this is what you intend,  you
     are probably better off calling APPLY yourself.
                                                                   178


                   24. The Evaluation Context Stack



When  you  bind  a  variable  in  Lisp,  the interpreter saves the old
binding on the "evaluation context stack".   This  stack  consists  of
pairs  of  items.    The first item of each pair is the variable being
rebound. The second is its old value.  When you exit from a  function,
the  old  values  are  restored by going up the stack.  In addition to
these saved bindings, there are  entries  whose  first  item  is  NIL.
These  are  called  "EVAL blips".  An eval blip is created whenever an
expression is evaluated. The first item is NIL, and the second item is
the expression being evaluated.  Saving all the  expressions  in  this
way  makes  it  possible  to  have  debuggers  that look around at the
context.

One of the most useful things you can do with an index is to  evaluate
something  in the context of some routine lower down in the stack (one
of your callers).  For this purpose EVAL and APPLY can take  an  extra
argument  that  is  a  stack  index.    The  stack will be temporarily
"unwound" to that point, the EVAL or APPLY  will  be  done,  and  then
everything  will  be  restored.   The effect is that the bindings used
inside the EVAL or APPLY are those that were in effect when that index
was at the top of the stack.  0 can always  be  used  to  specify  the
global context. Note that moving around the stack like this can take a
noticable amount of CPU time and memory.

One  way  of  getting  a  stack  index  is  to use an extra feature of
FEXPR's:  In the documentation above I said  that  an  FEXPR  has  one
argument.  Actually it can have a second argument. If one is supplied,
this  will  be bound to the stack index of the EVAL blip corresponding
to the FEXPR's function call.  The main use of this is  to  allow  the
FEXPR  to look at variables in the context of its caller. E.g. suppose
you have an FEXPR

    (df foo (args index) ...

Since FEXPR's get the unevaluated list of arguments, you often want to
evaluate them.  Thus you will likely see code like (EVAL (CAR  ARGS)),
to  get  the  value  of  the  first argument.  This is fine unless the
argument happens to be called ARGS or INDEX.  In that  case  you  will
get  the  ARGS  or  INDEX  from FOO, not from the caller, as intended.
However if you use INDEX you  specifically  ask  that  (CAR  ARGS)  be
evaluated  in your caller's context rather than your own.  In fact the
context is an optional argument to EVAL, so you would say  (EVAL  (CAR
ARGS) INDEX).

A  second  way  of  getting  a  stack  index  is  to call the function
*FUNCTION.   *FUNCTION  produces  a  structure  of  the  form  (FUNARG
function  . index).  E.g. if done at the top level, (*FUNCTION (LAMBDA
NIL (PRINT X))) would return

    (FUNARG (LAMBDA NIL (PRINT X)) . 0)

The interpreter allows a FUNARG to be used as a function.  The  effect
                                                                   179


of calling one is to first reset the stack pointer to the index there,
and  then  call  the  function.    Thus  you can call the funarg above
anywhere in your program, and it will always print the value of  X  as
it was at level 0 on the stack, which happens to be the global level.

There  are  a  number  of  functions  for looking at and changing this
stack.  They all work with stack indices.  A stack index  is  a  small
number. The first (lowest) pair on the stack is numbered 1, the second
2, etc.  These are integers, not actual addresses or Lisp pointers.

Currently  there  is a function SPDLPT that tells you the index of the
top of the stack, and functions for looking at the stack:

    SPDLPT          - give the index to the current top of stack
    SPDLFT (index)  - give the first item of a pair
    SPDLRT (index)  - give the second item of a pair
    NEXTEV (index)  - find the next EVAL blip on the stack
    PREVEV (index)  - find the previous EVAL blip on the stack
    STKPTR (index)  - pointer to (SPDLFT.SPDLRT),. pseudo-CONS
    STKCOUNT (name index1 index2) - no. of EVAL blips with name
    STKNAME (index) - for EVAL blips gets name of atom or function
    STKNTH (n index) - Nth Eval-blip from INDEX
    STKSRCH (name index flag) - searches for EVAL blip with name
    FNDBRKPT (index) - find Eval-block that Index is in

In addition, once you have an index, you can do various things in  the
context set by it:

    OUTVAL (index value) - return that value from that point
    SPREDO (index)  - adjust there and reevaluate what is there
    SPREVAL (index form) - eval form in that context and return
    EVALV (atom index) - find value of atom in that context
    RETFROM (function val) - return val from call to function

See the alphabetical list for details



24.1. A-lists as Contexts


Sometimes  you  want  a  function  to  work  with its own local set of
variables, which do not interact with any other variables by the  same
name  elsewhere  in the program.  You can do this by setting up an "A-
list".    An  A-list  is  a  list  of  pairs,  (variable.value),  e.g.
((A.X)(B.(X X))(C.34)). This A-list specifies values for the variables
A,  B, and C, namely X, (X X), and 34.  You may pass an A-list to EVAL
or APPLY as an optional extra argument (instead  of  a  context  stack
index).  In this case, EVAL will bind the variables on the list to the
specified  values,  and  then  do  its  normal  evaluation.  So during
execution of the EVAL, the values you specified will  be  used.    The
usefulness  of this feature is limited by the fact that any new values
assigned to these variables are not put back into the A-list.
                                                                   180


             25. Descriptions of the Individual Functions



(ABS n) [SUBR] --> absolute value of n

(ACOS number) [SUBR] --> real
          Take  the  arc  cosine  of a number of any type, in radians.
          Returns a real  number.    Because  of  limitations  of  the
          underlying  Fortran  function, the calculation is done using
          only 27 bits of precision in the mantissa.  To use this, you
          must have loaded the Arithmetic Package, q.v.  

(AEXPLODE thing) [SUBR] --> list of numbers
          AEXPLODE is a variant of EXPLODE.  Both of these effectively
          does PRIN1 of its argument, except instead  of  putting  the
          resulting  characters  into  a file, it makes a list of them
          and returns the list.  The difference is that with  EXPLODE,
          each  character  is  represented  as  a  one-character atom,
          whereas with AEXPLODE, each character is  represented  as  a
          number which is its ASCII value.

              (EXPLODE 'ABC) --> (A B C)
              (AEXPLODE 'ABC) --> (65 66 67)

          Because  of  a  peculiarity  in READLIST, AEXPLODE turns the
          numbers 0 to 9  (which  represent  control  characters  from
          control-@  to control-I) into 128 to 137 (200 to 211 octal).
          

(AEXPLODEC thing) [SUBR] --> list of numbers
          Like AEXPLODE but uses PRINC instead of PRIN1 to  print  the
          thing.

(ALIAS atom function-definition) [SUBR] --> the function definition
          Makes  the  atom  be  a  name  for  this  function. Puts the
          function definition in the appropriate  slot  in  the  atom.
          The  function  definition is a list that begins with the tag
          for its type. This is  one  of  EXPR,  FEXPR,  MACRO,  SUBR,
          FSUBR.   For EXPR, FEXPR, and MACRO, the list continues with
          the body, as a LAMBDA, e.g.

              (EXPR LAMBDA (X) (PRINT X))

          The format of SUBR and FSUBR  arguments  is  explicitly  not
          defined.  However you can use what FUNDEF returns.

          If  the  definition is a LAMBDA form, ALIAS will look at the
          formal parameter list and verify that all of the  parameters
          are  atoms, and none are NIL or T. This allows this checking
          to be skipped by EVAL, and speeds things up a  bit.    ALIAS
          also  sets  up a dispatch address within the atom, depending
          upon the function type and the number of  arguments.    This
          speeds  up  interpretation  considerably.   For this reason,
          once a function has been defined with ALIAS, if  you  should
                                                                   181


          not  change its type or the number of parameters, you should
          call ALIAS again.  (I.e. don't use RPLACA and RPLACD on  the
          formal  parameter  list  of a function without calling ALIAS
          when you are finished.)

          If  FUNCTION-DEFINITION  is  NIL,   the   function   becomes
          undefined.  

(ADD1 number) [SUBR] --> the number + 1

(ADDPROP atom value property) [EXPR] --> new value
          This  is  used to maintain properties that are lists.  It is
          presumed that (GET atom property)  is  a  list.    VALUE  is
          ENTER'ed  to the list, i.e. it is CONS'ed onto the beginning
          if it isn't already a member of the list.  This new list  is
          then put back as the new value of the property.  

(AND expr1 expr2 .. exprn) [FSUBR] --> NIL or value of formn
          Evaluates  expressions  until it sees one that is false.  If
          one is false, it returns NIL.  Otherwise it  returns  formn.
          In  addition to its obvious use in Boolean expressions, this
          is perfectly usable as a control structure (it is a slightly
          modified version of PROGN).

ALLFILES - variable
          A list of all files known to LOADF/SAVEF/FILES?.  A list  of
          dotted   pairs   in   the  form  (("PS:<HEDRICK>TEST.LSP"  .
          TESTFNS)), i.e. file name and variable.    The  variable  is
          assumed  to  contain  prettyprint  commands to reproduce the
          file.  At the moment these commands should use (F:  xx)  for
          functions,   (ST:   xx)  for  structure,  and  (V:  xx)  for
          variables.  Use NEWFILE to add things to ALLFILES.   Do  not
          edit  ALLFILES  directly,  because  its  exact  structure is
          subject to change without notice.  

ALLFNS - variable
          A list of all functions that have changed  since  they  were
          last  read.    Only functions defined with DE, DF, or DM are
          put here.

ALLSTRS - variable
          A list of all structure definitions that have changed  since
          they  were  last  read.  Only structures defined with DS are
          put here.  

ALLVALS - variable
          A list of all variables that have changed  since  they  were
          last read.  Only variables set with DV are put here.  

(ANTHCHAR thing N) [SUBR] --> a number
          Returns  the  Nth character in the printed representation of
          THING.  It is exactly like NTHCHAR  (including  the  use  of
          negative  numbers  to  count  from the end), except that the
          ASCII code is  returned  as  an  integer,  rather  than  the
          character  itself.    THING  is  assumed  to be printed with
                                                                   182


          PRINC.  

(*APPEND list1 list2) [SUBR] --> new list
          Special  version of APPEND that only works with 2 arguments.
          Possibly it is slightly faster in this case.  

(APPEND list1 list2 ... listn) [LSUBR] --> new list
          Concatenates the lists, copying all but the last.  

(APPLY  function  arglist  context)  [SUBR]  -->  value  returned   by
                    function.
          This  is  a  variant  of  APPLY, which is more convenient in
          certain cases.  (APPLY 'X '(A B)) is more or less equivalent
          to (EVAL '(X 'A 'B)).  See the description  of  EVAL.    The
          first  argument  (FUNCTION)  is  treated  just  as  in EVAL,
          including repeated evaluation as necessary to come up with a
          function atom or functional constant.  The  second  argument
          is  taken  to be a list of arguments to the function.  It is
          treated as appropriate to the binding type.

               EXPR's and functional constants (the usual case) -  the
                    arguments   are   bound  to  the  formals  of  the
                    function.  Note that they are  not  evaluated,  as
                    they would be by EVAL.  That is why passing '(A B)
                    as  a second parameter results in A and B (not the
                    values of A and B) being used as the arguments.

               FEXPR's - the second argument to APPLY is bound to  the
                    first  formal of the FEXPR.  That is, if FOO is an
                    FEXPR, (APPLY 'FOO '(A B)) is equivalent to (FOO A
                    B).  This is theoretically unclean, but needed for
                    compatibility with Rutgers/UCI Lisp.

               MACRO's - the first argument to APPLY is  CONS'ed  onto
                    the  beginning of the second argument, and this is
                    bound to the formal of the MACRO.  That is, if FOO
                    is a MACRO, (APPLY 'FOO '(A B)) is  equivalent  to
                    (FOO  A  B).   This is unclean in the same way and
                    for the same reason as with FEXPR's.

          The third argument is optional, and is a binding context  or
          A-list.  It is handled as in EVAL.  

(*APPLY function arglist) [SUBR] -- value returned by function
          The  internal  form  of  APPLY.    It  does  not  understand
          contexts.  Otherwise it is identical.  (APPLY  calls  *APPLY
          to do the actual evaluation.)  

(APPLY# function arglist) [SUBR] --> value returned by function.
          This  function  is  identical to *APPLY.  It is present only
          for compatibility with R/UCI Lisp.  

Arithmetic Package
          There is a special package  which  loads  various  functions
          from  the Fortran library.  To use these functions, you must
                                                                   183


          first do


              (DSKIN "ELISP:EARITH.LSP")



          If  you  get  odd results, such as illegal memory reference,
          please make sure  that  ELISP:ELISP.REL  refers  to  version
          corresponding  to  the version of ELISP you are using.  E.g.
          if you are using NEW:ELISP,  make  sure  that  your  logical
          definition of ELISP:  includes NEW:.

          Once   you   have  done  it,  the  following  functions  are
          available:  ACOS, ASIN, ATAN, COS, COSD, COSH,  EXP,  FLOAT,
          LOG,  LOG10,  RANDOM, SETRAN, SAVRAN, SIN, SIND, SINH, SQRT,
          TANH.  Where possible, double precision  versions  of  these
          functions  are  used,  since  Lisp  real numbers are double-
          precision.  However there are a few functions for which  the
          Fortran  library does not contain double-precision versions.
          In this case, single precision is used.  This fact is  noted
          in the documentation of the individual functions.  

(ARG n) [SUBR] --> value of that argument
          ARG  is  used  inside  an  LEXPR to get the value of the Nth
          argument passed to the LEXPR.  SETARG can be used to  change
          the  value  of  an  argument.  ARG and SETARG are legal only
          inside an LEXPR.  

(ASCII n) [SUBR] --> character atom
          Takes a number and produces the character having that as its
          ASCII value.  That is, if N is the internal  numerical  code
          for  a  character,  ASCII  returns  the character.  What you
          actually  get  is  an  atom  whose  name  consists  of  that
          character.  ASCII and CHRVAL are inverses.

              (ASCII 101Q) --> A

(ASIN number) [SUBR] --> real
          Take  the  arc  sine  of  a  number of any type, in radians.
          Returns a real  number.    Because  of  limitations  of  the
          underlying  Fortran  function, the calculation is done using
          only 27 bits of precision in the mantissa.  To use this, you
          must have loaded the Arithmetic Package, q.v.  

(ASSOC atom alist) [SUBR] --> associated value
          An Alist is a data structure often used to store values  for
          various  atoms.    It  can  be  used  as  a  quick and dirty
          database.  Here is an example of an ALIST:

              ((A . X)  (P . (1 2 3))  (Y . ((X . 4))))

          This is a list of 3 pairs.  The CAR of each pair is as  atom
          and  the  CDR  is its associated value.  ASSOC takes an atom
          and looks at all the pairs.  If it finds one  whose  CAR  is
                                                                   184


          the   requested  atom,  it  returns  the  associated  value.
          Otherwise it returns NIL.  Note that this has nothing to  do
          with  the  value  that  an  atom  has  when  considered as a
          variable.  The Alist is your own data structure and  can  be
          used to make any associations you want.  

(ASSOC# thing alist) [EXPR] --> pair or NIL
          Similar  to  ASSOC, but uses EQUAL instead of EQ to test the
          CAR of each pair.  Thus it is appropriate to look for things
          other than atoms on a Alist.

(ASSOC-EQUAL thing alist) [EXPR] --> pair or NIL
          An obsolete name for ASSOC#.  

(ATAN number) [SUBR] --> real
          Take the arc tangent of a number of any  type,  in  radians.
          Returns  a  real  number.  To use this, you must have loaded
          the Arithmetic Package, q.v.  

(ATOM thing) [SUBR] --> T if it is some object on which  CAR  and  CDR
                    are not appropriate.
          At  the moment an ATOM is anything other than a pair such as
          is created by CONS.  However it is possible that some  other
          data  type  might  be  added  on  which CAR and CDR are also
          appropriate.  These would also be excluded from being  ATOM.
          

(ATTACH x l) [EXPR] --> new list
          ATTACH  destructively  attachs  <x> to the beginning of list
          <l>.  For example, after

              (SETQ L '(A))
              (ATTACH 'B L)

          L has value (B A).  If L is NIL,  ATTACH  is  equivalent  to
          CONS.

(BACK-QUOTE template) [MACRO]
          A  call  to BACK-QUOTE expands to code to copy the template,
          replacing pieces of it that use comma and double comma.  See
          Template Instantiation.    The  back-quote  character  `  is
          normally  defined  as a read macro that expands to a call on
          BACKQUOTE.  Most of the documentation is in terms of `.  

BASE - a variable.
          This is the current output radix.  It  can  be  any  integer
          from  2  to 10.  The user can change it, and it takes effect
          immediately. This radix is used for all integer output.    8
          (octal)  and  10  (decimal) are the usual choices. 10 is the
          default.  When  *NOPOINT  is  NIL,  a  point  is  put  after
          integers  to show their radix unambiguously.  For decimal, a
          dot is used.  For octal, a  Q  is  used.    Points  are  not
          available for other radices.

(BININ) [SUBR] --> integer
                                                                   185


          Returns the next byte from the currently selected file as an
          integer.   The processing that is normally performed for TYI
          is not performed.  That  is,  nulls  are  not  removed,  the
          linelength  counter  is  not advanced, there is no character
          editing, etc.  This is the only way to read  from  a  binary
          file,  since  TYI  truncates  its  output  to 7 bits. If the
          current input file is the terminal (the channel NIL),  8-bit
          binary  I/O  is  done  to the terminal.  This means that the
          parity bit will be included.

(BINOUT byte) [SUBR] --> byte
          Writes the byte specified to the  currently  selected  file.
          The  processing  that  is  normally performed for TYO is not
          performed.  That is, nulls are not removed,  the  linelength
          counter is not advanced, etc.  In addition, for the terminal
          (NIL)  the monitor's character processing is also done using
          8-bit binary I/O, so that control  characters  come  out  as
          themselves rather than as ^X or $.

(*BOOLE op n1 n2) [SUBR] --> integer
          Special  version  of BOOLE that only works with 3 arguments.
          This is obsolete.  It is still around because  the  compiler
          used  to  compile BOOLE into nested calls to *BOOLE.  When I
          think there are no old .FLAP files  around  any  more,  this
          will be removed.  

(BOOLE op n1 n2 ... ni) [LSUBR] --> integer
          BOOLE treats arguments Ni as bit vectors containing 36 bits.
          It  combines  them  using  bitwise operations.  OP specifies
          which operation to use.   E.g.  (*BOOLE  1  N1  N2)  does  a
          bitwise  AND  of  N1  and  N2.    *BOOLE is defined only for
          integers.  Here are  the  functions.    The  formulas  below
          specify  what  bit i of the result is as a function of bit i
          of A and B. Initially N1  and  N2  are  A  and  B. Then  the
          results of previous operations are A and each new Ni is B. 

              0       0                       8       -Ai AND -Bi
              1       Ai AND Bi               9       Ai EQ Bi
              2       -Ai AND Bi              10      -Ai
              3       Bi                      11      -Ai OR Bi
              4       Ai and -Bi              12      -Bi
              5       Ai                      13      Ai OR -Bi
              6       Ai NE Bi                14      -Ai OR Bi
              7       Ai OR Bi                15      1

(BOUNDP atom) [SUBR] --> T or NIL
          Returns  T if ATOM has been bound to a value, NIL otherwise.
          The concept of having a binding is dynamic.    That  is,  an
          atom may be bound at one point and not at another.  Here are
          the ways a binding is established:

             - When  you enter a function, all the parameters are
               bound to the arguments you passed.   The  previous
               bindings  of  the  parameters  are  saved.    If a
               parameter was previously  unbound,  that  fact  is
                                                                   186


               saved.    When you exit from the function, the old
               bindings are restored.  In the case of a parameter
               that was previously unbound, it  is  made  unbound
               again.

             - When  you enter a PROG, all the PROG variables are
               bound to NIL.  The previous bindings are saved  as
               above.    When  you  exit  from  the PROG, the old
               bindings are restored as above.

             - When you do SET  or  SETQ,  the  atom's  value  is
               changed.    If  it  was  previously unbound, it is
               bound to the new value.  Note that SET and SETQ do
               not save old bindings.

(BREAK functions) [FEXPR]
          This function is part of the debugging system.  It  is  used
          to insert breakpoints at function calls.  See section 21.5.2
          for details.  

(BREAKIN function location) [FEXPR]
          This  function  is part of the debugging system.  It is used
          to  insert  breakpoints  inside  functions,   using   editor
          commands.  See section 21.5.4 for details.  

(BREAK0 function when commands) [EXPR]
          This  function  is  used  by  the debugging system to insert
          breakpoints and to establish tracing.   See  section  21.5.7
          for details.  

(BREAK1 brkexp brkwhen brkfn brkcoms brktype) [EXPR]
          This  is  the  main  body  of  the break system itself.  See
          section 21.3 for details.  

(CAR cell) [SUBR] --> first item in cell
          The cell should be a dotted pair (CONS cell).  

(CATCH expr label) [FEXPR] --> value

(CATCH expr (l1 e11 . . .) (l2 e21 . . .) . . .) [FEXPR] --> value
          (THROW value label)

          CATCH  and  THROW  provide  a  more  convenient  method   of
          programming  transfers  to  a  higher  level  in the control
          hierarchy than ERRSET/ERR, which (as the names  imply)  were
          originally  designed  for error handling rather than planned
          (programmed) transfers.  CATCH simply evaluates <expr>,  and
          if  no  THROWs  are executed during that evaluation, returns
          the value of <expr>.  If a THROW is evaluated and the  CATCH
          has  no  <label>  then  the CATCH is immediately exited with
          <value> as its value (regardless of whether the THROW had  a
          <label> or not).  An unlabeled CATCH will thus catch a value
          thrown  by  any  THROW.  If the CATCH has a <label>, it will
          catch values thrown only by a THROW  with  the  same  label;
          other THROWs are passed on in search of a higher-level CATCH
                                                                   187


          with  a matching label.  Finally, a single CATCH can catch a
          variety of different THROWs via a SELECTQ-like mechanism  as
          shown  above.    Each  <l>  is either a <label> or a list of
          <label>s; if a THROW <lable> matches an <l> or a  member  of
          an  <l>,  the corresponding <e>s are evaluated and the value
          of the last one is returned as the value of the CATCH.    If
          no  labels  match,  the  THROW  is  passed on in search of a
          higher level CATCH.  Note that a missing  THROW  <label>  is
          equivalent  to  a <label> of NIL, and may be caught as such.
          It should be noted that CATCH and THROW  interact  with  the
          ERRSET  mechanism  -  a  THROW  will  not go past an ERRSET,
          although an ERR will go past a CATCH.  The variable THROW is
          used to pass the <value> from a THROW to a CATCH, and  CATCH
          is  used  to pass the <label>.  CATCH and THROW are compiled
          in-line.  

(CDR cell) [SUBR] --> second item in cell
          The cell should be a dotted pair (CONS cell).  

CAAR...CDDDR [EXPR]
          These are abbreviations of combinations of CAR and CDR. E.g.
          (CADDR X) is (CAR (CDR (CDR X))).  I.e. take the name  CADDR
          and break it up:  C   A D D   R.  Each of the middle letters
          corresponds  to  a call on CAR (if it is A) or CDR (if it is
          D).  

(CHRCT) [SUBR] --> current position on line
          The number of characters left on the current output  channel
          before  it  will  overflow  (i.e.  have more than LINELENGTH
          characters).  If  LINELENGTH  is  negative  (i.e.  unlimited
          length), CHRCT always returns the largest possible INUM.  

(CHRPOS) [EXPR] --> integer
          Returns  the  number  of  the next available print position.
          This is 1 if output is at the beginning of the line.  

(CHRVAL char) [SUBR] --> integer code for character
          Takes as its argument an  character  object,  i.e.  an  atom
          whose  name  is  interpreted  as  a  character.  Returns the
          internal ASCII code for the character.  E.g. (CHRVAL 'A)  is
          65,  the  ASCII  code  for A. CHRVAL and ASCII are inverses.
          Actually any atom or string will work.  The first  character
          of the print name is used.

(CLOSEF channel keep) [SUBR] --> the channel
          Closes an I/O channel.  This had better not be the currently
          selected  input or output channel!  Normally it is used with
          only one argument,  the  channel.    If  a  second,  non-NIL
          argument,  is  specified,  then  the channel continues to be
          associated with the file.   It  can  be  reopened  by  using
          OPENF,   renamed  by  RENAMEF,  etc.    CLOSEF  returns  NIL
          normally, but if the extra argument is specified, it returns
          the channel.  

(CLRBFI) [SUBR] --> NIL
                                                                   188


          Clears  any input that has been typed ahead on the terminal.


COMMA - an atom
          (COMMA  exp)  has  a  special  meaning  within   expressions
          processed  by  the macro BACKQUOTE.  See Template Instantion
          for details.  The comma character is normally defined  as  a
          read   macro   such   that  ,exp  expands  to  (COMMA  exp).
          Documentation is normally written in terms of the character.
          

COMMENTSTR - a variable
          If non-NIL  comments  will  be  compacted  (ie  turned  into
          strings).  This is used by PP-COMMENT (the comment printer).
          (?? Does READ...  pay attention to this)

(COMPILE function) [FEXPR] --> NIL
          NB: COMPILE is defined only in ELISPC.EXE. It is not present
          in the usual core image.  FUNCTION is an atom, the name of a
          function.   Compiles the function, writing the compiled code
          to the currently selected output file.  Probably you want to
          use COMPL.  

(COMPL filename) [FEXPR] --> NIL
          NB: COMPL is defined only in ELISPC.EXE. It is  not  present
          in  the  usual  core  image.  FILENAME is normally a string.
          COMPL will compile a set of functions and other things  that
          are   in   a   file.      The  compiled  code  is  put  into
          "filename.FLAP".    A  declaration  file  "filename.LDC"  is
          produced, containing declarations:

             - all  special  declarations  made  in  the  file or
               discovered by the compiler

             - for each function defined in the file, the type of
               the function (EXPR, FEXPR, ...) and the number  of
               arguments it requires

             - for  each  macro  defined  in  the file, the macro
               definition itself

          See  the  chapter  on  the  compiler  for  details  of   its
          operation.  COMPL obeys *RAISEDSK and *NOPOINTDSK.  

(CONCAT object1 object2) [EXPR] --> string
          CONCAT  does string concatenation.  Normally it combines two
          strings to form a string containing the  characters  in  the
          original  one  concatenated.    However  the  inputs  do not
          actually have to be strings.  They  can  be  any  Lisp  data
          structure.    The printed representation (i.e. EXPLODE) will
          be used.  

(COND clause1 clause2 ... clausen) [FSUBR]
          The basic form used for testing.  It consists of  a  set  of
          "clauses".    The  CAR  of each clause is a test.  The first
                                                                   189


          clause  whose  test  returns  true (i.e. anything other than
          NIL) wins.  That is, the rest of that clause  is  evaluated,
          and  the  COND takes on the value from that clause.  No more
          clauses are evaluated.  Here is an example

              (COND ((EQ A 'B) (PRINT "We have a B"))
                    ((EQ A 'C) (PRINT "We have a C")))

          There are two clauses, one on each line.   Their  tests  are
          (EQ  A  'B)  and (EQ A 'C).  If the first succeeds, the COND
          then evaluated (PRINT "We have a B"), and  returns  whatever
          that  PRINT  returns  (which will be the string printed). If
          the first one fails, the second is then tried.  If (EQ A 'C)
          succeeds, then the  value  of  (PRINT  "We  have  a  C")  is
          returned.  If they all fail, the COND returns NIL.  Actually
          the  clause can have as many items in it as you like.  It is
          only required that it have at least a test.    If  the  test
          succeeds,  all  of the clauses are done in order.  The value
          of the last one is returned.  This is much like a PROGN.  

(CONS car cdr) [SUBR] --> new dotted pair
          CONS creates a new dotted pair, with the specified  CAR  and
          CDR.  

(CONSP thing) [SUBR] --> thing or NIL
          If  the thing is a CONS cell, returns the thing itself, else
          NIL.  

(COPY thing) [SUBR] --> new copy of thing
          Copies a list structure.  Only cons cells  are  copied.  The
          atoms at the bottom end of the structure are left alone. The
          implementation  is  recursive,  so it could run out of stack
          space when copying very large lists (but the stack has  256K
          elements  in  this  implementation,  so  maybe this is a bit
          unlikely).  

(COS number) [SUBR] --> real
          Take the cosine of a number  of  any  type,  interpreted  as
          radians.  Returns a real number.  To use this, you must have
          loaded the Arithmetic Package, q.v.  

(COSD number) [SUBR] --> real
          Take  the  cosine  of  a  number of any type, interpreted as
          degrees.  Returns a real number.  Because of limitations  of
          the  underlying  Fortran  function,  the calculation is done
          using only 27 bits of precision  in  the  mantissa.  To  use
          this, you must have loaded the Arithmetic Package, q.v.  

(COSH number) [SUBR] --> real
          Take the hyperbolic cosine of a number of any type.  Returns
          a  real  number.    Because of limitations of the underlying
          Fortran function, the calculation is done using only 27 bits
          of precision in the mantissa. To use  this,  you  must  have
          loaded the Arithmetic Package, q.v.
                                                                   190


(CREATE-STRUCTURE name field-list) [EXPR] --> name
          Create  a  record  structure.  MAKE-name can then be used to
          create individual instances of  this  structure.    See  the
          chapter  on  structures  for  a  discussion  of the problems
          involved with using this in compiled code.  For  the  format
          of FIELD-LIST, see STRUCTURE-FIELDS.  

(CSYM atom) [FSUBR] --> the atom
          Sets  the name that will be used by GENSYM.  This must be an
          atom or string with 5 characters, ending in  digits.    Note
          that it does not evaluate its argument, so a typical call is
          (CSYM G0001).

(CURPOS channel) [SUBR] --> number
          CURPOS  is used to find where you are within a random access
          file.  It returns the  byte  number  the  will  be  read  or
          written  by the next TYI or TYO.  The first byte is numbered
          0.  If the file is not on a random-access device, this  will
          be  of  dubious usefulness.  Typically 0 is returned in such
          cases.  

(DATE) [SUBR] --> (MONTH DAY YEAR-1900)
          Returns the date in the format shown.  All are numbers.  

(DDTIN flag) [SUBR] --> previous setting of flag
          The DDTIN flag controls the way terminal I/O is done.    The
          normal  setting  is NIL.  In this case, terminal I/O is done
          with the normal Tops-20 line reading conventions.  That  is,
          rubout,  ^U,  ^W,  ^R,  etc., all work.  Lisp only activates
          when you hit an end of line character.  When  DDTIN  is  set
          non-NIL,  input  is done character by character.  This means
          that you can no longer use the editing characters.  The only
          editing character defined is rubout, which kills the  entire
          current  S-expression.    (DDTIN T) is useful only for users
          who need to control terminal  I/O  at  the  lowest  possible
          level.  

(DE name arg-list body) [FEXPR] --> name
          DE  is  used for defining normal functions.  See the section
          on basic semantics.  DE makes up a LAMBDA with the specified
          argument list and body, and assigns it the  name  specified.
          E.g

              (DE FOO (N) (PLUS N A))

          defines assigns FOO as the name of an EXPR

              (LAMBDA (N) (PLUS N A))

          ALIAS  is  used  to  assign  the LAMBDA to the name.  If the
          formal parameter list is an atom,  this  defines  an  LEXPR.
          The  name of the function (FOO in this case) is added to the
          list ALLFNS.    If  FOO  was  previously  defined,  the  old
          definition  is  saved  as the SAVE property of FOO, and (FOO
          Redefined) is returned.
                                                                   191


(DEBUGINT flag) [SUBR] --> old flag
          Turns on or off the processing of those interrupt characters
          that  are  intended  for debugging, i.e. ^B, ^D, ^E, ^H, ^Y.
          Production programs will  probably  run  in  (DEBUGINT  NIL)
          mode, so that uninitiated users do not terminate the program
          accidentally  by  typing  ^D, etc.  ^G is not controlled, as
          this is one interrupt  that  is  often  used  in  production
          programs.    It can be disabled separately by using ERRCH if
          necessary.  Nor are  ^F  and  ^Z,  which  are  not  in  fact
          interrupts.  

(DECLARE exp1 exp2 ...) [special form]
          DECLARE  is  designed  to  be  used for things that only the
          compiler is to see.  Things inside it are completely ignored
          by the interpreter.  The DECLARE is completely "transparent"
          to the compiler.  I.e.  things inside it are compiled as  if
          the DECLARE were not there.  

(DECR x) [MACRO] - (SETQ X (SUB1 X))

(DEFLIST list value property) [FEXPR] --> NIL
          DEFLIST  is  useful  for  placing  a property on a number of
          atomic symbols.  LIST should be a list  of  items,  each  of
          which  is  either  an  atomic symbol A or a two-element list
          (A VAL).  Each A will have a PROPERTY property placed on its
          property list, with a value of VAL if present, or  VALUE  if
          only the atomic symbol was given.  VALUE is optional, with a
          default  value  of  T  assumed.  As an example of the use of
          DEFLIST, the following will give TOM and BOB ages of 15, and
          SAM an age of 20 (i.e., the 20 overrides the  default  value
          of 15):

              (DEFLIST (TOM BOB (SAM 20)) 15 AGE)

(DEFP atom1 atom2 propertylist) [FEXPR] --> atom1 or NIL
          Copies  a  property  or  properties  from  ATOM2  to  ATOM1.
          PROPERTYLIST can be either a single atom or a list of atoms.
          Any such properties that may be on ATOM2 are put onto ATOM1.
          Returns ATOM1 if any of the properties are found.  

(DEFPROP atom value property) [FEXPR] --> atom
          Similar to PUTPROP, but quotes it arguments.  That is

              (DEFPROP A B C)

          puts on atom A the value B for property C. To do  this  with
          PUTPROP, you would type

              (PUTPROP 'A 'B 'C)

(DEFV atom value) [FEXPR] --> atom
          Similar  to  (SETQ  atom  'value).    Note that VALUE is not
          evaluated.  Unlike SETQ (which would return the value), DEFV
          returns the ATOM.
                                                                   192


(DELETEF file keep) [SUBR] --> channel or NIL
          DELETEF  deletes a file.  FILE can be either a channel, or a
          filename (given as a string).  If it is a channel, the  file
          associated  with  that  channel is deleted.  If the file was
          open, it is closed first.  If the argument is a filename,  a
          channel  is  generated  for  it,  and  the  file is deleted.
          Normally only one argument is given (i.e. KEEP is NIL).   In
          this  case,  after  the  file  is  deleted,  the  channel is
          released, and can't be used for anything else.  If  KEEP  is
          non-NIL,  then  the channel is kept.  It is not open, but is
          still associated with the file.  It may be opened by  OPENF,
          etc.  

(DELIM char-code) [EXPR] --> T or NIL
          Tells you whether a character is a "delimiter".  A delimiter
          is  any  character  that  would  have to be quoted with / in
          order to appear inside an atom name.  The  argument  is  the
          ascii code for a character (an integer).  

(DF name arg-list body) [FEXPR] --> name
          DE is used for defining FEXPR functions.  See the section on
          basic  semantics.    DF makes up a LAMBDA with the specified
          argument list and body, and assigns it the  name  specified.
          E.g

              (DF FOO (N) (PLUS (EVAL (CAR N)) A))

          defines assigns FOO as the name of the FEXPR

              (LAMBDA (N) (PLUS (EVAL (CAR N)) A))

          ALIAS  is  used  to assign the LAMBDA to the name.  The name
          (FOO in this example) is added to the list ALLFNS.   If  FOO
          was  previously  defined, the old definition is saved on the
          SAVE property of FOO, and (FOO Redefined) is returned.  

(*DIF x y) [SUBR] --> x - y

(DIFFERENCE n1 n2 n3 ...) [MACRO] --> n1 - n2 - n3 ...
          This is a macro that expands to  an  appropriate  number  of
          calls to *DIF.  

(DIR filespec) [EXPR] --> list of file names
          FILESPEC  should be a string specifying a filename that uses
          wildcards.  If it is NIL, "*.*.*" is used.   DIR  returns  a
          list of all files that match that filespec.  

(DIVIDE x y) [SUBR] --> (CONS (QUOTIENT X Y) (REMAINDER X Y))

(DM name arg-list body) [FEXPR] --> name
          DE  is  used for defining MACRO's.  See the section on basic
          semantics.  DM makes up a LAMBDA with the specified argument
          list and body, and assigns it the name specified.  E.g

              (DM FOO (N) (LIST 'PRINT ('QUOTE (CDR N))))
                                                                   193


          defines assigns FOO as the name of the macro

              (LAMBDA (N) (LIST 'PRINT ('QUOTE (CDR N))))

          ALIAS  is  used  to assign the LAMBDA to the name.  The name
          (FOO in this example) is added to the list ALLFNS.   If  FOO
          was  previously  defined, the old definition is saved on the
          SAVE property of FOO, and (FOO Redefined) is returned.  

(%DEPTH sexp) [EXPR] --> integer
          This function returns the maximum nesting depth of the  list
          structure  SEXP.    It  is  used  internally by %SPRINT (and
          others).

(DO e1 e2 . . .) [MACRO] 
          DO is a macro which provides a general evaluation capability
          for RUCI LISP.  In its simplest form, DO  is  equivalent  to
          PROGN - each <e> is evaluated in turn, with the value of the
          last <e> returned as the value of the DO.

          The  following forms of DO expand into PROGs - note that the
          loop may be exited prematurely if desired  via  the  use  of
          RETURN.

(DO WHILE p e1 e2 . . .)
                    Evaluates  <p>,  and if non-NIL evaluates the <e>s
                    in turn.  This is repeated until <p> evaluates  to
                    NIL,  at which time the last value of the last <e>
                    is returned.

(DO UNTIL p e1 e2 . . .)
                    Equivalent to:

                        (DO WHILE (NULL p) e1 . . .)

(DO FOR var IN l e1 e2 . . .)
                    (Similar to MAPC).  VAR (which is  not  evaluated)
                    is bound to each element of L in turn, and the E's
                    are  evaluated  for  each  binding.    When  L  is
                    exhausted,  the  last  value  of  the  last  E  is
                    returned.    If  L  is  initially  NIL, no E's are
                    evaluated and DO returns NIL.  VAR will  be  bound
                    in  the  generated  PROG, so any previous value of
                    VAR will be saved and restored.

(DO FOR var ON l e1 e2 . . .)
                    (Similar to MAP).  Like the above, except  VAR  is
                    bound to successive tails of L. 

(DO FOR var RPT n e1 e2 . . .)
                    Similar  to the above, except VAR takes on integer
                    values from 1 to N. If N is initially less than 1,
                    none of the E's are evaluated and DO returns NIL.

DOUBLE-COMMA - an atom
                                                                   194


          (DOUBLE-COMMA  exp) has a special meaning within expressions
          processed by the macro BACKQUOTE.  See  Template  Instantion
          for  details.   The comma character is normally defined as a
          read macro such that ,,exp expands  to  (DOUBLE-COMMA  exp).
          Documentation is normally written in terms of the character.
          

(DREMOVE item list) [EXPR] --> modified list
          Removes  all  top  level  occurrences  of ITEM from the list
          LIST, giving a modified version of LIST with all  top  level
          elements EQ to ITEM removed.  Similar to REMOVE, but uses EQ
          instead  of  EQUAL,  and  actually  modifies the list L when
          removing X, and thus does not use  any  additional  storage.
          More efficient than REMOVE.

          NOTE:    If X = (L ...  L) (i.e. a list of any length all of
          whose top level  elements  are  EQ  to  L)  then  the  value
          returned  by  (DREMOVE  X  L)  is  NIL,  but  even after the
          destructive changes to X there is still one CONS  cell  left
          in  the modified list which cannot be deleted.  Thus if X is
          a variable and it is possible that the result of (DREMOVE  X
          L)  might be NIL the user must set the value of the variable
          given to DREMOVE to the value returned by the function.

(DREVERSE list) [EXPR] --> reversed list
          Returns a copy of the list, with its top-level  elements  in
          reverse  order.    Differs  from  REVERSE  because  it  uses
          "destructive" operations, i.e. RPLACD and RPLACA.    REVERSE
          gives you a reversed copy of the original list, not touching
          the  original.  DREVERSE changes the original list in place,
          so any pointers pointing to it now  point  to  the  reversed
          list.  However it is faster than REVERSE.  

(DRM char function) [FEXPR]
          Defines  the  character  as  a  readmacro.  CHAR should be a
          character atom.  You should quote it with / if  appropriate.
          FUNCTION  is a function, typically a LAMBDA form.  E.g. (DRM
          /' (LAMBDA NIL (LIST 'QUOTE (READ))).  See  the  section  on
          readmacros  in  the  introduction.  DRM puts the function as
          the property READMACRO on the character atom.  

(DSKIN filename) [FEXPR]
          DSKIN opens the specified file and reads from it.    Reading
          is  done with a REAL-EVAL-PRINT loop, so you all expressions
          in the file will be executed, and you will see the  results.
          When  you  are  finished, input will be restored to where it
          was before.

               Printing of the results is controlled by  the  variable
                    DSKIN.  If it is NIL, printing will be suppressed.
                    It is initially T. 

               The  variable  *RAISEDSK  (initially NIL) may be set to
                    non-NIL  in  order  to  cause   all   lower   case
                    characters  read  from  the file to be turned into
                                                                   195


                    upper  except within strings.  Note that *RAISEDSK
                    is only applicable within  DSKIN.    DSKIN  is  an
                    FEXPR, which means that the filename(s) should not
                    be quoted.

               Functions  that normally set ALLVALS, ALLSTRS or ALLFNS
                    (DE, DF, DM, DS, DV) do not do so inside DSKIN.

(DSKOUT filename things-to-write) [FEXPR]
          A way of writing function definitions and variable values to
          a file.  SAVEF is normally used.  DSKOUT is for use when the
          automated features of SAVEF are not appropriate.    Filename
          is  usually  a Tops-20 file name given as a string, although
          the old formats (as described under OUTPUT) are allowed.

          In the simplest case,  there  are  no  additional  arguments
          (i.e. no THINGS-TO-WRITE).  In this case, DSKOUT looks for a
          variable  that  contains a list of the things that belong in
          the file.  This variable is made by tacking FNS  on  to  the
          end  of  the file name.  E.g. if you have a file MYFILE.LSP,
          DSKOUT will assume that MYFILEFNS contains  a  list  of  all
          functions  and variables contained in that file.  If you say
          (DSKOUT "MYFILE.LSP"), DSKOUT will first look for a variable
          MYFILEFNS.  If it finds such a variable,  it  is  passed  to
          PPL,  and  you  end  up  writing  out  those  functions  and
          variables listed there.  If there is no such variable,  then
          DSKOUT  uses  ALLFNS,  ALLSTRS  and  ALLVARS.  The values of
          ALLFNS, ALLSTRS and ALLVALS are appended, sorted, and passed
          to PPL. The effect of this is to  write  out  all  functions
          defined  during  the  current session by DE, DF, and DM, all
          structures defined by DS, and all variables defined  by  DV.
          (Note  that  those  read  in  from  files  by  DSKIN are not
          included.)

          If a variable is passed  to  PPL,  its  definition  is  also
          written into the file.

          If  you  supply extra arguments (THINGS-TO-WRITE), of course
          they will be used in preference to these default. Non-atomic
          expressions appearing in the  DSKOUT  are  evaluated,  while
          atoms are passed to PPL.

          If the value of DSKOUT is T (its default value), the name of
          each  function prettyprinted during the DSKOUT is printed on
          the terminal so that the user may follow the progress of the
          dump.  If DSKOUT is set to  NIL,  no  terminal  printing  is
          performed.  The maximum line length used by DSKOUT is stored
          in DSKLENGTH, and may be changed if desired (it is initially
          80). *NOPOINTDSK is used  instead  of  *NOPOINT  to  control
          where  the  decimal  point (or octal point) is printed after
          integers.  

(DSM char function) [FEXPR]
          Defines the character as a splicemacro.  CHAR  should  be  a
          character  atom.  You should quote it with / if appropriate.
                                                                   196


          FUNCTION  is a function, typically a LAMBDA form.  E.g. (DSM
          /$ (LAMBDA NIL (LIST 'XX  (READ))).    See  the  section  on
          readmacros  in  the  introduction.  DSM puts the function as
          the property SPLICEMACRO on the character atom.  

(DSUBST X Y Z) [EXPR] --> new list structure
          Similar to SUBST, but uses EQ  and  does  not  copy  Z,  but
          changes  the  list  structure  Z itself.  DSUBST substitutes
          with a copy of X. More efficient than SUBST.  

(DTIME) [SUBR] --> integer
          Returns the time of day, milliseconds since  midnight.    At
          the moment this is only accurate to the nearest second.  

(DV atom value) [FEXPR] --> atom
          Same  as  DEFV,  but  DV  adds the atom to the list ALLVALS.
          That is, ATOM is set to VALUE (which is not evaluated), ATOM
          is added to ALLVALS, and ATOM is returned. DV is used by the
          prettyprinter to print VALUE properties.    In  general,  DV
          should  be used where you want DSKOUT and PP to show updated
          values, and DEFV should be used where you want the  original
          value to stay unchanged.  

(E: e ...) - alias to PROGN
          The  Es are simply evaluated.  For example, the inclusion of
          the following in a prettyprint list could be used to  change
          the base in the middle of a print:

                             (E: (SETQ BASE 10.))

(EDIT atom) [FSUBR] --> atom
          Edits  the  object  using  EMACS.    EDIT will edit function
          definitions for atoms that are defined as  EXPR,  FEXPR,  or
          MACRO's.    If the atom does not have a function definition,
          then it is checked to see if it has a value.   If  so,  EDIT
          will  edit the value.  Note that EDIT is an FSUBR, so you do
          not need to quote the argument.  A typical call is

              (EDIT MYFUN)

          The name of the function is added  to  ALLFNS.    Note  that
          there is a separate editor, the Lisp structure editor.  When
          the  term  "editor"  is  used in this document without other
          qualification, it is this structure editor that is  referred
          to, not EMACS.

(*EDIT thing) [SUBR] --> new thing
          Edits  the thing using EMACS.  Returns the new value.  THING
          is evaluated.  This is the function used by EDIT to  do  the
          actual editing.  

(EDITCH N) [SUBR] --> old value
          Sets  the  character  used  to trigger a call to the editor.
          This is normally ^F.  N is a number, the ASCII code for  the
          desired  value.  Any character may be used. The old value is
                                                                   197


          returned.    A  negative  number  means  that  there  is  no
          character for this purpose.  This  character  is  recognized
          only  on  terminal input.  When it is read (not typed - this
          is not an interrupt), it sets a flag inside read.  When READ
          is about to return the value typed, it  first  calls  FIXFN,
          which  is  initially  *EDIT  (a  call  to EMACS).  The value
          returned by FIXFN is used as the value of READ.  

(EDITE expr coms atm)
          Edits an expression.  Its  value  is  the  last  element  of
          (EDITL (LIST expr) coms atm NIL NIL).  Generates an error if
          expr is not a list.  

(EDITF x)
          FSUBR  function for editing a function.  (CAR x) is the name
          of the function, (CDR x) an optional list of commands.   For
          the  rest of the discussion, fn is (CAR x), and coms is (CDR
          x).

          If x is NIL, fn is set to the value of LASTWORD, coms is set
          to NIL, and the value of LASTWORD is printed.

          The value of EDITF is fn.

          In the most common case, fn is an non-compiled function, and
          EDITF simply performs (EDITE (CADR (GETL  fn  (QUOTE  (FEXPR
          EXPR MACRO)))) coms fn) and sets LASTWORD to fn.

          If  fn  is  not an editable function, but has a value, EDITF
          assumes the user meant to call EDITV, prints  =EDITV,  calls
          EDITV and returns.

          Otherwise, EDITF generates an fn NOT EDITABLE error.  

(EDITFINDP x pat flg)
          Allows  a  program  to  use  the edit find command as a pure
          predicate from outside the editor.  X is an expression,  pat
          a pattern.  The value of EDITFINDP is T if the command F pat
          would  succeed,  NIL otherwise.  EDITFINDP calls EDITFPAT to
          convert pat to the form expected by  EDIT4E,  unless  flg=T.
          Thus,  if  the  program  is  applying  EDITFINDP  to several
          different expressions using the same  pattern,  it  will  be
          more   efficient  to  call  EDITFPAT  once,  and  then  call
          EDITFINDP with the converted pattern and flg=T.

(EDITFNS x)
          FSUBR function, used to perform the same editing  operations
          on several functions.  (CAR x) is evaluated to obtain a list
          of  functions.  (CDR x) is a list of edit commands.  EDITFNS
          maps down the list of functions, prints  the  name  of  each
          function, and calls the editor (via EDITF) on that function.

          For  example, (EDITFNS FOOFNS (R FIE FUM)) will change every
          FIE to FUM in each of the functions on FOOFNS.
                                                                   198


          The  call  to the editor is ERRSET protected, so that if the
          editing of  one  function  causes  an  error,  EDITFNS  will
          proceed to the next function.

          Thus  in  the above example, if one of the functions did not
          contain a FIE, the R  command  would  cause  an  error,  but
          editing would continue with the next function.

          The value of EDITFNS is NIL 

(EDITFPAT pat flg)
          Makes a copy of pat with all patterns of type 5 converted to
          the  form  expected  by EDIT4E.  Flg should be passed as NIL
          (flg=T is for internal use by the editor).

(EDITL L coms atm marklst mess)
          EDITL is the structure editor.  Its first  argument  is  the
          edit chain, and its value is an edit chain, namely the value
          of L at the time EDITL is exited.  (L is a special variable,
          and  so  can  be  examined  or  set  by  edit commands.  For
          example, ^ is equivalent to (E (SETQ L(LAST L)) T).)

          Coms is an optional  list  of  commands.    For  interactive
          editing,  coms  is NIL.  In this case, EDITL types EDIT: and
          then waits for input from the teletype.  (If mess is not NIL
          EDITL types it instead of EDIT:.    For  example,  the  TTY:
          command  is  essentially (SETQ L (EDITL L NIL NIL NIL (QUOTE
          TTY:))).)  Exit  occurs  only  via  an  OK,  STOP,  or  SAVE
          command.

          If  coms is NOT NIL, no message is typed, and each member of
          coms is treated as a command and  executed.    If  an  error
          occurs  in  the  execution  of one of the commands, no error
          message is printed , the rest of the commands  are  ignored,
          and  EDITL exits with an error, i.e., the effect is the same
          as though a STOP command had been executed.  If all commands
          execute successfully, EDITL returns the current value of L. 

          Marklst is the list of marks.

          On calls from EDITF, Atm is the name of the  function  being
          edited;  on  calls from EDITV, the name of the variable, and
          calls from EDITP, the atom of which  some  property  of  its
          property  list is being edited.  The property list of atm is
          used by the SAVE command for saving the state of  the  edit.
          Thus  SAVE  will  not  save  anything  if atm=NIL i.e., when
          editing arbitrary expressions via EDITE or EDITL directly.

(%EDITOR-BUFFER-SIZE integer) [SUBR] --> size
          Make sure the  buffer  has  at  least  the  specified  space
          (number  of character) for insertion.  This space is made at
          the EMACS "point".  If no buffer exists, creates one.  If no
          EMACS fork exists, creates one.  Returns the actual size  of
          the gap, which is at least as big as what was asked for.
                                                                   199


(%EDITOR-CALL-FORK integer) [SUBR] --> returned value
          Calls the FSsuperior code in EMACS, passing it INTEGER as an
          argument.   Returns what EMACS returns in AC 3.  This is not
          the normal way to call EMACS.  See %EDITOR-RUN-FORK.    This
          is  used  to  call a special kludge in EMACS.  Create a fork
          and buffer if none exists.

(%EDITOR-CLEAR-BUFFER) [SUBR] --> NIL
          Clear the EMACS buffer.  Set point to  beginning,  and  make
          the buffer be zero size.

(%EDITOR-CLIP-BUFFER chan) [SUBR]
          Use  this  when  you  are  finished writing into the buffer,
          before calling EMACS.  It  updates  some  status  variables.
          They  are  invalid between the call to %EDITOR-WRITE-CHANNEL
          and the call to %EDITOR-CLIP-BUFFER.  Do  not  do  any  more
          writing  after  calling  this function.  If CHAN is NIL, the
          current output channel is used.

(%EDITOR-CREATE-FORK) [SUBR]
          Makes sure you have a valid editor fork and buffer.  Differs
          from %EDITOR-GET-FORK in that it calls EMACS with 0FSExit if
          needed to create a  buffer,  whereas  %EDITOR-GET-FORK  just
          gets  the  fork  without  starting it, so there is no buffer
          yet.  No-op if there is already a fork and buffer.

(%EDITOR-GET-FORK) [SUBR]
          Gets a fork and puts EMACS into it.  Doesn't start it.   No-
          op if there is already a fork.

(%EDITOR-KILL-FORK) [SUBR] --> NIL
          Kills  the  editor  fork,  i.e.  makes  the  fork  and EMACS
          completely go away.

(%EDITOR-READ-CHANNEL) [SUBR] --> channel
          Returns an I/O channel such that if you read from  it,  your
          input comes from the EMACS buffer.  It is set up to start at
          the  "virtual  beginning" of the buffer, and give EOF at the
          "virtual end".  An ESCAPE will be provided  as  the  N+1  st
          character  if  you  try  to read beyond the end.  Illegal if
          there is no EMACS fork.

(%EDITOR-RUN-FORK flag) [SUBR] --> ac3
          Normally this continues EMACS, waits for  it  to  stop,  and
          returns  the  value EMACS puts into AC3.  However if FLAG is
          non-NIL, or the fork has never been run, then it  starts  at
          the normal starting address.

(%EDITOR-SET-JCL string) [SUBR] --> the string
          Sets the string into the RSCAN buffer.

(%EDITOR-WRITE-CHANNEL) [SUBR] --> channel
          Creates  a channel such that if you write to it, your output
          goes into the EMACS buffer.   Certain  status  variables  in
          EMACS will be temporarily invalid after this.  Call %EDITOR-
                                                                   200


          CLIP-BUFFER  when you are finished writing to make them good
          again.  The  channel  is  set  so  that  things  output  are
          inserted after then EMACS "point".  

(EDITP x)
          FSUBR function, similar to EDITF for editing property lists.
          Like EDITF, LASTWORD is used if x is NIL.  EDITP calls EDITE
          on  the  property list of (CAR x).  When (if) EDITE returns,
          EDITP RPLACD's (CAR x) with the  value  returned,  and  sets
          LASTWORD to (CAR x).

          The  value  of  EDITP  is  the  atom whose property list was
          edited.

(EDITRACEFN com)
          Is available to help the user debug complex edit macros,  or
          subroutine calls to the editor.  EDITRACEFN is to be defined
          by  the  user.  Whenever the value of EDITRACEFN is non-NIL,
          the editor calls the function  EDITRACEFN  before  executing
          each  command  (at any level), giving it that command as its
          argument.

          For example, defineing EDITRACEFN as

              (LAMBDA (C) (PRINT C) (PRINT (CAR L)))

          will  print  each  command  and  the  corresponding  current
          expression.    (LAMBDA  (C)  (BREAK1  T T NIL NIL NIL)) will
          cause a break before executing each command.

          EDITRACEFN is initially equal to NIL, and undefined.  

(EDITV editvx)
          FSUBR function, similar to EDITF, for editing values.   (CAR
          editvx)  specifies  the  value,  (CDR editvx) is an optional
          list of commands.

          If editvx is NIL, it is set to the value  of  (NCONS  EDITV)
          and the value of EDITV is printed.

          If  (CAR  editvx)  is  a list, it is evaluated and its value
          given to  EDITE,  e.g.    (EDITV  (CDR  (ASSOC  (QUOTE  FOO)
          DICTIONARY)))). In this case, the value of EDITV is T. 

          However,  in  most  cases,  (CAR editvx) is a variable, e.g.
          (EDITV FOO); and EDITV calls  EDITE  on  the  value  of  the
          variable.

          If  the  value of (CAR editvx) is atomic then EDITV prints a
          NOT EDITABLE error message.

          When (if) EDITE returns, EDITV  sets  the  variable  to  the
          value returned, and sets EDITV to the name of the variable.

          The  value  of EDITV is the name of the variable whose value
                                                                   201


          was edited.  

(EDIT4E pat y)
          Is the pattern match routine.  Its value is T if pat matches
          y. See pp. 130 for definition of 'match'.

          Note:    before  each search operation in the editor begins,
          the entire pattern is scanned for atoms or strings that  end
          in at-signs.  These are replaced by patterns of the form

              (CONS (QUOTE /@) (EXPLODEC atom)).

          Thus from the standpoint of EDIT4E, pattern type 5, atoms or
          strings  ending  in  at-signs, is really "If car[pat] is the
          atom @ (at-sign), PAT will match with any  literal  atom  or
          string whose initial character codes (up to the 
          same as those in cdr[pat]."

          If  the  user  wishes  to  call  EDIT4E  directly,  he  must
          therefore  convert  any  patterns  which  contain  atoms  or
          strings ending in at-signs to the form recgnized by  EDIT4E.
          This can be done via the function EDITFPAT.  

(ELISP: form1 form2 ... formn) [FSUBR] --> value of formn
          This  is  exactly the same as PROGN.  It is intended for use
          in files to be run in both R/UCI Lisp  and  ELISP.    It  is
          defined  as  NILL in R/UCI Lisp.  Thus it should be used for
          code that is to be used only in ELISP.

ELISP.INIT - a file name
          This is the name  of  your  automatic  initialization  file.
          Anything  in  this  file will be read when Lisp starts.  The
          expressions in it will be evaluated but not printed.  

(ENTER val list) [EXPR] --> list
          This adds VAL to LIST if it isn't there already.  If VAL  is
          already a member of LIST (this is tested by MEMBFN, which is
          usually  MEMBER), LIST is returned unchanged.  If it is not,
          (CONS VAL LIST) is returned.  

(ERR code) [SUBR]
          This causes the most recent ERRSET to return CODE.    If  no
          ERRSET  is in effect, control returns to the top level READ-
          EVAL-PRINT loop, with  no  value  printed.    There  is  one
          special value of CODE, ERRORX.  (ERR 'ERRORX) will return to
          the  most  recent ERRSET for which FLAG was ERRORX.  It will
          skip any intervening ERRSET's  with  different  flags.    If
          there  is  no  such ERRSET, control returns to the top level
          READ-EVAL-PRINT loop.  

(ERRCH N) [SUBR] --> old value
          Sets  the  interrupt  character  used  to  generate   (ERROR
          ERRORX). This is normally ^G.  N is a number, the ASCII code
          for the desired value.  The only possible values are control
          characters,  escape,  rubout,  and  space.  The old value is
                                                                   202


          returned.    A  negative  number  means  that  there  is  no
          interrupt character for this purpose.  

(ERROR code) [SUBR]
          This causes a real Lisp error.  Here are the steps in this:

               if the most recent ERRSET specified NIL as the FLAG, do
                    (ERR NIL), i.e. return to the most recent  ERRSET,
                    returning NIL.

               unless  (*RSET  'ERRORX)  is in effect, print the error
                    code.    Printout  will   normally   be   on   the
                    controlling  terminal,  except  if the most recent
                    ERRSET specified a FLAG of 0, printout goes to the
                    currently selected output.

               if (*RSET NIL) is in effect, so (ERR NIL), i.e.  return
                    to the most recent ERRSET, or to top level.

               otherwise, evaluate (ERRORX T), which causes a break.

          The  error code is printed using PRIN1, except that if it is
          a list, it is printed by applying PRIN1 to  each  member  of
          the list.  

(ERRORX flag)
          This is the break package.  It is intended that the user can
          supply  his  own  definition  of ERRORX, although there is a
          default one.  See  ERROR  for  details  on  when  ERRORX  is
          called.    Currently  FLAG  is  always  passed  as  T. It is
          supposed to indicate whether the error is "serious".  

(ERRSET expr flag) [FSUBR]
          Flag is not evaluated.  Evaluates EXPR.  If ERR or ERROR  is
          called  within  the  computation,  the most recent ERRSET is
          examined.  Either a break will occur, or ERRSET will  return
          with

              if ERR was done - the argument to ERR
              if ERROR was done - NIL

          If  no  error  occurs,  ERRSET returns whatever the value of
          EXPR would be, CONS'ed to NIL.  I.e. if EXPR returns A,  you
          will get (A).  

(EQ thing thing) [SUBR] --> T or NIL
          Compares  two  objects  to see if they are the same pointer.
          This is a very strong test.  Things may look  the  same  and
          not  be  EQ.    They  are  not  just  similar structure, but
          literally the same pointer. Note that atoms  always  compare
          equal to themselves, but two strings that look identical may
          not be EQ.  Integers are always EQ to an integer of the same
          value, but reals are not.

(EQP x y) [SUBR] --> T or NIL
                                                                   203


          This  should  be a test for numerical equality.  I.e. T if X
          and Y are numbers and are equal, else NIL.  At the moment it
          is the same as EQUAL.  

(EQUAL thing thing) [SUBR] --> T or NIL
          Like EQ, but tries to see if the objects are "similar".  For
          list structure (CONS cells), the CAR and  CDR  are  compared
          recursively.  The result is that they are EQUAL if they have
          the  same  structure,  with  the same atoms in the "leaves".
          Numbers are checked to see if  they  have  the  same  value.
          Thus  123.0  (a  real)  and  123 (an integer) will be EQUAL.
          (The actual test for numbers is (ZEROP (DIFFERENCE X Y))  .)
          

(EQSTR str1 str2) [SUBR] --> T or NIL
          Compares  two  strings,  and  returns  T  if they are equal.
          Upper and lower case are considered different.  If  you  use
          an atom, its print name is used for the comparison.  

(EVAL expr context) [SUBR] --> value returned by expression
          EVAL calls the interpreter to interpret the EXPR which it is
          passed,  and returns the result of the evaluation.  Normally
          the expr has one of the following forms:

             - literal atom - a variable.  EVAL returns its value

             - any other atomic  item  (e.g.  number,  string)  -
               returns the item unchanged

             - (function  arg1 arg2 ...) - a function call.  EVAL
               passes the arguments to the  function,  calls  it,
               and returns the result.

          The only real complexity is with finding the function in the
          last form shown.  It can be one of two things:

             - an  atom  which  has been defined as a function by
               DE, DF, DM, or ALIAS.  This is  by  far  the  most
               common.

             - a  functional  constant, i.e. a LAMBDA, FUNARG, or
               LABEL.    (SUBR,  FSUBR,  and   MSUBR   functional
               constants   are   also  possible,  but  these  are
               generally produced only by the compiler.)

             - anything that evaluates to one  of  these  things.
               EVAL  will  evaluate  the function part (CAR) of a
               form repeatedly until it finds either an  atom  or
               something that looks like a function constant.

          Normally  arguments  to  a  function  are  evaluated left to
          right, and bound to the formal parameters specified  in  the
          function  definition.    This  binding  mechanism is in fact
          always used for functional constants.  However when you  are
          dealing with an atom that has been defined by DE, DF, DM, or
                                                                   204


          ALIAS,  the way arguments are treated is defined by the type
          of function.  See the section on the semantics of  Lisp  for
          details  of  these  various  binding  types.   Note that all
          functions are formally  identical  -  they  are  all  LAMBDA
          forms,  and their evaluation is identical.  All that differs
          between an EXPR, FEXPR, or MACRO is a  tag  associated  with
          them by the fact that you used DE, DF, or DM to define them.
          The reason functional constants are always treated as EXPR's
          is that since there is no tag associated with them, so there
          is no way to specify any other binding method.

          The  second  argument  is optional.  If specified (i.e. non-
          NIL), it has one of two forms:

             - integer - this is a binding context pointer (stack
               pointer).   See  the  section  on  the  evaluation
               context  stack  for  details.    Global  (special)
               bindings are first restored to the  stack  context
               specified  by  this number, then the EVAL is done,
               and then the  bindings  and  stack  are  restored.
               This  allows  the  form  being  EVAL'ed  to access
               variables values from  older  contexts.    However
               changes  made are lost when the stack is restored.
               The value in the older context is not changed.

             - Alist  -  i.e.  a  list  of  pairs,  of  the  form
               ((variable  . value) (variable . value) ...).  The
               variables  will  be  bound  to  the  corresponding
               values before execution of the form.  The original
               values  will  be  restored afterwards.  Changes in
               the variables listed will be lost

(*EVAL expr) [SUBR] -- value returned by form
          The internal form of EVAL.  It does not understand contexts.
          Otherwise it is identical.  (EVAL  calls  *EVAL  to  do  the
          actual evaluation.)  

(EVALV atom index) [SUBR] --> value of atom
          The  value  of EVALV is the value of the atom ATOM evaluated
          as of position INDEX.  EVALV is similar  to  EVAL  with  two
          arguments,  but  is  more  efficient.    However  it is only
          allowed for atoms, and if the atom it  unbound,  it  returns
          (UNBOUND), rather than generating an error.  

(EVERY fn l1 . . . ln) [LEXPR] --> T or NIL
          <fn>  (a  function of n arguments) is applied to the CARs of
          <l1>  through  <ln>  (like  MAPC),  returning  T   if   each
          application returns a non-NIL value.  If some application of
          <fn> returns NIL, EVERY stops at that point and returns NIL.
          For  example,  the  following  checks whether L is a list of
          atoms:

              (EVERY 'ATOM L)

          EVERY is compiled in-line.    For  details  on  the  binding
                                                                   205


          semantics,  see  the last paragraph of the description under
          MAPxxx

(EXAMPLE topic subtopic subtopic ...) [FEXPR] --> topic
          (EXAMPLE FOO) is equivalent to (HELP FOO-EXPLAIN).    It  is
          intended  to  elicit  examples that will further explain the
          topic.  

(EXIT flag) [SUBR] --> returns the flag
          The flag argument is optional,  and  is  provided  only  for
          compatibility  with  UCI  Lisp.   This exits to EXEC command
          level.  It is thus like typing ^C.  You can type CONTINUE to
          continue the program, in which case  EXIT  will  return  its
          value.    Or  you can type START to restart at the top level
          READ-EVAL-PRINT loop.  

(EXP number) [SUBR] --> real
          Take the exponential of a number of any type.  That  is,  it
          computes  E  to  the specified power, where E is the base of
          the natural logarithms.  Returns a  real  number.    To  use
          this, you must have loaded the Arithmetic Package, q.v.  

(*EXPAND expr ftn) [EXPR] --> new form
          This  is  used  for  defining  macros  that  apply  the same
          function to an indefinite number of arguments.  E.g. PLUS is
          defined by

              (DM PLUS (L)  (*EXPAND L '*PLUS))

          (CDR L) is supposed to be a list of forms  to  evaluate  and
          combine  by  FTN.    (CAR  L  is  the  macro name.)  What is
          returned is a nested set of calls to FTN, of the form

              (FTN (FTN (FTN N1 N2) N3) N4) ...

          Here is a more precise definition:

              (DE *EXPAND (L FN) (*EXPAND1 (REVERSE (CDR L)) FN))
              (DE *EXPAND1 (L FN)
               (COND ((NULL (CDR L)) (CAR L))
                     (T (LIST FN (*EXPAND1 (CDR L) FN) (CAR L)))))

(EXPLODE thing) [SUBR] --> list of characters
          In Lisp there has traditionally not been  very  good  string
          handling,  but  there  is  good list handling.  So typically
          instead of strings, one uses lists of characters.   This  is
          the  primary  way  you  get such lists.  EXPLODE effectively
          does PRIN1 of its argument, except instead  of  putting  the
          resulting  characters  into  a file, it makes a list of them
          and returns the list.  Each character is  represented  as  a
          one-character atom.  E.g.

              (EXPLODE 'ABC) --> (A B C)
              (EXPLODE '(A . B)) -->  ( /( A /. B /) )
                                                                   206


          See  also  AEXPLODE,  which returns numbers giving the ASCII
          codes.  

(EXPLODEC thing) [SUBR] --> list of characters
          Like EXPLODE but uses PRINC instead of PRIN1  to  print  the
          thing.  See also AEXPLODE.  

EXPR - a special tag used to make EXPR's.
          See  the  introductory  section  on basic semantics, and the
          function ALIAS.

(F: fn ...) [FEXPR] --> NIL
          Prettyprints any functional attributes of each FN,  ignoring
          all  other properties.  Actually, F: simply sets PRETTYPROPS
          to:

              '((EXPR . PP-FUNCTION)
                (FEXPR . PP-FUNCTION)
                (MACRO . PP-FUNCTION)))

          and passes its arguments  on  to  PP,  so  each  FN  may  be
          anything  which  can  normally  be used as an argument to PP
          (including another prettyprint  command).    PRETTYPROPS  is
          restored after printing is completed.  

FEXPR - a special tag used to make FEXPR's.  See the introductory
          section on basic semantics, and the function ALIAS.

(FILES?) [EXPR] --> list of pairs
          Used  to  find  all  files that need to be written out.  For
          each thing on ALLFNS,  ALLSTRS  or  ALLVARS,  looks  to  see
          whether  they  are  contained  in a file.  Returns a list of
          files with members on ALLFNS, ALLSTRS,  or  ALLVARS.    Uses
          ALLFILES  to  find all the files and what is in them.  If an
          object is not in a file, asks the user what file to  put  it
          in.    If  there  is only one file on ALLFILES, puts any new
          object there without asking.  Returns a list of pairs in the
          same format as ALLFILES.  

(FIX n) [SUBR] --> integer part of n
          Returns the largest integer not greater than N. 

              (FIX 1) = 1
              (FIX 1.1) = 1
              (FIX -1.1) = -2         not -1

FIXFN - a variable
          Should be bound to the function to use for ^F (or other char
          set up by EDITCH).  This function should take one  argument.
          Whatever  it  returns  is  returned  by READ.  Normally this
          should be an editor.  It is initially *EDIT.

(FLAP filename) [EXPR] --> filename
          Loads a compiled file, in FLAP format.  Normally users  will
          probably  load  such  files using DSKIN, as DSKIN calls FLAP
                                                                   207


          automatically when it detects a FLAP file.  Note that a FLAP
          file must be stored on disk, as random-access I/O is used in
          loading it.  

(FLATSIZE thing) [SUBR] --> number
          This  returns  the  number  of  characters  in  the  printed
          representation of THING.  You can think  of  it  as  (LENGTH
          (EXPLODE   THING)),   although   the  actual  code  is  more
          efficient.  

(FLATSIZEC thing) [SUBR] --> number
          As FLATSIZE, except that PRINC instead of PRIN1 is  used  to
          produce  the  printed  representation.    I.e. it is (LENGTH
          (EXPLODEC THING)).  

(FLOAT number) [SUBR] --> real
          Converts a number of any type into a real number.    To  use
          this, you must have loaded the Arithmetic Package, q.v.  

(FNDBRKPT index) [EXPR] --> index
          The value of FNDBRKPT is a stack pointer to the beginning of
          the  Eval-Block  that INDEX is in.  The beginning of a Eval-
          Block is defined as an Eval-Blip which does not contain  the
          next  higher  Eval-Blip within it.  This function is used by
          the backtrace functions.  

(FNTH list N) [SUBR] --> object
          Returns the Nth tail of LIST.  I.e. (FNTH  LIST  1)  returns
          LIST,  (FNTH  LIST  2)  returns  (CDR  LIST),  etc.  This is
          exactly like NTH, except that no validity checking at all is
          done on the arguments.  This should only be used  by  people
          who  know  what they are doing.  If LIST is not a list, or N
          is too large, you can end up with an illegal pointer,  which
          will cause trouble for the garbage collector.  

(FORMS: x ...) [FEXPR] --> (ASCII 0.)
          Each  X  is passed directly to SPRINT - may be used to print
          atoms  and  prettyprint  command  expressions  which   would
          normally be handled specially by PP.  

FSUBR - a special tag
          FSUBR  is used to mark compiled FEXPR's.  The form passed to
          ALIAS is (FSUBR <adddress> . <pass index?>).  Pass index  is
          non-NIL if the FSUBR expects to be passed a stack index as a
          second argument.

(FUNDEF atom) [SUBR] --> its function definition, or NIL if none
          FUNDEF  is  the inverse of ALIAS.  If the atom was set up as
          the name of a function, the function definition is returned.
          It will begin with the function type, one  of  EXPR,  FEXPR,
          MACRO, SUBR, FSUBR.  

(FUNARG function . index) - special form
          See  the second on the Evaluation Context Stack for details.
          The form (FUNARG <functional form> . index) can be used just
                                                                   208


          like  a  function.  However whenever it is invoked the stack
          is reset to INDEX before the function is interpreted.  

(FUNCTION function) [FSUBR] --> the function
          FUNCTION is the same as QUOTE in the interpreter.    In  the
          compiler,  FUNCTION  causes  the S-expression FUNCTION to be
          compiled, but QUOTE generates an S-expression constant.  

(*FUNCTION function) [FEXPR] --> a funarg object
          This returns a FUNARG object containing the  function  given
          and an index to the current stack level.  Note that function
          is  not  evaluated.    I.e.  you don't need to quote it, but
          should supply an actual form.  

(F:L param-list forms) -- special form
          This is an abbreviation  for  (FUNCTION  (LAMBDA  param-list
          forms)).    Since  FUNCTION  is  the  normal  way to quote a
          functional form,  this  is  a  convenient  way  for  writing
          functional forms to be used in MAP, etc.  

(GC) [SUBR] --> NIL
          Force a garbage collection.  

(GCD x y) [SUBR] --> number
          Defined  only  for  integers.    Returns the greatest common
          divisor of x and y. 

(GCGAG flag) [SUBR] --> old value
          Sets the GC output flag, and returns the old value.   If  it
          is  non-NIL,  you  get  a message whenever the system does a
          garbage collection.

(GCLEFT) [SUBR] --> space left before next GC
          Returns the number of words left before  the  next  GC  will
          trigger.  

(GCTIME) [SUBR] --> time in msec.
          Returns   the   total  amount  of  CPU  time  spent  garbage
          collecting in this core image, in milliseconds.

GCTRIGGER - variable
          Determines how often a GC happens.  At the end of  each  GC,
          all  used space is compact.  A certain amount of space above
          this compact used space is then allocated for the system  to
          grow  in  until  the  next GC.  This is called "free space".
          Free space is  computed  as  the  number  of  words  used  *
          GCTRIGGER.    GCTRIGGER  should  normally  be  a real number
          between 0 and 2.  The default is 1.0.  You will  always  get
          at  least 64000 words of free space, even if the calculation
          just documented leads to a smaller number.  

(GE x y) [EXPR] --> T if X <= Y, else NIL

(GENSYM) --> new atom
          This is used to generate new atoms when you need a new  one,
                                                                   209


          but  don't  care about its name.  It might be used for nodes
          in internal data structures where names don't matter.    The
          name  is  of  the  form  G0023,  i.e. 5 characters, with the
          trailing ones being digits.  The first GENSYM is G0001,  the
          next  call  returns G0002, the next G0003, etc.  You can set
          the next thing that GENSYM will return using  CSYM.    These
          atoms  are  not  INTERN'ed,  so  they will not show as EQ to
          things that you type in that look the same.  

(GET atom property) [SUBR] --> value of property, or NIL if none
          You can associate "properties"  with  an  atom.    The  atom
          simply  has a list of property names and values, in the form
          of an Alist (see ASSOC).  E.g.  the  atom  LISP  might  have
          associated with it the following property-value pairs:

              SYNTAX          YUCKY
              IMPLEMENTATION  NICE
              HOW-TO-USE      (PROGN (LOGIN) (RUN LISP) (LOGOUT))

          How  you  use this mechanism is completely up to you.  It is
          yet another way  to  construct  your  own  data  structures.
          There  can  be  as  many  property-value  pairs  as you like
          associated with a given atom (or none at all).   GET  checks
          an  atom  to  see  if  it has a pair with the given property
          name.  If so, it returns the associated value, if not,  NIL.


(GETALL atom property) [EXPR] --> value or NIL
          This  function  is  present for compatibility with the older
          R/UCI Lisp.  In the older Lisp,  function  definitions  were
          stored  as  properties on the function atom.  Thus (GET 'FOO
          'EXPR) would get an  EXPR  function  definition.    This  no
          longer  works.    FUNDEF  should now be used to get function
          definitions.  GETALL simulates GET in the old  Lisp.    That
          is,  (GETALL 'FOO 'EXPR) will return the function definition
          if FOO is an EXPR function.  But (GETALL 'FOO  'COLOR)  will
          return the COLOR property of FOO.  (GETALL 'FOO 'VALUE) will
          also return a simulated value cell, as in the older Lisp.

(GETBARRAY array index bytesize) [SUBR] --> integer
          ARRAY  must be an array pointer returned by MAKEARRAY.  Gets
          the INDEX'th byte of the array (starting at 0)  and  returns
          it  as an integer.  Bytes are packed as many as possible per
          word, left justified.

(GETDEF file at1 at2 . . .) [FEXPR] 
          GETDEF is similar to DSKIN, but only one  file  is  accessed
          and  only  selected expressions from that file are read.  In
          particular,  all  definitions  of  each  <at>  are   loaded,
          including  expressions  starting  with  DEFPROP, DE, DF, DM,
          LAP, DEFP, and DEFV (the list  of  expression  types  to  be
          examined  is stored as the value of the atom GETDEF, and may
          be changed if desired).  For example,

              (GETDEF "FUNCS.LSP" FN1 FN2 FN3)
                                                                   210


          loads  any  definitions  for  FN1, FN2, and FN3 found in the
          file FUNCS.LSP.  The value  of  each  expression  loaded  is
          printed  on  the  terminal for feedback purposes.  Note that
          GETDEF  does  not  intern  any  new  atomic  symbols  unless
          necessary  (i.e.,  unless  contained  in an expression to be
          loaded).  Free storage is thus not clogged  up  with  unused
          atomic symbols when scanning a large file for definitions.

(GETIARRAY array index) [SUBR] --> integer
          ARRAY  must be an array pointer returned by MAKEARRAY.  Gets
          the INDEX'th word of the array (starting at 0)  and  returns
          it as an integer.

(GETL atom properties) [SUBR] --> plist tail or NIL
          Like GET, but searches for more than one property at a time.
          PROPERTIES is a list of properties.  Searches the for any of
          the  properties on that list.  If one is found, it returns a
          tail of the property list, with the property found  the  CAR
          of the tail.  E.g.

              (GETL 'FOO '(COLOR SHAPE)) -->  (COLOR RED SIZE BIG)

          The  CAR  of  the thing returned is always the property that
          matched.  The CADR is always the  value  of  that  property.
          The  rest of the list returned is simply whatever happens to
          follow this data on the atom's property list.

          If none of the properties is found, returns NIL

(GETLALL atom properties) [EXPR] --> plist tail or nil
          Simulates GETL in the older R/UCI  Lisp.    See  GETALL  for
          details on the simulation.

(GETRARRAY array index) [SUBR] --> integer
          ARRAY  must be an array pointer returned by MAKEARRAY.  Gets
          the INDEX'th pair of words in the array (starting at 0)  and
          returns it as a real number.

(*GETSYM symbol) [SUBR] --> integer
          This looks up a symbol in the DDT symbol table.  This symbol
          table  has  the  values  of all internal symbols used in the
          assembly-language portion of the  interpreter,  and  symbols
          from  any modules loaded with LOADREL.  If the symbol occurs
          more than  once,  the  first  global  value  encountered  is
          returned  if  there is one, otherwise the first local value.
          The order of seach starts  with  the  most  recently  loaded
          module.     Symbol  should  be  an  atom  or  string,  using
          characters that are legal in LINK  symbol  tables  (letters,
          digits,  "%",  "$",  and  ".").   The value of the symbol is
          returned as an integer.

(GETSYM prop-or-template symbol1 symbol2 ...) [FEXPR] --> NIL
          This is designed for defining functions whose code has  been
          loaded by LOADREL.  It looks up the symbols, as described in
          *GETSYM.  For each symbol, it normally defines the symbol as
                                                                   211


          a  compiled  function  whose code is at the address found by
          *GETSYM.  PROP-OR-TEMPLATE specifies the details of how  the
          function  is to be defined.  It is supposed to be one of the
          following:

               (SUBR n) - defines the symbols as compiled EXPR's, with
                    N arguments

               (FSUBR) or  (FSUBR  .  T)  -  defines  the  symbols  as
                    compiled  FEXPR's.    The  form with . T indicates
                    that the FEXPR has two arguments.

               (MSUBR) - defines the symbols as compiled MACRO's.

               (LSUBR) - defines the symbols as compiled LEXPR's.

          A typical call looks like this:

              (GETSYM (SUBR 2) TESTFN DBFN)

          This defines TESTFN and DBFN  as  compiled  EXPR's,  with  2
          arguments.    TESTFN and DBFN should be symbols defined in a
          module that has been loaded with LOADREL.

          The PROP-OR-TEMPLATE can also be an atom, in which case  the
          value  returned  by  *GETSYM  is put on that property of the
          symbol.

(GETVECTOR vector index) [SUBR] --> object
          VECTOR must be a  vector  pointer  returned  by  MAKEVECTOR.
          Gets the INDEX'th item from the vector and returns it.  This
          can be any legal Lisp object (including a vector).  

(GO tag) [FSUBR] - meaningful only in PROG's.
          GO  requires  an  atom.    You can say (GO A) and if A is an
          atom, it will be used.   Otherwise,  it  will  be  evaluated
          until  an  atom  is  found.  In the interpreter, this can be
          done from functions called within PROG's, etc.   However  in
          the  compiler  it  is likely that it will have to be done at
          the top-level of the PROG, or within nested combinations  of
          COND, AND, and OR appearing at the top level of the PROG.  

(*GREAT x y) [SUBR] --> T if X > Y, else NIL

(GREATERP n1 n2 ...) [MACRO] --> T if the N's are in decreasing order
          i.e.  N1 > N2, N2 > N3, ..., else NIL.  This is a macro that
          generates a testusing *GREAT.  

(GT x y) [SUBR] --> T if X > Y, else NIL

(GTFDB chan displacement) [SUBR] --> integer
          Defined  only  for  Tops-20.  Returns one word from the file
          descriptor block  of  a  file.    CHAN  must  be  a  channel
          associated  with  the  file.  (It need not be open, but must
          have a file spec associated with it.)   DISPLACEMENT  is  an
                                                                   212


          integer  specifying the piece of information desired.  It is
          returned as an integer.  See the Monitor Calls manual for  a
          list of information available.

(HELP topic subtopic subtopic ...) [FEXPR] --> function-name
          The  top  level  of the help system.  See the chapter on the
          help system for a general description.    If  subtopics  are
          supplied,  they are concatenated onto the function-name with
          hyphens.  E.g. (HELP DO FOR) is equivalent to (HELP DO-FOR).
          HELP tries the following three ways of  getting  information
          about the object specified:

             - By  info on a file, pointed to by a property HELP-
               FILE-INFO whose  value  is  a  list  of  the  form
               ((MODULE (FILE START STOP))*), where the MODULE is
               provided   for  multiple  entries.  There  may  be
               multiple entries for a single module.  MODULE  may
               also  be  NIL, which indicates that the creator of
               the index did not bother to provide a module name.

             - By extracting comments from a function definition.

             - If all of these fail there is a  somewhat  dubious
               attempt  to  provide  info  about  the type of the
               value of the topic interpreted as a variable.

          Any call to HELP will load  ELISP.NDX  and  HELPER.INDEX  if
          they have not already been loaded.

(HELP:CREATE-INDEX-FILE sourcefile indexfile module) [EXPR]
          Sourcefile  is  expected  to be in help file format. See the
          chapter  on  the  help  system.    Creates  an  index   into
          sourcefile  on  indexfile.  Module  is of course what module
          this help file is for. May be NIL.  A list of keys is  saved
          as  the  value of the name of the sourcefile minus directory
          and extension.  Indexfile can simply be DSKINed.

(HELPM module topic subtopic subtopic ..) [FEXPR] --> topic
          Like HELP,  but  only  accesses  help  information  for  the
          specified module.

(HOOK1 expression) [EXPR] --> number
          This  is  one  of  the  functions  used by SSTEP, the single
          stepper.  The user can define his own HOOK1.  When  stepping
          is  in effect, every time EVAL is called for something other
          than a simple variable, it calls HOOK1.  It passes HOOK1 the
          expression being evaluated.  HOOK1 returns a code indicating
          what to do:

             - 0 - continue stepping

             - 1  -  turn  off  stepping  while  evaluating  this
               expression.    It  will  be  turned  back  on when
               evaluation of this expression is finished.
                                                                   213


             - 2 - turn off stepping permanently (except that any
               expressions  for  which  stepping  is currently in
               progress will still have HOOK2 called)

             - 3 - call BREAK1 on the expression

          I/O is automatically redirected to the terminal before HOOK1
          is called.

(HOOK2 value expression) [EXPR] --> ignored
          This is one of the  functions  used  by  SSTEP,  the  single
          stepper.   The user can define his own HOOK2.  When stepping
          is in effect, every time EVAL is called for something  other
          than  a  simple  variable,  it calls HOOK2.  HOOK2 is called
          after the evaluation is completed.  It is passed  the  final
          value  and  the  expression  that  was evaluated.  The value
          returned by HOOK2 is ignored.  Presumably HOOK2 will display
          the value and expression  in  some  useful  form.    I/O  is
          automatically  redirected  to  the  terminal before HOOK2 is
          called.  

IBASE - a variable.  
          This is the current input radix.  It can be any integer from
          2 to 10.  The user  can  change  it,  and  it  takes  effect
          immediately.  This  radix  is  used  for  all integer input,
          unless an explicit radix is indicated by a point  after  the
          number.    A  dot  (decimal  point)  indicates decimal.  A Q
          indicates  octal.    Points  are  not  available  for  other
          radices.  

(INC atom close) [EXPR] --> previous input channel
          This  function  is  provided only for compatibility with UCI
          Lisp.  New programs should  use  SELECTIN  to  select  input
          files.   INC is only useable for files opened by INPUT.  The
          previously selected input channel is  returned  in  its  UCI
          form, i.e. as an atom.  

(INCR x) [MACRO] - (SETQ X (ADD1 X)) 

/#%INDENT - a variable
          This is the current indentation level for output from TRACE.
          This may be useful if you supply your own output function as
          %PRINFN.    Note  that the actual variable name is #%INDENT.
          However # is a read macro in the default system, so you will
          have to "quote" it with / in order to type it in. 

(INITFN function) [SUBR] --> old function
          This allows you to  to  set  up  a  function  that  will  be
          executed  whenever  Lisp  gets  to  its "top level", i.e. at
          startup and after errors, ^G, etc.  It should be a  function
          of  no  arguments.  If this function is an infinite loop, it
          will effectively replace the Lisp READ-EVAL-PRINT loop.   If
          it exits, the normal READ-EVAL-PRINT loop will take over.  

(INITPROMPT n) [SUBR] --> old value
                                                                   214


          Sets  the  initial  value of the prompt printed when Lisp is
          waiting for terminal input.  This  is  normally  "*".    The
          value  set  by  this  function  is used to set up the prompt
          whenever Lisp is restarted by an error, ^G, etc.    Thus  it
          does  not  take effect immediately.  (Use PROMPT if you want
          it to take effect immediately, but be reset at the next  ^G.
          Use both for a permanent change.)  Note that the argument is
          a  number, which is the ASCII code for the prompt character.
          The old value is returned.  

(INP item list) [EXPR] --> T or NIL
          Returns T if any subpart of  LIST  is  EQ  to  ITEM.    This
          differs  from  MEMQ  in that it tests all parts of the list,
          not just the top level.  

(INPUT [atom] filenames) [FEXPR] --> the atom, or T if none
          This function is provided only for  compatibility  with  UCI
          Lisp.    New  programs  should  use OPENIN to open files for
          input.  In addition to the usual UCI file name  syntax,  you
          may use a string with a complete Tops-20 file specification.
          Note  that  "PPN"s  should  be pairs of atoms.  They will be
          concatenated to make a directory name.  E.g.  (HED RICK)  is
          equivalent to <HEDRICK>.  Wildcards (* and %) may be used in
          the filename.  

(INSERT object list comparefn nodups) [EXPR] --> list
          (The  insert,  merge,  and  sort  functions were copied with
          minor  modifications  from  the  Carnegie-Mellon  University
          LISPX  package).    INSERT destructively inserts OBJECT into
          the sorted list LIST in the proper slot using COMPAREFN as a
          binary comparison function.

              (COMPAREFN X Y)

          should return a non-NIL value if  X  either  precedes  Y  in
          sorted  order  or  X  and Y are equal, and NIL if Y precedes
          X. If COMPAREFN is missing or NIL, LEXORDER  will  be  used.
          NODUPS controls the handling of duplicate values:  if NODUPS
          is  non-NIL,  OBJECT  will  not  be inserted into LIST if an
          element equal to OBJECT is already present in LIST.   INSERT
          performs  a  binary  search to determine where to insert the
          new element.  The value returned by INSERT is the list  LIST
          with OBJECT inserted.  

(INTERN atom) [SUBR] --> atom
          INTERN  is  used  to  make sure that all atoms that look the
          same are  the  same.    GENSYM,  MAKNAM,  and  a  few  other
          functions,  can return data structures that look like atoms,
          but have not been checked for uniqueness.  That  is  (MAKNAM
          '(A  A A)) is something that looks like the atom AAA, but is
          not EQ to it.  That is  because  MAKNAM  produces  the  data
          structure  for an atom, but does not bother to check whether
          there is already an atom of the same name.  (INTERN  (MAKNAM
          '(A  A  A))) would look up the resulting name to see whether
          there is already an atom by that name.  If not, it will  add
                                                                   215


          the  new atom to the list of known atoms, and return it.  If
          there was already an atom by that name, INTERN  returns  the
          old  one.    Must functions that produce atoms have versions
          that automatically INTERN. (e.g. READLIST is like MAKNAM but
          INTERN's any atoms it creates.)  

(INTERSECTION l1 l2) [EXPR] --> L1 intersect L2
          Returns a list which is the intersection of  the  two  lists
          <l1>  and  <l2>.    If  <l1> and <l2> are of unequal length,
          INTERSECTION is more efficient if <l2> is the  longer  list.
          Note  that membership tests are made using MEMBER (and hence
          EQUAL).  If MEMB (EQ) checks are desired instead, change the
          value of MEMBFN from MEMBER to MEMB.  

(INUMP thing) [SUBR] --> T or NIL
          Is T is THING is an INUM, that is a number that requires  no
          space to store.  Currently numbers requiring 30 bits or less
          are represented as INUM's.

(JFNS <filename or channel> bits) [SUBR] --> filename
          This  allows  you  to  get  the filename associated with any
          channel that is open.  This name is returned  as  a  string.
          If BITS is omitted or NIL, you will get the name of the file
          in  the normal Tops-20 format.  See the Monitor Calls manual
          for other formats that you can generate by  supplying  BITS.
          If it is not NIL, BITS must be a number, and is used for AC3
          of the JFNS call.  CHANNEL must refer to an I/O channel that
          has  been  opened  on  a file.  Although NIL can normally be
          used as if it were a  channel,  it  is  not  legal  in  this
          context.

          You can also pass a string (or atom, in which case the PNAME
          is  used)  as  the  first  argument.  In this case JFNS will
          parse the string as a file name and return whatever piece of
          it is specified by the bits.  This is the recommended way of
          finding the device, directory, and extension, version, etc.,
          when you have a complete file name as a string.   Note  that
          JFNS will not actually look up the file, so it will not know
          any  information  not present in the original specification.
          If you do (JFNS "FOO.BAR" 000010000000Q) (this asks for  the
          version  number), you will get "0".  To actually look up the
          file and find its version number you  can  either  do  (JFNS
          (LOOKUP  "FOO.BAR") 000010000000Q) or actually open the file
          with OPENF and do JFNS on the channel.

(LABEL atom functional-form) - special form
          See the section on LABEL in the  introduction.    Binds  the
          atom  to the functional form, and otherwise acts the same as
          the functional form itself.  

(LAMBDA variable-list expr) - special form
          This is the basic way of writing Lisp functions.    See  the
          section of basic syntax at the beginning of this document.  

(LAST list) [EXPR] --> the last "tail" of the list.  
                                                                   216


          That  is,  it  CDR's  down the list until one more CDR would
          give an atom. E.g.

              (LAST '(A B C)) --> (C)
              (LAST '(A B C . D)) --> (C.D)

          Here is the definition:

              (DE LAST (L)
                  (COND ((ATOM (CDR L)) L)
                        (T (LAST (CDR L)))))

(LCONC pointer new-list) [EXPR] --> updated pointer
          LCONC is used for building up lists efficiently.    It  uses
          the same basic conventions as TCONC, so you should read that
          first.   Where TCONC is used to add elements at the end of a
          list, LCONC is used for building a list by adding  lists  at
          the end.  For example:

              *(SETQ FOO (NCONS NIL))
              (NIL)
              *(LCONC FOO (LIST 1 2))
              ((1 2) 2)
              *(LCONC FOO (LIST 3 4 5))
              ((1 2 3 4 5) 5)
              *(LCONC FOO NIL)
              ((1 2 3 4 5) 5)

          Note  that  LCONC uses the same pointer conventions as TCONC
          for eliminating searching to the end of the  list,  so  that
          the   same   pointer   can  be  given  to  TCONC  and  LCONC
          interchangeably.  

(LDIFF X Y) [EXPR] --> differences or NIL
          Y must be a tail of X, i.e.  EQ to the  result  of  applying
          some number of CDRs to X. LDIFF gives a list of all elements
          in  X  but  not  in  Y,  i.e.,  the list difference of X and
          Y. Thus (LDIFF X (MEMB FOO X)) gives all elements in X up to
          the first FOO.  Note that the value of LDIFF is  always  new
          list structure unless Y=NIL, in which case (LDIFF X NIL) s X
          itself.   If Y is not a tail of X, LDIFF generates an error.
          LDIFF terminates on a NULL check.

(LE x y) [EXPR] --> T if x <= Y, else NIL

(LENGTH list) [SUBR] --> length of list
          This is the number of things at top level of the list.  

(*LESS x y) [SUBR] --> T if x < y, else NIL

(LESSP n1 n2 ...) [MACRO] --> T if the N's are in increasing order
          i.e.  N1 < N2, N2 < N3, ..., else NIL.  This is a macro that
          generates a test using *LESS.  

(LEXORDER x y) [SUBR] --> T or NIL
                                                                   217


          This  is  used to test which of two objects comes before the
          other  in  alphabetical  order.    Strings  and  atoms   are
          considered  identical.  That is "ABC" and ABC compare as the
          same.  Upper and lower case letters are considered different
          (with lower case being "after" all the upper case).  Numbers
          are compared according to their numerical value.  Thus 1 and
          1.0 compare as the same.   Any  number  is  consider  to  be
          "before"  any  string  or  atom.  List structure can also be
          compared.  If X or Y is a list, LEXORDER  keeps  taking  CAR
          until something atom is found.  

(LINELENGTH n) [SUBR] --> current line length
          If  n  is  NIL, just returns the line length for the current
          output channel without change.  Else sets it to a new value,
          which it returns.  If any output would go beyond this number
          of characters on a line, the sequence ^Y <crlf> is inserted.
          This sequence is ignored on  input.    Note  that  the  line
          length  is  a  parameter associated with particular channel.
          LINELENGTH changes the  parameter  only  for  the  currently
          selected  channel.    Negative  line lengths are essentially
          infinite, except with the prettyprinter.  

(LINEREAD nilOK) [EXPR] --> list
          LINEREAD is designed for reading commands.  It  is  used  by
          the  break  package.  It normally reads what is typed on one
          line, making a  list  of  what  it  finds.    Lines  can  be
          continued by typing trailing spaces, tabs, or commas.  Also,
          if  you  start  an S-expression on one line and don't supply
          enough  close  parentheses  on  that  line,  LINEREAD   will
          continue  looking  on  succeeding  line,  until  things  are
          balanced.  Normally LINEREAD will keep reading until it sees
          something.  However if you set  the  flag  NILOK,  typing  a
          blank line will result in NIL.  

(LINES n) [SUBR] --> NIL
          Leaves  n blank lines.  (LINES 0) goes to the beginning of a
          new line if you are not currently at the beginning.   (LINES
          n) does (LINES 0) and then N (TERPRI)'s.  

(LIST item1 item2 ... itemn) [LSUBR] --> list of all items
          This is used for creating lists at runtime.  If you know you
          want  a list with elements A, B, and C, you can just say '(A
          B C).  But if one of them may be a variable, then  you  have
          to do it at runtime:  (LIST 'A X 'C).  

(LITATOM thing) [SUBR] --> T or NIL
          Returns  T  if THING is a literal atom.  Strings and NIL are
          not counted.

(LOADF file1 file2 ...) [FEXPR] --> Files-loaded
          The normal way to read in one or more files.    LOADF  opens
          each specified file and reads from it.  Reading is done with
          a  REAL-EVAL-PRINT loop, so all expressions in the file will
          be executed, and you will see the results.    When  you  are
          finished, input will be restored to where it was before.
                                                                   218


               Printing  of  the results is controlled by the variable
                    DSKIN.  If it is NIL, printing will be suppressed.
                    It is initially T. 

               The variable *RAISEDSK (initially NIL) may  be  set  to
                    non-NIL   in   order   to  cause  all  lower  case
                    characters read from the file to  be  turned  into
                    upper  except within strings.  Note that *RAISEDSK
                    is only applicable within  LOADF.    LOADF  is  an
                    FEXPR, which means that the filename(s) should not
                    be quoted.

               For  each file, constructs a variable containing a list
                    of its contents.  This variables is the file  name
                    with    FNS    added    to    it.       E.g.   for
                    "PS:<HEDRICK>TEST.LSP.2" the variable is  TESTFNS.
                    The  list  consists  of  prettyprint commands that
                    would duplicate the contents of the file, i.e. (F:
                    fn) for functions, (V:  var)  for  variables,  and
                    (FORM:   form)   for   anything   else   that  the
                    prettyprinter would treat specially.  In addition,
                    the dotted pair (filename . <name>FNS) is added to
                    ALLFILES if it isn't there already. This  variable
                    can be used by DSKOUT or SAVEF to simplify writing
                    new versions of the file.

               Note that functions which would normally add to ALLFNS,
                    ALLSTRS  or ALLVALS (DE, DF, DM, DS, DV) do not do
                    so  within  LOADF,  since  TESTFNS   serves   that
                    purpose.

          The  format  of what goes into the list of the file contents
          (e.g. TESTFNS) is as follows:

               (DE X args defn) [also DF and DM] - (F: X) - this is  a
                    command  to  the prettyprinter that makes it print
                    the current definition of X. Thus if  X  has  been
                    updated,  you will get the newest value.  Function
                    definitions in the old UCI DEFPROP format will  be
                    treated as if they were DE, DF, or DM.

               (DV  X  value)  -  (V:  X)  -  this is a command to the
                    prettyprinter that  makes  it  print  the  current
                    value  of  X. Thus if X has been updated, you will
                    get the newest value.  If  you  want  to  get  the
                    value  as  it was in the file, and not any updated
                    values, use DEFV instead of DV.

               (ELISP: -forms-), (NOCOMPILE -forms-) - the  forms  are
                    processed  recursively,  and a prettyprint command
                    is made up to print them as specified  here,  with
                    ELISP: or NOCOMPILE wrapped around them.

               others - the forms will be printed exactly as read.  If
                    the CAR of the form happens to be something with a
                                                                   219


                    special  meaning  to  the  prettyprinter,  (FORMS:
                    thing)  will  be  used,  to  supress  the  special
                    action.

(LOADREL instructions) [SUBR] --> NIL
          This  is  used  to  load  code  produced  by  assemblers and
          compilers that produced .REL files.    Examples  are  MACRO,
          FAIL, MIDAS, FORTRAN, and PASCAL.  This function is probably
          useful  mostly  to  experts, because it requires you to know
          the linkage conventions of both ELISP and the  language  you
          are trying to load.  LOADREL does no linkage - it just loads
          the  code  and  symbols  from  the  file into binary program
          space.  Currently this is section 1, so your code had better
          be able to run  in  section  1.    Your  program  is  loaded
          together  with SYS:ELISP.REL, which contains all the symbols
          used in  the  assembly  language  portion  of  ELISP.    The
          argument  to LOADREL is a string which is passed directly to
          LINK.  Note that it should end in /G.  The string  you  pass
          is prefixed by the following:

              /start:start/patchs:1/only:low/set:.low.:nnn
              sys:elisp.rel,

          NNN  is  the  address  of  the first free location in binary
          program space.  Your program is assumed to be a conventional
          relocatable program, using at most the normal low  and  high
          segments.    Once  you  have  loaded the program, GETSYM and
          *GETSYM are useful for setting up your routines so they  can
          be called.  

(LOG number) [SUBR] --> real
          Take the natural logarithm of a positive number of any type.
          Returns  a  real  number.  To use this, you must have loaded
          the Arithmetic Package (q.v.).  

(LOG10 number) [SUBR] --> real
          Take the logarithm to the base 10 of a  positive  number  of
          any  type.    Returns  a real number.  To use this, you must
          have loaded the Arithmetic Packages (q.v.).  

(LOOKUP filename) [EXPR] --> filename or NIL
          This checks  to  see  whether  the  specified  file  exists.
          FILENAME  should be a string.  If it exists, the name of the
          file is returned.  If not, NIL is returned.  The  file  name
          returned  is always a string produced by JFNS.  The argument
          can also be an old-format UCI Lisp name, for  compatibility.
          Note  that  whether  you  can see a file with LOOKUP depends
          upon  the  way  the  user  has  set  his  file   protection.
          Furthermore,  just  because  LOOKUP  returns true, you can't
          necessarily open it.  

(LSH X N) [SUBR] --> X, shifted N bits
          Defined only for integers.  Treats the integer X as a 36-bit
          bit vector.  Shifts it  N  bits  to  the  left.    If  N  is
          negative,  shifts  it  to  the  right.  Any vacated bits are
                                                                   220


          filled with zeros.  

(LSUBST x y z) [EXPR] --> copy of Z
          Substitutes  a  copy  of X for all EQUAL occurrences of Y in
          Z. However the copy is "spliced" into Z. Thus (LSUBST '(A B)
          'X '(X Y Z)) will  return  (A  B  Y  Z).    If  (A  B)  were
          substituted  in  the obvious way (e.g. by SUBST), the result
          would be ((A B) Y Z).  

(LT x y) [SUBR] --> T if X < Y, else NIL

MACRO - a tag
          This is used as a tag to ALIAS to  identify  a  Lisp  MACRO.
          The  internal  form  of  a MACRO is (LAMBDA (L) expression).
          The entire  call  is  bound  to  the  variable  L. Then  the
          expression  is evaluated. So far this is much like an FEXPR,
          although an FEXPR sees the CDR of the call.  But the  result
          is  taken as an expression to be evaluated, and it is passed
          to EVAL again.  Macros are used to define  new  Lisp  forms.
          The  Macro can be thought of as a small "compiler". It looks
          at the call and "compiles" a piece of Lisp.  That  piece  is
          then  executed.    Note  that  the  computation of the macro
          should not have any sideeffects,  and  should  be  a  proper
          function.    I  say this because the macro actually executed
          only the first time  it  is  invoked.    The  code  that  it
          "compiles"   is   saved  and  used  in  the  future  without
          "recompilation".  

MACROEXPANSION
          This serves two functions, both of which  are  described  in
          the section on Basic Semantics.  When Lisp evaluates a macro
          invocation,  it  normally  saves  the  code  produced by the
          macro, so it does not have to be called again in the future.
          The form containing the macro call is replaced by

              (MACROEXPANSION resulting-code original-call)

          MACROEXPANSION is defined as  an  FSUBR  the  evaluates  its
          second  argument  and  returns the result.  Hence all future
          calls will just execute the code compiled by the macro.

          Sometimes when you are debugging a macro, you  do  not  want
          this  saving  to  happen.    MACROEXPANSION is also a global
          variable, set initially to T. If you set  it  to  NIL,  this
          will  disable  creating  the  (MACROEXPANSION ..) forms, and
          force the macro to be called each time.

(MAKEARRAY n) [SUBR] --> array
          Returns a pointer to an array of N words.   An  array  is  a
          block  of  memory  that  is  not  looked  at  by the garbage
          collector.  Thus it is  used  for  storing  full-word  data,
          bytes,  and  other  objects  other  than Lisp pointers.  See
          GETxARRAY and SETxARRAY for how to access components  of  an
          array.
                                                                   221


(MAKECARRAY n) [SUBR] --> array
          Similar  to MAKEARRAY, except that the array is put into the
          same area where code is put.  This  is  sometimes  necessary
          for use with the (currently unimplemented) JSYS function.

(MAKEVECTOR n) [SUBR] --> vector
          Returns  a  pointer  to a vector of N items.  These are Lisp
          pointers, and are looked at by the garbage collector.    See
          GETVECTOR and SETVECTOR for how to access the items.

(MAKE-xxx field-name value ...) [MACRO] --> record pointer
          XXX  is  the structure type, as declared with DS.  There may
          be zero or more pairs of field name and value.    The  names
          are  not  evaluated,  the  values  are.  A new record of the
          specified type is created.  The specified fields are set  to
          the  indicated  values.  Any fields unspecified are then set
          to their default values, as defined in the DS  that  created
          the  structure type.  If no default value was specified, NIL
          is used.  

(MAKNAM char-list) [SUBR] --> thing
          Like READLIST, except that any time that READ would normally
          produce an  atom,  there  is  a  slight  change.    You  get
          something this is like an atom, but is not "intern'ed", i.e.
          not  put  on  the  OBLIST.    This  means  that  it won't be
          recognized if you type it later.  e.g.

              (MAKNAM '(A B C)) --> ABC

          but

              (EQ (MAKNAM '(A B C)) 'ABC) --> NIL

          That is because the ABC returned by MAKNAM is not  put  into
          the  "symbol  table", and is thus not recognized as the same
          object as the 'ABC.   With  READLIST  the  EQ  would  return
          T. Putting  things  in  the OBLIST is somewhat permanent, so
          there are times when it is useful to use MAKNAM.  

(MAPxxx ftn list1 list2 ... listn) [FSUBR] --> NIL
          There are several "mapping functions".  Each of them takes a
          function name and  one  or  more  lists.    It  applies  the
          function  to  successive  CDR's  of  the  lists.  E.g.  (MAP
          'PRINT '(A B C)) will print the following

              (A B C)
              (B C)
              (C)

          These functions are one of the main ways to write a loop  in
          Lisp.    The  function  can either be a function name, or an
          actual LAMBDA, FEXPR LAMBDA, etc.

          There are three different things that can be done  with  the
          results of applying a function to successive CDR's:
                                                                   222


               nothing  -  the function is applied for the benefits of
                    any sideeffects.  NIL is returned.

               make a list - the results of the  successive  calls  to
                    the function are combined into a list.  E.g.

                        ((A B C) (B C) (C))

               splice  a  list  -  the  results are NCONC'ed together.
                    E.g.

                        (A B C B C C)

          In addition, some of the functions apply  to  CAR's  of  the
          CDR's,  e.g.  instead  of  (A B C) (B C) and (C), they would
          apply to A, B, and C. 

          Here are the functions:

                      nothing       make a list    splice a list

              to CDR's   MAP           MAPLIST          MAPCON
              to CAR's   MAPC          MAPCAR           MAPCAN

          Because various maintainers have various ideas of names that
          are easy to remember, we have the following synonyms:

              MAPCONC - MAPCAN.
              MAPL    - MAPLIST
              MAPCL   - MAPCAR

          If the function takes N arguments, then you should supply  N
          lists.    MAPxxx  steps through all N lists in parallel.  It
          stops when any list runs out of elements.  E.g.

              (mapcar 'plus '(10 20 30) '(10 20)) --> (20 40)

          Some comment should be made about the semantics used for the
          function calls.  The MAP functions work as if they  did  the
          following.    (In  some cases they actually do, but some are
          optimized.)  A new variable is created for each list that is
          to be stepped.  Each time through the loop, they are set  to
          the  list tails or CAR's (depending upon the function).  The
          body of the loop is a call to the function you supply,  with
          these  variables  as the arguments.  MACRO's and FEXPR's can
          be used, and they will see these created variables as  their
          arguments.    In  compiled  code, the variables are declared
          special when the form is known to be an  FEXPR.    In  other
          cases,  specials  are  not  used.   If the compiler is wrong
          about the type of the function, this can result  in  unbound
          variables  or other strangeness.  Note that as a consequence
          of this, in compiled code the MACRO itself  (as  opposed  to
          the  code  generated by it) can't refer to the values of the
          generated variables.  (They would have to  be  specials  for
          that to work.)  Since macros are usually expanded only once,
                                                                   223


          we  conjecture  that the expansion process can't depend upon
          the current values of variables, and thus that such variable
          evaluations will not be done.  

(MAPATOMS func) [EXPR] --> NIL
          Applies FUNC to all atoms on the OBLIST, i.e. to  all  atoms
          in the system.  FUNC should be a function of one argument.  

(MAX n1 n2 ...) [MACRO] --> largest of the arguments
          N1,  N2,  etc. must be numbers.  This returns the largest of
          them.  It uses *MAX to compare them pairwise.  

(*MAX N1 N2) [EXPR] --> larger of the arguments
          N1 and N2 must be numbers.  This returns the larger of them.
          

(MBD: fn x ...) [FEXPR] --> (ASCII 0.)
          Passes the Xs on to PP in such  a  way  that  they  will  be
          prettyprinted inside of an expression starting with FN.  For
          example,  to  prettyprint  F1  and  F2  inside  of  a  PROGN
          expression (perhaps so they will not be compiled) one  could
          do:

              (MBD: PROGN F1 F2)

(MCONS thing1 thing2 ...) [MACRO] --> list structure
          Equivalent  to  (CONS thing1 (CONS thing2 ... (CONS thingn-1
          thingn)))))...  E.g. (MCONS 1 2 3) returns (1 2 . 3).  

(MEMB object list) [EXPR] --> tail of list of NIL
          This is an older name for MEMQ.  MEMQ should be used in  all
          new programs.  

(MEMBER object list) [EXPR] --> tail of list or NIL
          If  OBJECT  is a member of the LIST, returns the tail of the
          list starting with OBJECT.  NIL if it is not.   I.e.  MEMBER
          CDR's  down the list, checking each CAR to see whether it is
          EQUAL to OBJECT.  If so, it returns the  part  of  the  list
          that starts with OBJECT.

              (MEMBER 'B '(A B C)) --> (B C)

MEMBFN - a variable
          This  variable  is  bound  to the name of the function to be
          used by ENTER,  INTERSECTION,  and  UNION  to  test  whether
          something  is  already  in  a  list.  Normally it is MEMBER.
          These functions can be speeded up by setting it to MEMQ,  if
          all  lists  you  are  interested  in are known to consist of
          atoms only.  

(MEMQ object list) [EXPR] --> tail of list or NIL
          Like MEMBER, but uses EQ instead of  EQUAL  to  see  whether
          things  on  the  list  are  the  same of OBJECT.  Thus it is
          faster than MEMBER, since EQ is faster than EQUAL.  Since EQ
          works for literal atoms, MEMQ should always be used  if  you
                                                                   224


          know what you are looking for is a literal atom.  

(MERGE list1 list2 comparefn nodups) [EXPR] --> list
          MERGE  returns  a  new list which is the merge of the sorted
          lists  LIST1  and  LIST2.    COMPAREFN  and  NODUPS  are  as
          described  under  INSERT,  i.e.,  COMPAREFN  is  the  binary
          comparison function, and NODUPS controls  whether  duplicate
          elements  will  be  allowed  or  not.    These  last two are
          optional.    If  omitted  (i.e.  defaulted  to   NIL),   the
          comparison  function  is LEXORDER, and NODUPS is NIL.  These
          are reasonable for most cases.

(METER code) [SUBR] --> count
          Returns the low order 35  bits  of  the  accounting  meters.
          This is used for timing when high accuracy and repeatability
          are  needed.    Only differences between two values have any
          meaning.  Please note that the actual value is 59  bits,  of
          which  we  are  showing  you the low order 35.  In principle
          there could be overflows.    However  for  times  of  a  few
          minutes or less this should not be a problem.

          Currently two codes are defined:

              (METER 1) - EBOX count
              (METER 2) - MBOX count

          The  EBOX count is the number of EBOX ticks, i.e. the number
          of fast clock cycles.  These occur at a  rate  of  about  10
          million  per  CPU  second.   The MBOX count is the number of
          memory references.  Monitor overhead is removed  from  these
          counts.    However  pager  refills  and other load-dependent
          quantities may affect them slightly.  Before using this, you
          should probably consult a system wizard.  

(MIN n1 n2 ...) [MACRO] --> smallest of the arguments
          N1, N2, etc. must be numbers.  This returns the smallest  of
          them.  It uses *MIN to compare them pairwise.  

(*MIN N1 N2) [EXPR] --> smaller of the arguments
          N1  and  N2  must  be  numbers.  This returns the smaller of
          them.  

(MINUS number) [SUBR] --> - number

(MINUSP number) [SUBR] --> T if number is negative, else NIL

(MODCHR char-code new-value) [SUBR] --> old-value
          See the section on  the  read  table  in  the  introduction.
          MODCHR  takes  as  its  argument a number which is the ASCII
          code for a character.  It returns  the  entry  in  the  read
          table  for that character.  This value is a number which you
          can save, but whose format I am not going to define.  If you
          want  to  change  the  read  table  entry,  supply  a  third
          argument.   E.g. to make # be an open parenthesis, you might
          do
                                                                   225


              (MODCHR (CHRVAL '/#) (MODCHR (CHRVAL '/( ) NIL))

          If  the  second  argument  is  NIL or missing, MODCHR simply
          returns the old value without changing it.

(MSG thing1 thing2 ...) [FEXPR] --> NIL
          MSG provides a general message-printing facility  for  LISP.
          Each  <i>  is  an  instruction  which  provides  a  specific
          formatting capability:

               "<string>" Print <string> using PRINAC

               +<number> Space <number> (gt 0) spaces

               (T '<n>) Tab to position <n>

               T Move to new line

               -<number> Print <number> blank lines

               0 Get to start of line

               (E <expr>) Evaluate <expr> and print with PRIN1

               (C <expr>) Evaluate <expr> and print with PRINC

               other Eval and print using PRINA

          As an example of the use of MSG, consider the following:

              (MSG 0 "Value of X is:" 5 X T)

          which is equivalent to:

              (PROGN (LINES 0)
                     (PRINAC '"Value of X is:")
                     (SPACES 5)
                     (PRINA X)
                     (TERPRI))

          Note that MSG prints the desired message  on  the  currently
          selected  output  device.   MSG returns NIL, and is compiled
          in-line.

(MYDIR) [SUBR] --> string
          Returns the directory to which the user is connected,  as  a
          string.  A typical example is "PS:<HEDRICK>".

(MYUSER) [SUBR] --> string
          Returns  the  user's  user  name,  as  a  string.  A typical
          example is "HEDRICK".  

(*NCONC list1 list2) [SUBR] --> new list
          Special version of NCONC that only works with  2  arguments.
          Possibly it is slightly faster than NCONC in this case.  
                                                                   226


(NCONC list1 list2 ... listn) [LSUBR] --> new list
          Concatenates  the  lists  destructively.   That is, list1 is
          changed by making its last element point to list2.  The last
          element of list2 is made to point to list3,  etc.  That  is,
          the last element of each list has RPLACD done to it.  If any
          of  the lists is NIL, it is ignored.  The first non-NIL list
          is returned.  The result produced by NCONC looks the same as
          that produced by APPEND.  However APPEND does not change the
          original lists and NCONC does.  This  means  that  NCONC  is
          faster than APPEND, but more dangerous.  

(NCONC1 list item) [EXPR] --> list, modified
          Equivalent  to  (NCONC LIST (LIST ITEM)).  I.e. it adds ITEM
          to the end of LIST.  

(NCONS item) [EXPR] --> new list
          Returns a list with one member, ITEM.  It is  equivalent  to
          (CONS ITEM NIL).  

(NE x y) [EXPR] --> (NOT (EQP X Y))
          I.e. not equal, defined for numbers.  

(NEQ a b) --> (NOT (EQ A B))

(NEWFILE filename) [FEXPR] 
          Adds  a  file  to  ALLFILES.    Use  this to provide another
          alternative for the next call to SAVEF or FILES?.   Actually
          it  adds  both  the file name and <name>FNS, a variable made
          from the file name.  It sets the variable to NIL.

(NEXTF channel) [SUBR] --> channel or NIL
          Advances to the next file for a channel that  is  associated
          with more than one file.  This will happen if wildcards were
          specified  as part of a file name, or if a list of files was
          given.  NEXTF returns the channel if it succeeds, and NIL if
          it doesn't.  Usually if it returns NIL, this means that  you
          have  exhausted  the  list of files in the group.  Note that
          NEXTF  is  only  useful  with  channels  created  by  OPENF.
          Channels  created  by  OPENIN are always in CONTINUOUS mode.
          This means that they automatically advance to the next  file
          when  the  end  of  a  previous one is reached.  When NIL is
          returned, the channel is no longer of any use.  I.e.  it  is
          effectively closed in the default manner.  

(NEXTEV stack-index) [SUBR] --> stack-index
          See  the  section  on the evaluation context stack.  This is
          used to search for EVAL blips.  If the argument is the index
          of  an  EVAL  blip,  the  argument  is  returned  unchanged.
          Otherwise,   it  searches  down  the  stack  (towards  lower
          indices) for the next EVAL blip, and returns its index.  

NIL - an atom and a list.
          This is the null list.  It is also used for false in Boolean
          operations.  It is considered both an atom and a list.    It
          cannot  have  any  properties,  however.    It  evaluates to
                                                                   227


          itself, so you can write NIL instead of 'NIL.  It is illegal
          to rebind NIL.  (CAR NIL) and (CDR NIL) are both NIL.  

(NILL anything) [FEXPR] --> NIL
          NILL  ignores  its  argument.    It is an out of date way of
          putting comments into functions.  The convention using {;; }
          is recommended now.  

(NOCALL fn1 fn2 ...) --> NIL
          This is present for compatibility with older versions.    It
          doesn't  do  anything.    The  arguments  are supposed to be
          function names.  They are not evaluated.  

(NOCOMPILE exp1 exp2 ... expn) -- NIL or value of Expn
          This is used to control compilation.  NOCOMPILE acts exactly
          like PROGN in interpreted code.  However the  compiler  will
          completely  ignore  the  NOCOMPILE  and  anything inside it.
          Nothing will be written into the .LAP file for it.  

NOPRETTYPROPS - a variable
          If true (default) an error message will be  printed  on  the
          terminal if any argument to PP doesn't have a prettyprop.  

(NOT thing) [SUBR] --> T or NIL
          Returns T if thing is NIL, else NIL 

(NOTANY fn l1 . . . ln) [MACRO] --> NIL or T
          Equivalent to (NOT (SOME fn l1 . . .)).  

(NOTEVERY fn l1 . . . ln) [MACRO] --> NIL or T
          Equivalent to (NOT (EVERY fn l1 . . .)).  

(NOUUO flag) [EXPR] --> old value of flag
          This  is present only for compability of older versions.  It
          sets the value of the NOUUO flag, and returns the old value.
          However this flag is not used for anything at all.  

(NTH list n) [EXPR] --> returns Nth tail of the list

              NTH(L,1) is just the list L itself.
              NTH(L,2) is the CDR
              NTH(L,3) is (CDR (CDR L))
              etc.

(NTHCHAR thing n) [SUBR] --> character atom or NIL
          Gets the N'th character in  the  printed  representation  of
          THING.   It is assumed to be printed with PRINC (i.e. no " "
          around strings, etc.).  N = 1 is the first character.  If  N
          is  negative,  counting  is done from the end of the string.
          That is, -1 is the last character, -2 the next to last, etc.
          If N is 0, too large, or too small, NIL is returned.    This
          function  is  similar  to  (CAR  (NTH  (EXPLODEC THING) N)),
          however it doesn't do any CONS's.  

(NULL thing) [SUBR] --> T or NIL
                                                                   228


          Exactly like NOT 

(NUMBERP thing) [SUBR] --> T if it is a number, else NIL

(NUMTYPE number) [SUBR] --> FIXNUM, FLONUM, or INUM
          Valid  only for numbers.  It returns an atom indicating what
          sort of number its argument is.  INUM's are  integers  small
          enough that no space is needed.  Currently numbers requiring
          30  bits  or  fewer  are  stored  as  INUM's.   FIXNUM's are
          integers bigger than this (up  to  36  bits,  which  is  the
          largest  possible  on  this  system).  FLONUM's are floating
          point numbers.  

OBLIST - a variable
          This variable contains all of the  literal  atoms  that  the
          system  has  seen.  Whenever you type an atom, it is checked
          against the oblist to see if the atom has already been seen.
          If so, the old one is used.  If not, the new one is added to
          the oblist.  This is the reason that A is always that  same,
          no  matter  how many times you type it.  The OBLIST is not a
          simple list, but a two-level structure that is  searched  by
          hash-coding.   We  do  not  guarantee  to  keep  the  format
          constant.  At the moment it is not safe for  you  to  change
          the  OBLIST  yourself.  However you should feel free to look
          at it.

(OPENF filespec options) [SUBR] --> channel or NIL
          This function allows you to open files or simply  look  them
          up.    It is the basic function for generating I/O channels.
          Note however that for simple cases, OPENIN and  OPENOUT  are
          easier  to  use.   OPENF is controlled by a list of options.
          E.g. to duplicate the (OPENIN "DATA.FILE") as  shown  above,
          you  would  use (OPENF "DATA.FILE" '(OLD IN)).  This options
          OLD and IN specify that this must be an existing  file,  and
          that  it is to be opened for input.  The options come in the
          following sets:

               OLD, NEWVERSION, NEW -  Unless  you  give  an  explicit
                    version  number  with  the  file  name, you should
                    specify one of these.  OLD means that the  highest
                    existing  version  of  the  file will be used, and
                    that it must exist.  NEWVERSION means that  a  new
                    version  will be created.  NEW means that the file
                    must be entirely new.  That is, no version at  all
                    may exist before.

               WILD  - If you specify this, * and % will be allowed in
                    the file name.  In this case the channel  will  be
                    associated with an entire group of files.

               IN,  OUT,  APPEND  - If you want the file to be opened,
                    you must specify one of these.  IN is used if  you
                    want to read, OUT if you want to write, and APPEND
                    if  you  want to write starting at the end of what
                    was in the file before.  You may specify  both  IN
                                                                   229


                    and OUT if you want to be able to change the file.
                    If  you  don't  specify  at  least  one of these 3
                    options, the file will not be opened at  all.    A
                    channel  will  still  be  created,  and it will be
                    associated with the file.  However no I/O  can  be
                    done  on the file.  (This is still useful, since a
                    file can be renamed, deleted, etc., without  being
                    open.)

               ERROR  -  if  you specify this option, then if anything
                    goes wrong with looking up or  opening  the  file,
                    OPENF will return NIL.  Normally if something goes
                    wrong,  it  generates  an error.  This option lets
                    you handle errors yourself.

               CONTINUOUS - if you have specified more than  one  file
                    (either my using wildcards, or by giving a list of
                    file  names),  CONTINUOUS  means that they will be
                    treated as a single stream of input.  When end  of
                    file  is  reached  on  one, it will be closed, the
                    next one will be opened, and input will  continue.
                    If  this  is  not set, you will get an end of file
                    condition at the end of each file.  NEXTF can then
                    be used to get to the next file.

               integer - from 1 to 36.  Specifies the byte size of the
                    file.  (7 is the normal case for text, and is  the
                    default.  36 is the normal case for binary files.)

          The second argument to OPENF is a list of options taken from
          this list.  If you want the file opened, you must select one
          of  IN,  OUT,  or  APPEND.    If  most cases you should also
          specify either OLD or NEWVERSION.    The  other  things  are
          optional.    Effectively  OPENIN  is equivalent to using the
          options (OLD IN CONTINUOUS) and  OPENOUT  is  equivalent  to
          (NEWVERSION OUT)

          The  first argument is one of the following:  a file name, a
          list of file names, or a channel.  A file name is  a  string
          containing   a   valid   Tops-20  file  specification,  with
          wildcards allowed if WILD is set.  You can  also  specify  a
          list  of  such strings.  You can specify more than one file,
          either by using a list of names, or by using  wildcards  (or
          both).    In  this  case  the channel is associated with the
          entire group of  files.    Depending  upon  the  setting  of
          CONTINUOUS,  your  program  may  see  the whole group as one
          continuous file, or it may have to advance  explicitly  from
          one  to  the next using NEXTF.  Note that when you reach the
          end of a file, it is automatically closed if  CONTINUOUS  is
          set, but not if it is not set.

          A  channel is used as the first argument in case you want to
          open a channel that is closed.  Possibly the  original  call
          to  OPENF  did  not  specify  one of IN, OUT, or APPEND.  Or
          possibly you  have  closed  it  (with  the  optional  second
                                                                   230


          argument   set   in  CLOSEF).    In  this  case,  NEW,  OLD,
          NEWVERSION, and WILD are irrelevant.  The channel  continues
          to  refer to the same file it refered to before.  It is just
          opened.  You should specify one of IN, OUT, or APPEND.

          OPENF returns a channel if it works.    If  it  doesn't,  it
          either  generates  an  error  (default),  or returns NIL (if
          ERROR is set).

(OPENIN filespec list) [FSUBR] --> a channel
          This is the procedure used to open one  or  more  files  for
          input.    The  filespec list consists of one or more Tops-20
          file names, either as strings or atoms.   It  is  an  FSUBR,
          which  means  that  the arguments are not evaluated.  Thus a
          typical usage is

              (OPENIN "foo.bar"  "bar.lsp")

          If you specify more than one file,  input  switches  to  the
          next  at the end of file on the previous one.  This does not
          actually start reading from that file.  It only opens it and
          makes it available.  To actually read from  it,  you  should
          use  SELECTIN  on  the  channel  returned.  See SELECTIN for
          details.  Wildcards may be used in the filespec, as  allowed
          by Tops-20 file name syntax.

(OPENOUT filespec) [FSUBR] --> a channel
          Similar  to OPENIN, but for output files.  Only one file may
          be mentioned, since there is no such thing as end of file on
          an output file.  

(OR form1 form2 ... formn) [FSUBR] --> NIL or value of  first  non-NIL
                    form
          Evaluates  forms  until  one  is non-NIL.  Returns the first
          non-NIL form, or NIL if all are NIL.  This can  be  used  to
          combine  tests,  but  it  is also a perfectly usable control
          structure.  It is similar to a PROGN,  but  stops  when  the
          first expression succeeds.  

(OUTC atom close) [EXPR] --> previous output channel
          This  function  is  provided only for compatibility with UCI
          Lisp.  New programs should use SELECTOUT  to  select  output
          files.    OUTC  is  only useable for files opened by OUTPUT.
          The previously selected output channel is  returned  in  its
          UCI form, i.e. as an atom.  

(OUTPUT [atom] filenames) [FEXPR] --> the atom, or T if none
          This  function  is  provided only for compatibility with UCI
          Lisp.  New programs should use OPENOUT  to  open  files  for
          output.   In addition to the usual UCI file name syntax, you
          may use a string with a complete Tops-20 file specification.
          Note that "PPN"s should be pairs of atoms.    They  will  be
          concatenated  to make a directory name.  E.g.  (HED RICK) is
          equivalent to <HEDRICK>.  
                                                                   231


(OUTVAL index value) [SUBR] --> NIL if it fails
          OUTVAL  adjusts  INDEX to an Eval-Blip and returns from that
          position with VALUE.  If something goes  wrong,  it  returns
          NIL.  

(P: props x ...) [FEXPR] --> NIL
          PRETTYPROPS is set to PROPS, the Xs are passed on to PP, and
          PRETTYPROPS  is  restored.  For example, F: could be defined
          as

              (P: '((EXPR . PP-FUNCTION) (FEXPR . PP-FUNCTION)
                    (MACRO . PP-FUNCTION))
                  fn
                  ...)

(PATOM thing) [SUBR] --> T or NIL
          Returns T if THING is atomic (i.e. not  a  CONS  cell),  NIL
          otherwise.    This function is exactly the same as ATOM.  It
          is present for compatibility with Rutgers/UCI Lisp.  In  the
          latter,  ATOM was true only for legal Lisp pointers, whereas
          PATOM included wierd pointers.  In this version of Lisp,  it
          should  be  impossible to get anything other than legal Lisp
          pointers, so there is no difference.  

(PEEKC) [EXPR] --> number, code for a character
          Returns the next character from the current  input  channel,
          just  as  TYI would.  But it also UNTYI's it.  Thus next TYI
          will get it again.  

(*PG*) [EXPR] --> NIL
          Outputs a page eject; may be used to place various  sections
          of a large symbolic file on different pages.

(PLIST atom) [SUBR] --> property list
          This  returns  the  entire property list of the atom, in its
          internal form.    This  form  is  a  list  with  alternating
          properties  and  value,  e.g. (PROP1 VAL1 PROP2 VAL2).  Note
          that this is not ALIST format.  RPLACPLIST can  be  used  to
          change set the entire PLIST to a new value.  

(*PLUS x y) [SUBR] --> x + y

(PLUS n1 n2 ...) [MACRO] --> n1 + n2 + ...
          This  is  a  macro that expands to the appropriate number of
          calls to *PLUS.

(POP list) [MACRO] --> item
          LIST is the name of a variable that  is  bound  to  a  list.
          This  returns  the CAR of the list, and sets the variable to
          the CDR.  

(PP a ...) [FEXR] --> NIL
          Prettyprints objects.  If A is atomic, each  property  of  A
          which appears on the list PRETTYPROPS (see below for info on
          PRETTYPROPS)  is  printed  in  readable  format. (If no such
                                                                   232


          properties appear a message to that effect is printed - this
          message  may be suppressed by setting NOPRETTYPROPS to NIL).
          Each non-atomic A is simply printed via  SPRINT  unless  its
          CAR is defined as a "prettyprint command", in which case the
          expression is evaluated. (Prettyprint commands are explained
          in  section 19.2.)  A may also be a list consisting of a LAP
          expression followed by a sequence of LAP code; such  a  list
          will  be  printed  in  standard  LAP  format.   If no As are
          present, the value of LASTWORD is used.   LASTWORD  is  also
          set  to the name of the last function printed.  Note that if
          the value of the atomic symbol PP is non-NIL and  output  is
          being  directed  to  a  device other than the primary output
          channel (usually the terminal), PP will print  the  name  of
          each function printed on the terminal.  This feature is used
          by  DSKOUT  to  provide feedback about the dump (i.e., PP is
          set to the value  of  DSKOUT  before  the  prettyprinter  is
          invoked).  

(PP; l) [FEXPR] --> NIL
          This function is like PP, but comments are normally printed.
          

(PP-FORMAT e n flag) [EXPR] --> NIL
          Prints  the  expression  E  with the first N+1 elements (the
          function name and N arguments) printed on one  line.    FLAG
          specifies  how the remaining arguments are to be printed: if
          FLAG=NIL (standard  format),  all  remaining  arguments  are
          printed   under  the  first  argument;  if  FLAG=MISER,  the
          remaining arguments are placed under the function  name;  if
          FLAG=LABELS,  all non-atomic arguments are printed under the
          first argument, with atoms placed to  the  left  as  labels.
          Note, however, that if the entire expression will fit on one
          line,  and  is less than PPMAXLEN characters long (initially
          65), it will be printed on one line.

(PP-FUNCTION f d p) [EXPR] --> NIL
          This function is used by PP (et al) to print functions.   It
          is  a cross between a prettyprint function and a printmacro.
          It prints F with it's definition (D) in (DE ... format based
          upon property (the type of function).  The first  line  will
          try to have N elements on it where N is:

              (+ 1 (OR (GET f 'PP-FUNCTION) 2)

          (ie.  the  value  of  the  PP-FUNCTION of the function being
          printed, or if that is NIL, 3 the usual way to see DE) 

(PPL var ...) [FEXPR] --> NIL
          Prettyprint a list of objects. Each VAR should be an  atomic
          symbol  which is bound to a prettyprint list to be passed on
          to PP.  This prettyprint list  may  contain  atomic  symbols
          whose  properties  are  to  be  printed, prettyprint command
          expressions, and other expressions which are to be SPRINTed.
          Each VAR (except ALLFNS, ALLSTRS and ALLVALS) which  is  not
          already  a member of its prettyprint list will be printed so
                                                                   233


          that  if  dumping  to a file its value will be restored when
          the file is subsequently loaded.  The prettyprint list  will
          disappear  when the file is compiled, however (i.e., it will
          not appear in the LAP file).  

(PPL; l) [FEXPR] --> NIL
          This  function  is  like  PPL,  but  comments  are  normally
          printed.  

PPMAXLEN - a variable
          This  is  the page width used by PP.  It is initially set to
          65.

(PP-SPECIAL e) [EXPR] --> NIL
          Equivalent to:

              (PP-FORMAT e n flag)

          where N is  the  value  of  (GET  (CAR  e)  'PP-SPECIAL)  if
          present,  or  1 if there is no PP-SPECIAL property.  FLAG is
          either NIL or MISER, depending  on  how  deeply  nested  the
          expression  E  is.  This is the printmacro function used for
          system functions which  have  one  or  two  arguments  which
          should  be  printed  on  the  same line as the function name
          regardless of whether MISER  format  is  necessary  for  the
          remaining arguments (such as SETQ and DE).  

(PP-LABELS e) [EXPR] --> NIL 
          Equivalent to:

              (PP-FORMAT e n 'LABELS)

          where N is the value of (GET (CAR e) 'PP-LABELS) if present,
          or  1 if there is no PP-LABELS property.  This is the system
          printmacro function used for PROG.

(PP-MISER e) [EXPR] --> NIL 
          Equivalent to:

              (PP-FORMAT e n 'MISER)

          where N is the value of (GET (CAR e) 'PP-MISER) if  present,
          or  1  if there is no PP-MISER property.  This is the system
          printmacro function used for LAMBDA, DEFPROP, FUNCTION,  and
          *FUNCTION (the last two with n=0).

(PP-STRUCTURE name d 'STRUCTURE-FIELDS
          }  This  function  is  used  by  the pretty-printer to print
          structure definitions.  NAME is the name of  the  structure,
          and  D  is its definition (in internal format - which is not
          guaranteed).  

PRETTYFLG - a variable
          If NIL, suppress SPRINT from prettyprinting anything.
                                                                   234


PRETTYPROPS - a variable
          PRETTYPROPS  is a global variable.  It gives instructions to
          PP and PPL about what to print.  The most important  members
          of  PRETTYPROPS  are  EXPR,  FEXPR,  MACRO,  and  VALUE.  If
          PRETTYPROPS is the list (EXPR FEXPR MACRO  VALUE),  then  PP
          will  print  function  definitions of EXPR, FEXPR, and MACRO
          type, and  variable  bindings  ("values").  If  other  atoms
          appear  on PRETTYPROPS, they are taken to be property names.
          E.g.  if  PRETTYPROPS  is  (EXPR   COLOR),   then   function
          definitions  of  type  EXPR  are  printed,  as are any COLOR
          properties.

          If an entry in PRETTYPROPS is  a  simple  atom  (as  in  the
          examples  just  shown), PP will print the resulting property
          as a call to DEFPROP.  This is appropriate  for  properties.
          However functions need to be printed as calls to DE, DF, DM,
          and  values should be printed as calls to DV.  For this (and
          similar) applications, PRETTYPROPS allows you to specify the
          format to be used for printing a given property.   This  may
          be accomplished by putting a consed pair of the form (<prop>
          .  <fn>)  onto  PRETTYPROPS;  when  an  atom  with  a <prop>
          property is encountered, PP simply prints a carriage  return
          and  calls  <fn>.   <fn> will be passed three arguments: the
          atom currently  being  PPed,  the  value  stored  under  the
          property  <prop>,  and the atom <prop> itself.  The function
          can then print anything it wishes before returning to PP, at
          which time another carriage return will  be  printed.    For
          example, the functions PP-VALUE and PP-RMACS are provided by
          the   prettyprint  package  to  print  VALUE  and  READMACRO
          properties in special form.

          PRETTYPROPS is initialized to:

              (SPECIAL (READMACRO . PP-RMACS)
                       (EXPR . PP-FUNCTION)
                       (FEXPR . PP-FUNCTION)
                       (MACRO . PP-FUNCTION)
                       (VALUE . PP-VALUE)
                       PRINTMACRO)

          Prettyprint commands may be used as arguments to  PP  or  in
          PPL  prettyprint  lists  to  perform  a  variety  of special
          formatting tasks.    A  prettyprint  command  is  simply  an
          expression whose CAR is a function name with a non-NIL PPCOM
          property.    Such expressions are evaluated when encountered
          by PP, thus providing a  mechanism  for  "grabbing  control"
          during the prettyprint process.  The user may define his own
          prettyprint  commands,  or  may  use the following functions
          supplied by the system.  Note that in addition to  appearing
          as  prettyprint commands in PPL lists, these expressions may
          be used in other contexts as well.  

(PREVEV index) [EXPR] --> index or NIL
          Analagous to NEXTEV (q.v.), except  that  it  moves  up  the
          Evaluation  Context Stack instead of down it.  I.e. it moves
                                                                   235


          towards more recent data.  

(PRIN thing) - another name for PRIN1

(PRIN1 thing) [SUBR] --> the thing
          prints  the  thing.   This is the basic print routine.  Atom
          names and strings are printed in a way  that  lets  them  be
          read, i.e. with slashes and string quotes as required.  

(PRINA x pos) [EXPR] --> NIL
          Like  PRIN1,  except if an atom won't fit on the line, a tab
          to position  POS  on  the  next  line  is  performed  before
          printing  resumes.    POS  is  optional,  with  a value of 1
          assumed if omitted.

(PRINC thing) [SUBR] --> the thing
          prints the thing.  Differs from PRIN1 in  that  slashes  are
          never  used  in  atom names, and strings are printed without
          the string quotes.  

%PRINFN - a variable
          When the break package wants to print output,  it  uses  the
          value  of  this  variable  to  specify what function to use.
          Normally  it  is  PRINTLEV,  in  case  circular  lists   are
          produced.    You can speed up printout by setting %PRINFN to
          PRINT, and you can make it look nicer by  setting  it  to  a
          function that uses SPRINT.  

%PRINFNTOP - a variable
          This  should  be bound to a function.  This function will be
          used to print things at top level.  It is initially PRIN1.  

(PRINLEV expression depth) [EXPR] --> garbage
          Probably you want to use PRINTLEV.   This  is  the  internal
          function  used  by  PRINTLEV.    It differs in two ways:  It
          doesn't do a TERPRI first (as PRINTLEV does),  and  what  it
          returns is not well defined.  

(PRINT thing) [SUBR] --> the thing
          does TERPRI, PRIN1(thing), then prints a space.  

(PRINTC thing) [EXPR] --> the thing
          does TERPRI, PRINC(thing), then prints a space.  

(PRINTLEV expression depth) [EXPR] --> expression
          PRINTLEV  is a printing routine similar to PRINT.  PRINTLEV,
          however, only prints to a depth  of  DEPTH.    In  addition,
          PRINTLEV  recognizes  lists  which are circular down the CDR
          and  closes  these  with  '...]'  instead  of  ')'.      The
          combination  of  these two features allows PRINTLEV to print
          any circular list without an infinite loop.

          The value of PRINTLEV is the  value  of  EXPRESSION.    This
          means  that  PRINTLEV should not be used at the top level if
          EXPRESSION is a circular  list  structure,  since  the  LISP
                                                                   236


          executive would then attempt to print the circular structure
          which is returned as the value.  

PRINTMACRO - a property
          Used  to specify the format in which specific kinds of forms
          are printed.  E.g. to make all calls  to  SETQ  print  in  a
          specific  format,  you would put the format specification as
          the PRINTMACRO property on  SETQ.    See  section  19.3  for
          details on printmacros.  

(PROG variables expr expr ...) [FSUBR]
          This  is  the  closest that Lisp comes to an Algol or Pascal
          program.  A PROG has two parts: Local variables, and a body.
          E.g.

              (PROG (A B)
                    (SETQ A (CDR X))
              LOOP  (PRINT (CAR A))
                    (COND (A (GO LOOP))))

          (A B) is the list of local variables.  these  are  bound  to
          NIL  at  the  start  of the PROG.  Any previous bindings are
          saved, and are restored when the  PROG  exits.    Note  that
          binding  is  dynamic,  as  explained in the section on basic
          semantics.  The rest of the PROG is a series of  expressions
          that  will  be evaluated in order.  Any expression that is a
          simple atom is in fact a label.   You  can  branch  to  that
          label  by  using  (GO  label).    See the description of GO.
          Inside a PROG, you can also use (RETURN value).  This  stops
          the  PROG, and makes it return the specified value.  See its
          description.  

(PROGN form1 form2 ... formn) [FSUBR] --> value of formn
          evaluates several forms, returns  the  value  of  the  last.
          This  is  similar to a PROG, but has no local variables, and
          GO and RETURN do not work.  It is more efficient than  PROG,
          and is considered better style.  

(PROG1 form1 form2 ... formn) [SUBR] --> value of form1
          Similar to PROGN, except

             - returns value of form1

             - has limit of 5 forms

(PROG2 form1 form2 ... formn) [SUBR] --> value of form2
          Similar to PROGN, except

             - returns value of form2

             - has limit of 5 forms

(PROMPT number) [SUBR] --> old prompt, integer
          Used to set the prompt used for terminal input.  This is the
          *  that  Lisp  types  at  you  normally.   The argument is a
                                                                   237


          number,  the  ASCII code for a new prompt character.  PROMPT
          always returns the old value.  To simply  look  at  the  old
          value without changing it, do (PROMPT NIL).  

(PUSH list item) [MACRO] --> new list
          LIST  is  a  variable  that  is bound to a list.  ITEM is an
          expression which when evaluated gives  some  object.    PUSH
          CONS's  the  item onto the beginning of the list, and resets
          the variable to the new list.  I.e.  (PUSH  A  'X)  is  like
          (SETQ A (CONS 'X A)).  

(PUT atom value property) [SUBR] --> the value

(PUTPROP atom value property) [SUBR] --> the value
          Puts a property onto an atom's property list, or replaces an
          existing  property  if there already was one.  See GET for a
          general explanation of properties.    PUT  and  PUTPROP  are
          alternate names for the same function.  

(PUTLIST list value property) [EXPR] --> NIL
          Puts  VALUE on PROPERTY of all elements in LIST.  I.e. it is
          like (PUTPROP x value property) where X  is  bound  to  each
          member of LIST.  

(QUOTE thing) [FSUBR] --> the thing
          Instead  of  (QUOTE  X)  one usually types 'X.  READ expands
          this abbreviation.  Quote is explain in the section on basic
          syntax.  

(*QUO x y) [SUBR] --> x/y

(QUOTIENT n1 n2 n3...) [MACRO] --> n1 / n2 / n3 ...
          This is a macro that expands to the  appropriate  number  of
          calls to *QUO.  

*RAISE
          A variable.  If this is non-NIL, all input from the terminal
          will  have  lower  case  turned into upper case.  Since Lisp
          expects all function names and other atoms to  be  in  upper
          case,  this  is  a  convenience  for  those  with lower-case
          terminals.  This only affects characters in  atoms,  not  in
          strings.  A lower case character that is preceded by a slash
          will be left alone.  It is initially T. 

*RAISEDSK - a variable
          This  is  a  special version of *RAISE used by DSKIN, LOADF,
          and COMPL.  It is initially NIL.  

(RANDOM) [SUBR] --> real
          Returns a pseudo-random number between  0.0  and  .999999...
          Returns  a  real  number.    Because  of  limitations of the
          underlying Fortran function, the calculation is  done  using
          only 27 bits of precision in the mantissa.  To use this, you
          must  have  loaded  the  Arithmetic Package, q.v.  The first
          time you call this function  after  loading  the  Arithmetic
                                                                   238


          Package,  you  will  always get the same number.  SETRAN and
          SAVRAN allow you to set and look at the seed.  

(RDNAM) [SUBR] --> thing
          Reads an S-expression  from  the  currently  selected  input
          channel.    Exactly  like  READ  except  that  atoms are not
          INTERN'ed.  This is better if you are going to print out the
          structure or do string operations on it, but do not  require
          atoms  in  it  to  be  EQ  to  other atoms of the same name.
          Because atoms at not  INTERN'ed  on  the  OBLIST,  when  the
          structure  returned  by this is garbage collected, the atoms
          will also be garbage collected.  INTERN'ed atoms  are  never
          garbage collected.  

(READ) [SUBR] --> thing
          Reads  an  S-expression  from  the  currently selected input
          channel.  INC can be used to change this.   The  section  on
          basic  syntax  defines the syntax of an s-expression.  It is
          the smallest thing with parentheses balanced.  It can  be  a
          single  atom,  or  a  complex  structure.    See  TYI  for a
          description of error handling.  

(READCH) [SUBR] --> character atom
          Gets the next character from the  currently  selected  input
          file.    See TYI for details.  READCH returns this character
          in the form of a character atom,  which  is  an  atom  whose
          print name consists of the one character read.

(READCONTEXT forms) [FSUBR] --> value returned by last form
          This  is  used  to  allow ^Z and ^F to work in read routines
          that you write yourself.  The problem is that ^Z is supposed
          to abort the entire thing being typed in.  Suppose you write
          some function that calls READ to read in pieces of  a  form.
          Normally ^Z would abort only the piece that is being read by
          READ.    If  you  put  READCONTEXT around your code, ^Z will
          abort and restart the entire thing inside READCONTEXT.  E.g.
          LINEREAD uses READCONTEXT, which is why ^Z aborts the entire
          line rather than just the particular item  in  which  it  is
          typed.  Similarly, ^F will cause the entire form returned by
          READCONTEXT  to  be edited, rather than just the piece being
          read by the current call to READ.  

(READL) [SUBR] - another name for LINEREAD

(READLIST char-list) [SUBR] --> thing
          Char-list is supposed to be a list of characters.  Often  it
          is  produced by EXPLODE.  This list is passed to READ, which
          reads characters from the list instead of from a file.    It
          returns what it would return if it found those characters in
          a  file.    (READLIST (EXPLODE thing)) should be the same as
          the original thing.

              (READLIST '(A B C)) --> ABC   [an atom]

          Actually READLIST will accept almost any representation of a
                                                                   239


          character.   An atom or string will have the first character
          of the print name used.  A number will be interpreted as the
          ASCII values of a character.  E.g. (READLIST  '(65  66  67))
          will  also  produce  ABC, since 65 is the ASCII code for the
          letter A, etc.  For reasons that  I  consider  insufficient,
          the  numbers  0  though 9 are interpreted as characters, not
          numbers.  That is, (READLIST '(A 1 2  3))  will  return  the
          atom  A123.   According to the normal rules (A 1 2 3) should
          be  interpreted  as  A  control-A,  control-B  and  control-
          C. Since 1, 2, and 3 are numbers, READLIST should treat them
          as  the ASCII codes.  To get A123 you should have to use the
          characters /1 /2 and /3, i.e.  (READLIST  '(A  /1  /2  /3)).
          However  as  a  special "convenience", the digits 0 to 9 are
          accepted as equivalent to the characters /0 to /9.   To  get
          the control characters whose values are from 0 to 9, you use
          the  numbers  128  to  137  (i.e. you add 128 or 200 octal).
          Note that AEXPLODE handles this mapping for you.  

READMACRO [atom]
          This is a property used to define readmacros.  See  DRM  and
          the section on readmacros in the introduction.  

(READP) [SUBR] --> T or NIL
          This  indicates  whether  anything  has  been  typed  on the
          terminal and not yet read by Lisp.  Using it, you can  write
          a  program  that does work in the background, but when input
          is ready, stops and reads it.  

(REMAINDER X Y) [SUBR] --> x - (x / y) * y
          Defined only for integers.  The remainder after  dividing  X
          by Y. 

(REMLIST list property) [EXPR] --> NIL
          Removes  PROPERTY  from  all atoms on LIST.  I.e. it is like
          (REMPROP x property) with X being bound to  all  members  of
          LIST.  

(REMOB atom1 atom2 ... atomn) [FSUBR] --> NIL
          Removes  the  atoms listed from the OBLIST.  This means that
          Lisp will no longer recognize these atoms if they are  typed
          in.    If  someone types in something that looks like one of
          them, what they will get is an entirely new atom  that  just
          happens to have the same name.  If the atoms are not refered
          to  anywhere,  they  will be garbage-collected.  In order to
          garbage-collect an atom, it must be  REMOB'ed  first,  since
          the  garbage-collector considers everything on the OBLIST to
          be in use.  Note that REMOB  quotes  its  arguments.    I.e.
          (REMOB A B C) removes A, B, and C. 

(REMOVE item list) [EXPR] --> new list
          Removes  all  top  level  occurrences  of ITEM from the list
          LIST, giving a COPY of LIST  with  all  top  level  elements
          EQUAL  to  ITEM  removed.  If you want something faster, but
          more dangerous, see DREMOVE.  
                                                                   240


(REMPROP atom property) [SUBR] --> T or NIL
          Removes  the specified property from the atom.  Returns T if
          there  was  one,  NIL  if  not.    See  GET  for  a  general
          explanation of properties.  

(REMPROPS atom list) [EXPR] --> NIL
          Removes  all  properties  on LIST from ATOM. I.e. it is like
          (REMPROP atom x) with X being bound to all members of  LIST.


(RENAMEF oldfile newfile keep) [SUBR] --> channel or NIL
          Renames  a  file.    OLDFILE  may  be  either a channel or a
          filename  (a  string).    If  it  is  a  channel,  the  file
          associated  with  that channel is renamed.  If a filename, a
          channel is created for the file and it is renamed.   If  the
          file  is  open,  it  is  closed  first.   Normally the third
          argument ("keep") is left out, or NIL.  In this  case,  once
          the  rename  has  been  done,  the  channel  is  closed  and
          released.  I.e. it can no longer be  used.    If  a  non-NIL
          value  is  specified,  the  channel  is retained.  It is not
          open, but can be opened by OPENF, etc.  RENAMEF returns  the
          channel if it succeeds, and NIL if it fails.

(REQUIRE file1 file2 ...) --> NIL
          In interpreted code, this is ignored and returns NIL.  It is
          an  instruction  to  the compiler indicating the the current
          file is intended to be used with  the  files  listed.    The
          compiler  scans those files or their .LDC files for function
          definitions.  

(REREADCH N) [SUBR] --> old value
          Sets the character used to abort typein to READ.    This  is
          normally  ^Z.  N is a number, the ASCII code for the desired
          value.   Any  character  may  be  used.  The  old  value  is
          returned.    A  negative  number  means  that  there  is  no
          character for this purpose.  This  character  is  recognized
          only  on  terminal input.  When it is read (not typed - this
          is  not  an  interrupt),  it  causes  READ  to  throw   away
          everything it has seen so far and start reading again.  

(RETFROM fn val) [EXPR] --> NIL if it fails
          RETFROM  returns  VAL  from  the  most  recent  call  to the
          function FN with the value VAL.  For RETFROM to work,  there
          must be an Eval-Blip for FN.  The only way to be sure to get
          an  Eval-Blip  in  compiled code is to explicitly evaluate a
          quoted expression which  calls  the  function,  e.g.,  (EVAL
          '(FUNC A B)).  

(RETURN value) [SUBR] - This is meaningful only in PROG's.
          The  most  recent  PROG  is  returned  from,  with the value
          specified.  

(REVERSE list) [EXPR] --> new list
          Returns a copy of the list, with its top-level  elements  in
          reverse order.  E.g.
                                                                   241


              (REVERSE '(A B (C D E))) -->  ((C D E) B A).

          Here is an equivalent definition:

              (DE REVERSE (L) (REVERSE1 L NIL))
              (DE REVERSE1 (L M)
                   (COND ((NULL L) M)
                         (T (REVERSE1 (CDR L) (CONS (CAR L) M)))))

          See  DREVERSE if you want something more efficient, but more
          dangerous.  

(RPLACA cell new-car) [SUBR] --> the cell
          This can be used to change the CAR of a dotted pair.  It  is
          dangerous,  since  it  actually changes the pair itself.  It
          does not just give you a new  copy  with  a  different  CAR.
          This matters if some other part of the program has a pointer
          to the pair.  

(RPLACD cell new-cdr) [SUBR] --> the cell
          As RPLACA, but changes the CDR.

(RPLACPLIST atom plist) [SUBR] --> the cell
          Used  to change the entire property list of an atom at once.
          The property list of ATOM is changed to PLIST, which must be
          in the internal form described under PLIST.  

(RPTQ n expr1 expr 2 ...) [FEXPR] --> last expr evaluated

              for RPTN := 1 to N do
                begin expr1; expr2; ... end

          I.e. the form (PROGN expr1 expr2 ...) is executed  N  times.
          The  expression N is evaluated once, before the start of the
          loop.  Note that your code can use the variable RPTN.  If  N
          < 1, the loop is never executed (and NIL is returned).  

(*RSET value) [SUBR] --> old value
          Sets  the  *RSET  flag.    This  controls  the processing of
          errors.  In general, if *RSET is non-NIL, an error will  get
          you  into the break package, but if it is NIL, an error will
          just abort to an ERRSET or the  top  level.    ERRORX  is  a
          special  value  that  turns  off printing of error messages.
          For details see ERROR.  

(SASSOC atom a-list function) [SUBR] --> pair or function result
          See ASSOC.  This is like ASSOC, except that if the  atom  is
          not  in the A-list, instead of returning NIL, this calls the
          function and  returns  whatever  it  returns.  The  function
          should be a function with no arguments.  

(SAVE function) [FEXPR] --> function or NIL if fails
          Saves the definition of FUNCTION (which is not evaluated) on
          its SAVE property.  UNSAVE will restore the definition.
                                                                   242


(SAVEF file form1 form2 ...) [FEXPR] --> File-dumped
          The  arguments  are all optional.  If at least two arguments
          are specified, sets output to FILE and evaluates the  forms.
          If  any  form  is an atom, it is passed to PPL.  If only one
          argument is given (the  file  name),  it  is  looked  up  on
          ALLFILES  to find an associated list of things to put in the
          file.  This list is passed to PPL.    If  no  arguments  are
          given,  FILES?  is called to provide a list of files to work
          on.  Each one is processed as in a call with one argument.

          If the value of DSKOUT is T (its default value), the name of
          each function prettyprinted during the SAVEF is  printed  on
          the terminal so that the user may follow the progress of the
          dump.    If  DSKOUT  is  set to NIL, no terminal printing is
          performed. The maximum line length used by SAVEF  is  stored
          in DSKLENGTH, and may be changed if desired (it is initially
          80).  *NOPOINTDSK  is  used  instead  of *NOPOINT to control
          where the decimal point (or octal point)  is  printed  after
          integers.

(SAVEIMAGE filename) [FSUBR] --> NIL
          Filename  should  be a string containing the name of an .EXE
          file.  Will save the current core image on that file.    You
          can run that file later.  Caveats:

             - to minimze the size of the file, use (GC) first

             - this  function  is  designed to be called from the
               top level.  If it is called from  somewhere  else,
               your  current variable bindings will be the global
               bindings in the saved core image.

(SAVRAN) [SUBR] --> integer
          Returns the current value of the seed for the random  number
          generator (RANDOM), as an integer.  Takes no arguments.  The
          Arithmetic Package (q.v.) must be loaded for this to work.

(SELECTIN channel close) [SUBR] --> previosly selected input channel
          Lisp always has exactly one "channel" selected for input and
          one  for  output.   READ and TYI read from the current input
          and WRITE and TYO write to the  current  output.    SELECTIN
          changes  the  current  input  channel.    Note  that as many
          channels can be open as you like.  It is just a question  of
          which  one  is  currently the default for the I/O functions.
          SELECTIN selects the specified channel for input.  A channel
          is created when you open a file by calling OPENIN.    OPENIN
          returns  a  channel.  You should save that away and then use
          it in SELECTIN whenever you want to select that channel. The
          CLOSE flag  (which  defaults  to  NIL)  indicates  that  the
          previously  selected channel should be closed.  You can also
          explicitly close a channel by using CLOSE.

          To select the terminal, you may use NIL  as  if  it  were  a
          channel.  When the previously open channel was the terminal,
          SELECTIN  returns  NIL rather than the actual channel object
                                                                   243


          for the terminal.

(SELECTOUT  channel  close)  [SUBR]  -->  previously  selected  output
                    channel
          As with SELECTIN, but  selects  the  currently  open  output
          channel.  

(SELECTQ X "Y1" "Y2" ... "Yn" Z) [MACRO] --> last expr evaluated
          This  very  useful  function is used to select a sequence of
          instructions based  on  the  value  of  its  first  argument
          X. Each  of  the  Yi is a list of the form (Si E[1,i] E[2,i]
          ...  E[k,i]) where Si is the "selection key".

          If Si is an atom the value of X is tested to see if it is EQ
          to Si (not evaluated).  If so, the  expressions  E[1,i]  ...
          E[k,i]  are  evaluated in sequence, and the value of SELECTQ
          is the value of the last expression evaluated, i.e. E[k,i].

          If Si is a list, and if any element (not evaluated) of Si is
          EQ to the value of X, then E[1,i] ...  E[k,i] are  evaluated
          in turn as above.

          If  Yi is not selected in one of the two ways described then
          Y[i+1] is tested, etc. until all the Y's have  been  tested.
          If  none  is  selected, the value of SELECTQ is the value of
          Z. Z must be present.

          An example of the form of a SELECTQ is:

              (SELECTQ (CAR W)
                       (Q (PRINT FOO) (FIE W))
                       ((A E I O U) (VOWEL W))
                       (COND (W (QUOTE STOP))))

          which has two cases, Q and  (A  E  I  O  U)  and  a  default
          condition which is a COND.

          SELECTQ  compiles open, and is therefore very fast; however,
          it will not work if the value  of  X  is  a  list,  a  large
          integer, or floating point number, since it uses EQ.  

(SET atom new-value) [SUBR] --> the value
          Sets  a  variable.  Note  that SET evaluates both arguments.
          SETQ is normally used for this reason.  Here are examples of
          use:

              (SET 'A (PLUS X Y))
              (SETQ A (PLUS X Y))

          That is, SETQ is just like SET but automatically quotes  its
          first argument.

(SETARG n value) [SUBR] --> value
          SETARG is used to change the value of the Nth argument to an
          LEXPR.  It is legal only inside an LEXPR.
                                                                   244


(SETBARRAY array index bytesize value) [SUBR] --> value
          ARRAY  must be an array pointer returned by MAKEARRAY.  Sets
          the INDEX'th byte of the array (starting  at  0)  to  VALUE,
          which  must  be  an  integer.    Bytes are packed as many as
          possible per word, left justified.  

(SETCHR char bits) [SUBR] --> old bits
          This is used to change the status of a character as  a  read
          macro.    It  changes those bits in the read table entry for
          CHAR that affect its read macro status.  It returns the  old
          setting  of  these  bits.    If you supply NIL for BITS, old
          setting will be returned but not changed.

(SETIARRAY array index value) [SUBR] --> value
          ARRAY must be an array pointer returned by MAKEARRAY.   Sets
          the  INDEX'th  word  of  the array (starting at 0) to VALUE,
          which must be an integer.  

(SETPOS channel position) [SUBR] --> T or NIL
          This is used  to  reposition  a  random  access  file.    It
          positions  the file so that the next TYI or TYO will read or
          write the byte number specified.  0 is the first byte.    -1
          may be used for the last byte in the file.

SETRAN seed) [SUBR] --> NIL
          Sets  the  seed  for  the random number generator.  Takes an
          integer as argument, returns NIL.  The seed must be < 2**31.
          The Arithmetic Package (q.v.) must  be  loaded  before  this
          will work.

(SETRARRAY array index value) [SUBR] --> value
          ARRAY  must be an array pointer returned by MAKEARRAY.  Sets
          the INDEX'th pair of words in the array (starting at  0)  to
          VALUE, which must be a real number.  

(SETQ atom new-value) [FSUBR] --> the value
          The  usual  way  to set a variable.  Like SET but quotes its
          first argument.  E.g. to set A to B you say (SETQ A 'B).

(SETVECTOR vector index object) [SUBR] --> object
          VECTOR must be a  vector  pointer  returned  by  MAKEVECTOR.
          Sets  the INDEX'th item from the vector to OBJECT.  This can
          be any legal Lisp object (including a vector).  

(SIN number) [SUBR] --> real
          Take the sine of  a  number  of  any  type,  interpreted  as
          radians.  Returns a real number.  To use this, you must have
          loaded the Arithmetic Package (q.v.).  

(SIND number) [SUBR] --> real
          Take  the  sine  of  a  number  of  any type, interpreted as
          degrees.  Returns a real number.  Because of limitations  of
          the  underlying  Fortran  function,  the calculation is done
          using only 27 bits of precision in the  mantissa.    To  use
          this, you must have loaded the Arithmetic Package, q.v.  
                                                                   245


(SINH number) [SUBR] --> real
          Take the hyperbolic sine of a number of any type.  Returns a
          real  number.    Because  of  limitations  of the underlying
          Fortran function, the calculation is done using only 27 bits
          of precision in the mantissa.  To use this,  you  must  have
          loaded the Arithmetic Package, q.v.  

(SOME fn l1 . . . ln) [LEXPR] --> T or NIL
          <fn>  (a  function of n arguments) is applied to the CARs of
          <l1> through <ln> (like MAPC), returning a non-NIL value  if
          some   application   returns   a  non-NIL  value.    If  all
          applications of <fn> return NIL, SOME returns  NIL.    If  a
          non-NIL  result  is  found,  SOME  stops  at  that point and
          returns the tail of  <ln>  starting  with  the  value  which
          caused  the  non-NIL result.  SOME is compiled in-line.  For
          details on the binding semantics, see the last paragraph  of
          the description under MAPxxx

(SORT list comparefn nodups) [EXPR] --> list
          SORT  returns a new list which is the sort of the list LIST,
          using a binary insertion sort.  COMPAREFN and NODUPS are  as
          described  under  INSERT,  i.e.,  COMPAREFN  is  the  binary
          comparison function, and NODUPS controls  whether  duplicate
          elements  will  be removed or not.  These last two arguments
          are  optional.    If  left  out  (i.e.  NIL  is  used),  the
          comparison will use LEXORDER, and NODUPS will be NIL.  These
          are reasonable defaults for most cases.

(SPACES n pos) [EXPR] --> NIL
          Print  N  spaces,  using tab characters when possible.  If N
          spaces won't fit on the current line, current line, tabs  to
          position  POS  on  the  next  line.  POS is optional, with a
          value of 1 assumed if omitted.

(SPDLFT index) [SUBR] --> variable
          See the section on the evaluation context stack.    This  is
          used  to  examine one pair on the stack.  It takes the index
          of the pair, and returns the first  ("left")  of  the  pair.
          This  is  NIL  if  the  current  entry is an EVAL blip, or a
          variable,  either  a  user  variable  or  an  internal  Lisp
          variable.    (You  can tell which of these it is because the
          user variables are LITATOM, and the internal ones are  not.)
          

(SPDLPT) [SUBR] --> index
          See  the  section  on  the  evaluation  context stack.  This
          returns the index of the top of the stack.  

(SPDLRT index) [SUBR] --> item
          See the section on the evaluation context stack.    This  is
          used  to  examine one pair on the stack.  It takes the index
          of the pair, and returns the second ("right") of  the  pair.
          This  is  either  a  saved  value  from  a  variable  or  an
          expression being evaluated if this is an EVAL blip.  
                                                                   246


(SPEAK) [SUBR] --> integer
          Returns the total number of words of free space used in this
          core  image.   This is roughly the number of CONS's times 2,
          except that it counts strings and other objects also.  

(SPECIAL var1 var2 ... varn) [FSUBR] --> NIL
          In the interpreter, this form is ignored, and  returns  NIL.
          In files that are compiled, it declares the variables listed
          as "special".  See the chapter on the compiler.  

SPLICEMACRO [atom]
          This is a property used to define splicemacros.  See DSM and
          the section on readmacros in the introduction.  

(SPREDO index) [SUBR] --> NIL if it fails
          SPREDO  adjusts P to an Eval-Blip and re-evaluates from that
          point.  

(SPREVAL index form) [SUBR] --> NIL if it fails
          SPREVAL evaluates its argument FORM in its local context  to
          get  a form, and then it returns to the context specified by
          INDEX and evaluates the form in that context, returning from
          that context with the value.  This is very similar to SPREDO
          except that the EVAL-blip on the stack is changed.  

(SPRINT expr col) [EXPR] --> NIL
          SPRINT is the workhorse of the prettyprint package -  it  is
          used by PP and PPL to print EXPRs in pretty form starting in
          column  COL (1 if missing).  The prettyprinting capabilities
          of SPRINT may be suppressed by setting the special  variable
          PRETTYFLG to NIL.  In this mode, the prettyprint package may
          be  used to produce fast, compact (though not very readable)
          symbolic dumps.  

(%SPRINT exp brflag) [EXPR] --> NIL
          This is the work function of SPRINT.  It  will  prettyprints
          the   (non-atomic)   structure   EXP  using  parentheses  if
          BRFLAG=NIL and brackets if BRFLAG=T.  Checks for printmacros
          and lists of atoms (printed as blocks).  

(SQRT number) [SUBR] --> real
          Take the square root of a non-negative number of  any  type.
          Always  returns  a  real number.  To use this, you must have
          loaded the Arithmetic Package (q.v.).

(SSTEP expression) [FSUBR] --> value
          This is the single stepper.  Calls EVAL for the  expression.
          However  evaluation  proceeds  in  single  step  mode.  This
          allows the user to look at what is going on at every call to
          EVAL.  See section 21.2 for  the  way  this  is  set  up  by
          default.   Actually SSTEP arranges for HOOK1 and HOOK2 to be
          called for every EVAL cycle.  Of course single  stepping  is
          temporarily  turned  off  inside  HOOK1  and  HOOK2!   HOOK1
          returns a number that indicates whether single  stepping  is
          to continue.
                                                                   247


(ST: x1 x2 . . .)
          Prettyprints  any structure definitions of the X's, ignoring
          all other properties.

(STCONCAT string1 string2 ... stringn) [MACRO] --> string
          This  macro  uses  the  function  *STCONCAT  to  concatenate
          strings or atoms.

(*STCONCAT string1 string2) [SUBR] --> string
          *STCONCAT  concatenates two strings.  I.e. it produces a new
          string with the characters from each of the  input  strings.
          Actually  the inputs can be strings or atoms.  If an atom is
          given, its print name is treated as a string.  

(STKCOUNT name index ending-index) [EXPR] --> integer
          The value of STKCOUNT is the number  of  Eval-Blips  with  a
          STKNAME  of  NAME  occurring between stack positions INDEX-1
          and ENDING-INDEX, where ENDING-INDEX < INDEX.  

(STKNAME index) [EXPR] --> atom
          If position INDEX is not an Eval-Blip, the value of  STKNAME
          is  NIL.    If  position  P  is an Eval-Blip and the form is
          atomic, then the value of STKNAME is that atom.  If the form
          is non-atomic, STKNAME returns the CAR for  the  form,  i.e.
          the name of the function.  

(STKNTH N index) [EXPR] --> index
          The  value of STKNTH is a stack pointer to the Nth Eval-Blip
          starting at position INDEX.  If N is positive, STKNTH  moves
          up  the  stack,  and if N is negative, STKNTH moves down the
          stack.  

(STKPTR index) [SUBR] --> Lisp pointer
          Returns  a  pointer  to  the  specified  position   in   the
          evaluation  context stack (q.v.).  This pointer looks like a
          normal Lisp CONS cell, whose  CAR  is  SPDLFT,  and  CDR  is
          SPDLRT.    Indeed  by using RPLACA and RPLACD you can change
          the stack.  That is its main use, since  SPDLFT  and  SPDLRT
          are more useful for most cases.  

(STKSRCH name index flag) [EXPR] --> index
          The  value  of STKSRCH is a stack pointer to the first Eval-
          Blip with a STKNAME of NAME.  The direction of the search is
          controlled by FLAG.  If FLAG=NIL,  STKSRCH  moves  down  the
          stack.  Otherwise STKSRCH moves up the stack.  STKSRCH never
          returns  INDEX  for  its  value,  i.e.  it steps once before
          checking for NAME.  

(STORE (locative) value) [MACRO] --> value
          This is vaguely equivalent to SETQ, but for  putting  values
          into  data structures.  At the moment it is implemented only
          for arrays and structures.  LOCATIVE is an  expression  that
          would  normally be used to locate that value.  At the moment
          all that  is  allowed  is  (array-name  --subscripts--)  and
          (field-name record-pointer).
                                                                   248


(STORE-xxx record-pointer value) [MACRO] --> value
          Used to change the value of a field in a structure.  Changes
          the  XXX field of RECORD-POINTER to VALUE.  Exactly the same
          as (STORE (XXX RECORD-POINTER) VALUE).  

(STRINGP thing) [SUBR] --> T or NIL
          This returns T or NIL depending upon whether the thing is  a
          string or not.

STRUCTURE-FIELDS - property
          This  property  is used to define a record structure.  It is
          put on the structure type.  The value is the list of fields.
          Each member of the list is of  the  form  (FIELD-NAME  INDEX
          DEFAULT-VALUE).    INDEX is a number from 1 to the number of
          fields, indicating the position of the field in  the  vector
          used  to  implement  the record.  DEFAULT-VALUE is the value
          that will be given to  this  field  when  a  new  record  is
          created, if the user does not specify otherwise in MAKE-xxx.


(STRUCTUREP object) [EXPR] --> NIL or structure type
          The argument may be any Lisp object.  Checks whether it is a
          structure.  If so, returns the structure type (i.e. the name
          used in DS when defining it).  If not, returns NIL.  

(SUB1 N) [SUBR] --> N - 1

(SUBLIS Alist expr) [EXPR] --> new EXPR
          ALST  is  a  list of pairs ((U1 .  V1) (U2 .  V2) ...  (Un .
          Vn)) with each Ui atomic.  The value of SUBLIS is the result
          of substituting each V for the corresponding U in EXPR.

              Example:

              *(SUBLIS '((A . X) (C . Y)) '(A B C D))
               (X B Y D)

          New structure is created only if needed, e.g. if  there  are
          no  substitutions,  value is EQ to EXPR.  Note:  SUBLIS does
          not substitute copies of  the  appropriate  expression,  but
          substitutes the identical structure.  

(SUBPAIR old new expr) [EXPR] --> new EXPR
          Similar   to   SUBLIS   except  that  elements  of  NEW  are
          substituted for corresponding atoms of OLD in EXPR.

              Example:

              *(SUBPAIR '(A C) '(X Y) '(A B C D))
               (X B Y D)

          Note:  SUBLIS and SUBPAIR do not substitute  copies  of  the
          appropriate   expression,   but   substitute  the  identical
          structure.  
                                                                   249


SUBR - a special tag used for compiled EXPR's.
          A  SUBR  will have as the value of its name something of the
          form (SUBR <address> n), where n is the number of arguments.
          See the section on basic syntax.  

(SUBSET fn l)
          [EXPR] -->  new  list}  Applies  <fn>  (a  function  of  one
          argument)  to each element of the list <l>, returning a list
          consisting of each element  of  <l>  which  causes  <fn>  to
          return  a  non-NIL  value.  For example, the following finds
          all atoms in L:

              (SUBSET 'ATOM L)

          SUBSET is compiled in-line.   For  details  on  the  binding
          semantics,  see  the last paragraph of the description under
          MAPxxx

(SUBST X Y S) [EXPR] --> new list structure
          SUBST substitutes S-expression X for all  EQUAL  occurrences
          of S-expression Y in S-expression S. SUBST is equivalent to:

              (DE SUBST (X Y S)
                  (COND ((EQUAL Y S) X)
                        ((ATOM S) S)
                        (T (CONS (SUBST X Y (CAR S))
                                 (SUBST X Y (CDR S))))))

              Example:(SUBST 5 'FIVE '(FIVE PLUS FIVE IS TEN))
                                     = (5 PLUS 5 IS TEN)

(SUBSTRING str m n) [EXPR] --> new string
          Returns  a  new  string consisting of characters <m> through
          <n> of <str>.  <m> and <n> may be positive  integers  (count
          from  left) or negative integers (count from right).  If <m>
          is non-numeric a value of 1 (first  character)  is  assumed,
          and  if  <n>  is non-numeric -1 (last character) is assumed.
          Although <str> will typically be a  string,  SUBSTRING  will
          actually  work  with  any argument; the indicated characters
          are simply extracted from  the  PRINC  character  string  of
          <str> and formed into a string.  

T - an atom.
          Conventionally  used  whenever  a non-NIL value is required.
          It is initialized as a variable bound to itself.  So you can
          write T, and get the same effect as 'T.  It  is  illegal  to
          rebind T. 

(TAB n) [EXPR] --> NIL
          TAB  tabs to position N on the output line doing a TERPRI if
          the current position is already past N. Position  1  is  the
          beginning  of  the  line.    TAB uses tab characters to move
          across the line when this is appropriate.

(TAILP X Y) [EXPR] --> tail of Y
                                                                   250


          The  value  of  TAILP  is X iff X is a list and a tail of Y,
          i.e., X is EQ to some number of CDRs (possibly 0) of Y. 

(TALK) [SUBR] --> NIL
          TALK turns back on output, in case the user  has  typed  ^O.
          It discards anything output before TALK is called.  

(TANH number) [SUBR] --> real
          Take  the  hyperbolic  tangent  of  a  number  of  any type.
          Returns a real  number.    Because  of  limitations  of  the
          underlying  Fortran  function, the calculation is done using
          only 27 bits of precision in the mantissa.  To use this, you
          must have loaded the Arithmetic Package, q.v.  

(TCONC pointer new-item) [EXPR] --> updated pointer
          TCONC is useful for building a list by adding  elements  one
          at  a  time  at  the  end.    This could be done with NCONC.
          However, unlike NCONC, TCONC does not have to search to  the
          end  of  the  list  each time it is called.  It does this by
          keeping a pointer to the end of the  list  being  assembled,
          and  updating this pointer after each call.  The savings can
          be considerable for long lists.  The cost is the extra  word
          required  for storing both the list being assembled, and the
          end of the list.  POINTER is that word:   (CAR  POINTER)  is
          the  list  being  assembled,  (CDR  POINTER)  is  (LAST (CAR
          POINTER)).    The  value  of  TCONC  is  POINTER,  with  the
          appropriate  modifications  to  its  CAR and CDR.  Note that
          TCONC is a destructive operation, using RPLACA and RPLACD.

              Example:

              *(MAPC (FUNCTION (LAMBDA (X)
                               (SETQ FOO (TCONC FOO X))))
                     (QUOTE (5 4 3 2 1)))
              *FOO
              ((5 4 3 2 1) 1)

          TCONC can be initialized in two ways.  If  POINTER  is  NIL,
          TCONC  will  make  up a ptr.  In this case, the program must
          set some variable to the value of the first call  to  TCONC.
          After that it is unnecessary to reset since TCONC physically
          changes PTR thus:

              *(SETQ FOO (TCONC NIL 1))
              ((1) 1)
              *(MAPC (FUNCTION (LAMBDA (X) (TCONC FOO X)))
                     (QUOTE (4 3 2 1)))
              *FOO
              ((1 4 3 2 1) 1)

          If  POINTER  is  initially  (NIL), the value of TCONC is the
          same as for POINTER=NIL, but TCONC changes POINTER, e.g.
                                                                   251


              *(SETQ FOO (LIST NIL))
              (NIL)
              *(MAPC (FUNCTION (LAMBDA (X) (TCONC FOO X)))
                     (QUOTE (5 4 3 2 1)))
              *FOO
              ((5 4 3 2 1) 1)

          The latter method allows the program to initialize, and then
          call TCONC without having to perform SETQ on its value.  

TEMPLATE INSTANTIATION
          A  template  is any list structure preceeded by a back-quote
          (`).  Back-quote expands into code  to  copy  the  template,
          making  substitutions  as defined by occurences of comma and
          double comma.  A comma causes  the  next  expression  to  be
          evaluated  and  used in that spot in the template.  A double
          comma is similar,  but  the  outermost  parentheses  of  the
          evaluated  results  are  removed.   E.g here is a macro that
          lets you write MAPC in a  somewhat  simplified  form,  where
          only the list and the body of the loop are given.

              (DM MAPX (FORM)
                  `(MAPC (FUNCTION (LAMBDA (X) ,,(CDDR FORM)))
                         ,(CADR FORM)))

              For example

              (MAPX L (PROCESS X) (PRINT X))

              becomes

              (MAPC (FUNCTION (LAMBDA (X)
                                      (PROCESS X)
                                      (PRINT X)))
                    L)

          Note that (CDDR FORM), which is ((PROCESS X) (PRINT X)), was
          spliced into the pattern without the outermost parentheses.

          `EXP  ,EXP  and  ,,EXP  are  all  read macros that expand to
          (BACK-QUOTE  EXP),  (COMMA  EXP),  and  (DOUBLE-COMMA   EXP)
          respectively.  

(TERPRI thing) [SUBR] --> thing or NIL
          Put  out  a  CRLF  on  the current output channel.  THING is
          optional.  TERPRI simply returns it without looking  at  it.
          This is useful for such things as

              (PRIN1 (TERPRI 'foobar))

(THROW value label) [FEXPR] 
          (Value is evaluated).  See CATCH.  

(TIME) [SUBR] --> integer
          CPU  time  used  by  the  current process, i.e. this copy of
                                                                   252


          Lisp, since when you ran it.  In milliseconds.  

(*TIMES x y) [SUBR] --> x * y

(TIMER expression) [FEXPR] --> value returned by expression
          Prints  timing information about the computation:  CPU time,
          real time, time spent doing garbage collection,  and  number
          of words CONS'ed.  

(TIMES n1 n2 n3 ...) [MACRO] --> n1 * n2 * n3 ...
          This  is  a  macro that expands to the appropriate number of
          calls to *TIMES.  

(TRACE functions) [FEXPR]
          This function is part of the debugging system.  It  is  used
          to establish tracing of calls to one or more functions.  See
          section 21.5.3 for details.  

(TTYECHO) [SUBR] --> new value
          Controls  whether  typein  to  the terminal is echoed.  Each
          call to TTYECHO reverses the setting of echo.    It  returns
          the  new  value.  I.e. T if echo is being turned on, and NIL
          if off.  

(TTYIN stuff) [MACRO] --> value from stuff
          Like a PROGN, but sets the input to the terminal.  

(TTYMSG thing1 thing2 ...) [FEXPR] --> NIL
          Outputs things to the terminal (more precisely, your primary
          output device) using MSG.  In case you  have  selected  some
          other   output  device,  TTYMSG  saves  the  current  output
          channel, selects the terminal, does  its  output,  and  then
          restores the old output channel.  

(TTYOUT stuff) [MACRO] --> value from stuff
          Like a PROGN, but sets the output to the terminal.

(TTYPAUSE flag) [SUBR] --> old flag
          Sets  the  state  of  TERM  PAUSE END-OF-PAGE.  I.e. whether
          output pauses and waits for ^Q every N lines of output.  

(TYI) [SUBR] --> a character
          Actually this returns an integer which  is  the  character's
          ASCII  code)  Get  the  next  character  from  the currently
          selected input channel.  If input reaches the end  of  file,
          the  current  open  file is closed, and input is returned to
          primary input (usually the terminal).  Then (ERR  $EOF$)  is
          done.   Usually this returns you to the top level READ-EVAL-
          PRINT loop.  If you reach end of file on the primary  input,
          it is a fatal error.  This should not happen.  

(TYO character) [SUBR] --> the character
          A  character  is  an  integer which is the character's ASCII
          code. Put a character out on the currently  selected  output
          channel.  
                                                                   253


(TYOA char pos) [EXPR] --> char
          Identical to TYO, except if there is no room for CHAR on the
          current  line  a  TAB  to  position  POS on the next line is
          performed before printing CHAR.  POS  is  optional,  with  a
          value  of  1 assumed if omitted. Tabs are the only character
          handled specially, all others are assumed to take one space.
          

(TYPE file) --> nothing
          Types the file on the current output.  

(UCILISP: form1 form2 ... formn) [FSUBR] --> NIL
          Does absolutely  nothing  (except  return  NIL).    This  is
          exactly  the  same as NILL.  It is intended for use in files
          to be run in both R/UCI Lisp and ELISP.  It  is  defined  as
          PROGN  in  R/UCI Lisp.  Thus it should be used for code that
          is to be used only in R/UCI Lisp.  

(UGETI) [EXPR] --> number
          Gets the current position of the current input file.    That
          is, it is equivalent to (CURPOS (CURRENTIN)).  

(UGETO) [EXPR] --> number
          Gets  the current position of the current output file.  That
          is, it is equivalent to (CURPOS (CURRENTOUT)).  

(UNBOUND) [EXPR] --> un-interned atom representing no binding
          Every atom has a place for storing a value.    If  the  atom
          doesn't  have  a  value (i.e. it is "unbound" -- see BOUNDP)
          what really happens is that a special object is  strored  in
          this  value  cell.    That  special  object is a sign to the
          interpreter that any attempt to find the value of  the  atom
          should  be  considered an error.  (UNBOUND) will return that
          special object.  (SETQ A (UNBOUND)) will effectively make  A
          be  unbound.    Please  note  that this object looks like an
          atom, but in fact it is not INTERN'ed.  Thus you can't  type
          it.  You should always call UNBOUND when you need it.  

(UNBREAK functions) [FEXPR]
          This  function is used to remove breakpoints for one or more
          functions.  See section 21.5.5 for details.  

(UNION l1 l2) [EXPR] --> L1 union L2
          Returns a list which is the union of the two lists <l1>  and
          <l2>.  If <l1> and <l2> are of unequal length, UNION is more
          efficient  if <l2> is the longer list.  Note that membership
          tests are made using MEMBER (and hence EQUAL).  If MEMB (EQ)
          checks are desired instead, change the value of MEMBFN  from
          MEMBER to MEMB.  

(UNMACEXPAND form) [EXPR] --> same form
          See  the  second  on  basic forms, and MACROEXPANSION for an
          explanation of how macro expansions are saved.  If you  want
          to  change the definition of a macro and it has already been
          used, you have to remove the  expansion  and  put  back  the
                                                                   254


          original   call.    UNMACEXPAND  purges  all  occurences  of
          (MACROEXPANSION ...) in the form and returns the form to its
          original state.  To restore the definition of  the  function
          FOO to its pristine state, do

              (UNMACEXPAND (FUNDEF 'FOO))



(UNSAVE function
          [FEXPR]  -->  function  or  NIL  if  fails}  Restores an old
          definition of FUNCTION from its SAVE property.  

(UNTRACE functions
          [FEXPR]} This function is used to cancel tracing of  one  of
          more functions.  See section 21.5.6 for details.  

(UNTYI char) [SUBR] --> the char
          Put the specified character into the input stream.  The next
          TYI, READ, etc., will see that as its first character.  This
          is useful mostly for people who want to look ahead at input,
          but not "gobble" it.  E.g.

              (de peek nil (untyi (tyi)))

          CHAR  must  be  a  number.  It represents the character with
          that numerical code.

(UPTIME) [SUBR] --> integer, in milliseconds
          The amount of time since the system was brought up.  This is
          the right thing to use to measure incremental real time.  

(USETI pos) [EXPR] 
          Sets the current input file to  byte  POS.    Equivalent  to
          (SETPOS (CURRENTIN) POS).  

(V: x1 ...) [FEXPR] --> (ASCII 0.)
          Useful  for printing values.  Each X may be either an atomic
          symbol VAR or a list of the form (VAR VAL).  Each  VAR  will
          be printed as a DV expression, with a value of VAL if given,
          or  the  current  value of the variable if only the variable
          name was given (unbound variables are printed with  a  value
          of NIL).

(VECTORLENGTH vector) [SUBR] --> integer
          VECTOR  had been be a vector.  Returns the length (number of
          entries) allocated.

(VECTORP thing) [SUBR] --> T or NIL
          Returns T if THING is a vector, else NIL.

(WITH (variables) exp1 exp2 ... expn) [MACRO] --> expn
          WITH is used when you want some local variables, but do  not
          need  a  PROG.  It is more efficient and more elegant than a
          PROG.  The syntax is similar:
                                                                   255


              (WITH (A B)
                    (SETQ A (CONS L X))
                    (SETQ B (CONS A L)))

          A  and  B  are local variables.  They are bound to NIL, then
          the  expressions  after  the  variable  list  are  executed.
          Finally,  A  and  B  have  their  original  values  (if any)
          restored.  You may initialize local variables by  specifying
          (var value):

              (WITH ((A 2) B)
                      ....

          A  will  be initialized to 2.  The default, which B uses, is
          to initialize to NIL.

(WITHIN [T] channel exp1 exp2 ...expn) [FSUBR] --> expn
          WITHIN is  used  when  you  want  to  redirect  input  to  a
          specified  channel.    It  saves the value of the previously
          selected input channel.  Then it selects CHANNEL  (which  is
          evaluated)  as  the  current input channel. EXP1 .. EXPN are
          executed  exactly  as  in  a  PROGN.  After  EXPN  has  been
          executed,  the previously selected channel is restored.  The
          channel is saved in such a way that if any errors  or  other
          unusual exits occur, the previous channel will be restored.

          T is optional.  If supplied, when WITHIN is exited (normally
          or abnormally), the channel is closed.

          Here  is how to use WITHIN and WITHOUT to form a simple loop
          that copies a file

              (errset
                   (within t (openin "infile.lsp")
                        (without t (openout "outfile.lsp")
                                   (rptq 10000000 (tyo (tyi))))))

          This is a loop that reads a character with TYI and writes it
          with TYO.    The  WITHOUT  redirects  output  inside  it  to
          "OUTFILE.LSP".    The  WITHIN  redirects  input inside it to
          "INFILE.LSP".  When the end of file is reached, an error  is
          generated.    As  with  any  error,  control  returns to the
          nearest ERRSET.  Because this transfer of control leaves the
          WITHIN and WITHOUT, input and output are restored  to  their
          previous  channels.    Because the WITHIN and WITHOUT have T
          specified, the file mentioned above are closed.

(WITHOUT channel exp1 exp2 ... expn) [FSUBR] --> expn
          Exactly like WITHIN, except that the current output  channel
          is used.  

(XCONS cdr car) [SUBR] --> new cons cell
          This  is  exactly the same as CONS with arguments in reverse
          order.  It is there for the convenience of the compiler.  
                                                                   256


(ZEROP number) [SUBR] --> T if it is zero, else NIL
          This finds both integer and real zeros.  

(+ x y) [SUBR] --> X + Y

(+I x) [SUBR] --> X + 1

(- x y) [SUBR] --> X - Y

(-I x) [SUBR] --> X - 1

(* x y) [SUBR] --> X * Y

(// x y) [SUBR] --> X / Y

(= x y) [SUBR] --> T or NIL
          This is another name for EQUAL.  Tries to see if the objects
          are "similar".  For list structure (CONS cells), the CAR and
          CDR  are  compared recursively.  The result is that they are
          EQUAL if they have the same structure, with the  same  atoms
          in  the  "leaves".   Numbers are checked to see if they have
          the same value.  Thus 123.0 (a real) and  123  (an  integer)
          will  be  EQUAL.    (The  actual  test for numbers is (ZEROP
          (DIFFERENCE X Y)) .)  

(=0 x) [SUBR] --> T if x = 0, else NIL
          I.e. T if X is a number and is a zero of any kind (fixed  or
          floating).  

$EOF$ 
          A  special  atom,  used to signal end of file on input.  See
          TYI.  

*NOPOINT - variable
          If this is true (non-NIL), no radix point  will  be  printed
          after  integers.    If  it  is NIL, Lisp will try to print a
          radix point after integers.  It will print  a  period  after
          decimal  numbers  and  a Q after octal numbers.  By default,
          this is true, so the radix point is not usually printed.  It
          is initially T. 

*NOPOINTDSK - variable
          This is a special version of *NOPOINT used by DSKOUT, SAVEF,
          and COMPL.  It is initially NIL.  

(; anything) [FEXPR] --> NIL

(;; anything) [FEXPR] --> NIL
          These functions are used to implement the {;  ...}  and  {;;
          ...}  constructs.    They  ignore their arguments and return
          NIL.  Note that { is defined as a readmacro.  It  reads  the
          following ; or ;;, and then gobbles all characters up to the
          next  }.    All the extra characters are made into a string.
          This allows you to put things inside {;; ...} that would  be
          illegal  inside  a  Lisp  function  call, such as unbalanced
                                                                   257


          parentheses and dots in odd places.  {;; odd stuff} shows up
          internally  as  (;;  "odd stuff").  That is, the body of the
          comment is  turned  into  a  string.    The  pretty-printer,
          SPRINT,  turns these functions back into {;; odd stuff} when
          writing them out.
                                                                   258


                        26. Notes for hackers



This  chapter contains some brief discussions of representations, as a
help  to  anyone  trying  to  debug  ELISP.    Needless  to  say,  the
information  here is implementation-dependent, and you should not make
any programs depend upon it.



26.1. Use of DDT


If you want to use DDT  with  ELISP,  there  are  special  provisions.
(DDT)  will  transfer  control to DDT, loading it if it is not already
loaded.  RET$X will return  from  DDT.    This  is  fine  for  setting
breakpoints  or  otherwise looking around.  However sometimes you want
to get into DDT when disasters of various sort occur, and this is  not
practical.  Thus there are two other tricks you should know:

If Lisp should blow up once it is initialized, or if you want to enter
DDT  directly during running, this is fairly easy. From the EXEC, type
DDT.  You are now in DDT in section 0.  This is no good, as  it  can't
do extended addressing.  Type DDTST$G.  This will start DDT in section
1.  You can now set breakpoints, etc.

If  you  need  to  get into DDT very early in the startup code, do the
following:

   - GET BOOT

   - DDT

   - $G

You will be put back into DDT in section 1 as soon as multi-sectioning
has been set up.  You should not try  to  set  breakpoints  after  the
initial  DDT  command,  unless  you  want  to  put a breakpoint in the
single-section startup code.  Rather you should wait until you are put
back into DDT after the $G.  This sequence allows  you  to  debug  the
initial  startup  code  used  in  BOOT.EXE, in case there is a problem
before the system is in a state that lets you type (DDT).

There is currently no way to enter DDT in the bootstrap code  used  to
start  a  saved core image.  This is the startup code used with normal
saved core images such as ELISP.EXE.  This entire set of code will  go
away  with  release 5 of Tops-20, and normal debugging procedures will
become possible.
                                                                   259


26.2. Writing assembly language functions


This section describes the conventions to be used if you want to write
a  function to be called from Lisp.  The easiest way to do this at the
moment is to write in Macro and load the module with LOADREL.    Elisp
makes  heavy  use of macros and symbolic definitions.  This allows for
easy changes of representation when this is desirable.   This  section
will  use  these  symbolic names.  Current definitions for them may be
found in BOOT.MID, mostly near the beginning.  You will probably  also
find  it  useful  to  look  at EARITH.MAC, as an example of writing an
external module in Macro.

First, you must understand what is meant by the term "Lisp object".  A
Lisp object consists of one word, of which the high-order 6 bits are a
type code and the rest is either data or a pointer to the place  where
the  data  is stored. The macro OBJECT(code,data) is used to construct
an object.  The most common object is a CONS cell, in which  case  the
word  consists  of the type code TY%CON and a pointer to two words, of
which the first is the CAR and the second the CDR. Next most common is
an atom.  This consists of the type code TY%ATM and  a  pointer  to  a
block  containing  fields  such  as the pname, functin definition, and
value.  These fields are defined  in  BOOT.MID  as  symbolic  offsets.
E.g.  AT%VAL  is the place where the value is stored.  Numbers come in
two kinds:  INUM's and other kinds.  An INUM is an integer whose value
is small enough that it will fit into the 30 bits left after the  type
code.    Currently  this  is  simply  a 30-bit twos-complement number,
however at some point it is possible that we could change to  29  bits
or  to a different representation.  As long as you use the appropriate
macros you will not have any trouble.  The other numbers are  integers
larger than 30 bits and reals.  Objects of these types consist of type
codes plus pointers to the data.  There are a few other data types not
described  here.    They  are  all  documented  near  the beginning of
BOOT.MID.

Data for all objects except INUM's are stored in a single common heap.
CONS cells, atoms, and other objects  are  mixed  with  no  particular
codes  indicating  which  are  which.    Because  of the fact that all
pointers have associated type codes, the garbage collector is able  to
find out everything it needs from the pointers.  The garbage collector
assumes  that most words in this heap are legal Lisp objects.  This is
true for CONS cells, where the data consists of two Lisp objects,  and
atoms,  where  the  data  consists  of  various  fields  that are Lisp
objects.  There is a special type code TY%ADR that is used to  make  a
machine  address  into  a  legal  Lisp  object.    That is, an address
consists of TY%ADR in the high-order 6  bits,  and  then  the  address
itself  in  the  low-order  30 bits.  Since indexing ignores the high-
order 6 bits, this normally works.  There are a  few  cases  in  which
full-word  data  must  be  put  into  the  heap.  To prevent this from
confusing the garbage collector, any such data must be prefixed  by  a
"skip  pointer",  which  has  a  type  code of TY%SPC and a data field
indicating how many words to skip.  Thus a real number consists of the
type code TY%REA and a pointer to a 3-word block in the heap.  The  3-
word  block has OBJECT TY%SPC,2 and then two words containing the real
number in double precision.  The OBJECT TY%SPC,2 is necessary  because
                                                                   260


the following two words probably do not have valid type codes in their
high-order 6 bits.

Memory  management  is  modeled after the Lisp machine.  There are two
free space areas, with a copying GC.  While you are running (i.e.  not
in  the  GC),  NEW  (AC 13) points into the current free space, to the
next available location.  CONS and other functions that create objects
simply allocate space at the address in NEW and update  NEW  to  point
beyond  the  new  object.  Different  types  of objects are intermixed
randomly in memory.  They are simply stored in the order in which they
are created.  Because the pointers are type-coded, there is never  any
problem  figuring out what type of object one is dealing with, so this
random intermixing works fine.   There  is  a  variable  LASTL,  which
defines  an  upper bound on how much memory should be allocated.  When
an object causes NEW to go beyond LASTL, the GC is called.  This bound
is, strictly speaking, aritificial.  That is,  there  is  no  physical
reason  why  memory  couldn't continue to be allocated without calling
the GC.  It is there just to keep the  working  set  to  a  reasonable
size.    The  GC  copies  all  active  data  to  the other free space,
compacting it.  It attempts to linearize lists as it copies them.   At
the end of the GC, LASTL is reset.  It is set to the last address used
in  the  new space + new free space.  The new free space is the larger
of 200000 octal (sufficient space for 32,000 CONS cells) and half  the
amount of space used in the new space.

The  worst kludge in the system is the way compiled code refers to the
values of special variables.  To get the value of FOO,  the  following
code is used:

    FOOVAL: OBJECT TY%ATM,.FOO      ;.FOO is 30-bit address of the
                                    ;atom block for FOO

            MOVE O1,@FOOVAL

The  obvious  code  (roughly  speaking  -  this  would fail because of
multiple sections) would be MOVE O1,.FOO+AT%VAL, where AT%VAL  is  the
offset  of  the value field with the atom.  The reason this won't work
is that .FOO is not a fixed address.  Since we use a  copying  garbage
collector,  each  time the garbage collector is run, most of the atoms
move.  Thus we must  use  a  real  Lisp  pointer  for  the  reference.
Because  OBJECT  TY%ATM,.FOO  is a type-coded Lisp object, the garbage
collector will adjust it appropriately whenever it moves the atom FOO.
In order for this to work, the garbage collector must scan all of  the
Lisp objects appearing in compiled code.  Thus binary program space is
scanned  by  the  garbage  collector  in  the same manner as the heap.
Since we do not want the garbage collector to scan  the  code  itself,
code is preceeded by OBJECT TY%SPC,codesize, which causes the scanning
to  skip the code.  Note that AT%VAL, the offset of the value field in
an atom, is 0.  This allows the indirect reference to get to the value
field.  Also, since indirect references use the high-order 5 bits  for
indexing, the type code must be either 0 (which causes no indexing) or
1  (which indexes by AC 1, which always contains 0).  In fact the type
code for atoms is normally 1.

The example above ignores  one  problem:    how  to  get  the  pointer
                                                                   261


TY%ATM,.FOO into your code.  In fact atoms are normally created by the
Lisp  runtimes,  since  they  must  be put into the heap at a location
where there is free space, and it must be entered into the  OBLIST  in
the  appropriate place.  The Lisp compiler actually leaves pointers of
this sort empty and puts in a request for the Lisp runtimes to fill in
the actual object when the file is loaded.  Unfortunately  this  is  a
sort  of  request  which  you  cannot easily make in a Macro file.  So
either you will have to  get  along  without  refering  to  Lisp  data
structure  (except  of  course  those passed as arguments) or you will
have to refer to atoms that are in known places.   All  of  the  atoms
that  the  kernel must know about are stored in fixed locations.  They
are scanned by the  garbaged  collector,  so  that  their  values  and
function  definitions will be properly garbage-collected, but they are
not ever moved.  In order to distinguish such constant atoms, they are
given the type code TY%CAT (for Constant ATom).  In  fact,  there  are
constant  versions  of  several  of  the  types:    atoms, CONS cells,
strings, and I/O channels.  The type codes for the constant  and  non-
constant  versions of a type are always adjacent numerically, in order
to make it easy to test types.  E.g., a  regular  CONS  cell  has  its
high-order  6 bits (type code) equal to TY%CON (2), whereas a constant
CONS cells has TY%CCN (3).  Since these differ only in  the  low-order
bit  of  the type code, you can check whether something is a CONS cell
of either kind by comparing the high-order 5 bits against TY%XAT  (1).
There are in fact 3 macros used to check type codes:

   - GETTYP(AC) - loads the high-order 6 bits of AC into W2.

   - XTYPE(AC) - loads the high-order 5 bits of AC into W2.

   - GETDSP(AC)  - loads the high-order 6 bits of AC into W2, but
     turns off the two highest-order bits. (Actually this is done
     with a single LDB, so doesn't use an  extra  instruction  as
     this would imply.)

GETTYP  would be used to find the exact type code.  XTYPE is used when
you want to see whether something is either a constant atom or  normal
atom, etc.  GETDSP is used for loading an exact type code that you are
going  to use to index into a dispatch table.  At the moment there are
only 16 type codes used.  Thus most dispatch tables  contain  only  16
entries.    While  it is not possible that there should be a type code
larger than 15, what do you want to happen if the impossible  happens?
Clearly  you  would  prefer  to  have  an  incorrect  entry  used than
something outside the table.    Thus  GETDSP  truncates  the  code  to
something that is going to be within the dispatch tables.

If  an  atom  is declared in BOOT.MID as a constant atom, then you can
refer to it in your code relatively easily.  All of  these  atoms  are
declared  in a list near the end of BOOT.MID.  They are declared using
macros such as DECLAT (declare a simple atom) and  DECLSU  (declare  a
SUBR).  These macros generate the atom structure, complete with pname,
insert them into the OBLIST at the right place, etc.  They also define
symbols  beginning  with % to allow you to refer to them.  Thus %PRIN1
is a symbol for a Lisp object refering to the atom PRIN1,  essentially
OBJECT TY%CAT,.PRIN1
                                                                   262


The accumulators come in 4 groups:

   - Because  NIL is defined as 0, and the CAR and CDR of NIL are
     supposed to be NIL, locations 0 and  1  must  always  be  0.
     Note  that  locations  0 and 1 are the same as AC's 0 and 1.
     It is best not to touch AC's 0 or 1 at all.  However if  you
     must  (e.g.  when  doing a JSYS that takes an argument in AC
     1), make  sure  that  you  clear  them  before  calling  any
     function  within  the interpreter or returning.  In order to
     emphasize their  special  danger,  these  AC's  are  defined
     symbolically as NIL and NIL1.

   - AC's  2  through  N  are  working  AC's.    They are defined
     symbolically as W2  through  Wn.    Currently  they  are  W2
     through  W4.  You may use these AC's for anything other than
     a Lisp object.   While  a  Lisp  object  may  be  put  there
     temporarily,  it  must  not  remain when you exit, or if you
     call any  function  that  could  possibly  cause  a  garbage
     collection.    You may use these AC's freely except for this
     constraint.

   - AC's O1 through On are Lisp object AC's.  O1 is the first AC
     above the last working AC.  Currently these are  O1  through
     O6,  however  O6  may  go  away  if another AC is needed for
     something else.  These AC's  must  be  used  only  for  Lisp
     objects.  While something else may be put there temporarily,
     it  must  not  remain  when  you  exit,  or  if you call any
     function that could possibly  cause  a  garbage  collection.
     You   may   change   these  AC's  freely,  except  for  this
     constraint.

   - The AC's above the last  object  AC  are  used  for  special
     purposes,  mostly  stack  pointers.    They  should  not  be
     changed, except if you want to push or pop the stack.  There
     are in three stacks:  P, Q, and SP:

   - P is the normal control stack.  You call routines  by  PUSHJ
     P, and return by POPJ P,.  You may store anything other than
     a  Lisp object on P, assuming of course that you pop it back
     off before you exit.

   - Q is the Lisp object stack.  It is used  when  you  need  to
     save  a  Lisp object on a stack, either because you have run
     out of AC's, or because you need to call a routine  that  is
     going  to  garbage  the  AC's.   You must make sure that you
     leave this stack where you found it before exiting.

   - SP is the "special stack". It is used to save old values  of
     variables  when  you  want to rebind a variable.  Things are
     always pushed onto it in pairs, first the variable (which is
     normally an atom) and  then  the  old  value  to  be  saved.
     Before  exiting  you  must  restore  this stack to where you
     found it.  Since you normally  want  to  restore  the  saved
     variables  also,  you  should  either do that one by one, or
     exit via UNBIND (see below).
                                                                   263


Arguments  are  passed  in  AC's  O1  through  O5, except for LEXPR's.
Values are returned in AC O1.  For  LEXPR's,  the  caller  pushes  the
arguments  onto  Q, and puts the number of arguments (as an INUM) into
O1.  The caller restores Q after the LEXPR returns.

Here is a very simple example of some code to illustrate a  number  of
the  points  made  above.  Note the use of @[datsec,,.in] The indirect
reference is needed because of the fact that atoms  are  stored  in  a
difference  section  than  the  code,  and  Midas  is unable to handle
addresses in other sections.  DATSEC,,.IN is simply the address of the
atom IN, which is the symbol .IN in section  DATSEC  @[  ]  is  needed
because  this  address  takes more than 18 bits, and thus won't fit in
the effective address field.  Note that the symbols .IN  and  %IN  are
automatically generated when the atom IN is declared in BOOT.MID.

    code for (PROG (IN) (SETQ IN 1) (PRIN1 IN))

    push p,sp                       ;save original state of SP
    push sp,[%IN]                   ;save variable
    push sp,@[datsec,,.in+at%val]  ;old value of variable
    move o1,[object ty%int,1]       ;INUM 1
    movem o1,@[datsec,,.in+at%val] ;do the SETQ
    pushj p,prin1
    jrst unbind

Note  that  CALL PRIN1 is a direct call to the internal routine PRIN1.
If the  user  redefined  PRIN1,  you  would  still  get  the  original
definition.  A real Lisp call to PRIN1 would use the definition in the
atom block:

    pushj p,@[datsec,,.prin1+at%cal]

since  word AT%CAL in the atom block is always the address of code for
the routine.  This works even if PRIN1 is defined  as  an  interpreted
function,  since  that  word  will then be set to a routine within the
interpreter.

The JRST UNBIND restores the old value of IN and then returns.  UNBIND
assumes that the original value of SP is on the top of the P stack, as
it is in the example above.  If you want to unbind but not return,  do
the following:

    pop p,w2        ;get original value of SP into W2
    pushj p,unbin1  ;special entry to UNBIND that returns to us

Here is a summary of rules you should follow:

   - Make  sure  that  NIL and NIL1 are 0, when you exit and when
     you call any other routine.

   - Do not change AC's above the highest  object  AC  (currently
     O6), except when using them as stacks.

   - Make  sure that the working AC's do not contain Lisp objects
     when you exit and when you call any routine that  may  do  a
                                                                   264


     garbage collect.

   - Make  sure that the object AC's do contain Lisp objects when
     you exit and when you call any routine that may do a garbage
     collect.  It is sufficient to zero them, since zero is  NIL,
     which is a legal Lisp object.

   - Make  sure  that  you push things onto the right stack: Lisp
     objects onto Q (or SP if you are saving values), others onto
     P. 

   - Make sure that you adjust stacks before exiting  to  be  the
     same  as  when  you were entered, except if you exit by JRST
     UNBIND, in which case the old value of  SP  will  be  pushed
     onto P. 

Here are some useful routines and macros:

     GETINT  -  a routine to convert a Lisp number into a bare number.
          Works for INUM's or FIXNUM's.  Input:  a Lisp number in  O1.
          Output:  a machine number in W2.  Changes no other AC's.

     GETNUM  AC  -  a macro to converts an INUM into a machine number.
          Since an INUM need not be garbage collected, it is legal  to
          put  one in a working AC. AC must not be an object AC.  Thus
          typical code is:

              move w2,o1      ;get into working AC
              getnum w2       ;w2 is now a bare number

          Does no type checking.  You may do this in an object  AC  if
          you  are  careful  to  put  a Lisp object into the AC before
          exiting or calling any  Lisp  routines.    GETINT  is  safer
          because of the type checking.

     RETINT  -  A routine to convert a bare number into a Lisp number,
          either INUM or  FIXNUM,  depending  upon  the  size  of  the
          number.    Input:    a  bare  number in W2.  Output:  a Lisp
          number in O1.  Routines that are  going  to  return  numbers
          typically load the number into W2 and JRST to RETINT.

     MAKNUM  AC  -  A  macro to convert a machine number into an INUM.
          This is somewhat dangerous, since  numbers  bigger  than  30
          bits  will give garbage.  It is used for counts, characters,
          and other things that are known to be small.

     RETREA - A routine to convert a bare  double  precision  floating
          point  number into a Lisp real number.  Input:  a d.p. float
          number in W2 and W3.  Output: a Lisp number in O1.  Routines
          that are going to return real  numbers  typically  load  the
          number into W2 and W3 and JRST to RETREA.

     DOCONS  OUT,CAR,CDR - A macro that uses 3 AC's (OUT should not be
          the same as CAR or CDR).  Does a CONS inline.  Input:    CAR
          and CDR.  Output: OUT.
                                                                   265


     CONS  -  a  routine  that does CONS.  Input: O1(CAR) and O2(CDR).
          Output: O1.

     DOCAR OUT,IN - A macro that does CAR.  OUT and IN  are  AC's  and
          can be the same.

     DOCDR  OUT,IN  -  A macro that does CDR.  OUT and IN are AC's and
          can be the same.

     DORPA OUT,IN - A macro that does (RPLACA OUT IN).  OUT and IN are
          AC's.

     DORPD OUT,IN - A macro that does (RPLACD OUT IN).  OUT and IN are
          AC's.

     GETVAL OUT,IN - A macro that gets the value of a  variable  (i.e.
          atom).    OUT  and  IN are AC'S.  IN contains the atom whose
          value you want.  OUT is set to the value.

     SETVAL OUT,IN - A macro that sets the value of a  variable  (i.e.
          atom).    OUT  and IN are AC's.  OUT contains the atom whose
          value you want to set.  IN is the new value.

     BIND ATOM,VALUE - A macro to  bind  a  variable,  i.e.  save  the
          variable  and old value on SP and set a new value.  ATOM and
          VALUE are both AC's, containing  the  atom  and  new  value.
          Checks for illegal bindings, ATOM = NIL or T. 

     FASBIND ATOM,VALUE - same as BIND, but does not check for illegal
          bindings.

     GETTYP  AC,  XTYPE AC, GETDSP AC - Macros to load type codes into
          W2, the object being in AC.  Described above.

     SCONS AC - skip next instruction if object in AC  is  a  CONS  of
          either kind.

     SNCONS  AC  - skip next instruction if object in AC is not a CONS
          of either kind.

     ERR /text/ - a macro to generate an error.  Takes more  than  one
          word,  so  if  you  want  to  skip it, do JRST [ERR /text/].
          Zeros NIL and NIL1, so it is legal to do this even  if  they
          contain something non-zero.

     PERR  /text/  -  like  ERROR but first prints the contents of O1.
          This is the normal way to do errors.  E.g. when  EVAL  wants
          to  evaluate  a  variable,  it has the variable in O1 and if
          there is no value it says PERR /Unbound variable/.   If  FOO
          were in O1, the result would be
                                                                   266


              ? FOO
              ? Unbound variable

              FOO broken
              1:

     RETNIL  - a routine that moves NIL to O1 and does POPJ P,.  Often
          used as the object of a test, e.g. JUMPE  O2,RETNIL.    Also
          clears  NIL1,  so  it is legal to do this when NIL1 contains
          garbage.

     RETT - a routine that moves T to O1 and does POPJ P,.    Used  as
          above.  (Does not clear NIL1, though.)

     UNBIND  -  a  routine to restore old bindings from SP and return.
          It is designed to be  JRST'ed  to  from  at  the  end  of  a
          routine.  It assumes that the top thing on P is the value of
          SP to get back to, and that the return address is just below
          this.   Note that it is not practical to call this expecting
          a return, i.e.  you can JRST UNBIND but not PUSHJ  P,UNBIND.
          The  reason  is  that  PUSHJ  P,UNBIND  would put the return
          address on the top of P, and UNBIND expect the old value  of
          SP  to  be  there.   Please make sure you shouldn't be using
          CUBIND instead.

     UNBIN1 - a version of UNBIND designed to be PUSHJ'ed to.  Expects
          the old value of SP in W2.  Please make sure  you  shouldn't
          be using CUBIN1 instead.

     CUBIND  -  a  version  of UNBIND which should be used to clean up
          after non-local transfers of control, e.g. ERR or  GO.    It
          works  just  like  UNBIND,  but  also  closes any files from
          WITHIN or WITHOUT's that have been exited.  These files  are
          stored  on  a  separate stack (implemented with CONS cells).
          This check is not needed in case of a "normal  exit"  unless
          it  is  a  normal  exit from WITHIN or WITHOUT, since in the
          case of a normal exit one knows that  you  are  not  exiting
          through any WITHIN or WITHOUT.

     CUBIN1 - same relation to CUBIND as UNBIN1 has to UNBIND.

A  brief  discussion  of  the  special  pushdown stack seems in order.
Items are always pushed onto SP in pairs.  The first item in the  pair
is  an identification, and second item is data.  The most common thing
is to push a variable and its old value.  This is done  as  a  way  of
saving  old  values  whenever  a  variable  is  to be rebound in a new
context.  Whenever EVAL is about to interpret a  non-atomic  form,  it
pushes  NIL  and  then  the  form.  The NIL acts as a flag so that the
break package can recognize these forms.  UNBIND and related functions
simply go up the stack and restore the values saved  on  it.    UNBIND
ignores  pairs of which NIL is the first, but treats all other objects
as variable and values.

In addition to Lisp variables and NIL,  there  is  a  third  class  of
object on the SP.  This is internal variables.  These are used to save
                                                                   267


information  needed internally by the interpreter.  They are like one-
word atoms.  I.e. they have value cells, but nothing else.  Since  the
value  cell  of an atom is the first thing in it, these objects can be
treated by UNBIND as if they were atoms, thus eliminating the need for
any special testing in UNBIND.  The type code  used  for  pointers  to
such  things is TY%ADR (which is the code for a bare machine address).
These internal variables are used fairly  extensively,  e.g.  to  keep
track  of  where the interpreter is in the middle of a PROG.  The most
widely used are .CURIN and .CUROUT, which contain  the  current  input
and output channels.  So I/O fuctions usually begin with code like

            move o2,@[datsec,,.curout] ;output channel
            camn o2,@[datsec,,priout] ;see if primary output

Often  such variables are used to save contexts for non-local returns.
E.g. here is the code for ERRSET

    errset:
      ;construct saved environment for ERRSET
            docdr o2,o1
            camn o2,nil             ;if flag not specified
            skipa o2,[%t]           ;then default  o2 _ T
             docar o2,o2            ;else o2 _ F
            push p,sp
            push p,q
            push sp,[%TOPERR]
            push sp,@[datsec,,.TOPERR]
            move w2,p
            tlo w2,(object(ty%adr),0)
            movem w2,@[datsec,,.TOPERR]
            push sp,[%ERRFLAG]
            push sp,@[datsec,,.ERRFLAG]    ;save F for ERROR
            movem o2,@[datsec,,.ERRFLAG]
            docar o1,o1             ;o1 _ E
            call eval               ;result of expr to o1
            docons o2,o1,nil        ;make list of it - to o2
            move o1,o2              ;return list
            adjsp p,-1              ;kill saved Q. leave SP
            jrst unbind             ;restores old TOPERR

This uses two of these internal variables, TOPERR and ERRFLAG.  TOPERR
saves the context of the most recent ERRSET.  This contains sufficient
information to return to the ERRSET in case of error.  Note how it  is
done:  the  other  stacks are pushed onto P, and then TOPERR itself is
bound to the current value of P. P has  the  type  code  bits  set  to
TY%ADR  (the  type  for  a  bare address), because the values of these
special variable are processed by the GC.  Thus they must  have  valid
type  codes.  Thus to return to this context, one need only restore P,
pop off the rest of the stacks, and call UNBIND (actually  CUBIND)  to
clean  up  the  special  PDL.    If more than one ERRSET is in effect,
TOPERR always represents the most recent, which is the one  you  would
check  first  anyway.   If you restore the context of topmost one, the
UNBIND operation will take care of resetting TOPERR to the  next  most
recent  one.  ERRFLAG is the flag value passed by the user to the most
recent ERRSET.
                                                                   268


Another  interesting  internal variable is RDTOP.  This is used by the
macro RDENTER to  enter  read  context.    (RDENTER  is  the  internal
equivalent  of  the  Lisp  function READCONTEXT.)  The purpose of read
context is to establish a backup point in case the user types ^Z.   As
described  above,  the  other  stacks  are  pushed onto P and then the
current value of P is put into RDTOP.  The routine RDEXIT is  used  to
exit  from  read  context.  It checks RDTOP and if this is a top-level
exit, checks for ^F having been typed, calling the editor if so.  Read
context  is  complicated  by  the  fact  that  READ  can   be   called
recursively.   Only the outermost call should set the backup point and
only the outermost exit should activate the editor.
   