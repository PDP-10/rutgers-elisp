(SPECIAL SIZE: %FOOFNS ALLVALS ALLSTRS ALLFNS LASTWORD SAVE *RAISE *RAISEDSK
         %/#GENDATE %/#CGENDATE)

(SETQ GCTRIGGER 1.0)

 (DF DRM (F)
     (SETCHR (CAR F) 2)
     (PUTPROP (CAR F) (CADR F) 'READMACRO)
     (CAR F))

 (DF DSM (F)
     (SETCHR (CAR F) 3)
     (PUTPROP (CAR F) (CADR F) 'SPLICEMACRO)
     (CAR F))

[DF DEFPROP (L) (PUTPROP (CAR L) (CADR L) (CADDR L)) (CAR L)]

(DE CAAR (A) (CAR (CAR A)))
(DE CADR (A) (CAR (CDR A)))
(DE CDAR (A) (CDR (CAR A)))
(DE CDDR (A) (CDR (CDR A)))
(DE CAAAR (A) (CAR (CAR (CAR A))))
(DE CAADR (A) (CAR (CAR (CDR A))))
(DE CADAR (A) (CAR (CDR (CAR A))))
(DE CADDR (A) (CAR (CDR (CDR A))))
(DE CDAAR (A) (CDR (CAR (CAR A))))
(DE CDADR (A) (CDR (CAR (CDR A))))
(DE CDDAR (A) (CDR (CDR (CAR A))))
(DE CDDDR (A) (CDR (CDR (CDR A))))
(DE CAAAAR (A) (CAR (CAR (CAR (CAR A)))))
(DE CAAADR (A) (CAR (CAR (CAR (CDR A)))))
(DE CAADAR (A) (CAR (CAR (CDR (CAR A)))))
(DE CAADDR (A) (CAR (CAR (CDR (CDR A)))))
(DE CADAAR (A) (CAR (CDR (CAR (CAR A)))))
(DE CADADR (A) (CAR (CDR (CAR (CDR A)))))
(DE CADDAR (A) (CAR (CDR (CDR (CAR A)))))
(DE CADDDR (A) (CAR (CDR (CDR (CDR A)))))
(DE CDAAAR (A) (CDR (CAR (CAR (CAR A)))))
(DE CDAADR (A) (CDR (CAR (CAR (CDR A)))))
(DE CDADAR (A) (CDR (CAR (CDR (CAR A)))))
(DE CDADDR (A) (CDR (CAR (CDR (CDR A)))))
(DE CDDAAR (A) (CDR (CDR (CAR (CAR A)))))
(DE CDDADR (A) (CDR (CDR (CAR (CDR A)))))
(DE CDDDAR (A) (CDR (CDR (CDR (CAR A)))))
(DE CDDDDR (A) (CDR (CDR (CDR (CDR A)))))

(DE REVERSE (L) (REVERSE1 L NIL))
(DE REVERSE1 (L M)
	(COND ((ATOM L) M)
	      (T (REVERSE1 (CDR L) (CONS (CAR L) M)))))

[DE MEMBER (L1 L2) (COND ((ATOM L2) NIL)
		         ((EQUAL L1 (CAR L2)) L2)
			 (T (MEMBER L1 (CDR L2]

[DE MEMQ (L1 L2) (COND ((ATOM L2) NIL)
		         ((EQ L1 (CAR L2)) L2)
			 (T (MEMQ L1 (CDR L2]

[ALIAS 'MEMB 'MEMQ]

(DE LAST (L)
    (COND ((ATOM (CDR L)) L)
	  (T (LAST (CDR L)))))

(DE *EXPAND (L FN) (*EXPAND1 (REVERSE (CDR L)) FN))
(DE *EXPAND1 (L FN)
  (COND ((NULL (CDR L)) (CAR L))
        (T (LIST FN (*EXPAND1 (CDR L) FN) (CAR L)))))

(DM PLUS (L) (*EXPAND L '*PLUS))
(DM DIFFERENCE (L) (*EXPAND L '*DIF))
(DM TIMES (L) (*EXPAND L '*TIMES))
(DM QUOTIENT (L) (*EXPAND L '*QUO))
(DM STCONCAT (L) (*EXPAND L '*STCONCAT))
(DM GREATERP (L)
  (LIST '*GREAT
	(*EXPAND1 (CDR (REVERSE (CDR L)))
		  '(LAMBDA (X Y) (COND [(AND X [*GREAT X Y]) Y])))
	(CAR (LAST L))))
(DM LESSP (L)
  (LIST '*LESS
	(*EXPAND1 (CDR (REVERSE (CDR L)))
		  '(LAMBDA (X Y) (COND [(AND X [*LESS X Y]) Y])))
	(CAR (LAST L))))

(DE *BEXPAND (L FN) (*BEXPAND1 (REVERSE (CDDR L)) (CADR L)  FN))
(DE *BEXPAND1 (L CODE FN)
  (COND ((NULL (CDR L)) (CAR L))
        (T (LIST FN CODE (*BEXPAND1 (CDR L) CODE FN) (CAR L)))))


(DE NEQ (A B) (NOT (EQ A B)))

(DE NTH (L N) (COND [(*LESS N 1) (CONS NIL L)]
		    [T (PROG NIL
		       LOOP (COND [(OR (*LESS N 2) (ATOM L)) (RETURN L)])
			    (SETQ L (CDR L))
			    (SETQ N (SUB1 N))
			    (GO LOOP))]))

[ALIAS 'MAPCONC 'MAPCAN]

[DE PROG1 (E1 E2 E3 E4 E5) E1]

[DE PROG2 (E1 E2 E3 E4 E5) E2]

[DE PRINTC (THING) (TERPRI) (PROG1 (PRINC THING) (TYO 32.))]

(SETQ UCICHANNELS NIL)
(DF INPUT (F) (UCIOPEN 'OPENIN F T NIL))
(DF OUTPUT (F) (UCIOPEN 'OPENOUT F T NIL))

[DE FUCICH (REALCHAN) (AND REALCHAN (FUCICH1 REALCHAN UCICHANNELS)]

[DE FUCICH1 (REALCHAN CHANS)
   (COND ((NULL CHANS)
	  (SETQ UCICHANNELS (CONS (CONS (GENSYM) REALCHAN) UCICHANNELS))
	  (CAAR UCICHANNELS))
	 ((EQ REALCHAN (CDAR CHANS)) (CAAR CHANS))
	 (T  (FUCICH1 REALCHAN (CDR CHANS]

[DE INCH NIL (FUCICH (CURRENTIN))]

[DE OUTCH NIL (FUCICH (CURRENTOUT))]

[DE AREMOVE (THING L) 
 (COND ((ATOM L) NIL)
       ((EQ THING (CAAR L)) (CDR L))
       (T (CONS (CAR L) (AREMOVE THING (CDR L]

(DE UCIOPEN (PROC FILES UCICHAN ECHAN )
 [COND ((ATOM FILES) (ERROR "No files specified"))
       ([AND (ATOM (CAR FILES))
	     (NOT (STRINGP (CAR FILES)))
	     (NOT (EQ ': (CAR (LAST (EXPLODE (CAR FILES]
	(AND (NULL (CAR FILES)) (ERROR "Illegal to open a file on NIL"))
	(SETQ UCICHAN (CAR FILES))
	(SETQ FILES (CDR FILES]
 [COND ((SETQ ECHAN (CDR (ASSOC UCICHAN UCICHANNELS)))
        (CLOSEIO ECHAN)
	(SETQ UCICHANNELS (AREMOVE UCICHAN UCICHANNELS]
 [SETQ UCICHANNELS (CONS (CONS UCICHAN (EVAL (CONS PROC (FILEARGS FILES)))) UCICHANNELS]
 UCICHAN)

(DE INC (UCICHANNEL DOCLOSE)
[PROG1
 (INCH)
 [COND (DOCLOSE
	(SETQ UCICHANNELS (AREMOVE (INCH) UCICHANNELS))
	(CLOSEIO (CURRENTIN))]
 [COND ((NULL UCICHANNEL) (SELECTIN NIL))
       ((SETQ UCICHANNEL (CDR (ASSOC UCICHANNEL UCICHANNELS)))
	(SELECTIN UCICHANNEL))
       (T (ERROR "No INPUT - INC"]])
 
(DE OUTC (UCICHANNEL DOCLOSE)
[PROG1
 (OUTCH)
 [COND (DOCLOSE
	(SETQ UCICHANNELS (AREMOVE (OUTCH) UCICHANNELS))
	(CLOSEIO (CURRENTOUT))]
 [COND ((NULL UCICHANNEL) (SELECTOUT NIL))
       ((SETQ UCICHANNEL (CDR (ASSOC UCICHANNEL UCICHANNELS)))
	(SELECTOUT UCICHANNEL))
       (T (ERROR "No INPUT - INC"]])
 
(DE FILEARGS (L) (FILEARGS1 NIL NIL L))

[DE FILEARGS1 (DEV DIR L)
 (COND [(ATOM L) NIL]
       [(ATOM (CAR L)) 
	(COND [(STRINGP (CAR L))
	       (CONS (CAR L) (FILEARGS1 DEV DIR (CDR L]
	      [(EQ ': [CAR (LAST (EXPLODE (CAR L])
	       (FILEARGS1 (CAR L) DIR (CDR L]
	      [T
	       (CONS (MAKEFILENAME DEV DIR (CAR L) NIL)
		     (FILEARGS1 DEV DIR (CDR L]]
       [(ATOM (CDAR L))
	(CONS (MAKEFILENAME DEV DIR (CAAR L) (CDAR L))
	      (FILEARGS1 DEV DIR (CDR L]
       [T
	(FILEARGS1 DEV
		   [READLIST (APPEND (EXPLODE (CAAR L)) (EXPLODE (CADAR L]
		   (CDR L]]

[DE MAKEFILENAME (DEV DIR NAME EXT)
  [AND DEV (SETQ DEV (EXPLODE DEV]
  [AND DIR (SETQ DIR (APPEND '(<) (EXPLODE DIR) '(>)]
  [SETQ NAME (EXPLODE NAME]
  [AND EXT (SETQ EXT (APPEND '(/.) (EXPLODE EXT]
  [READLIST (APPEND '(/") DEV DIR NAME EXT '(/")]]

(DF DSKIN (L) (%DSKIN L NIL))

(DF LOADF (L) (%DSKIN L T))

(DE %DSKIN (%L %SETFOOFNS)
  (PROG (%CH %FOOFNS %FNAME ALLFNS ALLSTRS ALLVALS)
	(SETQ %CH (OPENF (FILEARGS %L) '(OLD IN WILD)))
LOOP	(SETQ %FOOFNS (LIST NIL))
	(%READIN %CH DSKIN)
	(COND (%SETFOOFNS
		(SETQ %FNAME (%FILEASSOC (JFNS %CH 001000000000Q) ALLFILES))
		(COND ((NOT %FNAME)
		       (SETQ %FNAME (CONS (JFNS %CH 111100000001Q)
					  (READLIST
					     (NCONC
						(EXPLODEC
						   (JFNS %CH 001000000000Q))
				 	        '(F N S)))))
		       (SETQ ALLFILES (CONS %FNAME ALLFILES)))
		      (T (RPLACA %FNAME (JFNS %CH 111100000001Q))))
	        (SET (CDR %FNAME) (CAR %FOOFNS))))
	(COND ((NOT (NEXTF %CH)) (RETURN 'F/i/l/e/s-L/o/a/d/e/d)))
	(OPENF %CH '(IN))
	(GO LOOP)))]

(SETQ DSKIN T)

(DE %READIN (CHAN PRINT)
  (PROG (*RAISE X SAWLAP OCHAN)
	(SETQ *RAISE *RAISEDSK)
	(AND PRINT [LINES 0.])
	(SETQ OCHAN (SELECTIN CHAN NIL))
	(SETQ X
	      (ERRSET (PROG (Y)
			    (SETQ Y (%UCIREAD))
			    (COND ((EQ Y 'SIZE:)   This is a FLAP file
				   (SETQ Y (JFNS CHAN 0))
				   (FLAP Y)
				   (COND [(EQ PRINT 'PRINT) (PRINT Y)]
					 [(AND PRINT Y) (PRIN1 Y) (PRINC " ")])
				   (ERR '$EOF$)))
			    (SETQ Y (EVAL Y))
			    (GO LOOP1)
		    LOOP    (SETQ Y (EVAL (%UCIREAD)))
		    LOOP1   (COND [(EQ PRINT 'PRINT) (PRINT Y)]
				  [(AND PRINT Y) (PRIN1 Y) (PRINC " ")])
			    (GO LOOP))
		      ERRORX))
	(AND PRINT [LINES 0.])
	(SELECTIN OCHAN NIL)
	(AND [NEQ X '$EOF$] [ERR X])))

(DEFPROP ELISP: %READANALYZE-RECURSE READCOM)

(DEFPROP NOCOMPILE %READANALYZE-RECURSE READCOM)

(DE %READANALYZE-RECURSE (Y TCONC-HEADER)
   (TCONC TCONC-HEADER
	(PROG	(%FOOFNS FORMS)
		(SETQ %FOOFNS (LIST NIL))
		(MAPC '%READANALYZE (CDR Y))
		(RETURN (MCONS 'MBD: (CAR Y) (CAR %FOOFNS)))))
   Y)

(DEFPROP DEFPROP %AN-DEFPROP READCOM)

(DE %AN-DEFPROP (Y TCONC-HEADER) (%XDEFPROP Y))

(DEFPROP DE %AN-DX READCOM)

(DEFPROP DM %AN-DX READCOM)

(DEFPROP DF %AN-DX READCOM)

(DE %AN-DX (Y TCONC-HEADER)
	(TCONC TCONC-HEADER (LIST 'F: (CADR Y)))
	(UNBREAK! (CADR Y))
	Y)

(DEFPROP DV %AN-DV READCOM)

(DE %AN-DV (Y TCONC-HEADER) (TCONC TCONC-HEADER (LIST 'V: (CADR Y))) Y)

(DEFPROP DS %AN-DS READCOM)

(DE %AN-DS (Y TCONC-HEADER) (TCONC TCONC-HEADER (LIST 'ST: (CADR Y))) Y)

(DE %READANALYZE (Y)
  (COND [(CONSP Y)
	 (COND [(AND (LITATOM (CAR Y)) (GET (CAR Y) 'READCOM))
		((GET (CAR Y) 'READCOM) Y %FOOFNS)]
	       [(AND (LITATOM (CAR Y)) (GET (CAR Y) 'PPCOM))
		(TCONC %FOOFNS (LIST 'FORMS: Y))
		Y]
	       [T (TCONC %FOOFNS Y) Y])]
	[T (TCONC %FOOFNS (LIST 'FORMS: Y)) Y]))

(DE %UCIREAD NIL
  (PROG (Y)
   	(SETQ Y (READ))
	(COND  ((AND (CONSP Y) (EQ (CAR Y) 'LAP))
		(TTYMSG T "Old format LAP defn for "
			  (CADR Y)
			  T)
		(TCONC %FOOFNS Y)
		(PROG NIL
		LOOP (SETQ Y (READ))
		     (TCONC %FOOFNS Y)
		     (OR Y (RETURN NIL))
		     (GO LOOP)))
	      (T (SETQ Y (%READANALYZE Y))))
	(RETURN Y)))

(DE %XDEFPROP (L)
    (COND [(AND [EQ (LENGTH L) 4] [MEMQ (CADDDR L) '(MACRO EXPR FEXPR)])
	   (UNBREAK! (CADR L))
	   (TCONC %FOOFNS (LIST 'F: (CADR L)))
	   (LIST 'PROG1
		 (LIST 'QUOTE (CADR L))
		 (LIST 'ALIAS
		       (LIST 'QUOTE (CADR L))
		       (LIST 'QUOTE (CONS (CADDDR L) (CADDR L)))))]
	  [(GET 'DEFPROP 'PPCOM) (TCONC %FOOFNS (LIST 'FORMS: L)) L]
	  [T (TCONC %FOOFNS L) L]))

[DF *FUNCTION (F BCP) (CONS 'FUNARG (CONS (CADR F) (DIFFERENCE BCP 2]

[ALIAS 'FUNCTION 'QUOTE]

(DE UNMACEXPAND (X)
  (PROG (XX DEF)
	(COND [(ATOM X) (RETURN X)]
	      [(AND [EQ (CAR X) 'MACROEXPANSION]
		    [NOT (ATOM (SETQ XX (CDR X)))]
		    [NOT (ATOM (SETQ XX (CDR XX)))]
		    [NOT (ATOM (SETQ XX (CAR XX)))]
		    [SETQ DEF (FUNDEF (CAR XX))]
		    [MEMQ (CAR DEF) '(MACRO MSUBR)])
	       (RPLACA X (CAR XX))
	       (RPLACD X (CDR XX))])
	(SETQ XX X)
   LOOP (UNMACEXPAND (CAR XX))
	(COND [(NOT (ATOM (SETQ XX (CDR XX)))) (GO LOOP)] [T (RETURN X)])))

[DE %BK (INDEX)
   (COND [(GREATERP INDEX 1)
	  (SETQ INDEX (NEXTEV (SUB1 INDEX)))
	  (PRINT '***************)
	  (TERPRI)
	  (%BKPRINT (SPDLRT INDEX))
	  (%BK INDEX)]
	 (T NIL))]

(DE %BKPRINT (%%L)
  (COND ((ATOM %%L) (PRIN1 %%L))
	((EQ (CAR %%L) 'MACROEXPANSION) (%BKPRINT (CADDR %%L)))
	((MEMQ (CAR %%L) '(/; /;/;))
	 (PRINC '/{)
	 (PRINC (CAR %%L))
	 (PRINC '/ )
	 (PRINC (CADR %%L))
	 (PRINC '/}))
	([AND (EQ (CAR %%L) 'QUOTE) (NOT (ATOM (CDR %%L)))]
	 (PRINC '/')
         (%BKPRINT (CADR %%L)))
        (T (%BKPRINT2 %%L))))

(DE %BKPRINT2 (%%L)
  (PROG NIL
  	(PRINC '/()
A	(%BKPRINT (CAR %%L))
	(SETQ %%L (CDR %%L))
	(COND ((NULL %%L) (PRINC '/)))
	      ((ATOM %%L) (PRINC '/ /./ ) (%BKPRINT %%L) (PRINC '/)))
	      (T (PRINC '/ ) (GO A)))))


(DE %TOPBREAK (INDEX)
   (PROG (%THING %OLDCHAR)
   [SETQ %OLDCHAR (PROMPT 58.)]
   [SETQ INDEX (NEXTEV (SUB1 (NEXTEV (SUB1 INDEX]
   [TERPRI]
   [PRIN1 (SPDLRT (NEXTEV (SUB1 INDEX]
   (PRINC "

BREAK - Type ? for help
")
LOOP
   (SETQ %THING (READ))
   (COND ((EQ %THING 'BK) (%BK INDEX))
	 [(EQ %THING 'EDIT) (RPLACD [STKPTR (NEXTEV (SUB1 INDEX]
			            (*EDIT (SPDLRT (NEXTEV (SUB1 INDEX]
	 ((EQ %THING 'OK) (PROMPT %OLDCHAR) (SPREDO (NEXTEV (SUB1 INDEX))))
	 ((EQ %THING '^) (RETURN NIL))
	 ((EQ %THING '^^) (RETURN NIL))
	 ((EQ %THING '?)  (PRINC "
Type one of
  BK for backtrace
  OK to retry failing expression and proceed
  EDIT to edit failing expression (but NOT function defn in which it appears)
  ^^ to exit
  ? for this message
  arbitrary Lisp expression, which will be evaluated in the
     context of the break
"))
	 (T (PRINT (EVAL %THING))))
   (TERPRI)
   (PRINT 'BREAK)
   (TERPRI)
   (GO LOOP)))

(DE ERRORX (SERIOUS) (%TOPBREAK (SPDLPT)))

(*RSET T)

(SETQ *RAISEDSK NIL)

(DF BOOT (F)
  (SETQ %/#GENDATE (DATE))
  (INITFN '[LAMBDA NIL  ((LAMBDA (INFILE)
			  (INITFN NIL)
			  [PRINC "Elisp, "]
			  [MAPC '(LAMBDA (X) (PRIN1 X) (PRINC " "))
			        %/#GENDATE]
			  [TERPRI]
                          [COND (INFILE 
			         (SELECTIN INFILE)
			         (PROG (%FOOFNS)
				   (SETQ %FOOFNS (LIST NIL))
			LOOP       (OR (EQ '$EOF$ (ERRSET (EVAL (%UCIREAD))
							   NIL))
				       (GO LOOP]
			  (**TOP**))
		         (OPENF "ELISP.INIT" '(IN OLD ERROR CONTINUOUS)))])
  (GC)
  (COND (F (EVAL (CONS 'SAVEIMAGE F))) (T (SAVEIMAGE "ELISP.EXE")))
)

(DE BOOTC NIL
  (SETQ %/#CGENDATE (DATE))
  (INITFN '[LAMBDA NIL  ((LAMBDA (INFILE)
			  (INITFN NIL)
			  [PRINC "Elisp compiler, "]
			  [MAPC '(LAMBDA (X) (PRIN1 X) (PRINC " "))
			        %/#CGENDATE]
			  [TERPRI]
                          [COND (INFILE 
			         (SELECTIN INFILE)
			         (PROG (%FOOFNS)
				   (SETQ %FOOFNS (LIST NIL))
 LOOP			           (OR (EQ '$EOF$ (ERRSET (EVAL (%UCIREAD))
							   NIL))
				       (GO LOOP]
			  (**TOP**))
		         (OPENF "ELISPC.INIT" '(IN OLD ERROR CONTINUOUS)))])
  (GC)
  (SAVEIMAGE "ELISPC.EXE")
)

(DE *EDIT (FORM)
 (%EDITOR-CLEAR-BUFFER)
 (WITHOUT (%EDITOR-WRITE-CHANNEL)
	  (SPRINT FORM)
	  (%EDITOR-CLIP-BUFFER NIL))
 (%EDITOR-RUN-FORK NIL)
 (WITHIN (%EDITOR-READ-CHANNEL)
	 (READ)))

[DF EDIT (L) 
  (OR L (AND LASTWORD (SETQ L (LIST LASTWORD))) (ERROR "Nothing to edit"))
  (SETQ LASTWORD (SETQ L (CAR L)))
  (COND  ((NOT (LITATOM L)) 'Function-not-editable)
	 ([AND (FUNDEF L) (MEMQ (CAR (FUNDEF L))'(EXPR FEXPR MACRO]
	 (COND [(GETL L '(BROKEN-IN NAMESCHANGED))
		(UNBREAK! L)]
	       [(GET L 'TRACE) (SETQ L (CDR (GET L 'TRACE)))])
	 [ALIAS L (*EDIT (UNMACEXPAND (FUNDEF L]
         (SETQ ALLFNS (ENTER L ALLFNS))
         L)
        ([NOT (ATOM (ERRSET (EVAL  L) NIL]
	 [SET L (*EDIT (EVAL L]
	 (SETQ ALLVALS (ENTER L ALLVALS))
	 L)
	(T 'Function-not-editable]

(DF DSKOUT (%L)
  (PROG (%CH)
	(SETQ %CH (EVAL (LIST 'OUTPUT (GENSYM) (CAR %L))))
	(SETQ %CH (OUTC %CH NIL))
	[ERRSET (EVAL (CONS 'GRINDEF (CDR %L]
	(OUTC %CH T)
	(RETURN 'File-Dumped)))

(DE TCONC
  (P X)
  (COND [(NULL P) (CONS (SETQ X (NCONS X)) X)]
	[(ATOM P) (ERROR (LIST P '"BAD ARGUMENT - TCONC"))]
	[(CDR P) (RPLACD P (CDR (RPLACD (CDR P) (NCONS X))))]
	[T (RPLACA (RPLACD P (SETQ X (NCONS X))) X)]))

(DE LCONC
  (PTR X)
  (PROG (XX)
	(COND [(NULL X) (RETURN PTR)]
	      [(OR [ATOM X] [CDR (SETQ XX (LAST X))]) (GO ERROR)]
	      [(NULL PTR) (RETURN (CONS X XX))]
	      [(ATOM PTR) (SETQ X PTR) (GO ERROR)]
	      [(NULL (CAR PTR)) (RETURN (RPLACA (RPLACD PTR XX) X))]
	      [T (RPLACD (CDR PTR) X) (RETURN (RPLACD PTR XX))])
  ERROR (ERROR (LIST X '"BAD ARGUMENT - LCONC"))))

(DE DREVERSE
  (L)
  (PROG (Y Z)
     L1 (COND [(ATOM (SETQ Y L)) (RETURN Z)])
	(SETQ L (CDR L))
	(SETQ Z (RPLACD Y Z))
	(GO L1)))

(DE REMOVE
  (ELT LIST)
  (COND [(ATOM LIST) LIST]
	[(EQUAL (CAR LIST) ELT) (REMOVE ELT (CDR LIST))]
	[(CONS (CAR LIST) (REMOVE ELT (CDR LIST)))]))

(DE DREMOVE
  (X L)
  (COND [(ATOM L) NIL]
	[(EQ X (CAR L))
	 (COND [(CDR L) (RPLACA L (CADR L)) (RPLACD L (CDDR L)) (DREMOVE X L)])]
	[T (PROG (Z)
		 (SETQ Z L)
	      LP (COND [(ATOM (CDR L)) (RETURN Z)]
		       [(EQ X (CADR L)) (RPLACD L (CDDR L))]
		       [T (SETQ L (CDR L))])
		 (GO LP))]))

(DE TAILP
  (X Y)
  (AND X 
       [PROG NIL
	  LP (COND [(ATOM Y) (RETURN NIL)] [(EQ X Y) (RETURN X)])
	     (SETQ Y (CDR Y))
	     (GO LP)]))

(DF NILL (F) NIL)

(DF ; (F) NIL)

(SETQ ; NIL)

(DF ;; (F) NIL)

(SETQ ;; NIL)

(DRM /{ /{)

(DE /{
  NIL
  (PROG (CH COM FLG INTERNSTR)
	(SETQ COM (TCONC NIL 40.))
   LOOP (COND [(OR [EQ (SETQ CH (TYI)) 32.] [AND [*LESS CH 14.] [*GREAT CH 8.]])
	       (SETQ FLG T)
	       (GO LOOP)]
	      [(NEQ CH 125.)
	       (COND [FLG (TCONC COM 32.) (SETQ FLG NIL)])
	       (TCONC COM (COND [(EQ CH 34.) 39.] [T CH]))
	       (GO LOOP)]
	      [(SETQ CH (MEMB 32. (CAR COM)))
	       (RPLACD CH (CONS 34. (CDR CH)))
	       (TCONC COM 34.)])
	(TCONC COM 41.)
	(RETURN  (READLIST (CAR COM))  )))

(ALIAS 'LT '*LESS)
(DE LE (A B) (NOT (*GREAT A B)))
(ALIAS 'EQP 'EQUAL)
(DE NE (A B) (NOT (EQUAL A B)))
(DE GE (A B) (NOT (*LESS A B)))
(ALIAS 'GT '*GREAT)

(ALIAS '+ '*PLUS)
(ALIAS '* '*TIMES)
(ALIAS '- '*DIF)
(ALIAS '// '*QUO)
(ALIAS '+I 'ADD1)
(ALIAS '-I 'SUB1)
(ALIAS 'APPLY/# '*APPLY)
(ALIAS 'PUT 'PUTPROP)
(ALIAS '=0 'ZEROP)
(ALIAS '= 'EQUAL)

(ALIAS 'ELISP: 'PROGN)

(ALIAS 'UCILISP: 'NILL)

(ALIAS 'GLOBALMACRO 'NILL)

(DE PEEKC NIL (UNTYI (TYI)))

(DM SELECTQ (X)
 (LIST
  (LIST 'LAMBDA '(SELECTQ)
	(CONS 'COND
	 (MAPLIST (FUNCTION(LAMBDA (Y)
		   (COND [(CDR Y)
			  (COND [(ATOM (CAAR Y))
				 (CONS (LIST 'EQ 'SELECTQ
					     (LIST 'QUOTE (CAAR Y)))
				       (CDAR Y))]
				[T (CONS (LIST 'MEMQ 'SELECTQ
					       (LIST 'QUOTE (CAAR Y)))
					 (CDAR Y))])]
			 [T (LIST T (CAR Y))])))
		  (CDDR X))))
  (CADR X)))

(DE DELIM (CHAR) (NOT (MEMQ [BOOLE 1 (MODCHR CHAR) 77Q] '(0 1 9 13 14))))

(ALIAS 'MAPL 'MAPLIST)

(ALIAS 'MAPCL 'MAPCAR)

(ALIAS 'PRIN 'PRIN1)

(ALIAS 'NOCOMPILE 'PROGN)

(ALIAS 'SPECIAL 'NILL)

(ALIAS 'DECLARE 'NILL)

(ALIAS 'NOCALL 'NILL)

(ALIAS 'REQUIRE 'NILL)

(SETQ %%NOUUO T)

(DE NOUUO (NEW) (PROG1 %%NOUUO (SETQ %%NOUUO NEW)))

(NILL "These are dummies in order to let DE from LISP LSP work")
(DE UNBREAK! (L) NIL)
(DE UNBREAK0 (L) NIL)
(DE PACK-IN (L) NIL)
(DE RESTORE (A B) NIL)
(SETQ BROKENFNS NIL)
(SETQ TRACEDFNS NIL)

   