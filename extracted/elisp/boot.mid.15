	;-*-midas-*-
	title ELISP BOOT

;
;
;                COPYRIGHT (c) 1981
;                CHARLES L. HEDRICK
;
;     THIS  SOFTWARE  IS  FURNISHED  UNDER AN AGREEMENT FOR MUTUAL
;     SOFTWARE EXCHANGE, AND  MAY  BE  USED  AND  COPIED  ONLY  IN
;     ACCORDANCE  WITH  THE  TERMS  OF SUCH AGREEMENT AND WITH THE
;     INCLUSION OF THE ABOVE COPYRIGHT NOTICE.   THIS SOFTWARE  OR
;     ANY OTHER COPIES THEREOF MAY NOT  BE  PROVIDED  OR OTHERWISE
;     MADE  AVAILABLE  TO  ANY  OTHER  PERSON.   NO  TITLE  TO AND
;     OWNERSHIP OF THE SOFTWARE IS HEREBY TRANSFERRED.
;
;     THE INFORMATION  IN  THIS  SOFTWARE  IS  SUBJECT  TO  CHANGE
;     WITHOUT  NOTICE  AND SHOULD NOT BE CONSTRUED AS A COMMITMENT
;     BY CHARLES HEDRICK OR RUTGERS UNIVERSITY.

	.decsav			;produce an .EXE file

.qmtch=1			;use "X" for characters instead of "X

	loc 140

smap%=jsys 767
xsir%=jsys 602
meter%=jsys 766
define xblt(ac,foo)
	extend ac,[020_27.] termin
define cmpsle(ac,foo)
	extend ac,[003_27. ? 0 ? 0] termin
define cmpse(ac,foo)
	extend ac,[002_27. ? 0 ? 0] termin

old==1  ;until it is safe to take away *boole

;This version of Lisp is supposed to be very modular.  Nobody is
;supposed to use any knowlege about the representations of anything
;without declaring it at the beginning of the page.  Nobody is
;supposed to refer to variables in other pages without declaring it.
;The following information is classified.  Those with a need to
;know will list "memory structure" at the top of their page.

;memory structure.  this is more complex than it should be because
;of the way the KL's pager works.  The original structure caused
;thrashing.  There are two constraints:
;  the page table is organized in 4-page groups.  All 4 pages
;	must be from the same section.  so if you have code in
;	page 1000 trying to refer to data in page 3000, there will
;	be thrashing, since these are page 0 from two different
;	sections.  Special tricks are used in the hardware to
;	protect from interference between user programs and the
;	monitor, and between odd and even section numbers.  to
;	make the protection against the monitor work, one should
;	avoid pages 300-377 and 700-777 in any even section.
;  in extended code, the PDL is not protected against overflow.
;	This means that there should be non-existent pages or
;	(better) sections around the stack, so that overflow is
;	caught.

;here are the sections.  However the stacks do not begin at the start
;of the section, but are staggered, to prevent interference.  The
;stack that grows the slowest is started first, so as to avoid the
;possibility of having two stacks cross each other and thus 
;interfere.  The offsets are shown below, where QSEC, etc., are
;defined.
;	1 - code
;       2 - EMACS
;       3 - LINK
;	4 - Q pdl (data)
;       5 - I/O buffers
;	6 - P pdl (control)
;	10 - evalstack
;	12 up - data space, 2 spaces of equal size used alternately

;Everything in Q is a legal Lisp "object".  The structure of objects
;will be described in a minute.  Basically, they are things with
;type codes, so that the GC can tell how to handle them.  There are
;no "protected AC's".  When you call CONS, or anything else that
;can cause a GC, all Lisp objects are supposed to be on Q, so that
;GC can find them.  GC starts by pushing OBLIST onto Q.

;Lisp objects take up a full word.  We intend to be able to use the
;full 30-bit address space of the DEC-20.  Thus an object consists
;of:
;  1 bit - zero, to indicate that this object (if it is an address)
;	is to be treated as global by the hardware (i.e. that it
;	is a 30-bit address, not an 18-bit one)
;  5 bits - a type code, types defined below
;  30 bits - the object itself.  Nobody is supposed to depend upon
;	the structure of a type of object without declaring it.
;	Every attempt is made to confine such knowlege to a few
;	pages.  The GC will, however, know at least whether something
;	is a pointer into list space or not.

;CHKQUO should be put after any JSYS that can cause quota exceeded.
; Note that it does not handle first-part-done properly, and should
; not be used (at least without fixing) after ILDB's, etc.  (If you
; need to fix it, the code is at MAPERR - however you might just
; as well use MAPERR itself in that case.  MAPERR differs by handling
; a few more cases, such as missing pages from read-only files.)
define chkquo
	ercal quochk	termin

addbts==7777777777	;address bits

define object(type,val)
  <.byte 1,5,30. ? 0 ? type ? val> termin

define gettyp (x)
	ldb w2,[.bp 37_30.,x] termin

;getdsp is a special version of gettyp designed for type dispatch tables
;To avoid doubling their size, we only get bits 17.  This means that if
;there is some garbage, it may be treated wrong.
define getdsp (x)
	ldb w2,[.bp 17_30.,x] termin

;;TY%ATM
define satom (x)
	tlne x,360000	;skip if atom or constant atom
	termin

define snatom (x)
	tlnn x,360000	;skip if not atom or constant atom
	termin

define scons (x)
	tlnn x,340000	;non-skip if higher than CONS
	tlnn x,020000	;skip if exactly CONS
	termin

define smcons (x)	;skip if a movable (i.e. not constant) CONS
	tlnn x,350000	;non-skip if higher than CONS, or constant
	tlnn x,020000	;skip if exactly CONS
	termin

define sncons(x)
	xtype x
	cain w2,ty%xcn	;skip if not cons or constant cons
	termin

define chcons(x)
	tlnn x,340000	;non-skip if higher than CONS
	tlnn x,020000	;skip if exactly CONS
	jrst notcns
	termin

define xtype (x)
	ldb w2,[.bp 36_30.,x] termin

;xtype is like gettyp but ignores the low order bit.


;here are the currently defined types.  Representations are described
;here.  This information is, however, classified.
;note that the atom has to be 0 so that NIL is taken as an atom
;any table that lists all type should by commented ;;TYPES

;Note that the types with constant equivalents should be defined so 
;that they form even/odd pairs.  This lets us ignore the low order
;bit to see if we have an atom when we don't care whether it is
;constant or not.

;;TYPES - note that code in several places depends upon the fact
;   that ty%atm and ty%xat are 0.  You should be able to change
;   the rest of the definitions.
;Note that GETTYP and XTYPES have entries for 0 to 17.  Change those
;macros if you use the extra bit
;Warning:  compiled code uses the fact that atoms and constant
; atoms are 0 and 1, and that ac 1 always has 0 in it.  Thus we can
; do things like @[object ty%cat,foo].  Also, in compiled code
; when you want an indirect reference to an absolute address, you
; use @[object ty%iadr,addr], where TY%IADR is defined as the same
; as TY%CAT.  Only the GC will ever look at these references, and
; as far as the GC is concerned, TY%CAT and TY%ADR are the same, i.e.
; constants.
;Also, there are pointers of type TY%ATM into word AT%CAL of an atom.
; The GC has to handle all supposed atom pointers to make sure whether
; they point to the beginning of an atom, or word AT%CAL.
ty%atm==0	;atom
ty%cat==1	;constant atom
  ty%xat==0	;some kind of atom
ty%iadr=1	;internal address, for use by LAP. You better not print this!
ty%con==2	;cons cell (two words)
ty%ccn==3	;constant cons cell
  ty%xcn==1	;some kind of cons
ty%str==4	;string (see below)
ty%cst==5	;constant cstring
  ty%xst==2	;some kind of string
ty%chn==6	;I/O channel
ty%cch==7	;constant I/O channel
  ty%xch==3	;some kind of channel
;the numerical types must be adjacent
ty%nst==10	;start of numbers
ty%int==10	;integer (30 bit integer)
ty%rea==11	;real (30 bit real number, last six bits are zero)
ty%big==12
ty%nen==12	;end of numbers
ty%vec==13	;vector (starts with size as INUM)
ty%adr==14	;address (30 bit unsigned integer)
ty%spc==15	;beginning of a non-GC'ed block
ty%ary==16	;array (starts with size as TY%SPC)
ty%car==17	;constant array
  ty%xar==7	;some kind of array
;note:  there is a JSP W3, in atom blocks.  The code in CPYATM depends
; upon the fact that all legal lisp type codes are less than JSP, which
; is 26.

;here is the structure of an atom:
;	value cell
;	ptr to property list (=cdr)
;	pname, a string pointer
;	function defn - lambda if expr or addr if subr
;	function evaluator for interpreter
;	jsp w3,@.+1 - calls are done to here
;	addr of ftn code or routine in interpreter
;note that jsp w3,@.+1 and the next instruction must be in the
;same section, since .+1 will wrap around into the AC's
;otherwise.
at%val==0
at%pro==1
at%pna==2
at%fun==3
at%fev==4
at%cal==5
at%dsp==6
at%siz==7	;size of block
;note that some of the property list code depends upon at%pro being 1
;the variables declared by DECLFU depend upon the fact that AT%VAL is
;0, but this can be changed by changing DECLFU.

;here is the structure of a string.  This is what is pointed to
; by a string pointer
;object(ty%spc,number of words following)
;asciz string

;AC usage is (unfortunately) known by everybody

p=17		;control stack
q=16		;data stack.
sp=15
n=14		;will be used for number of args passed
free=13		;start of free space

nil=0		;must always contain 0
nil1=1		;must always contain 0 except during jsys's

;The working AC's are separated into those that contain GC'able
;objects and those that don't.  This lets us know which to
;GC when we have to do that.  It also allows interrupt handling,
;since we know what is in each AC.

;AC's w2 to w4 must not contain legal Lisp objects, i.e. things
;that need not be GC'ed.  If they must be saved, they should be
;pushed onto P.  These must be first in order to allow jsys's
;to be called, since clearly the AC's used by jsys's can't in
;general be assumed to contain lisp objects.

;Wn may be assumed to be ACn.  These must include at least AC2,3,
;and 4, since these AC's are used for JSYS's.  

;There is no W1 because W1 is part of NIL.  To emphasize that fact,
;we call this NIL1.  This should remind you to zero it if you
;put anything in it.

w2=2
w3=3
w4=4

;AC's o1 to o6 must contain legal Lisp objects, i.e. things that
;GC can collect.  If they must be saved, they should be pushed
;onto Q

o1=5
o2=6
o3=7
o4=10
o5=11
o6=12		;used as a temp in macros - avoid using it yourself

;to call a routine, load the args into O1 to O6.  They must be legal
;Lisp objects, or the GC will get you.  Don't try to economize by
;passing a bare number - set the type code, please. there are macros to
;go from numbers to objects and visa versa, just so you don't have to
;know the numerical representation.  We will, however, tell you
;that the representation for integers is efficient enough that these
;macros are not expensive.  values are returned in O1.

;In general you should assume that calling a routine garbages all
;the working AC's, i.e. Ox and Wx.  The exceptions are the macros
;for CAR, CDR, RPLACA, RPLACD, and CONS, which touch only those
;AC's that they are defined as touching.

call=pushj p,
ret=popj p,

define makerr (*str)
[object ty%adr,[asciz |str|]] termin

define err(*str)
	move o1,makerr /str/
	jrst error
	termin

define perr(*str)
	move o6,makerr /str/
	jrst perror
	termin


;save/restart - produce pseudo-.EXE file and bootstrap the system from one

;this code is needed because the save and get jsae do not work for extended
;sections.  Thus we write an .EXE file with two parts - a normal .EXE
;file containing only the following bootstrap, and then extra pages
;containing the real program.  the version of Lisp that the user runs is
;actually one of these files, since it is produced by loading a default
;environment and then saving the result.  The bootstrap code should
;be the first code in the core image, as only page 0 from the core image
;is mapped out in the "normal" part of the .EXE file.

;Here is the format of the pseudo-.EXE file:

;page 0 is a normal .EXE directory

;1776,,3
;300000,,1    [file page]
;0	      [process page]
;1775,,3
;3            [# words in entry vector]
;bootst
;1777,,1

;page 1 is a directory for the real program, in the format of an .EXE
;file.  (This allows us to use the same routines to read both)

;1776,,11
;300000,,file page		;for codesec,,0  to codesec,,bpsend-1
;nnn000,,process page		;nnn is repeat count
;  ditto for datsec,,0 to hipags-1
;  ditto for stthis to free
;  ditto for SP
;1777,,1


;page 2 is a copy of page 0 of the core image - the bootstrap loader
;This is all that the GET jsys will see


;pages 3 to N are the data for the real program


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   SECTION creation code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;common routine for creating all the sections.  See the following
;page for documentation of the program structure.

sects:	movei w2,qsec
	call maksec
	 jrst secfai
	movei w2,bufsec
	call maksec
	 jrst secfai
	movei w2,psec
	call maksec
	 jrst secfai
	movei w2,spsec
	call maksec
	 jrst secfai
	movei w4,datsiz		;loop on data sections
	movei o1,datsec		;first such section
datlop:	move w2,o1
	call maksec
	 jrst secfai		;ran out of sections
	addi o1,1
	sojg w4,datlop
	movei w4,datsiz		;now same for second set of sections
	movei o1,datsc2
datlp2:	move w2,o1
	call maksec
	 jrst secfai
	addi o1,1
	sojg w4,datlp2
	movei w2,codsec		;now the code
	call maksec
	 jrst secfai
	ret

;maksec - create a section.
;  w2 - section number to make.  
; skip return if it works
maksec:
  ;create the section
	setz nil1,
	hrli w2,.fhslf
	move w3,[pm%cnt\pm%rwx\1]
	smap%
	 erjmp cpopj
	aos (p)
cpopj:	ret

secfai:	hrroi nil1,[asciz / Can't create section
/]
	esout
	haltf
	jrst .-1

tmpsts==10
	.vector tmpstk(tmpsts)

exeerr:	hrroi nil1,[asciz / Bad .EXE file
/]
	esout
	haltf
	jrst .-1

badfil:	hrroi nil1,[asciz / Problems reading .EXE file - you must run this program from disk, 
  and must not change the core image before starting it.
/]
	esout
	haltf
	jrst .-1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   BOOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This code is all that is loaded into memory when you first run a saved
;core image.  Its responsibility is to load the rest of the file.
;One of the trickier things is to find out what file it is.  We do
;this by doing RMAP, which gives you the JFN that is mapped into page
;0.  That should be the file.  Note that the JSYS manual specifically
;prohibits this code.  However it should work if we are running from
;disk.

;O2 is global to this section, and contains the JFN of the file.

bootst:	reset
	move nil1,[.fhslf,,0]		;see who we are mapped to
	rmap				;nil1 - jfn,,file page
	hlrz o2,nil1			;save in o2
	caige o2,100			;see if valid jfn
	caig o2,0
	jrst badfil
	move p,[-tmpsts,,tmpstk-1]
;create sections
	call sects
;now read the rest of the code from our pseudo-EXE file.  We do
;this in sections.  Each section corresponds to a 2-word entry
;in the directory, and describes a set of contiguous pages.
;We first read the 2-word entry and then pmap in the pages
;that it describes.
  ;get to the directory and validate it.
	hrrz nil1,o2			;get to directory page
	movei w2,1000			;start of page
	sfptr
	 erjmp badfil
	bin				;should be 1776,,n
	hrrz w4,w2			;isolate count
	hlrz w2,w2			;make sure it is kosher
	caie w2,1776
	jrst exeerr			;illegal structure
	subi w4,1			;w4 - number of entries
	lsh w4,-1
  ;pmap in the data, one piece at a time
    ;get data for one chunk from directory
bootlp:	hrrz nil1,o2			;jfn
	bin
	push p,w2			;(p) - 300000,,file page
	bin				;w2 - rpt000,,process page
    ;pmap it in
	pop p,nil1			;jfn,,file page
	hrl nil1,o2
	ldb w3,[.bp 777000000000,w2]	;bits,,count
	addi w3,1			;.EXE file has odd defn of count
	hrli w3,(pm%cnt\pm%rd\pm%ex\pm%cpy)
	hrli w2,.fhslf			;.fhslf,,process page
	pmap
	sojg w4,bootlp			;again if there are more
  ;end loop when get to end of directory
;finally, ddt.  We map the pages that contain ddt from section 0 to
;section 1, so if the user does the DDT command it shows up in
;section 1, which is after all where it is most useful.
	move nil1,[.fhslf,,ddtpag] ;and the upper 1/4 to codsec (for DDT)
	move w2,[.fhslf,,codsec*1000+ddtpag]
	move w3,[pm%cnt\pm%rd\pm%cpy\ddtsiz]
	pmap
;reset so restart gets us to new context
	movei nil1,.fhslf
	move w2,[3,,evec]
	sevec
;and go to permanent Lisp context
	move q,[baseq-1]
	move p,[basep-1]
	xjrstf [0
		codsec,,.+1]
	move w2,[jfcl]
	movem w2,evhook
	move free,freesv'
;At the moment, section zero contains just one page, the bootstrap.
;We would like the whole thing, since it contains DDT symbols (which
;DDT stubbornly refuses to take from section 1.  Also the entry
;vectors, DDTST, and other randomness.  In order to save swap space,
;we want to map this all from the file.  This works because we
;guarantee that sections zero and one are the same.  Note that we
;don't bother to map BPS into section 0
	move nil1,[.fhslf,,1000]		;get ident for section 1
	rmap
	move w2,[.fhslf,,0]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	hrrz w4,bpsend				;first address beyond end
	subi w4,1				;last used
	lsh w4,-9.				;last page
	addi w4,1				;number of pages
	hrr w3,w4
  ;The obvious thing is to just do the pmap we just set up.  Alas,
  ;the destination page is 0.  when you do this in section 1, page 0
  ;is interpreted as page 0 in the current section.  we have to go
  ;back to section 0 in order to get this page number interpreted right.
        xjrstf [0
	        0,,.+1]
	pmap
	xjrstf [0
	        codsec,,.+1]
  ;and finish init
	setzb nil,nil1
	setzb o1,o2
	setzb o3,o4
	call limstk		;set up stack limits
	call ioinit		;set up I/O system
	setzm edfork		;no editor there now
	setzm lnkfrk		;nor LINK
	setzm @[datsec,,.CFILE]	;no open files
	move sp,bootsp		;unbind from here
	move w2,[basesp-1]	;down to here
	call unbin1
	jrst toplev		;start top

;make sure everything needed above is on this page

	.scalar bpsbeg,bpsend,bootsp

	consta

	variab


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  SAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Here is the save code
;the following AC's are global to this whole section.  The rest are temps.
;  O1 - channel object for file
;  W4 - last disk page written

;(save "filename") - save the core image
;o1 - string or atom for file name
xsave:	
;open and set up file
	call xoutpu		;o1 - channel object for file
  ;the only AC that will be needed for booting is FREE.  Note that this
  ;is being saved in section 1, not section 0.
	movem free,freesv	;save free for BOOT
	movem sp,bootsp		;and SP for unbinding after BOOT
	hrrz nil1,ch%jfn(o1)	;xoutpu openned for 7 bits, change to 36
	movei w2,36.
	sfbsz
	 erjmp [setz nil1,
		err /Can't set byte size to 36/]
;write out bootstrap directory and data
	movei w4,1		;pages 0 and 1 are used (for directory)
	call dirhd6		;type 6 header (page directory)
	movei w2,0		;process 0
	movei w3,1		;count 1
	call diren6		;type 6 entry
	call dirtr6		;type 6 trailer
	movei w2,3		;vector length 3
	movei w3,bootst		;vector location
	call dir5		;type 5 (entry vector)
	call dir7		;type 7 (end block)
;write out actual data directory and data
  ;get to directory page
	hrrz nil1,ch%jfn(o1)	;now go to second (kludgo) directory
	movei w2,1000		;page 1
	sfptr
	 erjmp [setz nil1,
		err /Can't set file pointer to page 2/]
  ;header
	call dirhd6		;type 6 header
  ;the code
	movei w2,codsec*1000	;process page
	hrrz w3,bpsend		;number of pages - this is first address above
	subi w3,1		;last addr used
	lsh w3,-9.		;last page used
	addi w3,1		;number of pages
	call diren6		;type 6 entry for code
  ;constant data area.  This is the start of the first free space,
  ;and contains the initial OBLIST and its friends.
	movei w2,datsec*1000	;process page
	move w3,hipags		;number of pages
	call diren6		;type 6 entry for constant data
  ;the currently active free space.  Only the part with data in
  ;it is saved.
	move w2,stthis		;now copy currently active free space - start
	lsh w2,-9.		;convert to page - first page
	move w3,free		;last addr
	lsh w3,-9.		;convert to page - last page
	sub w3,w2
	addi w3,1		;page count
	call diren6		;type 6 entry for free space
  ;currently active SP
	move w2,[basesp/1000]	;first page of SP
	move w3,sp		;last addr
	lsh w3,-9.		;convert to page - last page
	sub w3,w2
	addi w3,1		;page count
	call diren6		;type 6 entry for SP
	call dirtr6		;type 6 trailer
  ;close things off
	call dir7		;end
	move w2,[444440,,0]
	movem w2,ch%bpt(o1)	;say 36 bit bytes
	addi w4,1		;go to base 1 count
	imuli w4,512.		;convert pages to bytes
	movem w4,ch%lby(o1)	;and say we have this many pages
	call xclose		;close file
	move o1,nil
	ret

;routines for writing .EXE files - w4 is an implict arg to all these
;routines.  It is the last file page that has been written.

;type 6 - the actual data.  The structure of this is
;  1776,,length
;  pairs of data
;To do this, first call DIRHD6 once to leave space for the header
;DIREN6 once for each entry, to make the pairs  (actually if the count
;	is .GT. 1000, one call may make more than one pair)
;DIRTR6 once at the end to go back and fill in the count in the header
	
;dirhd6 - header for directory entry
dirhd6:	hrlzi w2,1776		;make 1776,,length - length filled in later
	hrrz nil1,ch%jfn(o1)	;to output
	bout
	rfptr			;find out where we are
	 jrst poserr
	subi w2,1
	movem w2,dirst6'	;save as start of directory
	ret

poserr:	err /Can't use random access on file/

;diren6 - entry for directory entry - process page in w2, count in w3
;This routine allows counts .GT. 1000, calling DIR6DO several times in
;that case.
diren6:	caig w3,1000		;1000 is the maximum count we can have
	jrst dir6do		;.LE. 1000, OK
	push p,w2		;save for next time
	push p,w3
	movei w3,1000		;do the first 1000 pages
	call dir6do
	pop p,w3
	pop p,w2
	subi w3,1000		;now have 1000 pages fewer to do
	addi w2,1000		;starting 1000 pages later
	jrst diren6		;so try again

;dir6do - this routine does an actual type 6 entry - proc pag in w2, count w3
dir6do:	push p,w2		;-1(p) - process page
	push p,w3		;(p) - count of pages
;first put dir entry to dir area
	hrrz nil1,ch%jfn(o1)
	move w2,w4		;300000,,file page
	addi w2,1		;use first page after last used
	hrli w2,300000
	bout			;put to file
	move w2,(p)		;rpt000,,process page
	subi w2,1		;DEC's rpt count is count-1
	lsh w2,27.		;in bits xxx000,,000000
	hrr w2,-1(p)		;saved process page
	bout			;put to file
;now actual data pages - uses page BUFPAG as a buffer
dir6lp:	sosge (p)		;any more left?
	jrst dir6ex		;no - done
	addi w4,1		;next disk page
	hrl nil1,ch%jfn(o1)	;file jfn,,file page
	hrr nil1,w4
	move w2,[.fhslf,,bufpag]	;to buffer page
	move w3,[pm%rd\pm%wr]	;we want to write it (obviously)
	pmap			;now we have mapping to file
	movei nil1,1000		;next we copy a page to the buffer - 1000 wds
	move w2,-1(p)		;this page
	lsh w2,9.		;but we want address
	move w3,[bufpag*1000]	;to buffer
	xblt nil1,
	aos -1(p)		;advance process page
	jrst dir6lp		;and try again
dir6ex:	adjsp p,-2		;get rid of saved args
	seto nil1,		;and unmap buffer page
	move w2,[.fhslf,,bufpag]
	setz w3,
	pmap
	ret			;and return

;dirtr6 - trailer for directory entry.  Must fill in length part of header
dirtr6:	hrrz nil1,ch%jfn(o1)	;jfn of file
	rfptr			;current pos in w2
	 jrst poserr
	move w3,dirst6		;start of block
	movem w2,dirst6		;save current pos
	sub w2,w3		;subtract start, for length
	hrli w2,1776		;1776,,length
	rout			;put out the header at start pos
	move w2,dirst6		;get back end position
	sfptr			;and go back there
	 jrst poserr
	ret

;dir5 - entry vector - length in w2, address in w3
dir5:	push p,w2
	hrrz nil1,ch%jfn(o1)	;jfn of file
	move w2,[1775,,3]	;entry header
	bout
	pop p,w2		;length
	bout
	move w2,w3
	bout
	ret
	
;dir7 - end - no args
dir7:	hrrz nil1,ch%jfn(o1)	;jfn of file
	move w2,[1777,,1]
	bout
	ret


;startup - sets up memory structure.

;this routine knows about memory structure.
;anyone who wants initialization done should write a routine and
;	put a call to it here.

;memory structure is documented at the beginning of the program.
;anyone changing these declarations should change those comments.

;locals:

;section definitions.
codsec==1		;code
edsec==2		;EMACS subfork
lnksec==3		;LINK subfork
qsec==4			;section for Q stack
 baseq=qsec,,40000	;start of Q pdl, used in GC
 endq=qsec,,740000	;leave a bit of space for debugger in case of PDL over
 endqs=qsec+1,,0	;real end of section
bufsec==5		;I/O buffers
 bufill=bufsec,,0	;illegal page to stop Q stack
 bufst=bufsec,,400000	;first buffer
 bufend=bufsec+1,,0	;end of buffers
psec==6			;section for P stack
 basep=psec,,20		;ERCAL gets confused if this is between ,,0 and ,,17
			;also, until that bug is fixed, the stack can't cross
			;a section boundary.
 endp=psec,,740000
 endps=psec+1,,0
spsec==10		;section for SP stack
 basesp=spsec,,20000
 endsp=spsec,,740000
 endsps=spsec+1,,0
bufpag==10000		;page for use in SAVE command.  Any free page will do

datsiz==11		;maximum number of sections in each data space
	;this number should be odd, in order that both data spaces start
	;in sections of the same parity.  This is important for performance
	;reasons.
datsec==12		;first section in first data space
datsc2==datsec+datsiz+1	;first section in second data space

ddtpag==760		;start of ddt
ddtsiz==20		;number of pages in ddt

evec:	xjrstf [0
		codsec,,rstart]
	xjrstf [0
		codsec,,rstart]
	1,,0

ddtst:	xjrstf [0
		codsec,,770000]

calddt:	skipe @770001
	jrst caldd1
;no DDT yet - get it
	move nil1,[gj%old+gj%sht]  ;look up the file
	hrroi w2,[asciz /sys:uddt.exe/]
	gtjfn
	 jrst [err /Can't find SYS:UDDT.EXE/]
	push p,nil1		;save jfn
	movei nil1,.fhslf
	gevec			;get entry vector, since GET will change it
	move nil1,(p)		;now get back JFN
	movem w2,(p)		;and save entry vector
	hrli nil1,.fhslf
	get
	 erjmp [err /Can't get SYS:UDDT.EXE/]
	movei nil1,.fhslf	;put back entry vector
	pop p,w2
	sevec
	setz nil1,
	move w2,@[116]		;get symbol pointer
	hrrz w3,770001		;get addr of symbol table in DDT, sec. 0
	movem w2,(w3)		;now put symbol pointer in symbol table
caldd1:	call 770000
	jrst retnil

start:	reset
	move p,[-tmpsts,,tmpstk-1]
;Most of the following code is used to get us into our final
;sections.  there is no way to get Midas or Link to load
;code directly into a non-zero section, but we must be there
;or global addressing won't work.  To get into a non-zero
;section, you must
;  1) use SMAP% to create the section
;  2) PMAP code there from an existing place
;  3) use XJRSTF to get there.  XJRSTF is the only instruction
;	that you can use to get from section zero to a non-zero
;	section.
  ;write out ELISP.REL, with symbols in it
	call wrirel
  ;create sections
	call sects		;routine also used by BOOT code
;now we move things into these sections we just created.  Things go
;faster when a page is not mapped, so we first map them copy on
;write, and then do a MOVES on each page to make them private.
;this may be superstition.  You should see whether it seems to help.
;There is some evidence that the tests we used to evaluate this
;strategy were wrong.  If so, turn on PM%WR instead of PM%CPY, and
;omit the code that does MOVES on each page.

;low section - code. This is from 0 to then end of the symbol table.
	hrrz w4,116		;.jbsym - symbol table
	hlre o1,116		;negative length
	movn o1,o1		;positive length
	add w4,o1		;w4 is now first loc after sym tab
	subi w4,1		;need last used
  ;construct entry for list of symbol tables
	push w4,[0]		;end of list
	hrli w4,codsec		;put in section number
	movem w4,symlst		;first entry in list of symbol tables
	push w4,116		;AOBJN word for this table
	hrli w4,codsec		;put in section number
	addi w4,1		;first beyond
	movem w4,bpsbeg		;save as start and end of BPS
	movem w4,bpsend		;
	tlz w4,777777		;get back to local addressing
	subi w4,1		;w4 is now last loc used
	lsh w4,-9.		;w4 is now last page used
	addi w4,1		;w4 is now number of pages used
	movem w4,lopags'	;save for later
	move nil1,[.fhslf,,0]	;pmap lower half of our sec 0 to codsec
	move w2,[.fhslf,,codsec*1000]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	ior w3,w4		;or in count
	pmap
;now high section (oblist) to data.  This is from 0 to ENDOBL.
;Actually it is loaded at 400000 to 400000+ENDOBL, since we can't
;have two things at the same place.
	movei w4,endobl		;now number of pages in oblist
	subi w4,1		;just like above
	lsh w4,-9.
	addi w4,1
	movem w4,hipags'	;save for later
	move nil1,[.fhslf,,400]	;the oblist to datsec
	move w2,[.fhslf,,datsec*1000]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	ior w3,w4
	pmap
;finally, ddt
	move nil1,[.fhslf,,ddtpag] ;and the upper 1/4 to codsec (for DDT)
	move w2,[.fhslf,,codsec*1000+ddtpag]
	move w3,[pm%cnt\pm%rd\pm%cpy\ddtsiz]
	pmap
  ;reset so restart gets us to new context
	movei nil1,.fhslf
	move w2,[3,,evec]
	sevec
  ;also so DDT gets the right DDT
	movei w2,ddtst
	skipe 770000			;if we have ddt
	movem w2,74			;make jbddt point to extended ddt
	xjrstf [0
		codsec,,.+1]
  ;and go to permanent Lisp context
	move q,[baseq-1]
	move p,[basep-1]
	move sp,[basesp-1]
	move w2,[jfcl]
	movem w2,evhook
  ;now make all the pages private
    ;code
	move w2,[codsec,,20]		;first in code pages
	move w3,lopags			;number of pages
	moves (w2)			;make private
	addi w2,1000			;next page
	sojg w3,.-2			;loop for all pages
   ;data
	move w2,[datsec,,20]		;same for data
	move w3,hipags
	moves (w2)
	addi w2,1000
	sojg w3,.-2
  ;if ddt is here, start it
	skipn 770000
	jrst noddt
	movei w2,ddtst
	movem w2,74
	hrroi nil1,[asciz /
Type DDTRET$G to return
/]
	psout
	xjrstf [0
		codsec,,770000]
ddtret:	xjrstf [0
		codsec,,noddt]
  ;now do initialization for various pieces of code that need it
noddt:	setzb nil,nil1
	setzb o1,o2
	setzb o3,o4
	call limstk		;set up stack limits
	call ioinit		;set up I/O system
	push q,[datsec,,0]
	push q,[datsec,,endobl]
	push q,[datsec+datsiz,,0]
	push q,[datsc2,,0]
	push q,[datsc2+datsiz,,0]
	call gcinit
	jrst topst		;start top

;WRIREL - write out ELISP.REL, with all of our symbols in it, for use
;  by the LINK interface.
wrirel:	movsi nil1,(gj%fou+gj%sht) ;new version
	hrroi w2,[asciz /ELISP.REL/]
	gtjfn
	 erjmp wrirer
	movem nil1,n			;save JFN in N
	move w2,[<44_30.>\of%wr]	;open binary
	openf
	 erjmp wrirer
 ;NAME block
	move w2,[6,,1]
	bout
	movei w2,0
	bout
	move w2,[.rsqz 0,ELISP]
	bout
 ;SYMBOL block
	hlre w2,116		;get count, negative
	movn w2,w2		;make positive
	subi w2,2		;leave out the program name
	hrli w2,2		;block type 2
	bout
	move w3,116		;W3 - AOBJN word for symbols
	add w3,[2,,0]		;leave out the program name
	setz w4,		;W4 - counter for every 22 words
  ;main loop - here to output another symbol if there is one left
wrirl:	sojg w4,wrirn		;if W4 non-zero, normal case
  ;W4 exhausted, time for a relocation word
	movei w2,0		;none relocatable
	bout
	movei w4,11		;reinit W4 for 11 symbols (22 words)
  ;normal symbol output
wrirn:	move w2,(w3)		;get symbol
	hlrz o1,w2		;O1 - LH of symbol
	hlrz o2,1(w3)		;O2 - LH of value
	trz o1,740000		;clear flags in symbol
	caie o1,014772		;symbol = G00xxx
	cain o2,(object ty%ccn,<datsec,,0>) ;dummy symbol inside atom
	jrst wrirn1		;leave local
	tlne w2,040000		;already global or PNAME?
	jrst wrirn1		;yes - leave it alone
	tlne w2,100000		;local?
	tlc w2,140000		;yes - make global
wrirn1:	bout			;output it
	aobjp w3,wrire		;go to next
	move w2,(w3)		;get value
	bout			;put it out
	aobjn w3,wrirl
  ;done with symbols
wrire:		
 ;END block
	move w2,[5,,2]
	bout
	movei w2,0
	bout
	bout
	bout
 ;now finished
	closf
	 erjmp .+1
	setz nil1,
	setzb o1,o2
	ret

wrirer:	hrroi nil1,[asciz /Can't open ELISP.REL/]
	esout
	setz nil1,
	setzb o1,o2
	ret

;forward decls - these belong on the page with CAR and CDR
define docar(x,y)
	move x,(y)
	termin

define pushcar(x,y)
	push x,(y)
	termin
	
define docdr(x,y)
	move x,1(y)
	termin

define pushcdr(x,y)
	push x,1(y)
	termin

define doboth(x,y)
	dmove x,(y)
	termin

;;TY%CON
define dorpd(x,y)
	movem y,1(x)
	termin

;;TY%CON
define docons(x,y,z)
	caml free,lastl		;make sure there is space
	 call sgc		;special version of GC that saves AC's
	push free,y		;and set car and cdr
	move x,free		;return next free
	tlo x,(object(ty%con,0)) ;as cons cell
	push free,z
	termin

;;TY%ATM
define bind(x,y)		;bind x to y using z as temp
	jumpe x,illreb		;check for NIL and T
	came x,[%T]
	satom x			;and make sure it is an atom
	jrst illreb
	push sp,x		;save old value
	push sp,at%val(x)
	setval x,y
	termin

;FASBIND is used in fast EVAL, where ALIAS has validated the formals
;when the function was defined.
;;TY%ATM
define fasbind(x,y)
	push sp,x
	push sp,at%val(x)
	setval x,y
	termin

;;TY%ATM
define setval(atom,value)
	movem value,at%val(atom)
	termin

define getnum(ac)
	lsh ac,6
	ash ac,-6
	termin

define maknum(ac)
	tlz ac,770000
	tlo ac,(object(ty%int,0))
	termin

define makinm(ac)
	ash ac,6
	lsh ac,-6
	tlo ac,(object(ty%int,0))
	termin

define makstr &str&
	object ty%cst,<codsec,,[object ty%spc,.length str
				asciz str]>
	termin

;I/O - TYI and TYO
;knows about representation of TY%CHN, and characters.  This should be the
;only page (except for the GC, to some extent) that knows about
;channels.  The string stuff will probably have to know about char's.
;Anyone else wanting to convert from char objects to char's should use
;the macros GETCHR and MAKCHR.

;locals to this page: 

;variables for terminal I/O:
trmbfs==100.	;size of buffer
	.vector trmbuf(trmbfs)	;terminal input buffer
	.scalar trmcnt		;number of char's available
	.scalar trmpnt		;ILDB pointer to next char
	.scalar trmlka,trmlst	;lookahead for untyi

;macros for people to convert between char objects and characters

;GETCHR(AC) - convert char object in AC to ASCII character
define getchr(ac)
	tlz ac,770000		;clear type code
  termin

;MAKCHR(AC) - convert ASCII char in AC to char object
define makchr(ac)
	tlo ac,(object(ty%int,0)) ;and make char
  termin

;CHAR(ch) - a character object with this code
define char(ch)
	object(ty%int,ch) termin

;Channels have the following form:
;	jfn
;	line length
;	char's left on the line
ch%spc==0	;code for gc - may be ch%666 or ch%666-1 depending upon
		;whether the data in ch%dat is GC'able or not
ch%jfn==1	;these are bare numbers
ch%len==2
ch%pos==3
ch%get==4	;routine for tyi
ch%put==5	;routine for physical put
ch%lka==6	;lookahead character in case we backed up
ch%lst==7	;last char read for untyi
ch%dsp==10	;dispatch for less-used routines
 ch%cps==0		;curpos
 ch%sps==1		;setpos
 ch%clo==2		;close
ch%buf==11	;address of window
ch%pag==12	;file page mapped to window
ch%bpt==13	;byte pointer
 ;two-word byte pointer
ch%bct==15	;byte count
ch%bfs==16	;bytes per window
ch%cby==17	;current byte in file
ch%lby==20	;last byte in file
ch%lts==21	;line number test word
ch%pgs==22	;bytes per page
ch%dat==23	;mode-dependent data
ch%666==23	;last entry

winpgs==4	;size of window in pages

;;TY%ATM
;;TY%CHR
;CHRVAL - octal for char atom
;O1 - char atom or string
chrval:	call getstr
	move w3,o1
	tlz w3,770000		;clear type code
	hrlzi w2,010740		;w2,w3 are extended BP
	ildb w2,w2
	maknum w2
	move o1,w2
	ret

;MODCHR - change read table
;O1 - char to modify; O2 - new value if non-nil
modchr:	gettyp o1
	caie w2,ty%int		;better be an integer
	jrst illasc
	move w3,o1
	getnum w3
	cail w3,0
	caile w3,177
	jrst illasc
	move w2,rdtab(w3)	;get old read table entry
	jumpe o2,retint		;done unless new value
	push p,w3		;save char index
	move o1,o2
	call getint		;get integer value to w2
	pop p,w3
	exch w2,rdtab(w3)	;save numerical value, get old
	jrst retint		;return old

;SETCHR - change read table, only read macro part (first 2 bits)
;O1 - char to modify; O2 - new value if non-nil
setchr:	push q,o2
	call chrval		;get integer to o1
	pop q,o2
	ldb w2,[.bp 600000000000,rdtab(o1)] ;get old read table entry
	jumpe o2,retint		;done unless new value
	push p,w2		;save old value
	exch o1,o2		;save char index
	call getint		;get integer value to w2
	dpb w2,[.bp 600000000000,rdtab(o2)] ;set new value
	pop p,w2
	jrst retint		;return old

;;TY%CHR
;ASCII - char atom for octal code
mascii:	gettyp o1
	caie w2,ty%int		;better be an integer
	jrst illasc
	move w2,o1
	getnum w2
	cail w2,0
	caile w2,177
	jrst illasc
	move o1,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	ret

illasc:	perr /Arg to ASCII must be integer from 0 to 127./

;;TY%CHN
lineln:	move o2,@[datsec,,.curout] ;output channel
	jumpe o1,getlln		;new value: none, wants to see current
	gettyp o1
	caie w2,ty%int		;make sure it is integer
	jrst lenerr		;no
	move w3,o1
	getnum w3		;get internal integer
	movem w3,ch%len(o2)	;new line len
	ret

getlln:	move w3,ch%len(o2)	;current length
	maknum w3
	move o1,w3		;return it
	ret

lenerr:	perr /LINELENGTH requires a number greater than 8/

;;TY%CHN
chrct:	move o1,@[datsec,,.curout] ;output channel
	move w2,ch%len(o1)
	jumpl w2,chrcti		;if length negative, return +INF
	sub w2,ch%pos(o1)
	jrst retint

chrcti:	move o1,[%INF]		;return +INF
	ret

;;TY%CHN
chrpos:	move o1,@[datsec,,.curout] ;output channel
	move w2,ch%pos(o1)
	addi w2,1
	jrst retint

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  STRING stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;ISTLEN - internal string length
;O1 - Lisp string object
;returns in W4 the length of the string
;Garbages W2 and W3, preserves all Lisp AC's
istlen:	move w4,(o1)		;length in words
	tlz w4,770000		;minus type code
	subi w4,1		;w4 - full words
	xmovei w3,(o1)		;address before string
	add w3,w4		;w3 - word before last
	imuli w4,5		;w4 - chars due to full words
	move w2,[010740,,0]	;w2/3 - byte pointer to last word
istln2:	ildb nil1,w2
	jumpe nil1,cpopj	;now count chars in that word
	aoja w4,istln2

;GETSTR - Lisp object of unknown type in O1
;If string, OK
;If atom, get pname to O1
;Else error
;Preserves AC's above O1
getstr:	jumpe o1,[move o1,@[datsec,,.nil+at%pna]
		  ret]
	xtype o1
	cain w2,ty%xat
	jrst [move o1,at%pna(o1)
	      ret]
	cain w2,ty%xst
	ret
	perr /Not string or atom/

;NTHCHAR - returns char object
; O1 - string
; O2 - place in string
nthchr:	call getnth		;internal NTHCHR, gets char to w4
	jumpl w4,retnil		;if failed, give NIL
	move o1,@[<w4_30.>\<datsec,,charar>] ;get atom for this char
	ret

;ANTHCHAR - like NTHCHAR, but returns INUM
; O1 - string
; O2 - place in string
anthch:	call getnth		;internal NTHCHR, gets char to w4
	jumpl w4,retnil		;if failed, give NIL
	maknum w4
	move o1,w4
	ret

;TY%STR
;TY%ATM
;TY%SPC
;Internal NTH CHAR - returns char itself in W4
; O1 - string
; O2 - place in string
getnth:	exch o1,o2		;number in o1
	call getint		;numerical value to W2
	jumpl w2,getnng		;if negative, it is harder
;here to redirect output to dummy channel that finds Nth char in output
getnps:	push p,sp		;save sp since we rebind curout
	push p,q		;also we will do not-local exit
	move o1,[.dumchn]	;get the dummy channel
	movem p,ch%jfn(o1)	;save for non-local exit
	movei w3,ch%666		;make ch%dat be not checked by GC
	hrrm w3,ch%spc(o1)
	movem w2,ch%dat(o1)	;here is the count of where to stop
	xmovei w3,nthput	;special put routine that stops at N
	movem w3,ch%put(o1)
	setom w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	move o1,o2		;get thing to print into O1
	call princ		;and print with princ
	seto w4,		;if got here, we failed
	adjsp p,-1
	jrst unbind		;rebind curout

;here non-locally if we find it
nthfnd:	move p,ch%jfn(o2)	;end - stop quickly
	pop p,q			;restore context
	move w4,w2		;move return value where unbind won't kill
	jrst unbind

;here if negative number - subtract abs(n) from length+1
getnng:	push q,o2		;save args
	push p,w2
	move o1,o2		;now find length
	call flatsc		;FLATSIZEC - has to be non-neg INUM [;TY%NUM]
	tlz o1,770000		;so fast conversion
	pop p,w2		;get back length, is negative
	add w2,o1		;subtract abs(n)
	addi w2,1		;+1
	pop q,o2		;got arg back
	jrst getnps		;and process as positive

;EQSTR - compare two strings (or atoms) for equality
eqstr:	call getstr		;get valid string arg in o1
	exch o1,o2
	call getstr		;now in both o1 and o2
	move w4,[cmpse o1,]	;compare for equal
	jrst cmpstr

;IDIRST - currently this is an internal routine
; W2 - directory or user number
; returns string in O1
idirst:	push free,[object(ty%spc,0)] ;now make string - dont know how big
	move nil1,[.bp 376,(free)] ;destination - free space
	dirst
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
	jrst strret		;finish bookkeeping on string

myuser:	gjinf
	move w2,nil1
	jrst idirst

mydir:	gjinf
	jrst idirst

;time since midnight, msec.  (actually seconds at the moment)
dtime:	seto w2,		;use current time
	setz w4,		;default format
	odcnv
	andi w4,777777		;time since midnight
	imuli w4,1000.		;pseudo-msec.
	maknum w4
	move o1,w4		;and return as INUM
	ret

;

;DATE - (MO DO YR-1900)
date:	seto w2,
	setz w4,
	odcnv
	hlrz o2,w2		;year
	subi o2,1900.
	maknum o2		;-1900 as inum
	docons o1,o2,nil	;(YR-1900)
	hlrz o2,w3		;day, 0 based
	addi o2,1
	maknum o2
	docons o3,o2,o1		;(DAY YR-1900)
	hrrz o2,w2		;month, 0 based
	addi o2,1
	maknum o2
	docons o1,o2,o3		;(MO DAY YR-1900)
	ret

;CONCAT - string concatenation
concat:	call getstr		;validate the args
	exch o1,o2
	call getstr
	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word of string
	hrlzi nil1,440740	;w1/2 source
	xmovei w2,1(o2)		;first arg
conc1:	ildb o2,nil1
	jumpe o2,conc2		;loop over first string
	setzm 1(w4)		;clear next word, for low order bits
	idpb o2,w3
	jrst conc1
conc2:	hrlzi nil1,440740	;second source
	xmovei w2,1(o1)
conc3:	ildb o2,nil1
	jumpe o2,conc4
	setzm 1(w4)
	idpb o2,w3
	jrst conc3

conc4:	idpb nil,w3		;make ASCIZ
	xmovei w2,1(free)	;start of string
	move free,w4		;update free list
	sub w4,w2		;w3 is length in words
	tlo w4,(object(ty%spc,0)) ;special GC code
	movem w4,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	move o1,w2		;and return it
	setzb o2,nil1		;clear garbage
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;This section is organized in layers.
;;;;1) TYO and TYOUT, which think all characters and devices are the same
;;;;2) character-dependent routines that keep track of position on
;;;;     the line and any other bookkeeping
;;;;3) device-dependent routines that actually put out the characters.


;;;;;;;;;;;;;;;LEVEL 1 --  TYO and TYOUT;;;;;;;;;;;;;;;;;


;tyout - prints an asciz string - string in w2
;this is an internal routine only, so it does not return a value
tyout:	push p,[440740,,0]	;make up byte pointer at -1(p)
	push p,w2
tyolp:	ildb w2,-1(p)		;next char
	jumpe w2,tyoend		;done
	makchr w2
	move o1,w2
	call tyo
	jrst tyolp
tyoend:	adjsp p,-2
	ret


;;TY%CHN
;TYO - output char on currently open channel
tyo:	move o2,@[datsec,,.curout] ;output channel
	gettyp o1
	caie w2,ty%int		;better be an integer
	jrst illasc
	move w2,o1
	getnum w2
	cail w2,0
	caile w2,177
	jrst illasc
	hrrz w3,rdtab(w2)	;see what it is
	xct tyotab(w3)

;;;;;;;;;;;;;;;LEVEL 2 -- character action routines;;;;;;;;;;;;;;;;;

;;READTABLE
tyotab:	jrst tyon	;letters
	jrst tyon	;lower case
	jrst tyon	;(
	jrst tyon	;)
	jrst tyon	;[
	jrst tyon	;]
	jrst tyon	;.
	jrst tyon	;,
	jrst tyon	;'
	jrst tyon	;/
	jrst tyon	;"
	jrst tyosp	;space
	jrst tyoeol	;all end of lines
	jrst tyon	;digits
	jrst tyon	;+ -
	jrst tyon	;esc
	jrst tyon	;comment
	jrst tyon	;null

tyoeol:	setzm ch%pos(o2)	;reinit new line
	jrst tyodo

tyon:	aos w3,ch%pos(o2)	;normal char - is there room?
	skipl ch%len(o2)	;forget the test if length .LT. 0
	camg w3,ch%len(o2)
	jrst tyodo		;there is room - normal
	jrst tyocnt		;there isn't, do continuation

;to continue to next line
tyocnt:	push p,w2
	movei w2,31		;^Y
	move w3,ch%jfn(o2)	;see if terminal
	caie w3,.priou		;yes - no ^Y
	call @ch%put(o2)
	movei w2,15		;crlf
	call @ch%put(o2)
	movei w2,12
	call @ch%put(o2)
	pop p,w2
	setzm ch%pos(o2)
	aos ch%pos(o2)
	jrst tyodo		;finally do the real char

;space or tab
tyosp:	caie w2,11		;tab?
	jrst tyon		;no - just do it
;tab - note that tabs never get ^Y'ed.  However they may make the
;next character get it.
	move w3,ch%pos(o2)	;w3 is now 0 if at start of line
	trz w3,7
	addi w3,10		;w3 is now next tab stop
	movem w3,ch%pos(o2)
	jrst tyodo		;put out the tab

tyodo:	call @ch%put(o2)	;put it out
	ret

;;;;;;;;;;;;;;;;LEVEL 3 -- device-dependent routines;;;;;;;;;;;;;

;these routines always take an ASCII char in W2.
;o2 is assumed to contain the channel object

;this is the normal put routine, for physical devices
norput:	hrrz nil1,ch%jfn(o2)
	bout
cpopn1:	setz nil1,
	ret

;this is the routine for explode.  ch%jfn is the last CONS in
;the list being built
expput:	move o3,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	move o4,ch%dat(o2)		;old end
	docons o5,o3,nil		;(char)
	dorpd o4,o5			;(old char)
	movem o5,ch%dat(o2)		;save as new end
	ret

;this is the routine for aexplode.  ch%jfn is the last CONS in
;the list being built
aexput:	caige w2,10.			;numbers less then 10
	addi w2,200			;have an extra bit because of MAKNAM
	maknum w2
	move o4,ch%dat(o2)		;old end
	docons o5,w2,nil		;(char)
	dorpd o4,o5			;(old char)
	movem o5,ch%dat(o2)		;save as new end
	ret

;this is the routine for flatsize.  Incr's count
fltput:	aos ch%dat(o2)
	ret

;this is the routine for NTHCHAR.  Stop at nth char
nthput:	sose ch%dat(o2)			;count down
	ret				;not yet
	jrst nthfnd			;found the right char - in W2

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;TYI is in three levels:
;;;;;; 1) TYI and its subroutine is device-independent.  Its only
;;;;;;		intelligence is the ^Y convention.
;;;;;; 2) TYIGET implements UNTYI
;;;;;; 3) device dependent routines do the actual I/O


;;;;;;;;;;;;;;;;;;;;;;;LEVEL 1 -- TYI;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;the main responsibility at this level is to handle ^Y


tyi:	call tyiget		;real read
	hrrz w3,rdtab(w2)	;see if funny char
	caie w3,rd%cmt		;comment and null
	cain w3,rd%nul
	jrst tyifun		;are funny
	makchr w2		;have char, make object
	move o1,w2		;return it
	ret

tyifun:	cain w3,rd%nul		;if null, ignore it
	jrst tyi
tyiflp:	call tyiget		;now skip to end of line
	hrrz w3,rdtab(w2)
	cain w3,rd%esc
	jrst tyi		;esc is end of line
	caie w2,15		;cr is not real end of line
	caie w3,rd%eol
	jrst tyiflp
	jrst tyi		;now get a real char

;;;;;;;;;;;;;;;;;LEVEL 2 -- TYIGET;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;the main responsibility at this level is UNTYI.  Get a char
;and return it in W2.  all other AC's are free.

;;TY%CHN
tyiget:	move o2,@[datsec,,.curin] ;input channel
	skipe w2,ch%lka(o2)	;lookahead?
	jrst tyilka		;yes, use it
	call @ch%get(o2)	;no, real get
	andi w2,177
	movem w2,ch%lst(o2)	;save as last char in case of UNTYI
	ret

;here if found a lookahead char
tyilka:	setzm ch%lka(o2)	;no more lookahead
	movem w2,ch%lst(o2)
	ret

;There was some confusion over TYI in the documentation.  UNTYI is
;the original implementation, based on erroneous documentation.
;XUNTYI is what UCILSP actually implemented.  I am leaving UNTYI
;because internal code uses it.  However XUNTYI is the function that
;the user will get when he calls UNTYI.
;;TY%CHN
xuntyi:	gettyp o1		;check the thing
	caie w2,ty%int		;better be an integer
	jrst illasc
	move w2,o1
	getnum w2
	cail w2,0
	caile w2,177
	jrst illasc
	move o2,@[datsec,,.curin] ;current input channel
	movem w2,ch%lka(o2)	;use for lookahead
	ret

;;TY%CHN
;untyi - back up pointer
untyi:	move o2,@[datsec,,.curin] ;current input channel
	move w2,ch%lst(o2)	;get last char
	movem w2,ch%lka(o2)	;and use for lookahead
	jrst retnil


;;;;;;;;;;;;;;;;;;;LEVEL 3 -- actual I/O routines;;;;;;;;;;;;;;;;;;;
;get a char into W2, preserve O2, which is the channel object.
;  other AC's free

;;TY%CHN
;norget is for everything except terminals
norget:	hrrz nil1,ch%jfn(o2)	;jfn
	bin			;do the input
	 erjmp eoferr		;error - treat as EOF
	setz nil1,
	ret

;This is EOF on input.  Try the following:
; 1 - see if GNJFN finds another file
; 2 - see if there were more files in the original OPENIN
; 3 - generate $EOF$ error
;O2 has the channel object, which must be preserved
eoferr:	move w2,ch%jfn(o2)	;see if we should do EOF processing
	tlnn w2,(gn%cnt)	;continuous mode?
	jrst eofbad		;no - done
	call inextf		;try to advance to next file
	 jrst eofbad		;failed
;open file, given indexable file handle in 1,
;openf bits in 2
	tlz nil1,777777		;have to open with JFN only
	move w2,[070000000000+of%rd]
	openf
	 erjmp opfer2		;error with file in o2
	move w4,w2		;openf bits for opendv
	move o1,o2		;and file in standard place
	call opendv		;do any device setups
	move o2,o1		;now get it back in our wierdo AC
	setz nil1,
	jrst @ch%get(o2)	;and try char on this one
	

;NEXTF
; get JFN on next file in wildcard or list
nextf:	jumpe o1,retnil		;if nil, fails always
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst retnil
	jumpe nil1,retnil	;also if nothing there any more, fails
	hrrz nil1,ch%jfn(o1)	;now see if open
	gtsts
	xmovei w3,inextf	;assume close needed
	tlnn w2,(gs%opn)	;is it open?
	xmovei w3,inext1	;no - use other entry
	setz nil1,
	push q,o1		;save arg
	move o2,o1		;inextf needs arg in O2
	call (w3)		;go to next file
	 jrst nextfe		;error
	pop q,o1		;return arg
	setz nil1,
	ret

nextfe:	adjsp q,-1		;error - return nil
	setzb nil1,o1
	ret

;INEXTF
; internal version of NEXTF.  In order for use for EOF processing,
;   - arg is channel in O2
;   - return +1 is error, +2 is OK
; returns indexable file handle in NIL1, also put into ch%JFN
;INEXT1 is special entry if no close needed
inextf:	
;close file, since GNJFN requires this
	move o1,o2		;file must be in O1 for close
	movsi w2,(co%nrj)	;don't release JFN
	call doclos		;do dev-specific and monitor close
	 jrst .+1
	move o2,o1		;get file back to O2
;now see if GNJFN gives us any more files
;INEXT1 - entry if no close needed
inext1:	move nil1,ch%jfn(o2)	;indexable file handle
	tlz nil1,(gn%cnt)	;this is a bogus bit, clear it
	gnjfn
	 erjmp eofnfl		;nothing there, next file spec please
;yes, we can just reopen and use it
	move nil1,ch%jfn(o2)	;get jfn again
	aos (p)			;worked - good return
	ret			

;here if we have to go to a new file spec
eofnfl:	
;first finish getting rid of old one
	hrrz nil1,ch%jfn(o2)	;jfn
	rljfn			;release it
	 erjmp .+1		;ignore errors
	move nil1,ch%jfn(o2)	;get old JFN
	setzm ch%jfn(o2)	;say no longer open
;now look at new ones
	move o3,ch%dat(o2)	;any more files?
	jumpe o3,cpopj		;no - it is bad
;here if there are more files, open the next one
	docar o1,o3		;get the new file
	docdr o3,o3		;get to next for next time
	movem o3,ch%dat(o2)
	push p,nil1		;save old file handle
	call mflnam		;put name in FILNAM
	move nil1,[gj%old+gj%ifg+gj%flg+gj%sht]  ;and open it, as in xinput
	hrroi w2,filnam
	gtjfn
	 erjmp oper
	pop p,w2		;get old file handle
	tlne w2,(gn%cnt)	;if was continuous before
	tlo nil1,(gn%cnt)	;make it so now
	movem nil1,ch%jfn(o2)	;new jfn
	aos (p)			;OK return
	ret

eofbad:	move w2,@[datsec,,priin]
	movem w2,@[datsec,,.curin]
	move o1,[%$EOF$]
	setz nil1,		;=*= re-entering the LISP world ...
	call uerr

;special read from terminal for DDTIN mode
  ;first see if anything left over in line buffer
ddtget:	sosge trmcnt		;anything left over from line-mode read?
	 jrst ddting		;no - do real DDTIN input
	ildb w2,trmpnt
	jrst trmdon		;and check for odd char's

  ;real input routine for DDTIN
ddting:	setzm trmcnt
	pbin
	move w2,nil1
	move w3,w2		;get copy without high-order bit
	andi w3,177		;ignore high-order bit
	setz nil1,
	camn w3,fixch		;fix char?
	jrst trmfix		;yes - do it
	came w3,rerdch		;reread char or
	cain w3,177		;kill char?
	jrst trmrer		;yes - do that
	ret			;no - done

;;;;;;This is the set of routines for normal terminal input

;special read from terminal
trmget:	sosge trmcnt		;anything there?
	 jrst trmgbf		;no - get a buffer
	ildb w2,trmpnt
;now check for odd char's
trmdon:	camn w2,rerdch		;reread char
	jrst trmrer		;do it
	camn w2,fixch		;fix char
	jrst trmfix		;do it
	ret

;;;;;;Here are the action routines for funny char's

;here for fix char
trmfix:	skipn @[datsec,,.rdtop]	;in read?
	ret			;no - return normal anyway
	setom sawfix'		;say we saw it
	jrst @ch%get(o2)	;and get a real char

;here for reread char
trmrer:	skipn @[datsec,,.rdtop]	;in read?
	ret			;no - return normal anyway
	hrroi nil1,[asciz / XXX
/]
	psout
	setz nil1,
	setzm ch%lka(o2)	;clear lookahead
	setzm ch%lst(o2)
	jrst rdkill		;yes - kill read

	.scalar prmpch

;here if buffer empty
trmgbf:	hrroi nil1,prmpch	;prompt
	psout
	hrroi nil1,trmbuf
	move w2,[rd%top+5*trmbfs]
	hrroi w3,prmpch		;prompt char
	rdtty
	 jrst [	setz nil1,
		err /End of file on primary input/]
	andi w2,777777		;get count
	subi w2,5*trmbfs
	movnm w2,trmcnt
	move nil1,[.bp 376,trmbuf-1] ;reinit byte pointer
	movem nil1,trmpnt
	setzm @[datsec,,outchn+ch%pos]
	setz nil1,
	jrst trmget		;and go read it

;PROMPT
;  O1 - new prompt char
prompt:	move w3,[.bp 774000000000,prmpch] ;current prompt
	jrst setprm

;INITPROMPT
iniprm:	move w3,[.bp 774000000000,inprch] ;toplevel prompt
	jrst setprm

;SETPRM - internal routine to set prompt or initprompt
;  O1 - new char
;  w3 - byte pointer to prompt or initprompt
;returns old value
setprm:	ldb w4,w3		;get old char
	makchr w4
	jumpe o1,setpnl		;see if need to set new one
	gettyp o1
	caie w2,ty%int		;better be an integer
	jrst illasc
	move w2,o1
	getnum w2
	cail w2,0
	caile w2,177
	jrst illasc
	dpb w2,w3		;set new char
setpnl:	move o1,w4		;return old value
	ret

;TALK - clear output and ^O
talk:	movei nil1,.priou
	rfmod			;get modes in W2
	tlnn w2,(tt%osp)	;are we in ^O?
	jrst talkx		;no
	cfobf			;yes, kill rest of output
	tlz w2,(tt%osp)		;clear ^O
	sfmod
talkx:	setz nil1,
	ret

;TTYECHO - complement echo
ttecho:	movei nil1,.priou
	rfmod			;get modes in W2
	trc w2,tt%eco		;complement echo
	sfmod
	setzb o1,nil1		;assume turning off
	trne w2,tt%eco		;if just turned it on
	move o1,[%T]		;say so
	ret

;TTYPAUSE - set pause on end of page or not
ttpaus:	movei nil1,.priou
	movei w2,.morxo		;look at old status
	mtopr
	exch o1,w3		;old value to return, new to w3
	caie o1,0		;normalize O1 to T/NIL
	move o1,[%T]
	caie w3,0
	movei w3,1		;normalize W3 to 0/1
	movei w2,.moxof		;now set new value
	mtopr
	setz nil1,
	ret

;CLRBFI
; return NIL
clrbfi:	movei nil1,.priin
	cfibf			;yes, kill rest of output
	setzm @[datsec,,inchn+ch%lka]
	setzm @[datsec,,inchn+ch%lst]
	setzm trmcnt		;and clear internal buffer
	setzb nil1,o1
	ret

;READP - is there an input char ready?  Ignores lookahead buffer
;  (as UCI Lisp does)
readp:	skiple trmcnt		;if we have anything in RDTTY buffer
	jrst rett		;then yes
	movei nil1,.priin
	sibe
	skipa o1,[%t]		;not empty, i.e. something there
	move o1,nil		;empty, not
	setz nil1,
	ret

;REREADCH
; O1 - number of char to use for ^Z
;negative numbers are a flag that no ^Z char at all
setrrd:	call getint
	exch w2,rerdch
	jrst retint

;EDITCH
; O1 - number of char to use for ^F
;negative numbers are a flag that no ^F char at all
setedc:	call getint
	exch w2,fixch
	jrst retint

;ERRCH
; O1 - number of char to use for ^G (ERR ERRORX)
;negative numbers are a flag that no ^G char at all
errch:	call getint		;get integer value to w2
	caig w2,33		;esc and lower
	jrst ercok		;are OK as is
	cain w2,177		;so is rubout
	jrst ercrub
	cain w2,40		;and space
	jrst ercsp
	perr /ERRCH must be control char, <esc>, <del>, or <sp>/

ercrub:	skipa w2,[.ticrb]
ercsp:	movei w2,.ticsp
ercok:	hrl w2,w2		;char,,chan
	hrr w2,erchin
	hlrz nil1,erchin	;old association
	trnn nil1,400000	;none
	dti			;cancel it
	move nil1,w2		;new association
	tlnn nil1,400000	;none
	ati			;make it
	setz nil1,
	exch w2,erchin		;now save new, get old
	hlrz w2,w2		;get old char
	caig w2,.tices		;if esc or less
	jrst retint		;just return it
	cain w2,.ticrb		;else map it back
	movei w2,177
	cain w2,.ticsp
	movei w2,40
	jrst retint



;;TY%CHN
;BINOUT - binary out
binout:	move o2,@[datsec,,.curout] ;output channel
	camn o2,@[datsec,,priout] ;instead of .PRIOUT
	move o2,[.binchn]	;use binary channel
	call getint		;get arg into W2
	jrst @ch%put(o2)	;now put out the thing

;;TY%CHN - binary in
binin:	move o2,@[datsec,,.curin] ;output channel
	camn o2,@[datsec,,priin] ;instead of .PRIIN
	move o2,[.binchn]	;use binary channel
	call @ch%get(o2)	;now get the char
	jrst retint		;and return as integer

;;TY%CHN
;CURPOS - get current position in random access. Next GET will read this
curpos:	jumpe o1,ret0		;terminal always as 0
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst ret0
	jumpe nil1,retnil	;also if nothing there any more, fails
	move w2,ch%dsp(o1)
	call @ch%cps(w2)
	 jrst retnil		;not open, etc. - NIL
	skipe ch%lka(o1)	;if lookahead
	sos w2			;then logically back one in file
	setz nil1,
	jrst retint

ret0:	move o1,[object ty%int,0]
	setz nil1,
	ret

;;TY%CHN
;SETPOS - set current position in random access. Next GET will read this
setpos:	jumpe o1,retnil		;terminal always as 0
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst retnil
	jumpe nil1,retnil	;also if nothing there any more, fails
	exch o1,o2		;get number
	call getint		;into W2
	move w3,ch%dsp(o2)
	call @ch%sps(w3)
	 jrst retnil		;not open, etc. - NIL
	setzm ch%lka(o2)	;clear lookaheads
	setzm ch%lst(o2)
	setz nil1,
	jrst rett		;OK



;put for pmapped I/O
dskput:	aos w3,ch%cby(o2)	;advance current byte
	camle w3,ch%lby(o2)	;beyond end seen so far?
	movem w3,ch%lby(o2)	;yes - update it
	sosge ch%bct(o2)	;room in buffer?
	 call dskadv		;no - next
	idpb w2,ch%bpt(o2)
	 ercal maperr
	ret

;This routine is called when we get an error upon attempting access
; to a page.  It makes assumes that the caller uses the following
; sequence:
;	aos ch%cby(o2)
;	sos ch%bct(o2)
;	idpb/ildb w2,ch%bpt(o2)
;	 ercal maperr
; as it will undo the sideeffects of these operations if necessary.
;    When a hole is found (only possible on read), we just have to set w2
;    to zero after clearing the page.
; But on a real error, we have to back out all the operations shown
;	and abort the caller.

maperr:	
;for tops-20 the most likely thing here is that we tried to read a
;  hole in the file. Tops-20 gives an ill mem read in that case. 
;Also, it may be quota exceeded.
;So the code comes in these pieces:
;  diagnose it - hole in the file?
;  if a hole, then give a zero page
;  else, print an error message and back out of the I/O operation

	sfm w3			;save flags in W4
	tlo w3,020000		;set first part done, as ILDB was interrupted
	move w4,[440700,,w4]	;do an ILDB to clear first part done
	ildb w4,w4		;since ERCAL may leave it set
	push p,w2		;save the char
	movei nil1,400000	;see what error
	geter
	tlz w2,777777		;w2 _ error code
	cain w2,iox11		;if quota error
	jrst mapquo		;special handling
	pop p,w2		;put back stack (don't care about char now)
;here we check to see if the page is perhaps nonexistent in the file
;if so, we treat it as zeros.  
	move nil1,ch%bpt+1(o2)	;addr of core page
	lsh nil1,-11		;convert to page
	hrli nil1,.fhslf	;in our fork
	rpacs
	 erjmp maper3		;treat this as an I/O error
;The case we are looking for is read-only access and an indirect pointer
	tlnn w2,(pa%wt)		;if have write access, not this problem
	tlnn w2,(pa%ind)	;if indirect too, that is it
	jrst maper3		;write access or not indirect: normal error
  ;here if it is a hole.  clear the page
maper1: move w2,nil1		;b _ .fhslf,,core page no.
	seto nil1,		;clear page
	setz w3,		;no counts
	pmap
	 chkquo			;[27]
	 erjmp maper2		;can't clear page
	setzb nil1,w2		;return a zero byte
	ret			;and continue as if ILDB had worked

;here if is a quota error, to retry
mapquo:	hrroi nil1,[asciz / Quota exceeded or disk full for /]
	esout
	movei nil1,.priou
	hrrz w2,ch%jfn(o2)
	push p,w3
	setz w3,
	jfns
	hrroi nil1,[asciz /
[Find some space, then type CONTINUE]
/]
	psout
; Finally we are ready to restore to the user's context and continue,
; if user types CONTINUE
	pop p,w3
	pop p,w2		;restore thing to put out
	pop p,w4		;return address
	subi w4,2		;back to the IDPB
	setz nil1,		;get legal again
	haltf			;let him delete some files
	xjrstf w3		;flags (including first part done) are in W4

;here is the beginning of the true error code.
maper2:	
maper3:
	sos ch%cby(o2)		;move back
	aos ch%bct(o2)
;the following should use ADJBP with -1, but that doesn't work in extended
;addressing (at least in release 4)
	ldb w3,[.bp 77_24.,ch%bpt(o2)] ;byte size
	ldb w2,[.bp 77_30.,ch%bpt(o2)] ;offset - can't be 44, as we have just
					;done ildb
	add w2,w3		;move back a byte
	dpb w2,[.bp 77_30.,ch%bpt(o2)]	;and put it back in byte pointer
	setz nil1,
ioer:	jrst opfer2		;error with file in O2

dskeof:	sos ch%cby(o2)		;yes - don't do the advance
	jrst eoferr		;now see if more files, etc.

;get for pmapped I/O
dskget:	aos w3,ch%cby(o2)	;advance current byte
	camle w3,ch%lby(o2)	;beyond eof?
	 jrst dskeof		;yes - do it
	sosge ch%bct(o2)	;count bytes left in this buffer
	call dskadv		;none - get new buffer
	ildb w2,ch%bpt(o2)	;get character
	 ercal maperr
	move w3,ch%lts(o2)	;line no. test bit if 7 bit mode
	tdnn w3,@ch%bpt+1(o2)	;was it a line no.?
	ret			;no - that's all
;currently we aren't giving the user the line number
;	move w3,@ch%bpt(o2)	;line no. - get it
;	movem w3,...		;save it for user
	aos ch%bpt(o2)		;skip it
	movei w3,5		;update currentposition
	addm w3,ch%cby(o2)
	movni w3,5		;note getchb already skipped one char, so
	addb w3,ch%bct(o2)	; we only skip 5
	jumpge w3,dskget	;now get real character
;the context in which dskadv is valid is where we have just done sosge ch%bct,
;and are about to do ildb.  Usually this is right, as in the subtraction of
;5 above, 1 of the 5 is in the new block.   so that is the sosge.  we will
;still have to do an ibp afterwards, though.  If we are further into the
;word than the first char, we now back up, since filadv will leave us at
;the start of the buffer (and its error handling is predicated on the
;assumption that we are working on the first char)
	addi w3,1		;if more than one char into new buffer
	addm w3,ch%cby(o2)	;move back (T is negative)
	call dskadv		;go to new buffer
;this should be IBP, but IBP doesn't work in extended addressing
	ildb w3,ch%bpt(o2)	;pass over first char (tab)
	jrst dskget		;now go back for real char

;pmap I/O - buffer advance and go to new page

;dskadv - get to the next page when reading sequentially.  If
; the getpage succeeds, this gives new byte ptr, count, etc., for
; the new page.  Otherwise you are left exactly where you were before,
; with filcby adjusted, since the caller is assumed to have
; incremented it.
;    W2 must be preserved, since it has the character in it
dskadv:	move w3,ch%pag(o2)	;old page
	addi w3,winpgs		;new page
	call getfpg		;get page routine
	 jrst badadv		;can't get new page
	move w3,ch%bfs(o2)	;bytes in buffer
	subi w3,1		;caller has done sosge
	movem w3,ch%bct(o2)
	move w3,ch%buf(o2)	;pointer to start of buffer
	movem w3,ch%bpt+1(o2)
	movei w3,44
	dpb w3,[.bp 77_30.,ch%bpt(o2)]
	ret

badadv:	sos ch%cby(o2)		;user has done aos on this
	err /I-O error on disk file/

;getfpg - get specified page 
;	w3 - desired page - preserved
;	w2 - preserved
;  returns:  w3 - requested disk page, skip if works, non-skip if not
;    also resets 
;	ch%pag to indicate we are on a new file page
;    the user is assumed to adjust counts, pointers, etc., as he likes

getfpg:	push p,w2
	push p,w3
	hrr nil1,w3		;desired page
	hrl nil1,ch%jfn(o2)	;on this file
	move w2,ch%buf(o2)	;address of buffer
	lsh w2,-9.		;make page no.
	hrli w2,400000		;current process
	move w3,[pm%cnt\pm%rd\pm%wr\pm%pld\winpgs] ;use count, preload
	pmap
	 chkquo			;[27]
	 erjmp badpag
	setz nil1,
	pop p,w3
	pop p,w2
	movem w3,ch%pag(o2)	;only now can we say are on that page
	aos (p)			;skip return - success
	ret

;note that badpag is called with b&c saved on stack
badpag:	pop p,w3		;we don't change filpag, as haven't moved
	pop p,w2
	setz nil1,
	ret			;error return

;pmap I/O - device dependent openning

;Here after a file has been opened on disk.
;W4 - OPENF bits user asked for (if simulating append, may have used others)
;O1 - file, which must be preserved

;The first problem is to see whether we have enough access to the file to
;   PMAP it.  Write-only or append-only files can't be pmapped.
dskopn:	hrrz nil1,ch%jfn(o1)	;let's see whether we can use PMAP'ed I/O
	gtsts			;w2 - file status
	tlne w2,(gs%opn)	;if not open, nothing we can do
	tlnn w2,(gs%rdf)	;also if can't read, pmap is no use
	ret			;not open or no read
	tlnn w2,(gs%rnd)	;better not be opened append-only
	ret			;it is
	trnn w4,of%wr\of%app	;if he wanted write or append
	jrst dskop1		;no - read is enough
	tlnn w2,(gs%wrf)	;we had better be able to write
	ret			;can't - let monitor figure this out
;If here, we know we will be able to PMAP the file
dskop1:	push p,w4		;save open bits for later users
	skipe w2,ch%buf(o1)	;if there is already a buffer
	jrst dskop2		;we use it
	movei w2,winpgs		;get this many pages
	call getbuf		;returns address in W2
dskop2:	movem w2,ch%buf(o1)	;now set up all the fields
	movem w2,ch%bpt+1(o1)
	ldb w2,[.bp 77_30.,(p)] ;get byte size
	cain w2,0		;if not specified
	movei w2,7		;use ascii
	movei w3,36.		;now compute number of bytes per word
	idiv w3,w2		;w3 - number of bytes per word
	lsh w3,9.		;w3 - number of bytes per page
	movem w3,ch%pgs(o1)
	imuli w3,winpgs		;w3 - number of bytes per buffer
	movem w3,ch%bfs(o1)
	setzm ch%lts(o1)	;assume no line number test needed
	cain w2,7		;if 7-bit
	aos ch%lts(o1)		;then turn on the bit
	lsh w2,24.		;move into byte size field in byte ptr
	tlo w2,440040		;and make pointer to start of word, extended
	movem w2,ch%bpt(o1)	;now we have a full byte pointer (2-word)
	movni w2,winpgs		;set set DSKADV gives first page
	movem w2,ch%pag(o1)
	setom ch%bct(o1)	;no space left
	setzm ch%cby(o1)	;and no char's read
	move w2,[codsec,,dskget] ;set up dispatches
	movem w2,ch%get(o1)
	move w2,[codsec,,dskput]
	movem w2,ch%put(o1)
	move w2,[codsec,,dskdsp]
	movem w2,ch%dsp(o1)

;here we have to split according to the sort of open being done
	pop p,w2		;get back openf bits
	trne w2,of%app		;special code to simulate append
	jrst dskapp
	trnn w2,of%rd		;special code if write-only
	jrst dskwrt
;read or update
	trne w2,of%wr		;if only read
	jrst sizefi		;and finally, use size of existing file

  ;read only
	move w2,[codsec,,errio]	;disable writing
	movem w2,ch%put(o1)
	move w2,[codsec,,dskrds] ;use special dispatch because of close
	movem w2,ch%dsp(o1)
	jrst sizefi		;and finally, use size of existing file

;write only
dskwrt:	setzm ch%lby(o1)		;file is now zero length
	ret			;that's it

;append simulation
dskapp:	pushj p,sizefi		;find end of file
	move w2,ch%lby(o1)	;go to end
	move o2,o1		;retint will set O1
	call retint
	exch o1,o2		;file to O1, position to O2
	push q,o1
	call setpos		;now setpos to position
	pop q,o1
	ret

;These are common initializations that must not be done until
;we know the open succeeded

;Find the size of the file, and set up CH%LBY
sizefi:	hrrz nil1,ch%jfn(o1)
	move w2,[2,,.fbbyv]
	movei w3,w2		;put w2 _ byte size, w3 _ bytes in file
	gtfdb			;get from fdb
	 erjmp opfer
	ldb w4,[.bp 77_24.,ch%bpt(o1)]	;w4 _ our byte size
	ldb w2,[.bp 77_24.,w2]	;w2 _ file's byte size
	cain w2,0		;[2] if zero
	movei w2,36.		;[2] use 36 to prevent divide by 0
	camn w2,w4
	jrst sambsz		;if same, use exact calculation
;[44] new algorithm that gets exact sizes if at all possible
;different byte sizes.  First we figure the number of completely filled
;words.  Then if not an even number of words, we handle the last,
;partially filled word separately.  The object is to avoid rounding up
;if possible.
	movei o2,36.
	idiv o2,w2		;o2 - file bytes/wd
	move o3,w3		;o3 - number of full words, o4 - extra fil byt
	idiv o3,o2
	imul o4,w2		;o4 - extra bits in last word
	movei o5,36.		;o5 - our bytes per word
	idiv o5,w4
	imul o5,o3		;o5 - our bytes in full words
	move o6,o5		;o6 - our bytes in full words
	idiv o4,w4		;o4 - extra bytes of our size in last wd
				;o5 - extra bits beyond those bytes
	add o6,o4		;o6 - our bytes due to full words and extra
				;    bytes in last word
	skiple o5		;any bits not yet counted?
	addi o6,1		;yes - say one more byte
	move w3,o6		;c - final result - bytes in file
	setzb o2,o3		;make these things legal
	setzb o4,o5
	setz o6,
;[44] end of new algorithm
sambsz:	movem w3,ch%lby(o1)
	ret

;I/O buffer allocation

;At the moment all of our buffers are the same size, so we use a
;bit mask showing availability of buffers, not pages.  A bit
;turned on indicates something is there, as this is easier to find.

numbfs==64.	;number of buffers possible
winpgs==4
;fremap is initially an array of 64 bits

;GETBUF
;W2 - number of pages to get
;returns address in W2

getbuf:	caie w2,winpgs
	jrst [err /Bad request - GETBUF/]
	seto w2,	;assume nothing there
	skipe fremap+1	;anything in second word?
	movei w2,1	;yes - use it if not in first
	skipe fremap	;anything in first word?
	setz w2,	;yes - use it
	jumpl w2,[err /No space for I-O buffer/]
;w2 is now a word in FREMAP having an entry
	move w3,fremap(w2) ;get the word
	jffo w3,getbf1
	err /Impossible error in GETBUF/
getbf1:	movsi w3,400000	;make up mask
	movn w4,w4
	lsh w3,(w4)
	andcam w3,fremap(w2)
	movn w4,w4
	imuli w2,36.	;number of bits per word
	add w2,w4	;w2 now has a buffer number
	imuli w2,winpgs	;now we have a page number
	lsh w2,9.	;to address offset
	add w2,[bufst]	;and real address in section
	ret		;that's it

;RELBUF
;W2 - address
;W3 - number of pages
relbuf:	caie w3,winpgs	;better be this
	jrst [err /Bad request - RELBUF/]
	sub w2,[bufst]	;get to address offset
	lsh w2,-9.	;to page number
	idivi w2,winpgs	;to buffer number
	idivi w2,36.	;to word and bit
	movsi w4,400000	;mask
	movn w3,w3
	lsh w4,(w3)	;now have bit in right place
	iorm w4,fremap(w2) ;in right word
	ret

;pmap I/O - device-dependent routines

;break - force out the buffer - this is close for read-only
dskbrk:	skipge ch%pag(o1)	;anything there?
	ret			;no - nothing to do
	seto nil1,		;clear the pages
	move w2,ch%buf(o1)	;this core address
	lsh w2,-9.		;convert to page
	hrli w2,400000		;in this process
	move w3,[pm%cnt\winpgs]	;this many
	pmap
	 chkquo
	 erjmp opfer		;error with file in O1
	setz w2,
	exch w2,ch%buf(o1)	;address of buffer
	movei w3,winpgs		;size
	call relbuf		;release the space
	setz nil1,
	ret

;close for read/write modes
dskclo:	call dskbrk		;force the last buffer
	hrli nil1,400000\.fbbyv	;byte size, suppress updating disk copy
	hrr nil1,ch%jfn(o1)
	move w3,ch%bpt(o1)
	hrlzi w2,007700		;mask
	chfdb
	 erjmp .+1		;if not open for output, ignore
	hrli nil1,.fbsiz	;no. of bytes
	hrr nil1,ch%jfn(o1)
	move w3,ch%lby(o1)
	seto w2,		;all bits
	chfdb
	 erjmp .+1
	setz nil1,
	ret

	subttl pmap I/O - random access

;setpos - file is O2, position is W2
;skips if works, error is non-skip

;dskmov - internal routine to move to new place
dskmov:	caige w2,0		;if less than zero
	move w2,ch%lby(o2)	;use end of file
	push p,w2		;save desired byte in W4
	idiv w2,ch%pgs(o2)	;w2 _ pages, w3 _ bytes off in page
	sub w2,ch%pag(o2)	;w2 _ pages from start of buffer
	cail w2,0		;is it in the window
	cail w2,winpgs
	jrst dskmv1		;no - need a new page
dskmv2:	pop p,ch%cby(o2)	;we are now at requested place
  ;compute byte count
	move w2,ch%pag(o2)	;compute bytes left in buffer - bytes to start
	imul w2,ch%pgs(o2)
	sub w2,ch%cby(o2)	;- (current - start of window)
	movn w4,w2		;for later: w4 = current - start of window
	add w2,ch%bfs(o2)	;bytes left in window
	movem w2,ch%bct(o2)
  ;compute byte pointer - this code is because ADJBP doesn't work for 2-word
	move w3,ch%bpt(o2)	;get the byte size from the current pointer
	tlz w3,770040		;00nn00,,0
	tlo w3,440000		;44nn00,,0
	adjbp w4,w3		;w4 - one-word bpt from zero
	tlo w4,000040		;LH is now LH of 2-word
	hllm w4,ch%bpt(o2)
	hrre w4,w4		;address portion only
	add w4,ch%buf(o2)	;add to start of buffer
	movem w4,ch%bpt+1(o2)	;this is second word of 2-word pointer
	aos (p)			;good (skip) return
	ret

dskmv1:	move w3,(p)		;get back target byte
	idiv w3,ch%pgs(o2)	;w3 _ pages
	call getfpg		;get file page
	 jrst .+1		;error
	jrst dskmv2		;it worked
	adjsp p,-1		;fail return
	ret

dskcpo:	move w2,ch%cby(o1)
	aos (p)
	ret

;error handling

;chkquo - special thing designed to be used with ERCAL after a
;jsys that may write to disk.  If quota is exceed, gives a
;message that looks just like the EXEC's, and retries the jsys
;if continued.
quochk:	push p,nil1
	push p,w2
	movei nil1,400000
	geter
	tlz w2,777777		;b _ error code
	caie w2,iox11		;is it quota problem?
	cain w2,pmapx6
	jrst isquot		;yes
;not a quota problem, do the next instruction, including erjmp/cal
;simulation.
	move nil1,-2(p)		;ret addr
	hlrz w2,(nil1)		;next inst
	cain w2,(erjmp)		;is erjmp?
	jrst dojmp
	cain w2,(ercal)		;is ercal?
	jrst docal
retba:	pop p,w2		;no, normal return
	pop p,nil1
	ret

;here are the erjmp/cal simulations
dojmp:	hrrz w2,(nil1)		;address to go to
	hrrm w2,-2(p)		;make us return there
	jrst retba

docal:	hrrz nil1,(nil1)	;address to call
	hll nil1,(p)		;left half should be callers section
	pop p,w2
	exch nil1,(p)
	adjsp p,-1		;we now have goto addr 1(p)
	aos (p)			;return after the next ercal
	jrst @1(p)		;this is pjrst

;here if it is a quota problem
; print a message, and then prepare to retry the instruction
isquot:	hrroi nil1,[asciz / Quota exceeded or disk full
[Find some space, then type CONTINUE]
/]
	esout
; Finally we are ready to restore to the user's context and continue,
; is user types CONTINUE
	pop p,w2
	pop p,nil1
	sos (p)			;make return point to thing before QUOCHK
	sos (p)
	haltf			;let him delete some files
	ret

;disk dispatch

dskdsp:	codsec,,dskcpo		;curpos
	codsec,,dskmov		;setpos
	codsec,,dskclo		;close

;for read-only
dskrds:	codsec,,dskcpo		;curpos
	codsec,,dskmov		;setpos
	codsec,,dskbrk		;close

;here is what the dispatch routines must do:
;	curpos - file in O1, return position in W2.  Wn's are free
;	setpos - file in O2, position in W2 ; skips if it works. Wn's are free
;	close - file in O1.  Wn's are free

;Here are the routines for normal files

norcpo:	hrrz nil1,ch%jfn(o1)
	rfptr
	 erjmp .+2
	aos (p)
	setz nil1,
	ret

norspo:	hrrz nil1,ch%jfn(o2)
	sfptr
	 erjmp .+2
	aos (p)
	setz nil1,
	ret

;And here is the dispatch for them

nordsp:	codsec,,norcpo
	codsec,,norspo
	codsec,,cpopj

;This is for channels not yet open or open on odd streams

errdsp:	codsec,,errio
	codsec,,errio
	codsec,,errio




;;TY%CHN
;;TY%ATM
;special read for readlist
rdlget:	move o3,ch%dat(o2)	;get tail of list
	camn o3,[%dointern]	;see if trying to go beyond end
	jrst [err /READLIST: list ends before end of object/]
	jumpe o3,rdleof		;just at end of list
	docar o4,o3		;current element
	docdr o3,o3		;advance for next time
	movem o3,ch%dat(o2)
	getdsp o4		;get type
	xct rdltab(w2)		;and dispatch on type
;falls through here if NIL
	movei w2,"N"
	ret

rdltab:	jumpn o4,rdlatm		;normal atom (except nil)
	jrst rdlatm			;  constant atom
	jrst rdlerr		; cons
	jrst rdlerr		;  constant cons
	jrst rdlstr		; string
	jrst rdlstr		;  constant string
	jrst rdlerr		; channel
	jrst rdlerr		;  constant channel
	jrst rdlint		; integer
	jrst rdlerr		; real
	jrst rdlerr		; bignum
	jrst rdlerr		; hunk
	jrst rdlerr		; address
	jrst rdlerr		; special
	jrst rdlerr		;16
	jrst rdlerr		;17

rdlstr:	skipa w3,o4

rdlatm:	move w3,at%pna(o4)	;put byte ptr to pname in -1(p)
	tlz w3,770000		;clear type code
	hrlzi w2,010740		;w2,w3 are extended BP
	ildb w2,w2		;first byte
	ret

rdlerr:	move o1,o4
	perr /arg to READLIST must be a character/

rdleof:	movei w2," "		;give him a space at the end
	move o3,[%dointern]	;and set special flag
	movem o3,ch%dat(o2)	;to kill him next time
	ret

;rdlint - if integer, we treat it as ascii value
rdlint:	move w2,o4
	getnum w2
	cail w2,0
	caile w2,177+9.		;200 to 211 is kludge for 0-11
	jrst rdlerr
	caige w2,10.		;except if 0-9
	addi w2,"0"		;it is handled as digit
	andi w2,177		;200-211 kludge
	ret


;;;;;;;;;;;;;;MISC INPUT-RELATED FUNCTIONS;;;;;;;;;;;;;;;;;;;;


;;TY%INT
readch:	call tyi
	move o1,@[<o1_30.>\<datsec,,charar>] ;get atom for this char	
	ret

;;TY%CHN
;clearin - clear input buffer
clrin:	move o2,@[datsec,,.curin] ;current input chan
	setzm ch%lka(o2)
	setzm ch%lst(o2)
	hrrz nil1,ch%jfn(o2)	;jfn
	cain nil1,.priin	;priin is special
	setzm trmcnt
	jumpe nil1,cpopn1	;if no jfn, forget it
	cfibf
	setz nil1,
	ret

;can't open binary tty output
ttoper:	hrroi nil1,[asciz /Can't open JFN for binary TTY output/]
	esout
	movei nil1,.priou
	movem nil1,@[datsec,,binchn+ch%jfn]
	jrst ioin1

;check stack limit and redo if needed.  If case debugger has released
;the limit.
chstlm:	skipe @[datsec,,.%%STKLIM]	;only do this if not done
	ret
	hrroi nil1,[asciz /
[Reducing stacks to normal size]
/]
	psout
	seto nil1,			;kill the extra pages
	move w2,[.fhslf,,endq_-9.]	;start at top of normal
	move w3,[pm%cnt+<<endqs-endq>_-9.>] ;to end of section
	pmap				;clear them all
;limit stack usage, so we trap PDL overflows in time to call debugger
limstk:	move o1,[%T]
	movem o1,@[datsec,,.%%STKLIM]	;say limit has been done
;put illegal pages in to limit memory usage
	moves @[endp]			;create the page
	move nil1,[.fhslf,,endp/1000]	;end of P
	setz w2,			;no access
	spacs
	moves @[endsp]			;create the page
	move nil1,[.fhslf,,endsp/1000]	;end of SP
	setz w2,			;no access
	spacs
	moves @[endq]			;create the page
	move nil1,[.fhslf,,endq/1000]	;end of Q
	setz w2,			;no access
	spacs
	setz nil1,
	ret	

;EXPSTK - allow access to the whole section, to allow debugging after PDL ovrfl
expstk:	setzm @[datsec,,.%%STKLIM]	;say need to reset them later
;put illegal pages in to limit memory usage
	move nil1,[.fhslf,,endp/1000]	;end of P
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	move nil1,[.fhslf,,endsp/1000]	;end of SP
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	move nil1,[.fhslf,,endq/1000]	;end of Q
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	setz nil1,
	jrst (w3)

ioinit:	
;open jfn on TTY in binary mode, put it in BINTTY
	moves @[bufill]			;create the page
	move nil1,[.fhslf,,bufill/1000]	;illegal page in buf sec, to stop Q
	setz w2,			;no access
	spacs
	dmove w2,[-1 ? 777777777400]	;say all I/O buffer pages free
	dmovem w2,fremap
	movsi nil1,(gj%fou\gj%phy\gj%sht)
	hrroi w2,[asciz /TTY:/]
	gtjfn
	 erjmp ttoper
	move w2,[<10_30.>\of%rd\of%wr] ;binary access
	openf
	 erjmp ttoper
	movem nil1,@[datsec,,binchn+ch%jfn]
;initialize I/O state stuff
ioin1:	setzm trmcnt		;force read on first try
	move w2,@[datsec,,priin] ;init current channels
	movem w2,@[datsec,,.curin]
	setzm ch%lka(w2)	;clear lookahead
	setzm ch%lst(w2)
	move w2,@[datsec,,priout]
	movem w2,@[datsec,,.curout]
	setzm @[datsec,,.rdtop]
	movei nil1,.fhslf
;turn on ^C interrupt
	rpcap
	tlo w3,(sc%ctc)		;enable control-C
	epcap
;enable char interrupts
	movei nil1,2
	movem nil1,cnccnt
	setzm crit		;not in critical section
	movei nil1,.fhslf
	move w2,[codsec,,sirarg]
	xsir%
	eir
	movei nil1,.fhslf
	move w2,[770547,,104000] ;channels to enable
	aic
;These are the mandatory channels
	move nil1,["C"-100,,0]	;^C on channel 0
	ati
	 erjmp [hrroi nil1,[asciz /
% Can't trap ^C - Use (EXIT) to reset terminal modes
/]
		psout
		jrst .+1]
	move nil1,erchin	;^G on channel 3 (unless reset)
	tlnn nil1,400000	;if -1 LH, none at all
	ati	
;Now turn on or off the optional interrupts
	move o1,@[datsec,,.debiok] ;turn on or off the optional ones
	call debint		;turn on the optional ones
	setz nil1,
	ret

;DEBUGINT - O1 is T to turn on, NIL to turn off, return old
debint:	move w2,[ati]		;assume turn on
	cain o1,0		;unless off
	move w2,[call dodti]
	move nil1,["D"-100,,1]	;^D on channel 1
	xct w2
	move nil1,["E"-100,,2]	;^E on channel 2
	xct w2
	move nil1,["H"-100,,4]	;^H on channel 4
	xct w2
	move nil1,["B"-100,,5]	;^B on channel 5
	xct w2
	move nil1,["Y"-100,,24.] ;^Y on channel 23
	xct w2
	setz nil1,
	exch o1,@[datsec,,.debiok] ;return old, set new
	ret

dodti:	hlrz nil1,nil1
	dti
	ret

sirarg:	3
	codsec,,levtab
	codsec,,chntab

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Interrupt system
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;We have to disable interrupts during the GC.  The way we will
;handle this is by using routines STCRIT and ENCRIT.  STCRIT
;will just set a flag CRIT.  ENCRIT will clear this flag and
;activate any delayed interrupt.  At the moment we will use
;only level 2.  The routine CHCRIT should be used to check if
;we are in a critical section and if so delay the interrupt.
;Note that only one interrupt at a time is delayed, the most
;recent.

	.vector lev1pc(2),lev2pc(2),lev3pc(2),cnccon(2)
	.scalar crit,cnccnt

;crit-
;  0 if not in critical section
;  -1 if in critical section, but no interrupts yet
;  chan number if in cricial section and an interrupt has happened.


levtab:	codsec,,lev1pc
	codsec,,lev2pc
	codsec,,lev3pc


;;;;;;The following routines must always preserve all AC's, stack, etc,
;;;;;; since they may be called anywhere.  They may however garbage
;;;;;; AC's if they have determined that they are about to abort, etc.

;^C - exit at next good time, unless he gets impatient
cncint:	
;if he has done 6 ^C's without an exit, don't check critical section, just exit
	sosge cnccnt		;if 6 ^C's,
	jrst cncdo		;just do it
;now do normal processing
	push q,[object ty%adr,0]
	call chcrit		;delay if in critical section
cncdo:	push p,nil1
	movei nil1,2		;rearm the count
	movem nil1,cnccnt
	movei nil1,.priin
	cfibf			;otherwise EXEC will see our typeahead
	hrroi nil1,[asciz /^C
/]
	psout
	call warncr
	pop p,nil1	
	haltf
	debrk

cnyint:	push p,nil1
	movei nil1,.priin
	cfibf			;otherwise EXEC will see our typeahead
	hrroi nil1,[asciz /^Y
/]
	psout
	call warncr
	pop p,nil1
	haltf
	debrk

;WARNCR - if in GC, warn the user
warncr:	hrroi nil1,[asciz /%% Beware - you are in the garbage collector.  CONTINUE is OK, but START 
   will result in an unusable core image.
/]
	skipe crit
	psout
	ret

;^D - to top level
cndint:	push q,[object ty%adr,1]
	call chcrit
kill:	movei nil1,7
	pbout
	setz nil1,
	move w2,[codsec,,restac]
	dmovem nil1,lev2pc
	debrk

;^E - (ERR NIL)
cneint:	push q,[object ty%adr,2]
	call chcrit
	move o1,nil
	move w2,[codsec,,uerr]
	movei nil1,7
	pbout
	setz nil1,
	dmovem nil1,lev2pc
	jsp w2,valsp
	debrk

;^G - (ERR 'ERRORX)
cngint:	push q,[object ty%adr,3]
	call chcrit		;delay if in critical section
	move o1,[%ERRORX]
	move w2,[codsec,,uerr]
	movei nil1,7
	pbout
	setz nil1,		;if interrupting the RDTTY, NIL1 is non-zero
	dmovem nil1,lev2pc	;zero flags and new PC
	jsp w2,valsp
	debrk

;^H - break later
cnhint:	push p,w2
	move w2,[jrst latbrk]	;now establish break
	movem w2,evhook
	pop p,w2
	debrk

latbrk:	move w2,[jfcl]
	movem w2,evhook
	err /Break caused by ^H/

;^B - break now
cnbint:	push q,[object ty%adr,5]
	call chcrit		;delay if in critical section
	move o1,makerr /Break caused by ^B/
	move w2,[codsec,,error]
	movei nil1,7
	pbout
	setz nil1,		;if interrupting the RDTTY, NIL1 is non-zero
	dmovem nil1,lev2pc	;zero flags and new PC
	jsp w2,valsp
	debrk

;VALSP - check for SP of odd size or with partial EVAL blip at top, due
;to interrupting an operation on the SP
;  This must be done at interrupt level, before the DEBRK
valsp:	move w3,savesp		;get known valid SP
	xor w3,sp		;compare with current
	trne w3,1		;if different parity
	adjsp sp,-1		;then adjust to valid
	skipe -1(sp)		;if partial EVAL blip
	jrst (w2)		;not - done
	push sp,[%savep]	;finish the blip
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	jrst (w2)	

;start critical section
stcrit:	setom crit		;say in critical section
	ret

;end critical section - this is called as a normal routine, so the AC's
;are free.  But we do have to prevent race conditions.
;Do any deferred interrupts.
encrit:	setz w3,
	exch w3,crit		;no longer critcal, see if anywhere to go
	jumpe w3,[halt .]	;not in critical section???
	jumpl w3,cpopj		;no interrupt happened
;here when we have defered an interrupt.  The channel number will be in
;CRIT, now in W3.
	hrlzi w2,400000		;make bit from bit number
	tlz w3,770000		;this was an object, so clear ty%adr
	movn w3,w3
	lsh w2,(w3)
	movei nil1,.fhslf
	iic
	setz nil1,
	ret

;this is called at interrupt level, so we are protected against
;further interrupts.  Thus we don't have to do anything fancy with
;EXCH, etc.
chcrit:	skipn crit		;in critical section?
	jrst chcrix		;no - exit
;we are in critical section - save the fact that int occured and debreak
	pop q,crit		;arg is interrupt channel
	adjsp p,-1		;forget ret addr
	debrk

chcrix:	adjsp q,-1		;forget arg
	ret

exit:	haltf
	ret

;ILLMEM - interrupt handler for illegal mem reads and writes
illmem:	move nil,@lev2pc+1	;get the bad instruction
	ldb nil,[.bp <740,,0>,nil] ;the AC field
;check for PDL overflow
	cain nil,p
	jrst regpdl		;P pdl
	cain nil,q
	jrst datpdl		;Q pdl
	cain nil,sp
	jrst spcpdl		;SP pdl
;check for data out of range
	move nil,@lev2pc+1	;the bad instruction
	tlz nil,777740		;change into XMOVEI NIL,
	tlo nil,(xmovei nil,)
	xct nil			;now have E.A. of instruction
	camg nil,[datsec+datsiz,,1000] ;see if just above data section 1
	camge nil,[datsec+datsiz,,0]
	jrst .+2
	jrst freovr		;yes - free space overflow
	camg nil,[datsc2+datsiz,,1000] ;see if just above data section 1
	camge nil,[datsc2+datsiz,,0]
	jrst .+2
	jrst freovr		;free space overflow in other space
	camg nil,[codsec+1,,1000] ;see if just above code section
	camge nil,[codsec+1,,0]
	jrst .+2
	jrst codovr		;code space overflow
	dmove w2,[0 ? codsec,,grbptr]
	dmovem w2,lev2pc
	debrk
grbptr:	setzb nil,nil1
	move 
	err /Reference to illegal address - probable garbage pointer/

;various error processing routines
;PDL overflows - expand the stacks so we can use the debugger

regpdl:	hrroi nil1,[asciz / The control stack overflowed - probably too much recursion/]
	jrst dopdl

datpdl:	hrroi nil1,[asciz / The data stack overflowed - probably too much recursion/]
	jrst dopdl

spcpdl:	hrroi nil1,[asciz / The special stack overflowed - probably too much recursion/]
	jrst dopdl

dopdl:	esout
	skipn @[datsec,,.%%STKLIM]	;already in bad shape?
	jrst badpdl
	dmove w2,[0 ? codsec,,dopdl1]
	dmovem w2,lev2pc
	debrk
dopdl1:	jsp w3,expstk			;no - expand it
	jsp w2,valsp			;make sure SP is valid
	err /Expanding stacks temporarily to allow the debugger to run/

badpdl:	hrroi nil1,[asciz /
Your stack is already expanded, so we must return you to the top level of LISP
/]
	jrst fatal

freovr:	hrroi nil1,[asciz /You have run out of memory in Lisp free space.  Your program is probably 
too big.  We will return you to the top level of Lisp.  You should save any
data you can, because your core image is probably irretrievably garbaged.
/]
	jrst fatal

codovr:	hrroi nil1,[asciz /You have run out of memory in code space.  If you were not loading compiled
code, it is possible that what you really have is a garbage pointer.
/]
	jrst fatal

fatal:	esout
	setzb nil,nil1
	jrst kill

pdlovr:	dmove w2,[0 ? codsec,,pdlmsg]
	dmovem w2,lev2pc
	debrk
pdlmsg:	setzb nil,nil1
err /Pushdown list overflow.  This should be impossible.  Probably a bug in
the interpreter or compiled code./

sysres:	dmove w2,[0 ? codsec,,syrmsg]
	dmovem w2,lev2pc
	debrk
syrmsg:	hrroi nil1,[asciz /
System resources exhausted.  Probably you have run out of memory.
If so, your core image has probably been irretrievably lost.  
Type "CONTINUE" to try to restart Lisp.
/]
	psout
	haltf	;make him type continue, to avoid infinite loop
	setzb nil,nil1
	jrst restac

maxerr==40
	.vector errmsg(maxerr)	;place to put monitor error msg

illins:	dmove w2,[0 ? codsec,,ilsmsg]
	dmovem w2,lev2pc
	debrk
ilsmsg:	hrroi nil1,errmsg	;put it here
	move w2,[.fhslf,,-1]	;most recent error for this process
	hrlzi w3,-maxerr*5	;this many char's
	erstr
	 jrst illinx
	 jrst illinx
	move o1,[object ty%adr,errmsg] ;print the message returned
	setzb nil,nil1
	jrst error

illinx:	setzb nil,nil1
	err /The operating system has issued an error that we can't figure out/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  I/O channel stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

fnaml==40
	.vector filnam(fnaml)

;;TY%ATM
;one arg - put name as asciz in filnam
mflnam:	jumpe o1,mflnil		;nil is special
	call getstr		;get valid string into o1
mflnm1:	move w2,(o1)		;get length code
	tlz w2,770000		;clear funny bits
	caile w2,fnaml		;if too long
	movei w2,fnaml		;use maximum length
	xmovei w3,1(o1)		;get addr of first data word
	move w4,[codsec,,filnam] ;put it here
	xblt w2,		;do the copy
	ret

mflnil:	err /Null file name/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here are the new file I/O functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;xopenf - this is OPENF.
; o1 - channel, or list of files
; o2 - NIL or list of options

define cntflg			;-1: continuous input
	0(p) termin
define gtjbts			;gtjfn bits
	-1(p) termin
define opfbts			;openf bits
	-2(p) termin
define errflg			;-1: return NIL if error
	-3(p) termin

gn%cnt==gn%dir			;flag for doing continous proceed to next

xopenf:	push p,[0]		;place for bits to go
	push p,[0]
	push p,[0]
	push p,[0]
;check options arg type
	jumpe o2,openfj		;none - do gtjfn
	scons o2
	jrst [move o1,o2
	      perr /OPENF options must be a list/]
;we now have a valid option list in O2
openf1:	docar o3,o2		;o3 - current option
	gettyp o3
	cain w2,ty%int		;may be byte size
	jrst opfbsz
	camn o3,[%OLD]
	jrst opfold
	camn o3,[%NEW]
	jrst opfnew
	camn o3,[%NEWVERSION]
	jrst opfnve
	camn o3,[%WILD]
	jrst opfwld
	camn o3,[%CONTINUOUS]
	jrst opfcnt
	camn o3,[%UEROR]	;ERROR
	jrst opferr
	camn o3,[%IN]
	jrst opfin
	camn o3,[%OUT]
	jrst opfout
	camn o3,[%APPEND]
	jrst opfapp
	move o1,o3
	perr /Unknown OPENF option/

openf2:	docdr o2,o2		;next option
	jumpn o2,openf1		;if any
	jrst openfj		;none - now gtjfn

;here are the option processors
opfnew:	skipa w2,[gj%new]
opfold:	movsi w2,(gj%old)
	iorm w2,gtjbts
	jrst openf2

opfnve:	skipa w2,[gj%fou]
opfwld:	movsi w2,(gj%ifg)
	iorm w2,gtjbts
	jrst openf2

opfin:	skipa w2,[of%rd]
opfout:	movei w2,of%wr
	iorm w2,opfbts
	jrst openf2

opfapp:	movei w2,of%app
	iorm w2,opfbts
	jrst openf2

opfcnt:	setom cntflg
	jrst openf2

opferr:	setom errflg
	jrst openf2

opfbsz:	move w2,o3		;move into byte size field
	lsh w2,30.
	iorm w2,opfbts		;and put it in OPENF
	jrst openf2

;now we have the bits set up in the stack - O1 is file list
;Make channel and do GTJFN if needed
;This entry is used by INPUT and OUTPUT
openfj:	xtype o1
	cain w2,ty%xch		;if already a channel
	jrst openfo		;go directly to OPEN
	scons o1		;if list
	jrst [push q,nil	;not - treat it as singleton
	      jrst openf3]
	push q,o1		;save arg list
	docar o1,o1		;get first one for now
openf3:	call mflnam		;put name in FILNAM
	move nil1,gtjbts	;find the gtjfn bits
	tlo nil1,(gj%sht+gj%flg) ;standard bits
	hrroi w2,filnam
	gtjfn
	 erjmp [skipn errflg
		jrst oper
		adjsp q,-1
		adjsp p,-4
		setzb nil1,o1
		ret]
	skipe cntflg		;if asking for continuous
	tlo nil1,(gn%cnt)	;then set that bit
	call makchn		;make a channel with that JFN in it
	pop q,o2		;get back arg list
	docdr o2,o2		;any more?
	jumpe o2,openfo		;no - done
	sos ch%spc(o1)		;yes - put the rest in list
	movem o2,ch%dat(o1)
;Open the file if called for.
; This entry is used by eoferr
openfo:	skipn opfbts		;does he want any open functions?
	jrst openfx		;no - forget it - channel already in O1
	hrrz nil1,ch%jfn(o1)	;get JFN
	gtsts			;see if it is open
	tlnn w2,(gs%opn)	;is it open?
	jrst openff
 ;file is open, we must close it
	movsi w2,(co%nrj)	;don't release JFN!
	call doclos		;dev-specific and monitor close
	 jrst opfer
openff:	hrrz nil1,ch%jfn(o1)	;get back pure jfn
	dvchr			;see what we have
	ldb w4,[.bp 777_18.,w2]	;device type
	hrrz nil1,ch%jfn(o1)	;get back jfn again
	move w2,opfbts		;and openf bits
	tlnn w2,770000		;already have byte size?
	tlo w2,070000		;no - add in 7-bit mode
 ;this is code to let us try simulating append with normal read/write I/O
	cain w4,.dvdsk		;disk?
	trnn w2,of%app		;append?
	jrst openfn		;no or no - just go ahead
	trz w2,of%app		;first try to let us simulate - clear append
	tro w2,of%wr\of%rd	;first try to let us simulate using read/write
	openf
	 erjmp [move w2,opfbts		;oh, well, try again the original way
		tlnn w2,770000		;already have byte size?
		tlo w2,070000		;no - add in 7-bit mode
		hrrz nil1,ch%jfn(o1)	;get back pure jfn
		jrst openfn]
	jrst openfy
 ;end of special append code
openfn:	openf
	 erjmp [skipn errflg
		jrst opfer
		adjsp p,-4
		rljfn
		 erjmp .+1
		setzb nil1,o1
		ret]
;we now have a file open.  Do device depend initialization if needed
openfy:	move w4,opfbts
	call opendv
;done - restore things
openfx:	adjsp p,-4
	setzb nil,nil1
	ret

;OPENDV is a general routine, usable by anyone who opens files and
;wants the right device-specific stuff.  We assume that the channel
;has already been set up except the DSK specific stuf.  W4 contains
;the OPENF bits, including byte size.
opendv:	move w2,[codsec,,norget] ;initialize for random device
	movem w2,ch%get(o1)
	move w2,[codsec,,norput]
	movem w2,ch%put(o1)
	move w2,[codsec,,nordsp]
	movem w2,ch%dsp(o1)
	hrrz nil1,ch%jfn(o1)	;get back pure jfn
	dvchr			;see what we have
	ldb w2,[.bp 777_18.,w2]	;device type
	cain w2,.dvdsk		;disk?
	call dskopn		;yes - set up for PMAP I/O
	setz nil1,
	ret

;RENAME
; o1 - file or channel
; o2 - file name
; o3 - non-NIL to suppress release
;returns file name if it works, NIL if not
rename:	push q,o3		;save args
	push q,o2
	move o2,[object ty%ccn,<datsec,,oldopt>]  ; '(OLD ERROR)
	call xopenf		;get jfn if necessary
	jumpe o1,renerr		;if error, stop
	hrrz nil1,ch%jfn(o1)	;close if still open
	gtsts
	tlnn w2,(gs%opn)	;if open
	jrst renam1
	movsi w2,(co%nrj)	;don't release
	call doclos		;dev-specific and monitor close
	 jrst renerr
renam1:	exch o1,(q)		;save channel, get new name
	call mflnam		;put name in FILNAM
	move nil1,[gj%fou+gj%sht] ;get jfn for new file
	hrroi w2,filnam
	gtjfn
	 erjmp renerr
	move w2,nil1		;2 - new jfn
	move o1,(q)		;old channel
	hrrz nil1,ch%jfn(o1)	;1 - old jfn
	rnamf
	 erjmp renerr
	movem w2,ch%jfn(o1)	;channel now has new JFN
	skipe -1(q)		;allow close?
	jrst renex		;no - done
	move nil1,w2		;yes - release
	rljfn
	 erjmp .+1
	setzm ch%jfn(o1)	;everything is gone now
renex:	adjsp q,-2
	setz nil1,
	ret

renerr:	setzb nil1,o1
	adjsp q,-2
	ret

;DELETE
; o1 - file or channel
; o2 - non-NIL to suppress release
;returns file name if it works, NIL if not
delete:	push q,o2		;save args
	move o2,[object ty%ccn,<datsec,,oldopt>]  ; '(OLD ERROR)
	call xopenf		;get jfn if necessary
	jumpe o1,delerr		;if error, stop
	hrrz nil1,ch%jfn(o1)	;close if still open
	gtsts
	tlnn w2,(gs%opn)	;if open
	jrst delet1
	movsi w2,(co%nrj)	;don't release
	call doclos
	 jrst delerr
delet1:	hrrz nil1,ch%jfn(o1)
	skipe (q)		;keep jfn?
	tlo nil1,(df%nrj)	;yes
	delf
	 erjmp delerr
	skipn (q)		;keep jfn?
	setzm ch%jfn(o1)	;no - none left
	setz nil1,
	adjsp q,-1
	ret

delerr:	setzb nil1,o1
	adjsp q,-1
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here are the old file I/O functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;xinput - this is OPENIN.  It is an FEXPR that takes a list of file names.

xinput:	push p,[0]
	push p,[070000000000+of%rd]
	push p,[gj%old+gj%ifg+gj%flg+gj%sht]	;allow wildcards
	push p,[-1]		;continue to next file
	jrst openfj		;now let openf do it

;;TY%CHN
;makchn - make channel object for real I/O device, jfn in NIL1
makchn:	push free,[object ty%spc,ch%666] ;GC code
	move w2,free		;save addr to return
	push free,nil1		;jfn
	push free,[72.]		;len
	push free,[0]		;pos
	push free,[codsec,,errio] ;get
	push free,[codsec,,errio] ;put
	push free,[0]		;lka
	push free,[0]		;lst
	push free,[codsec,,errdsp] ;normal dispatch table
	movei w3,ch%666-ch%dsp	;number of extra entries needed
	push free,[0]
	sojg w3,.-1
	tlo w2,(object ty%chn,0)
	move o1,w2		;return new channel
	setz nil1,
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

xoutpu:	push p,[0]
	push p,[070000000000+of%rd+of%wr]
	push p,[gj%fou+gj%sht]
	push p,[0]
	jrst openfj		;now let openf do it

;here for error from openf - file in O1
;actually the error message used is from the monitor, so this case
;be used for any error in which there is a file in O1
opfer2:	move o1,o2		;file is on O2
opfer:	hrrz w2,ch%jfn(o1)	;get name for this file
	hrroi nil1,filnam
	setz w3,		;default format
	jfns
;here for error from gtjfn - file name in FILNAM
oper:	hrroi nil1,errmsg	;put it here
	move w2,[.fhslf,,-1]	;most recent error for this process
	hrlzi w3,-maxerr*5	;this many char's
	erstr
	 jrst operx
	 jrst operx
	move o6,[object ty%adr,errmsg] ;print the message returned
	move o1,[object ty%cst,<codsec,,filnam-1>]
	jrst perror

operx:	perr /Error in file operation/

;;TY%CHN
;JFNS 
; O1 - channel or string
; O2 - format bits, as integer
xjfns:	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst stjfns		;if string or atom, special
	skipn w2,ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	trne w2,777700		;and legal range for JFN (i.e. no .PRIIN)
	jrst [perr /JFNS is only legal for files/]
	push free,[object(ty%spc,0)] ;now make string - dont know how big
	exch o1,o2		;get code into O1
	skipn o1		;if nil
	move o1,[object(ty%int,0)] ;use default
	call getint		;value into W2
	move w3,w2		;this is format
	move nil1,[.bp 376,(free)] ;destination - free space
	hrrz w2,ch%jfn(o2)	;source - this file
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
;now we have to make sure the unused portions of these words are zero
strret:	movei w4,1		;clear this bit
	hrrz w2,nil1		;we used this many words
	hrrm w2,(free)		;note that fact in header
	move o1,free		;remember start as final string
	tlo o1,(object(ty%str,0))
	jumpe w2,xjfns2		;now loop over words
xjfns1:	aoj free,		;incrementing free
	andcam w4,(free)	;and clearing bit
	sojg w2,xjfns1
xjfns2:	seto w3,		;now handle the last word
	setz w2,		;w2,w3 = 0,,0,,-1,,-1
	lsh nil1,-30.		;nil1 is now offset to rightmost bit used
	lshc w2,(nil1)		;give us ones for the rest
	andcam w2,(free)	;and clear those bits in last word
	setz nil1,		;that's it - O1 was set above
	camle free,lastl	;see if need GC
	 call sgc
	ret		

;STJFNS - O1 is a string.  We want to use JFNS to return a certain
; field from the string.  To do this, we get a parse-only JFN on it,
; do the JFNS, and then release the JFN.
stjfns:	call getstr
	movsi nil1,(gj%sht+gj%ofg) ;parse-only jfn
	move w2,[440705,,1]	;POINT 7,1(O1)
	gtjfn
	 erjmp retnil
	push free,[object(ty%spc,0)] ;now make string - dont know how big
	exch o1,o2		;get code into O1
	skipn o1		;if nil
	move o1,[object(ty%int,0)] ;use default
	call getint		;value into W2
	move w3,w2		;this is format
	move w2,nil1		;jfn in W2
	move nil1,[.bp 376,(free)] ;destination - free space
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
	push p,nil1		;save pointer
	move nil1,w2		;JFN to 1
	rljfn
	 erjmp .+1
	pop p,nil1
	jrst strret	

;(GTFDB chan word#)
xgtfdb:	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn nil1,ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	trne nil1,777700	;and legal range for JFN (i.e. no .PRIIN)
	jrst [perr /GTFDB is only legal for files/]
	hrrz nil1,nil1		;get JFN part only
	move o1,o2		;get integer value
	call getint		;into W2
	hrli w2,1		;count in left
	movei w3,o1		;place to put result
	gtfdb
	setz nil1,
	move w2,o1
	jrst retint

;;TY%CHN
ddtin:	move w2,[codsec,,trmget] ;normal terminal input routine
	skipe o1		;but if DDTIN T
	move w2,[codsec,,ddtget] ;special routine
	exch w2,@[datsec,,inchn+ch%get] ;use as read char
	move o1,nil		;return prev
	came w2,[codsec,,trmget]
	move o1,[%T]
	ret

;;TY%CHN
;INCH - return current input 
inch:	move o1,@[datsec,,.curin]
	camn o1,@[datsec,,priin] ;return NIL if primary input
	move o1,nil
	ret

;;TY%CHN
;OUTCH - return current output
outch:	move o1,@[datsec,,.curout]
	camn o1,@[datsec,,priout] ;return NIL if primary output
	move o1,nil
	ret

;;TY%CHN
inc:	jumpe o2,inc1		;no close
	push q,o1		;save arg
	move o1,@[datsec,,.curin]
	call xclose
	pop q,o1		;get back new chan
inc1:	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	exch o1,@[datsec,,.curin]
	camn o1,@[datsec,,priin] ;return NIL if primary input
	move o1,nil
	ret

;;;;;CWTHIN and CWTHOU are for compiled functions:
;;;;;  move o1,channel   ;non-NIL corresponds to T in WITHIN
;;;;;  move o2,flag
;;;;;  call cwthin
;;;;;  jrst ret+1
;;;;;  code inside the within
;;;;;  ret


;;TY%CHN
;WITHIN - For compactness, we use the special coroutine kludge designed
;  for compiled code
within:	setz o3,		;assume the close flag is not given
	docar o2,o1		;look at car
	came o2,[%T]		;if T, then must save for close on exit
	jrst wthin1
	move o3,o2		;it was - say so
	docdr o1,o1		;and skip over the T
wthin1:	pushcdr q,o1		;save forms
	push q,o3		;and flag
	docar o1,o1		;get channel
	call eval
	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
;now that the args are set up, we do a call to CWTHIN, just as would
;be done from compiled code
				;o1 is already the channel
	pop q,o2		;o2 is the flag
	pop q,o3		;o3 is the code to execute
	call cwthin
	 jrst cpopj		;this is done at the end
	 move o1,o3		;here is the thing we do
	 call progn		;a progn
	 ret			;returns to the JRST WTHIN2


;;TY%CHN
withou:	push p,[0]		;0 is normal case, -1 if must close channel
	docar o2,o1		;look at car
	came o2,[%T]		;if T, then must save for close on exit
	jrst wthou1
	setom (p)		;flag that we saw T
	docdr o1,o1		;and skip over the T
wthou1:	pushcdr q,o1		;save forms
	docar o1,o1		;get channel
	call eval
	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	skipn (p)		;if must have it closed on exit
	jrst wthou2		;no worry
	move o2,@[datsec,,.CFILES] ;get list of files to close
	docons o3,o1,o2		;add new one
	move w2,sp
	tlo w2,(object(ty%adr,0)) ;and SP where it is relevant
	docons o2,w2,o3
	movem o2,@[datsec,,.CFILES]
wthou2:	movem sp,(p)		;save for unbind (replaces flag at (P) )
	push sp,[%CUROU]	;save current channel
	push sp,@[datsec,,.curou]
	movem o1,@[datsec,,.curou] ;and reset to terminal
	pop q,o1
	call progn
	jrst cubind		;restore channel, closing files

;;;;;CWTHIN and CWTHOU are for compiled functions:
;;;;;  move o1,channel   ;non-NIL corresponds to T in WITHIN
;;;;;  move o2,flag
;;;;;  call cwthin
;;;;;  jrst ret+1
;;;;;  code inside the within
;;;;;  ret

;;TY%CHN
cwthin:	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	jumpe o2,cwthn2		;skip following if not flagged
	push q,o3
	move o2,@[datsec,,.CFILES] ;get list of files to close
	docons o3,o1,o2		;add new one
	move w2,sp
	tlo w2,(object(ty%adr,0)) ;and SP where it is relevant
	docons o2,w2,o3
	movem o2,@[datsec,,.CFILES]
	pop q,o3
cwthn2:	push p,sp		;save for unbind
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	movem o1,@[datsec,,.curin] ;and reset to terminal
	call wtherr		;this does what the user wanted, in an errset
	 skipa			;error return - diagnose it
	jrst cubind		;normal return - restore channel, closing
	came o1,[%$eof$]	;end of file?
	call uerr		;no - just propagate the error
	setz o1,		;yes - return nil
	jrst cubind


;WTHERR is the ERRSET inside WITHIN
wtherr:	move o1,[%T]		;make this a default errset
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG]	;save F for ERROR
	movem o1,@[datsec,,.ERRFLAG]
	move w2,-4(p)		;get address to go to for user's code
	call 1(w2)
	aos -2(p)		;if we get to here, it is success
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst cubind		;restores old TOPERR


;;TY%CHN
cwthou:	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	jumpe o2,cwtho2		;skip following if not flagged
	push q,o3
	move o2,@[datsec,,.CFILES] ;get list of files to close
	docons o3,o1,o2		;add new one
	move w2,sp
	tlo w2,(object(ty%adr,0)) ;and SP where it is relevant
	docons o2,w2,o3
	movem o2,@[datsec,,.CFILES]
	pop q,o3
cwtho2:	push p,sp		;save for unbind
	push sp,[%CUROU]	;save current channel
	push sp,@[datsec,,.curou]
	movem o1,@[datsec,,.curou] ;and reset to terminal
	move w2,-1(p)		;get ret addr
	call 1(w2)		;call one beyond
	jrst cubind		;restore channel, closing files

;;TY%CHN
outc:	jumpe o2,outc1		;no close
	push q,o1		;save new chan
	move o1,@[datsec,,.curout]
	call xclose
	pop q,o1		;get back new chan
outc1:	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary output
	xtype o1		;make sure its a channel
	caie w2,ty%xch	
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	exch o1,@[datsec,,.curout]
	camn o1,@[datsec,,priout] ;return nil if priout
	move o1,nil
	ret

;;TY%CHN
;This function should never give an error, unless it is given an object
;that couldn't be a legal channel.  I.e. it should be legal to close
;channels that are already closed, etc.
xclose:	jumpe o1,cpopn1		;if nil, no-op
	setz o2,		;release JFN
closef:	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, noop
	cain nil1,.priou
	jrst cpopn1
	jumpe nil1,retnil	;also if nothing there any more, already done
	gtsts
	 erjmp closz		;trap all errors
	tlnn w2,(gs%nam)	;something wrong with JFN?
	jrst closz		;yes - forget it all
	tlnn w2,(gs%opn)	;is it open?
	jrst closno		;no - release it instead
	push q,o2		;save flag
	setz w2,		;no funny bits
	skipe o2		;except if requested to keep jfn
	tlo w2,(co%nrj)		;then do so
	call doclos		;call common routine for actual close
	 jrst .+1
	pop q,o2
	skipn o2		;unless kept jfn
closz:	setzb o1,ch%jfn(o1)	;say nothing there now
closx:	setz nil1,
	ret

;here if JFN not open - release it instead
closno:	skipe o2		;if keeping JFN
	jrst closx		;nothing to do
	rljfn
	 erjmp .+1		;ignore errors
	setzb o1,ch%jfn(o1)	;nothing there now
	setz nil1,
	ret

;doclos - routine to close a file.  File in O1, close bits in W2
doclos:	push p,w2		;save bits
	move w2,ch%dsp(o1)	;dispatch
	call @ch%clo(w2)	;dev-specific close
	pop p,nil1		;get back bits
	hrr nil1,ch%jfn(o1)	;and add in JFN
	closf
	 erjmp .+2		;error return
	aos (p)			;normal return
	setz nil1,
	ret


illchn:	perr /Illegal I-O channel/

notopn:	perr /I-O channel not open/

;;;;;Various restart addresses

;internal restart - here to restart clearing typeahead
restac:	call clrin
	jrst restar

;external restart, i.e. used by START command
rstart:	cis			;clear any interrupts, since this may
				;have been done from interrupt level if
				;he did ^C
	setzm crit		;forget it if we are in crit section
;internal restart - here to restart without clearing typeahead
restar:	setzb nil1,nil
	setzb o1,o2		;make sure AC's are valid
	setzb o3,o4
	setzb o5,o6
	seto n,
	move p,savep
	move q,saveq
	move w2,savesp		;get known valid SP
	xor w2,sp		;compare with current
	tlne w2,1		;if different parity
	adjsp sp,-1		;then adjust to valid
	move w2,savesp
	call cubin1		;unbind, closing files passed
	move sp,savesp
	move w2,[jfcl]
	movem w2,evhook
	move o1,nil
	move o2,[%T]
	call inc
	move o1,nil
	move o2,[%T]
	call outc
	setzm @[datsec,,.rdtop]
	setzm @[%BKSAVE]
	move o1,[object ty%int,0]
	movem o1,@[%INDENT]
	move o1,[%t]
	movem o1,@[datsec,,.dointern]	;turn on interning
	jrst toplev

;The number stuff will go here
;

%INF=<object(ty%int,3777777777)>

;ldreal - loads real number into w2 and w3 from pointer
define ldreal(pnt)
	dmove w2,1(pnt)
	termin

minus:	getdsp o1
	xct minust(w2)
	jrst notnum		;for atom case, if not NIL

;;TYPES
minust:	jumpe o1,minusi		;NIL ==> 0, else error
	jrst notnum			;  constant atom
	jrst notnum		; cons
	jrst notnum		;  constant cons
	jrst notnum		; string
	jrst notnum		;  constant string
	jrst notnum		; channel
	jrst notnum		;  constant channel
	jrst minusi		; integer
	jrst minusr		; real
	jrst minusb		; bignum
	jrst notnum		; hunk
	jrst notnum		; address
	jrst notnum		; special
	jrst notnum		;16
	jrst notnum		;17

minusi:	move w2,o1		;integer version (also uses NIL)
	getnum w2
	jrst minusc		;go to common integer code

minusb:	move w2,1(o1)		;fixnum version - get number
minusc:	movn w2,w2		;common code - do the negate
	jrst retint

minusr:	ldreal o1		;real version
	dmovn w2,w2		;negate it
	;jrst retrea		;return the value

;;TY%REA
;return real number, in w2 and w3
retrea:	push free,[object(ty%spc,2)] ;now make real number object
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%rea,0))
	move o1,w4		;and return that
	push free,w2
	push free,w3
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

;;TY%INT
;;TY%BIG
;Lisp object in O1.  Returns integer value in w2
getint:	gettyp o1
	cain w2,ty%int
	jrst getin1
	cain w2,ty%big
	jrst getin2
	perr /Must be an integer/
;small integer
getin1:	move w2,o1
	getnum w2
	ret
;bignum
getin2:	move w2,1(o1)
	ret

;;TY%INT
;;TY%BIG
;return integer, in w2.  Assume jov has been done, so any overflow is due
;to the ASH here
retint:	move w3,w2		;save value
	ash w3,6		;see if fits in 30 bits
	jov retbig		;no - use BIGNUM format
	lsh w3,-6
	tlo w3,(object(ty%int,0)) ;INUM
	move o1,w3		;return it
	ret

retbig:	push free,[object(ty%spc,1)] ;now make real number object
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%big,0))
	move o1,w4		;and return that
	push free,w2
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all


;in w4 - a table giving the operation for each legal type combination
numop:	jov .+1
	getdsp o1
	jrst @numt1(w2)

;;TYPES
numt1:	codsec,,notnum		;atom
	codsec,,notnum			;  constant atom
	codsec,,notnum		; cons
	codsec,,notnum		;  constant cons
	codsec,,notnum		; string
	codsec,,notnum		;  constant string
	codsec,,notnum		; channel
	codsec,,notnum		;  constant channel
	codsec,,numo1i		; integer
	codsec,,numo1r		; real
	codsec,,numo1b		; bignum
	codsec,,notnum		; hunk
	codsec,,notnum		; address
	codsec,,notnum		; special
	codsec,,notnum		;16
	codsec,,notnum		;17

numo1i:	getdsp o2
	jrst @numt2i(w2)

;;TYPES
numt2i:	codsec,,notnm2		;atom
	codsec,,notnm2			;  constant atom
	codsec,,notnm2		; cons
	codsec,,notnm2		;  constant cons
	codsec,,notnm2		; string
	codsec,,notnm2		;  constant string
	codsec,,notnm2		; channel
	codsec,,notnm2		;  constant channel
	codsec,,numoii		; integer
	codsec,,numoir		; real
	codsec,,numoib		; bignum
	codsec,,notnm2		; hunk
	codsec,,notnm2		; address
	codsec,,notnm2		; special
	codsec,,notnm2		;16
	codsec,,notnm2		;17

numo1b:	getdsp o2
	jrst @numt2b(w2)

;;TYPES
numt2b:	codsec,,notnm2		;atom
	codsec,,notnm2			;  constant atom
	codsec,,notnm2		; cons
	codsec,,notnm2		;  constant cons
	codsec,,notnm2		; string
	codsec,,notnm2		;  constant string
	codsec,,notnm2		; channel
	codsec,,notnm2		;  constant channel
	codsec,,numobi		; integer
	codsec,,numobr		; real
	codsec,,numobb		; bignum
	codsec,,notnm2		; hunk
	codsec,,notnm2		; address
	codsec,,notnm2		; special
	codsec,,notnm2		;16
	codsec,,notnm2		;17

numo1r:	getdsp o2
	jrst @numt2r(w2)

;;TYPES
numt2r:	codsec,,notnm2		;atom
	codsec,,notnm2			;  constant atom
	codsec,,notnm2		; cons
	codsec,,notnm2		;  constant cons
	codsec,,notnm2		; string
	codsec,,notnm2		;  constant string
	codsec,,notnm2		; channel
	codsec,,notnm2		;  constant channel
	codsec,,numori		; integer
	codsec,,numorr		; real
	codsec,,numorb		; bignum
	codsec,,notnm2		; hunk
	codsec,,notnm2		; address
	codsec,,notnm2		; special
	codsec,,notnm2		;16
	codsec,,notnm2		;17

;At the moment the following combinations are defined.  These are the indices
;to the operation tables passed in W4.  Note that there are more than this
;number of entries, because there are separate BIGNUM entires, but the
;not separate operation tables, since BIGNUM and INUM use the same code
;  0 - integer, integer
;  1 - real, integer
;  2 - integer, real
;  3 - real, real


;;0 - INTEGER, INTEGER;  4 versions because of BIGNUM's
numoii:	move w2,o1
	getnum w2
	move w3,o2
	getnum w3
	xct (w4)
	jov intovr
	jrst retint

numobi:	move w2,1(o1)
	move w3,o2
	getnum w3
	xct (w4)
	jov intovr
	jrst retint

numoib:	move w2,o1
	getnum w2
	move w3,1(o2)
	xct (w4)
	jov intovr
	jrst retint

numobb:	move w2,1(o1)
	move w3,1(o2)
	xct (w4)
	jov intovr
	jrst retint	

;;1 - REAL, INTEGER, in two versions because of BIGNUM's

numori:	move w3,o2		;convert second to real
	getnum w3		;put value in w3
	jrst numorc

numorb:	move w3,1(o2)
numorc:	jumpl w3,reain1		;if negative, special
	move w2,[<62.+200>_27.]	;and exp in w2
	dfad w2,nil		;normalize by adding 0
reain2:	push p,w2
	push p,w3		;now they are on stack
	ldreal o1		;and o1 is in w2,w3
	xct 1(w4)
	jov reaovr
	adjsp p,-2
	jrst retrea

reain1:	movn w3,w3		;get positive form
	move w2,[<62.+200>_27.] ;and exp in w2
	dfad w2,nil		;normalize by adding 0
	dmovn w2,w2		;negate the whole thing
	jrst reain2

;;2 - INTEGER, REAL, in 2 versions because of BIGNUM's
numoir:	move w3,o1		;convert first to real
	getnum w3		;put value in w3
	jrst numocr

numobr:	move w3,1(o1)
numocr:	jumpl w3,intre1		;if negative, special
	move w2,[<62.+200>_27.]	;and exp in w2
	dfad w2,0		;normalize by adding 0
intre2:	xct 2(w4)
	jov reaovr
	jrst retrea

intre1:	movn w3,w3		;get positive form
	move w2,[<62.+200>_27.] ;and exp in w2
	dfad w2,0		;normalize by adding 0
	dmovn w2,w2		;negate the whole thing
	jrst intre2


;;3 - REAL, REAL
numorr:	ldreal o1		;o1 to w2,w3
	xct 3(w4)
	jov reaovr
	jrst retrea
	
	
intovr:	err /Integer result too big/

reaovr:	err /Real overflow/

notnm2:	move o1,o2
notnum:	perr /Argument to numerical function is not a number/

diff:	movei w4,[sub w2,w3
		 dfsb w2,-1(p)
		 dfsb w2,1(o2)
		 dfsb w2,1(o2)]
	jrst numop

quot:	movei w4,[idiv w2,w3
		 dfdv w2,-1(p)
		 dfdv w2,1(o2)
		 dfdv w2,1(o2)]
	jrst numop

plus:	movei w4,[add w2,w3
		 dfad w2,-1(p)
		 dfad w2,1(o2)
		 dfad w2,1(o2)]
	jrst numop

times:	movei w4,[imul w2,w3
		 dfmp w2,-1(p)
		 dfmp w2,1(o2)
		 dfmp w2,1(o2)]
	jrst numop

eqp:	movei w4,[jrst eqp1
		 jrst eqp2
		 jrst eqp3
		 jrst eqp3]
	jrst numop

eqp1:	camn w2,w3
	jrst rett
	jrst retnil

eqp2:	camn w2,-1(p)
	came w3,(p)
	skipa o1,nil
	move o1,[%T]
	adjsp p,-2
	ret

eqp3:	camn w2,1(o2)
	came w3,2(o2)
	jrst retnil
	jrst rett

;iniint - initialize arg values into w2 and w3, assuming they are integers
iniint:	gettyp o2
	cain w2,ty%int
	jrst iniin3
	caie w2,ty%big
	jrst notin2
	move w3,1(o2)
iniin1:	gettyp o1
	cain w2,ty%int
	jrst iniin4
	caie w2,ty%big
	jrst notint
	move w2,1(o1)
iniin2:	ret

iniin3:	move w3,o2
	getnum w3
	jrst iniin1

iniin4:	move w2,o1
	getnum w2
	jrst iniin2

notin2:	move o1,o2
notint:	perr /Argument to an integer function not an integer/

rem:	call iniint
	jov .+1
	idiv w2,w3
	jov intovr
	move w2,w3
	jrst retint

;divide - (quotient . remainder)
divid:	call iniint
	jov .+1
	idiv w2,w3
	jov intovr
	push p,w3	;(p) - rem
	call retint	;o1 - quot
	push q,o1	;(q) - quot
	pop p,w2	;w2 - rem
	call retint	;o1 - rem
	move o3,o1	;o3 - rem
	pop q,o2	;o2 - quot
	docons o1,o2,o3	;o1 (quot.rem)
	ret
	
;GCD
gcd:	call iniint	;args to w2,w3
	jov .+1
	movm w2,w2
	movm w3,w3
	jov intovr
;euclid's algorithm
	camg w3,w2
	exch w3,w2	;larger to w3
	jumpe w2,gcdx	;smaller is zero, return larger
gcdl:	idiv w3,w2	;remainder in w3
	move w3,w2
	move w2,w4	;use smaller and remainder
	jumpn w2,gcdl
gcdx:	move w2,w3	;return larger
	jrst retint

;BOOLE - LSUBR, 1st arg is code, rest are combined
;o3 - arg count
;nil1 - boole code (first arg)
;w3 - place for building up result
boole:	move w4,q		;w4 - addr of last arg
	sub w4,o1		;w4 - below first arg
	tlz w4,770000
	tdnn o1,[377777776]	;any args?
	jrst [perr /BOOLE needs at least 2 args/]
	move o3,o1		;move count
	move o1,1(w4)		;boole code
	gettyp o1
	caie w2,ty%int
	jrst notint		;o2 is 0 to 17
	move nil1,o1
	getnum nil1
	cail nil1,0
	caile nil1,17
	jrst [perr /BOOLE - function must be 0 to 15/]
	lsh nil1,29.		;put into bits 074000,,0
	ior nil1,[setz w3,w2]
	move o1,2(w4)		;first arg
	call getint		;to w2
	move w3,w2		;accum in w3
boolel:	aoj w4,			;incr pointer
	soj o3,			;and decr count
	tdnn o3,[377777776]	;any args?
	jrst boolex		;no - done
	move o1,2(w4)		;yes - get it
	call getint		;to w2
	xct nil1		;and combine into w3
	jrst boolel		;now see if more

boolex:	setz nil1,		;clear up NIL1
	move w2,w3
	jrst retint

ifn old,[
;*BOOLE
;o1 - which function
;o2 - arg 1
;o3 - arg 2
sboole:	gettyp o1
	caie w2,ty%int
	jrst notint	;o1 is 0 to 17
	move w4,o1
	getnum w4
	cail w4,0
	caile w4,17
	jrst [perr /BOOLE - function must be 0 to 15/]
	dmove o1,o2	;get args into o1 and o2 for iniint
	call iniint	;arg values now in W2, W3
	lsh w4,29.	;put into bits 074000,,0
	ior w4,[setz w2,w3]
	xct w4
	jrst retint

] ;ifn old


;lsh
lshf:	call iniint	;args to w2,w3
	lsh w2,(w3)
	jrst retint

;numberp
nump:	gettyp o1
	cail w2,ty%nst
	caile w2,ty%nen
	jrst retnil
	jrst rett

;inump
inump:	gettyp o1
	caie w2,ty%int
	jrst retnil
	jrst rett

;numtype
numtyp:	getdsp o1
	xct nmtytb(w2)
	ret

nmtytb:	jrst notnum		;atom
	jrst notnum		;  constant atom
	jrst notnum		; cons
	jrst notnum		;  constant cons
	jrst notnum		; string
	jrst notnum		;  constant string
	jrst notnum		; channel
	jrst notnum		;  constant channel
	move o1,[%INUM]		; integer
	move o1,[%FLONUM]	; real
	move o1,[%FIXNUM]	; bignum
	jrst notnum		; hunk
	jrst notnum		; address
	jrst notnum		; special
	jrst notnum		;16
	jrst notnum		;17

;zerop
zerop:	getdsp o1
	jrst @zeropt(w2)

;;TYPES
zeropt:	codsec,,notnum		;atom
	codsec,,notnum			;  constant atom
	codsec,,notnum		; cons
	codsec,,notnum		;  constant cons
	codsec,,notnum		; string
	codsec,,notnum		;  constant string
	codsec,,notnum		; channel
	codsec,,notnum		;  constant channel
	codsec,,zeropi		; integer
	codsec,,zeropr		; real
	codsec,,zeropb		; bignum
	codsec,,notnum		; hunk
	codsec,,notnum		; address
	codsec,,notnum		; special
	codsec,,notnum		;16
	codsec,,notnum		;17

zeropi:	camn o1,[object ty%int,0]
	jrst rett
	jrst retnil

;;TY%BIG
zeropb:	skipe 1(o1)
	jrst retnil
	jrst rett

;;TY%REA
zeropr:	skipn 1(o1)
	skipe 2(o1)
	jrst retnil
	jrst rett

;SUB1
sub1:	getdsp o1
	jrst @sub1t(w2)

;;TYPES
sub1t:	codsec,,notnum		;atom
	codsec,,notnum			;  constant atom
	codsec,,notnum		; cons
	codsec,,notnum		;  constant cons
	codsec,,notnum		; string
	codsec,,notnum		;  constant string
	codsec,,notnum		; channel
	codsec,,notnum		;  constant channel
	codsec,,sub1i		; integer
	codsec,,sub1r		; real
	codsec,,sub1b		; bignum
	codsec,,notnum		; hunk
	codsec,,notnum		; address
	codsec,,notnum		; special
	codsec,,notnum		;16
	codsec,,notnum		;17

sub1i:	came o1,[object ty%int,0]	;would overflow into type field
	camn o1,[object ty%int,4000000000] ;or sign bit
	jrst sub1x
	subi o1,1
	ret

sub1x:	move w2,o1
	getnum w2
	jrst sub1c
	ret


sub1b:	move w2,1(o1)
sub1c:	jov .+1
	subi w2,1
	jov intovr
	jrst retint

;;TY%REA
sub1r:	jov .+1
	ldreal o1
	dfsb w2,[1.0 ? 0]
	jov reaovr
	jrst retrea

;ADD1
add1:	getdsp o1
	jrst @add1t(w2)

;;TYPES
add1t:	codsec,,notnum		;atom
	codsec,,notnum			;  constant atom
	codsec,,notnum		; cons
	codsec,,notnum		;  constant cons
	codsec,,notnum		; string
	codsec,,notnum		;  constant string
	codsec,,notnum		; channel
	codsec,,notnum		;  constant channel
	codsec,,add1i		; integer
	codsec,,add1r		; real
	codsec,,add1b		; bignum
	codsec,,notnum		; hunk
	codsec,,notnum		; address
	codsec,,notnum		; special
	codsec,,notnum		;16
	codsec,,notnum		;17

;;TY%INT
add1i:	came o1,[object ty%int,7777777777]  ;would carry into type field
	camn o1,[object ty%int,3777777777]  ;would carry into sign bit
	jrst add1x
	addi o1,1
	ret

add1x:	move w2,o1
	getnum w2
	jrst add1c

;;TY%BIG
add1b:	move w2,1(o1)
add1c:	jov .+1
	addi w2,1
	jov intovr
	jrst retint

;;TY%REA
add1r:	jov .+1
	ldreal o1
	dfad w2,[1.0 ? 0]
	jov reaovr
	jrst retrea

;minusp
minusp:	getdsp o1
	xct minupt(w2)
	jrst notnum

;;TYPES
minupt:	jrst notnum		;atom
	jrst notnum			;  constant atom
	jrst notnum		; cons
	jrst notnum		;  constant cons
	jrst notnum		; string
	jrst notnum		;  constant string
	jrst notnum		; channel
	jrst notnum		;  constant channel
	jrst minupi		; integer
	jrst minupr		; real
	jrst minupb		; bignum
	jrst notnum		; hunk
	jrst notnum		; address
	jrst notnum		; special
	jrst notnum		;16
	jrst notnum		;17

minupi:	move w2,o1
	getnum w2
	jumpl w2,rett
	jrst retnil

;;TY%REA
;;TY%BIG
minupb:
minupr:	skipl 1(o1)
	jrst retnil
	jrst rett


;abs
absf:	jov .+1
	getdsp o1
	xct absft(w2)
	jrst notnum

;;TYPES
absft:	jrst notnum		;atom
	jrst notnum			;  constant atom
	jrst notnum		; cons
	jrst notnum		;  constant cons
	jrst notnum		; string
	jrst notnum		;  constant string
	jrst notnum		; channel
	jrst notnum		;  constant channel
	jrst absfi		; integer
	jrst absfr		; real
	jrst absfb		; bignum
	jrst notnum		; hunk
	jrst notnum		; address
	jrst notnum		; special
	jrst notnum		;16
	jrst notnum		;17

absfi:	move w2,o1
	getnum w2
	movm w2,w2
	jov intovr
	jrst retint

;;TY%REA
;;TY%BIG
absfb:	move w2,1(o1)
	movm w2,w2
	jov intovr
	jrst retint

absfr:	dmove w2,1(o1)
	caige w2,0		;if negative
	dmovn w2,w2		;negate it
	jov intovr
	jrst retrea
;FIX
fixf:	getdsp o1
	xct fixft(w2)
	jrst notnum

;;TYPES
fixft:	jrst notnum		;atom
	jrst notnum			;  constant atom
	jrst notnum		; cons
	jrst notnum		;  constant cons
	jrst notnum		; string
	jrst notnum		;  constant string
	jrst notnum		; channel
	jrst notnum		;  constant channel
	ret			; integer - already fixed
	jrst fixfr		; real
	ret			; bignum - already fixed
	jrst notnum		; hunk
	jrst notnum		; address
	jrst notnum		; special
	jrst notnum		;16
	jrst notnum		;17

fixfr:	jov .+1
	dmove w2,1(o1)		;value to w2,w3
	skipge w2		;treat negative separately
	jrst fixfn
	ldb w4,[.bp <377_27.>,w2]	;get exponent
	tlz w2,377000		;and clear it
	ashc w2,-200-27.(w4)	;now shift bits so integer part in w2
	jov intovr
	jrst retint

fixfn:	ldb w4,[.bp <377_27.>,w2]	;get exponent
	movn w4,w4
	tlo w2,377000		;and clear it
	ashc w2,177-27.(w4)	;now shift bits so integer part in w2
	jov intovr
	jrst retint


;greaterp
greatp:	exch o1,o2
	call diff
	jrst minusp

;lessp
lessp:	call diff
	jrst minusp


;;TYPES
;TY%ATM
;TY%STR
;LEXTB - type dispatch for LEXORDER
;W3 - where to go if number
;O1 - object we are looking at
;string pointer left in O1

lextb:	call lexatm		;atom
	move O1,at%pna(o1)	;  constant atom
	call lexcon		;cons
	call lexcon		;  constant cons
	jfcl			;string
	jfcl			;  constant string
	jrst lexill		; channel
	jrst lexill		;  constant channel
	jrst (w3)		; integer
	jrst (w3)		; real
	jrst (w3)		; bignum
	jrst lexill		; hunk
	jrst lexill		; address
	jrst lexill		; special
	jrst lexill		;16
	jrst lexill		;17

lexill:	perr /Argument to LEXORDER must be number, string, or atom/

lexatm:	skipn o1
	move o1,[%NIL]
	move O1,at%pna(o1)	;atom
	ret

lexcon:	docar o1,o1
	sos (p)
	sos (p)		;try again
	ret

;TY%STR
;TY%SPC
;lexorder - compare either numbers or strings
;TRUE IF A IS ALPHAMERICALLY LESS THAT OR EQUAL TO B
;**	FIXED TO HANDLE LISTS BY FINDING LEFT-MOST ATOM

lexord:	xmovei w3,lex2		;where to go if number
	getdsp o1		;check first arg
	xct lextb(w2)
	exch o1,o2
	xmovei w3,retnil	;if first non-num, second num, NIL
	getdsp o1
	xct lextb(w2)
	move w4,[cmpsle o1,]
;o2 - 1st arg, string; o1 - second arg, string; w4, cmpxx instruction
cmpstr:	xmovei o6,1(o1)		;address only, second arg
	xmovei o3,1(o2)		;address only, first arg
	move o4,(o1)		;size, second arg
	tlz o4,770000
	move o1,(o2)		;size, second arg
	tlz o1,770000
	move o2,[444340,,0]	;35-bit byte, extended format
	move o5,o2		;for both
	xct w4			;compare
	skipa o1,nil		;failed - nil
	move o1,[%t]		;succeeded - T
	setzb o2,o3		;clear garbage
	setzb o4,o5
	setz o6,
	ret

lex2:	exch o1,o2		;now analyze second
	xmovei w3,lex3		;both numbers, continue
	getdsp o1
	xct lextb(w2)
	jrst rett		;1st=num, 2nd not, defined as true

;now both known to be numbers, but order is reversed.  Correct test
;is .LE., so we do .GE., in form .NOT. .LT.
lex3:	call diff
	call minusp
	jrst not

;meter
;accounting meter stuff
umeter:	gettyp o1
	caie w2,ty%int
	jrst notint		;better be an integer
	move nil1,o1
	getnum nil1
	meter%
	setz nil1,
	ashc w2,-12.		;right justify
	move w2,w3		;we want low order end
	jrst retint		;return as integer

;time
;runtime for process
runtim:	movei nil1,.fhslf
	runtm			;runtime to nil1 in msec
	move w2,nil1		;need it in W2 for retint
	setz nil1,
	jrst retint

	; CAR, CDR, CONS and of course the garbage collector
	; code in this section knows about the format of cons cells
	; (a cons cell is two consecutive words containing values)
	; the garbage collector knows a little bit about everything,
	; so always check it when any format is changed.
;this page contains all routines that depend upon the format of a
;cons cell.  for the use of other pages, we define macros for
;car, cdr, rplaca, and rplacd.

;;TY%CON
CAR:	scons o1		;make sure it is cons cell
	jumpn o1,notcns		;if not, error unless it's nil
	move o1,(o1)		; car of a cell is the first word
	ret

;optimized form of CAR, called directly from eval
evcar:	docdr o1,o1
	docar o1,o1		;now have the arg
	call eval		;have to eval it
	scons o1
	jumpn o1,notcns
	move o1,(o1)
	adjsp p,-2
	adjsp sp,-4
	ret


notcns:	perr /Attempt to CAR or CDR something that is not a CONS cell/


;;TY%CON
CDR:	scons o1		;make sure it is a cons cell
	jumpn o1,notcns		;if not, error unless it's nil
	move o1,1(o1)		; cdr of a cell is the second word
	ret

;optimized form of CDR, called directly from eval
evcdr:	docdr o1,o1
	docar o1,o1		;now have the arg
	call eval		;have to eval it
	scons o1
	jumpn o1,notcns
	move o1,1(o1)
	adjsp p,-2
	adjsp sp,-4
	ret

;;TY%CON
rplaca:	chcons o1		;better be a cons cell
	movem o2,(o1)
	ret

;;TY%CON
define dorpa(x,y)
	movem y,(x)
	termin

;;TY%CON
rplacd:	chcons o1		;better be a cons cell
	movem o2,1(o1)		;put it in cdr
	ret

;;SASSOC - assoc that calls a funct when it fails
sassoc:	skipa w2,[sassf]

;;ASSOC - assoc that returns nil when it fails
assoc:	movei w2,retnil

;;IASSOC - search a list of pairs looking for one with a given CAR
;o2 - list, o1 - target, w2 - place to go if you lose
;O6 is assumed to be preserved 
iassoc:	
  ;loop until list runs out
assocl:	jumpe o2,(w2)		;if list empty, return nil
	docar o4,o2		;o1 _ caar of list
	docar o5,o4
	camn o5,o1		;if EQ target
	jrst assocf		;found it, yes
	docdr o2,o2		;no, advance down list
	jrst assocl
assocf:	move o1,o4		;return car
	ret

;here if SASSOC fails
sassf:	move o1,o3
	move o2,nil
	jrst apply

retnl1:	adjsp q,-1
retnil: setzb o1,nil1
	ret

rett1:	adjsp q,-1
rett:	move o1,[%t]
	ret

;EQ - fast compare
eq:	camn o1,o2
	jrst rett
	jrst retnil

;eveq - direct call version
eveq:	docdr o1,o1		;two args
	pushcdr q,o1		;save cdr args
	docar o1,o1		;first
	call eval
	exch o1,(q)		;save first res; rest cdr
	docar o1,o1
	call eval		;second
	pop q,o2		;first
	camn o1,o2		;same?
	jrst evrett		;yes
evretn:	move o1,nil		;no
	adjsp p,-2
	adjsp sp,-4
	ret


;;TY%INT
;;TY%REA
;EQUAL - compare two objects to see if they are similar
;o1 and o2 are the objects
equal:
  ;if the two objects are EQ, then they are EQUAL
	camn o1,o2
	jrst rett		;if EQ then true
  ;otherwise we recursively check CAR and CDR of each to see
  ; if they match.  If they aren't both cons cells, then this
  ; is nonsense, and they fail
	scons o1		;else only thing else would be real
	jrst eqncon
	scons o2
	jrst retnil
  ;recursively compare CAR's and CDR's
	pushcdr q,o1		;else save cdr's for later
	pushcdr q,o2
	docar o1,o1		;compare car's
	docar o2,o2
	call equal		;recursively
	jumpe o1,eqfai		;if failed, prune stack and fail
	pop q,o2
	pop q,o1
	jrst equal		;else loop to compare cdr's
eqfai:	adjsp q,-2
	move o1,nil
	ret

;;TYPES
;here if first is not cons - if they are numbers, compare them
eqncon:	gettyp o1
	cail w2,ty%nst
	caile w2,ty%nen
	jrst retnil
	gettyp o2
	cail w2,ty%nst
	caile w2,ty%nen
	jrst retnil
;they are numbers
	jrst eqp

;;TY%ATM
;PLIST - return property list of atom
plist:	satom o1		;better be an atom
	jrst [perr /PLIST argument must be an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o1,at%pro(o1)	;the property list
	ret

;;TY%ATM
;RPLACPLIST - set property list of atom
rplacp:	satom o1		;better be an atom
	jrst [perr /PLIST argument must be an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	movem o2,at%pro(o1)	;the property list
	ret

;;TY%ATM
;GET - look up property on atom's property list
;o1 - the atom, o2 - the property
;O6 is assumed to be preserved 
xget:	satom o1
	jrst retnil		;if not atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o1,at%pro(o1)	;the property list
	jumpe o1,retnil		;if nothing left, we failed
xgetl:	docar o3,o1
	camn o3,o2		;is CAR what we want?
	jrst xgets		;yes - success
	docdr o1,o1		;no - double cdr
	docdr o1,o1
	jumpn o1,xgetl
	jrst retnil		;nothing left, failed
  ;if we find it, what we found is a pair.  The CDR is the value part.
xgets:	docdr o1,o1		;get the value
	docar o1,o1
	ret

;;TY%ATM
;GETL - look up properties on atom's property list
;o1 - the atom, o2 - list of properties
getl:	satom o1
	jrst retnil		;if not atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	jumpe o2,retnil		;if nothing to look for, will fail
	move o1,at%pro(o1)	;the property list
	jumpe o1,retnil		;if nothing left, we failed
;o3 - current property from plist
;o4 - copy of list of properties
;o5 - current property from list of properties

;while not end of property list do
getlo1:	docar o3,o1
	move o4,o2
;while not end of list of properties do
getli1:	docar o5,o4
	camn o5,o3		;is this one of the properties?
	ret			;yes - success - tail is already in o1
	jumpe o4,getlo2		;no - go to next prop in list of prop's
	docdr o4,o4
	jrst getli1
;end while
getlo2:	
	docdr o1,o1		;nothing matches here, try next
	docdr o1,o1
	jumpn o1,getlo1		;if something left, try it
	jrst retnil		;nothing left, failed
;end while

;;TY%ATM
;putprop - atom, value, prop
;o1 - atom, o2 - value, o3 - prop
putp:	satom o1
	jrst [perr /Attempt to PUTPROP something that is not an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o4,at%pro(o1)	;o4 - property list tail
  ;now we search the plist to see if the prop is there already
putpl:	jumpe o4,putpno		;if run out, not there
	docar o5,o4		;o5 _ car of list
	camn o5,o3		;if EQ target
	jrst putpys		;found it, yes
	docdr o4,o4		;no, advance down list
	docdr o4,o4
	jumpn o4,putpl
;not found - add it at beginning
putpno:	move o4,at%pro(o1)	;old property list
	docons o5,o2,o4		;(value --orig--)
	docons o4,o3,o5		;(prop value --orig--)
	movem o4,at%pro(o1)	;new property list
	move o1,o2		;return the value
	ret
;found - just change the value
putpys:	docdr o4,o4
	dorpa o4,o2
	move o1,o2		;return the value
	ret	

;;TY%ATM
;remprop - atom, prop
;o1 - atom, o2 - prop
remp:	satom o1
	jrst retnil		;if not an atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
  ;cdr of the atom header is really a pointer to the plist
  ;we use this as a kludge to regard the atom header itself as
  ;the previous cell in the property list
  ;now we search the plist to see if the prop is there already
	;o1 - previous cell in plist
	;o3 - this cell
rempl:	docdr o3,o1		;get next cell
	jumpe o3,retnil		;if none, failed
	docar o4,o3		;o4 - the prop
	camn o4,o2		;if the same, we have it
	jrst rempys
	docdr o1,o3		;else advance
	jrst rempl
rempys:	docdr o3,o3		;get cdr to our cell
	docdr o3,o3
	dorpd o1,o3		;put it after previous
	jrst rett		;and return true

;APPEND - append N lists, copying all but last - LSUBR
;o2 - will be final result
;o3 - tail of list being copied
;o4 - new copy, end
;o5,o6 - work
uapp:	tdnn o1,[377777777]	;any args?
	jrst retnil		;no - NIL
	move w4,q		;w4 - addr of last arg
	sub w4,o1		;w4 - below first arg
	tlz w4,770000	
	docons o4,nil,nil	;dummy start
	movem o4,o2		;save start of copy
  ;more lists to copy?
uappp1:	tdnn o1,[377777776]	;still more than one arg?
	jrst uappex		;no - stick on last one unchanged
  ;start of copying one more list
	move o3,1(w4)		;o3 - current list being copied
	scons o3
	jrst uapppx		;while tail not atom do
  ;copy one cell in the list
uapplp:	docar o6,o3		;o6 _ next list element
	docons o5,o6,nil	;o5 _ copy of it
	dorpd o4,o5		;link into list
	move o4,o5		;new is now old
	docdr o3,o3
	sncons o3
	jrst uapplp
  ;now done with one list
uapppx:	subi o1,1		;decr count
	aoja w4,uappp1		;go to next

  ;here when only one list left, the last
uappex:	move o3,1(w4)		;o3 - current list being copied
	dorpd o4,o3		;link onto end of old
	docdr o1,o2		;and return start of copy
	ret

;*APPEND - list1, list2
;o1 - list1, o2 - list2
;o3 - list1 tail
;o4 - new copy, end
;o5 - cell being constructed
app:	move o3,o1		;init tail
	docons o4,nil,nil	;dummy start
	movem o4,o1		;save start of copy
	scons o3
	jrst appex		;while tail not atom do
applp:	docar o6,o3		;o1 _ next list element
	docons o5,o6,nil	;o4 _ copy of it
	dorpd o4,o5		;link into list
	move o4,o5		;new is now old
	docdr o3,o3
	sncons o3
	jrst applp
appex:	dorpd o4,o2		;link onto copy
	docdr o1,o1		;return start of copy, its cdr
	ret

;NCONC - append N lists, destructively; LSUBR
;o2 - thing we will return
;o3 - current list we are working on
;o4 - next list
unconc:	move o2,nil		;default return
	move w4,q		;w4 - addr of last arg
	sub w4,o1		;w4 - below first arg
	tlz w4,770000
  ;find the first list
nconl1:	tdnn o1,[377777777]	;any args?
	jrst ret2		;no - done
	move o3,1(w4)		;get current arg
	aoj w4,1		;get to next arg
	soj o1,
	scons o3		;is it a list?
	jrst nconl1		;no - skip it
  ;O3 is now the first non-nil list
	move o2,o3		;return that
  ;now find next list
nconl2:	tdnn o1,[377777777]
	jrst ret2		;no more - done
	move o4,1(w4)		;get current arg
	aoj w4,1		;get to next arg
	soj o1,
	scons o4		;is it real?
	jrst nconl2		;no - skip it
  ;O4 is now next list - now tack it on to current one
nconl3:	docdr o5,o3		;find end of current list
	scons o5		;atom is end
	jrst nconx3		;at end
	move o3,o5		;not yet
	jrst nconl3
  ;now at end of current list
nconx3:	dorpd o3,o4		;put next list onto end of current
	move o3,o4		;next is now current
	jrst nconl2		;and now look for more

ret2:	move o1,o2
	ret

;Here is an *NCONC, 2 args only
;NCONC - append a second list to a first destructively
;o1 - first list, o2 - second list
nconc:	scons o1
	jrst inconf		;first is atom (probably nil)
  ;go to end of first
	move o4,o1		;o4 - tail of first
inconl:	docdr o3,o4		;o3 - cdr
	scons o3
	jrst incone		;atom, probably nil - ready to append
	move o4,o3		;not, try again
	jrst inconl
  ;once at end, rplacd the new list onto it
incone:	dorpd o4,o2		;do the rplacd
	ret

inconf:	move o1,o2		;null first - return sec
	ret

;LENGTH - list in o1
length:	setz w2,
lenlp:	scons o1
	jrst lenx
	docdr o1,o1
	aoja w2,lenlp
lenx:	maknum w2
	move o1,w2		;return length
	ret

;FNTH - nth, but no error checking
;TY%INT - we assume no list can be long enough to require a FIXNUM to
;  describe it. This seems valid, since each element is 2 words.
fnth:	move w2,o2		;strip type bits
	tlz w2,770000
fnthl:	caig w2,1
	ret
	docdr o1,o1
	soja w2,fnthl

;TY%CON
XCONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o2		; set up car
	push free,o1		; and cdr
	xmovei o1,-1(free)	; make address into cons cell
	tlo o1,(object(ty%con,0))
	ret

;TY%CON
NCONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o1		; set up car
	move o1,free		; make address into cons cell
	tlo o1,(object(ty%con,0))
	push free,nil		; and cdr
	ret

;TY%CON
CONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o1		; set up car
	move o1,free		; make address into cons cell
	tlo o1,(object(ty%con,0))
	push free,o2		; and cdr
	ret

;optimized version of CONS that is called directly be eval
evcons:	docdr o1,o1		;two args
	pushcdr q,o1		;save cdr args
	docar o1,o1
	call eval		;eval first
	exch o1,(q)		;save first result, get cdr
	docar o1,o1
	call eval		;eval second
	pop q,o2		;o2 - first; o1 - second
	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o2		; set up car
	move o3,free		; make address into cons cell
	tlo o3,(object(ty%con,0))
	push free,o1		; and cdr
	move o1,o3		; get thing to return
	adjsp p,-2
	adjsp sp,-4
	ret


;SGC - version of GC that saves all AC's
sgc:	push p,w2
	push p,w3
	push p,w4
	push q,o1
	push q,o2
	push q,o3
	push q,o4
	push q,o5
	push q,o6
	call gc
	pop q,o6
	pop q,o5
	pop q,o4
	pop q,o3
	pop q,o2
	pop q,o1
	pop p,w4
	pop p,w3
	pop p,w2
	sos (p)
	sos (p)
	ret

; the garbage collector.  its init routine is called gcinit and
; takes these args:
;   - the beginning of constant data space, which is really at the
;	start of the first of the two data spaces
;   - the first word beyond the constant data space, which is the
;	beginning of the usable part of the first data space
;   - the start of the second data space
;   - the first word beyond the second data space
	; garbage collector variables:
	;free - last used location in data space
	;lastl - last legal location in this data space - 1.  Trigger a GC if
	;   someone tries to go beyond this.
	;stthis - start of this data space
	;enthis - end of this data space
	;stthat - start of other data space
	;enthat - end of other data space
	;stcnst - start of constant space
	;encnst - end of constant space

	.scalar lastl,stthis,enthis,stthat,enthat,stcnst,encnst

freesz==200000	;amount of free space at end of GC

gcinit:	
;init the variables describing the spaces
	pop q,enthat		;end of second data space
	pop q,w2		;start of second data space
	addi w2,freesz		;offset second space to speed up GC
	movem w2,stthat
	pop q,enthis		;end of first data space
	pop q,w2		;end of constant area
	movem w2,stthis
	movem w2,encnst		;end of constant area
	pop q,w2
	movem w2,stcnst		;start of constant space
;set up memory allocation variables for initial space
	move free,stthis	;start at beginning of space
	subi free,1		;prepare for push
	move w2,free		;allow allocation of FREESZ words before GC
	addi w2,freesz
	movem w2,lastl		;lastl gives upper limit
	ret

;This is used for explicit user calls.
ugc:	call gc
	move o1,nil
	ret

	.scalar gcstrt,gcstrc,gctimt,gccont

;This is always used when you run out of space
gc:	movei nil1,.fhslf
	runtm
	movem nil1,gcstrt	;time starting GC
	move w2,free
	sub w2,stthis
	movem w2,gcstrc		;starting free space
	skipn @[datsec,,.gcgag]	;if output
	jrst gc1		;none
	hrroi nil1,[asciz /
[GC, /]
	psout
	move w2,free
	sub w2,stthis
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl			;<
	hrroi nil1,[asciz / ==> /]
	psout
gc1:	setz nil1,
	call igc		; call internal gc
	skipn @[datsec,,.gcgag]	;if output
	jrst gc2		;none
	move w2,free
	sub w2,stthis		;free space after
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl
	hrroi nil1,[asciz /, in /]
	psout
	movei nil1,.fhslf
	runtm
	sub nil1,gcstrt		;how much time?
	move w2,nil1
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl
	hrroi nil1,[asciz / msec.]
/]
	psout
	setzm w2,@[datsec,,outchn+ch%pos]
gc2:	movei nil1,.fhslf
	runtm
	sub nil1,gcstrt
	addm nil1,gctimt
	move w2,free
	sub w2,stthis		;new free space
	sub w2,gcstrc		;minus start
	movn w2,w2		;make positive - this is garbage gotten
	addm w2,gccont		;add to cumulative
	setzb nil,nil1
	ret

;GCGAG - set GCGAG flag and return prev
xgcgag:	exch o1,@[datsec,,.gcgag]
	ret

;GCTIME - total time spent in GC so far
gctime:	move w2,gctimt
	jrst retint

;SPEAK - amount of CONS'ing so far
speak:	move w2,free		;amount in this pass
	sub w2,stthis
	add w2,gccont		;plus cumulative from past
	jrst retint

;UTIME - uptime
uptime:	time
	move w2,nil1
	setz nil1,
	jrst retint

;This is a copying GC, modelled after the Lisp Machine GC, as
;described in Henry Baker's thesis.  There are two data spaces, old and new.
;A GC copies everything that is in use from old to new, and makes new the
;current one.  The main operation is translating objects.  If the object
;is absolute, e.g. an INUM, this is a no-op.  Only pointers into the old
;space are translated.  They are translated by finding the equivalent object
;in the new space, and using its pointer.  There are two cases:
;  - we have already moved the object.  In this case the first entry of
;	the old space copy is a pointer to the copy in new space.  These
;	pointers have the sign bit on, for easy detection.
;  - we have not moved the object.  In this case, we copy it to the end of
;	new space, and use the pointer to the beginning of this copy.
;At any given time, we have a pointer into new space.  Everything before
;this pointer has been translated.   Everything after it has not.  We also
;have to translate the stack and the constant area.  Indeed it is translating
;these areas that first puts something into new space to translate.

mark==400000,,0		;bit that says this has already been translated

;Because there are four different areas to translate, we have a separate
;routine to do the translation.
;  gctran:
;	w3 - first address to be translated.  W2 is updated, and is the
;		pointer mentioned above.  I.e. everything before W2 has
;		been translated
;	w4 - last address to be translated.
;	o5 - lower end of old space
;	o6 - upper end of old space

;The code within gctran avoids the use of the stacks, in order to avoid
;performance problems because of addressing conflicts between the stack
;and the areas being GC'ed.

gctran:	move o1,(w3)		;o1 - thing to be translated
	gettyp o1		;see what we have
	xct trntab(w2)		;translate depending upon type
	camge w3,w4		;see if done
	aoja w3,gctran		;no - next
	ret

;GCTRAX - special version of the above for doing new space.  Ends when
;we reach the free pointer
gctrax:	move o1,(w3)		;o1 - thing to be translated
	gettyp o1		;see what we have
	xct trntab(w2)		;translate depending upon type
	camge w3,free		;see if done
	aoja w3,gctrax		;no - next
	ret

;;TYPES
trntab:	jsp w2,cpyatm		; atom
	jfcl			;  constant atom
	jsp w2,cpycon		; cons
	jfcl			;  constant cons
	jsp w2,cpystr		; string
	jfcl			;  constant string
	jsp w2,cpychn		; channel
	jfcl			;  constant channel
	jfcl			; integer
	jsp w2,cpyrea		; real
	jsp w2,cpybig		; bignum
	jsp w2,cpyvec		; vector
	jfcl			; address
	jsp w2,cpyspc		;[15] special
	jsp w2,cpyary		; array
	jfcl			; constant array
repeat 5,[jsp w2,cpygrb
	]			;undefined types 17 to 24
	jfcl			;[25] jrst and jfcl in evhook
	jfcl			;[26] jsp in atom block
repeat 11,[jsp w2,cpygrb
	]			;undefined types

;here to translate a CONS cell - normally we copy it and use addr of new copy
;Make lists contiguous
cpycon:	caml o1,lbcon		;make sure valid pointer
	camle o1,ubcon
	jrst cpycgt		;test for garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havcon		;yes - use it
	
	dmove o2,(o1)		;copy it - CDR will be in O3 for code below
	dmovem o2,1(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%con,0))
	movem o2,(w3)		;put it in place to be translated
cpycnl:	tlc o2,(mark\object(ty%con,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,2		;advance free list
	smcons o3		;skip if CDR movable CONS (i.e. not constant)
	jrst (w2)		;not - return
;Now we loop on the CDR, in order to make lists be contiguous.  
;W3 - use FREE, since that is what we are translating
	move o1,o3
	caml o1,lbcon		;make sure valid pointer
	camle o1,ubcon
	jrst cpycgt		;test for garbage
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst (w2)		;yes - no CDR coding is needed.
	
	dmove o2,(o1)		;copy it
	dmovem o2,1(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%con,0))
	movem o2,(free)		;put it in place to be translated
	jrst cpycnl

havcon:	tlc o2,(mark\object(ty%con,0)) ;turn into a real cons pointer
	movem o2,(w3)		;put in place to be translated
	jrst (w2)

;CPYCONS garbage test
;Normally pointers should be into the old space.  I.e. the design is
;such that we never try to translate things twice.  However
;because of our "CDR-coding", it is possible that a pointer will
;be a pointer to the next word.  We check for that case explicitly.
cpycgt:	xmovei o2,-1(o1)	;strip type bits and subtract 1
	came o2,w3		;so is it pointing to next word?
	jrst cpygrb		;no - it is real garbage
	jrst (w2)		;yes - it is fake garbage - return

;here to translate an ATOM - at the moment just like cons cell
cpyatm:	caml o1,lbatm		;make sure valid pointer
	camle o1,ubatm
	jrst cpygrb		;garbage pointer (NB - nil also goes here)
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havatm		;yes - use it
	caml o2,[jsp w2,0]	;is this really pointer to at%cal?
	jrst cpyatc		;yes, special handling
	movei o2,at%siz		;length of atom block
	move o3,o1		;source
	movei o5,at%dsp+1(free)	;compute address of AT%DSP word
	jumpe o5,[push free,nil	;if wraps around, try again
		  jrst .-1]	
	xmovei o4,1(free)	;dest
	xblt o2,
	hrrm o5,at%cal+1(free)	;put address of AT%DSP into the JSP
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%atm,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%atm,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,at%siz	;advance free list
	jrst (w2)

havatm:	tlc o2,(mark\object(ty%atm,0))
	movem o2,(w3)
	jrst (w2)

;cpyatc is used when o1 turns out to be a pointer to word at%cal of
;the atom block.
cpyatc:	skipge o2,-at%cal(o1)	;do we already have translation?
	jrst havatc		;yes - use it
	movei o2,at%siz		;length of atom block
	xmovei o3,-at%cal(o1)	;source - at%cal before pointer
	movei o5,at%dsp+1(free)	;compute address of AT%DSP word
	jumpe o5,[push free,nil	;if wraps around, try again
		  jrst .-1]	
	xmovei o4,1(free)	;dest
	xblt o2,
	hrrm o5,at%cal+1(free)	;put address of AT%DSP into the JSP
	xmovei o2,at%cal+1(free);make address into pointer to new at%cal 
	tlo o2,(object(ty%atm,0))
	movem o2,(w3)		;put it in place to be translated
	xmovei o2,1(free)	;make address into indirect pointer
	tlo o2,(mark)		; to translated version, for later callers
	movem o2,-at%cal(o1)	;and put it in at start of atom
	addi free,at%siz	;advance free list
	jrst (w2)

havatc:	tlc o2,(mark\object(ty%atm,0))
	addi o2,at%cal		;relocate to at%cal
	movem o2,(w3)		;and use as translation
	jrst (w2)

;here to copy string
cpystr:	caml o1,lbstr		;make sure valid pointer
	camle o1,ubstr
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havstr		;yes - use it
	move o3,(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,(o1)		;source
	xmovei o5,1(free)	;destination
	move o2,o5		;destination will be final result also
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%str,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%str,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	jrst (w2)

havstr:	tlc o2,(mark\object(ty%str,0))
	movem o2,(w3)
	jrst (w2)

;here to translate a CHANNEL - at the moment just like cons cell
cpychn:	caml o1,lbchn		;make sure valid pointer
	camle o1,ubchn
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havchn		;yes - use it
	movei o2,ch%666+1	;length of channel block
	move o3,o1		;source
	xmovei o4,1(free)	;dest
	xblt o2,
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%chn,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%chn,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,ch%666+1	;advance free list
	jrst (w2)

havchn:	tlc o2,(mark\object(ty%chn,0))
	movem o2,(w3)
	jrst (w2)

;here to translate a REAL
cpyrea:	caml o1,lbrea		;make sure valid pointer
	camle o1,ubrea
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havrea		;yes - use it
	dmove o2,(o1)		;copy it
	dmovem o2,1(free)
	move o2,2(o1)		;3 cells
	movem o2,3(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%rea,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%rea,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,3		;advance free list
	jrst (w2)

havrea:	tlc o2,(mark\object(ty%rea,0))
	movem o2,(w3)
	jrst (w2)

;here to translate a BIGNUM
cpybig:	caml o1,lbbig		;make sure valid pointer
	camle o1,ubbig
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havbig		;yes - use it
	move o2,(o1)		;size - this is the special size field
	tlz o2,770000		;clear type bits
	addi o2,1		;size is that +1 if you count this size field
	xmovei o3,(o1)		;source
	xmovei o4,1(free)	;dest
	move o5,o4		;save start addr in O5
	add free,o2		;advance free list
	xblt o2,
	tlo o5,(object(ty%big,0))
	movem o5,(w3)		;put it in place to be translated
	tlc o5,(mark\object(ty%big,0)) ;make a pointer to put into old copy
	movem o5,(o1)		;and put it there
	jrst (w2)

havbig:	tlc o2,(mark\object(ty%big,0))
	movem o2,(w3)
	jrst (w2)

;here to copy vector
cpyvec:	caml o1,lbvec		;make sure valid pointer
	camle o1,ubvec
	jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst havvec		;yes - use it
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%vec,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%vec,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

havvec:	tlc o2,(mark\object(ty%vec,0))
	movem o2,(w3)
	jrst (w2)


;here to copy vector
cpyary:	caml o1,lbary		;make sure valid pointer
	camle o1,ubary
	jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst havary		;yes - use it
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%ary,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%ary,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

havary:	tlc o2,(mark\object(ty%ary,0))
	movem o2,(w3)
	jrst (w2)

;here if given a garbage pointer or NIL
cpygrb:	jumpe o1,(w2)		;return if nil
	hrroi nil1,[asciz /Bad pointer detected by GC.  Type CONTINUE to proceed.
/]
	psout
	setz nil1,
	haltf
	setzm (w3)		;get rid of it
	jrst (w2)

;here for special thing that GC should ignore. o1 is code,,length
cpyspc:	tlz o1,770000		;make pure number
	add w3,o1		;skip that many words
	jrst (w2)

;the following variables contain lower and upper bounds for pointers
;of each type. this is just stthis and free from before the GC,
;with the appropriate type code filled in

.scalar lbcon,ubcon,lbatm,ubatm,lbstr,ubstr,lbchn,ubchn,lbrea,ubrea,lbbig,ubbig
.scalar lbvec,ubvec,lbary,ubary

igc:	call stcrit			;GC is critical section
  ;initialize for copying scan
  ;bounds for areas
     ;cons
	move w3,[object ty%con,0]
	add w3,stthis
	movem w3,lbcon
	move w3,[object ty%con,0]
	add w3,free
	movem w3,ubcon
     ;atom
	move w3,[object ty%atm,0]
	add w3,stthis
	movem w3,lbatm
	move w3,[object ty%atm,0]
	add w3,free
	movem w3,ubatm
     ;string
	move w3,[object ty%str,0]
	add w3,stthis
	movem w3,lbstr
	move w3,[object ty%str,0]
	add w3,free
	movem w3,ubstr
     ;channel
	move w3,[object ty%chn,0]
	add w3,stthis
	movem w3,lbchn
	move w3,[object ty%chn,0]
	add w3,free
	movem w3,ubchn
     ;real
	move w3,[object ty%rea,0]
	add w3,stthis
	movem w3,lbrea
	move w3,[object ty%rea,0]
	add w3,free
	movem w3,ubrea
     ;bignum
	move w3,[object ty%big,0]
	add w3,stthis
	movem w3,lbbig
	move w3,[object ty%big,0]
	add w3,free
	movem w3,ubbig
     ;vector
	move w3,[object ty%vec,1]
	add w3,stthis
	movem w3,lbvec
	move w3,[object ty%vec,1]
	add w3,free
	movem w3,ubvec
     ;array
	move w3,[object ty%ary,1]
	add w3,stthis
	movem w3,lbary
	move w3,[object ty%ary,1]
	add w3,free
	movem w3,ubary
	
	move free,stthat	;start copy in other area
	subi free,1		;because designed for PUSH

  ;now scan the areas that are to be translated
	move w3,bpsbeg		;translate BPS
	move w4,bpsend
	subi w4,1
	call gctran
	move w3,[baseq]		;translate data stack
	move w4,q
	call gctran
	move w3,[basesp]	;translate special PDL
	move w4,sp
	call gctran
	move w3,stcnst		;translate constant area
	move w4,encnst
	subi w4,1
	call gctran
	move w3,stthat		;now do the new space
	call gctrax

  ;now reverse areas
	move w2,stthis
	exch w2,stthat
	movem w2,stthis
	move w2,enthis
	exch w2,enthat
	movem w2,enthis
  ;clear q above the point actually used.  This is necessary since
  ;compiled code sometimes does ADJSP Q,+N.  The effect is that
  ;there may be data on Q that was not put there explicitly.  If a
  ;GC should happen before real data was put in, we could be in trouble
  ;if there were any pointers left over from a previous GC cycle.  To
  ;be safe, we must purge all old items from the Q section.  Other
  ;sections need not be cleared, since data is put in SP space and
  ;and free space only by PUSH or by adjusting FREE to beyond data
  ;actually used.
	move w2,q			;.Q + 1 is first to be cleared
	tro w2,777			;end of page is last
	sub w2,q			;here is number of words
	jumpe w2,igcldn			;forget it if none
	setzm 1(q)			;clear first
	caig w2,1			;done if only one
	jrst igcldn
	xmovei w3,1(q)			;source is .Q + 1
	xmovei w4,2(q)			;dest is one more
	xblt w2,			;clear them all
;now we have cleared remaining part of current page - kill higher pages
igcldn:	move w2,q
	tro w2,777
	addi w2,1			;first word of next page
	lsh w2,-9.			;w2 - page number of next page
	movei w3,endq_-9.		;page number beyond section
	skipn @[datsec,,.%%STKLIM]	;expanded stack?
	movei w3,endqs_-9.		;yes - then to end of section
	sub w3,w2			;w3 - number of pages to clear
	jumpe w3,igpmdn			;done if none
	seto nil1,			;AC1 - unmap
	hrli w2,.fhslf			;AC2 - self,,first page
	tlo w3,(pm%cnt)			;AC3 - count
	pmap				;clear them all
  ;and set up trigger for next GC
igpmdn:	move w3,free			;but now compute used/2
	sub w3,stthis			;  w3 _ used
	fltr w3,w3			;to floating point
	move o1,@[datsec,,.GCTRIG]	;now multiply by trigger
	gettyp o1
	cain w2,ty%int
	jrst [move w2,o1		;convert integers
	      getnum w2
	      fltr w2,w2
	      jrst igpmd0]
	caie w2,ty%rea			;if not real, ignore it
	jrst igpmd1
	move w2,1(o1)			;get high-order part
igpmd0:	fmpr w2,w3			;now have real free space
	fixr w2,w2			;convert back to integer
	caige w2,freesz			;give him at least this much
igpmd1:	movei w2,freesz			;no - use this
	add w2,free			;     + free
	movem w2,lastl
	setzb nil,nil1
	setzb o1,o2			;clear these AC's so have valid data
	setzb o3,o4
	setzb o5,o6
	call encrit			;no longer in critical section
	ret

;GCLEFT - amount of space left before the next GC
gcleft:	move w2,lastl
	sub w2,free
	jrst retint

;VECTOR and ARRAY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	VECTOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;makvec
makvec:	gettyp o1
	tlnn o1,4000
	caie w2,ty%int			;better be integer
	jrst makver
	push free,o1			;start with size
	move w2,o1			;w2 - size as number
	getnum w2
	xmovei o1,1(free)		;save start as returned vector
	tlc o1,(object(ty%vec,0))
	xmovei w3,1(free)		;w3 - start of data
	add free,w2
	jumpe w2,makv1			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,makv1			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
makv1:	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret				;object already in o1

makver:	perr /Size of vector must be non-negative integer/

;(GETVEC vector index)
getvec:	caml o2,[object ty%int,0]	;better be in bounds
	caml o2,-1(o1)
	jrst bounds
	xmovei w2,(o1)			;addr of vector
	add w2,o2
	move o1,(w2)
	ret

;(SETVEC vector index value)
setvec:	caml o2,[object ty%int,0]	;better be in bounds
	caml o2,-1(o1)
	jrst bounds
	xmovei w2,(o1)			;addr of vector
	add w2,o2
	movem o3,(w2)
	move o1,o3
	ret

;(VECTORBLT num fromvec frmindex tovec toindex)  ; JoSH
vecblt:	caml o3,[object ty%int,0]
	 camge o5,[object ty%int,0]
	  jrst bounds
	move w2,o1		; # of items
	tlz w2,770000		; TY%INT
	xmovei w3,(o2)		; set up from addr
	add w3,o3
	xmovei w4,(o4)		; to addr
	add w4,o5
	add o3,w2		; range check
	add o5,w2
	camg o3,-1(o2)		; (no explicit check for num<0 since
	 camle o5,-1(o4)	;  the tlz will leave a huge pos. no.)
	  jrst bounds
	xblt w2,
	jrst retnil

bounds:	move o1,o2
bound1:	perr /Vector subscript out of bounds/

;Entry for ARRAY subscript calculators.  Entries are made from
;BNDERR to BNDERR+4, depending upon which AC is involved
bnderr:	move o2,o1		;o1
	move o3,o2		;o2
	move o4,o3		;o3
	move o5,o4		;o4
	move o1,o5		;o5
	maknum o1
	setzb o2,o3
	setzb o4,o5
	jrst bound1

;VECTORLENGTH
veclen:	move o1,-1(o1)
	ret

;VECTORP
vecp:	gettyp o1
	caie w2,ty%vec
	jrst retnil
	jrst rett

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	ARRAY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;makary
makary:	gettyp o1
	tlnn o1,4000
	caie w2,ty%int			;better be integer
	jrst makver
	move w2,o1			;size as ty%spc
	tlc w2,(<object(ty%int,0)>#<object(ty%spc,0)>)
	push free,w2			;start with size
	tlz w2,770000			;now bare number
	xmovei o1,1(free)		;save start as returned vector
	tlc o1,(object(ty%ary,0))
	xmovei w3,1(free)		;w3 - start of data
	add free,w2
	jumpe w2,makv1			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,makv1			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
maka1:	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret				;object already in o1

;makcary
makcar:	gettyp o1
	tlnn o1,4000
	caie w2,ty%int			;better be integer
	jrst makver
	move w2,o1			;size as ty%spc
	tlc w2,(<object(ty%int,0)>#<object(ty%spc,0)>)
	aos w3,bpsend			;get address to use
	movem w2,-1(w3)			;header is at -1
	tlz w2,770000			;now bare number
	addm w2,bpsend			;update end
	move o1,w3			;make up pointer for start
	tlc o1,(object(ty%car,0))
	jumpe w2,cpopj			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,cpopj			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
	ret				;object already in o1

;(GETIARRAY vector index)
getiar:	move w2,-1(o1)
	tlc w2,(<object(ty%spc,0)>#<object(ty%int,0)>)
	caml o2,[object ty%int,0]	;better be in bounds
	caml o2,w2
	jrst bounds
	move w2,o1			;addr of vector
	add w2,o2
	move w2,(w2)
	jrst retint			;and return as integer

;(GETBARRAY vector index byte-size)
getbar:	exch o1,o2
	call getint		;index to w2
	jumpl w2,bound1
	movei w3,36.		;calculate bytes per word
	idivi w3,(o3)		;w3 - bytes per word
	idiv w2,w3		;w2 - words, w3 - bytes
	exch w2,w3		;w2 - bytes, w3 - words
	xmovei w4,(o2)		;in this word
	add w4,w3		;relocate by word offset
	movsi w3,440040		;first half of byte ptr - to high order byte
	dpb o3,[.bp 7700000000,w3] ;take byte size from arg
	ildb o1,w3		;increment so we do LDB not ILDB
	jumpe w2,.+3		;now increment by byte offset
	ildb o1,w3		;must use ILDB because IBP doesn't work
	sojg w2,.-1
  ;w3,w4 is now the byte pointer
	xmovei w2,(o2)		;base address
	sub w2,w4		;here is word offset
	movn w2,w2
	tlo w2,(object(ty%spc,0)) ;set type bits for comparability
	caml w2,-1(o2)		;better be less than upper bound
	jrst bound1
	ldb w2,w3
	jrst retint

;(GETRARRAY vector index)
getrar:	move w2,o2			;index
	lsh w2,1			;* 2
	tlc w2,(<object(ty%spc,0)>#<<object(ty%int,0)>_1>) ;convert to SPC
	addi w2,1
	caml w2,[object ty%spc,1]	;better be in bounds
	caml w2,-1(o1)
	jrst bounds
	add w2,o1			;and add base of vector
	dmove w2,-1(w2)
	jrst retrea			;and return as real

;(SETIARRAY vector index value)
setiar:	move w2,-1(o1)
	tlc w2,(<object(ty%spc,0)>#<object(ty%int,0)>)
	caml o2,[object ty%int,0]	;better be in bounds
	caml o2,w2
	jrst bounds
	move w3,o1			;addr of vector
	add w3,o2
	move o1,o3			;get new value
	call getint
	movem w2,(w3)
	ret

;(SETBARRAY vector index byte-size value)
setbar:	exch o1,o2
	call getint		;index to w2
	jumpl w2,bound1
	movei w3,36.		;calculate bytes per word
	idivi w3,(o3)		;w3 - bytes per word
	idiv w2,w3		;w2 - words, w3 - bytes
	exch w2,w3		;w2 - bytes, w3 - words
	xmovei w4,(o2)		;in this word
	add w4,w3		;relocate by word offset
	movsi w3,440040		;first half of byte ptr - to high order byte
	dpb o3,[.bp 7700000000,w3] ;take byte size from arg
	ildb o1,w3		;increment so we do LDB not ILDB
	jumpe w2,.+3		;now increment by byte offset
	ildb o1,w3		;must use ILDB because IBP doesn't work
	sojg w2,.-1
  ;w3,w4 is now the byte pointer
	xmovei w2,(o2)		;base address
	sub w2,w4		;here is word offset
	movn w2,w2
	tlo w2,(object(ty%spc,0)) ;set type bits for comparability
	caml w2,-1(o2)		;better be less than upper bound
	jrst bound1
	move o1,o4		;get new value
	call getint		;into w2
	dpb w2,w3
	ret

;;TY%REA
;(SETRARRAY vector index value)
setrar:	gettyp o3
	caie w2,ty%rea
	jrst [move o1,o3
	      perr /SETRARRAY - must be real/]
	move w2,o2			;index
	lsh w2,1			;* 2
	tlc w2,(<object(ty%spc,0)>#<<object(ty%int,0)>_1>) ;convert to SPC
	addi w2,1
	caml w2,[object ty%spc,1]	;better be in bounds
	caml w2,-1(o1)
	jrst bounds
	add w2,o1			;and add base of vector
	dmove w3,1(o3)			;get new value
	dmovem w3,-1(w2)		;put it in
	move o1,o3			;and return new
	ret

;read and print.
;This page contains all the code that depends upon the representation
;of atoms and strings.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	print
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

princ:	push q,o1		; save return value
	getdsp o1
	xct prtab(w2)

;;TYPES
prtab:	jrst pratom		; atom
	jrst pratom		;  constant atom
	jrst prlist		; cons
	jrst prlist		;  constant cons
	jrst prstr		; string
	jrst prstr		;  constant string
	jrst prchn		; channel
	jrst prcch		;  constant channel
	jrst prnum		; integer
	jrst prrea		; real
	jrst prbig		; bignum
	jrst prvec		; vector
	jrst pradr		; address
	jrst prspc		; special
	jrst prary		; array
	jrst prcar		; constant array

;;TY%STR
;print a string
prstr:	move w2,o1		;string to print
	jrst prstr1

;;TY%STR
;;TY%ATM
;print an atom
pratom:	jumpe o1,prnil		;nil is special
	move w2,at%pna(o1)	;put byte ptr to pname in -1(p)
prstr1:	tlz w2,770000		;clear type code
	push p,[010740,,0]	;W2 is addr of TY%SPC - data in next wd
	push p,w2
pratlp:	ildb w2,-1(p)		;get next byte to print
	jumpe w2,praten
	makchr w2		;make it a char
	move o1,w2
 ;printing
	call tyo
	jrst pratlp

praten:	adjsp p,-2
	pop q,o1		;return saved value
	ret

;print a list
;This routine supplies the ( ) around a list, calling PRINC recursively
; to print the items inside
prlist:	push q,o1		;copy orig value so we can work with it
  ;left parent
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prlslp:	move o1,(q)		;get car of list
	docar o1,o1
	call princ
	move o1,(q)
	docdr o1,o1		;now cdr to next elt
	movem o1,(q)
  ;now go to next.  There are several cases
  ; NIL - stop with right parent
  ; cons cell - go on
  ; other thing - use a final dot
	skipn o1		;if nil
	jrst prlsen		;then done
	scons o1		;continue if cdr is cons cell
	jrst prlsdt		;not, do . )
	move o1,[char " " ]	;space before next elt
	call tyo
	jrst prlslp

;here if ends with . X rparent
prlsdt:	movei w2,[asciz / . /]
	call tyout
	move o1,(q)
	call princ		;now print the last thing
prlsen:	adjsp q,-1		;and forget it
	move o1,[char 51]	;rparent
	call tyo
	pop q,o1		;return original arg
	ret	

;print a vector
;This routine supplies the #( ) around a vector, calling PRINC recursively
; to print the items inside
prvec:	push q,[object ty%int,0] ;and count
  ;left parent
	move o1,[char 43]	;#
	call tyo
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prvecl:	move o1,-1(q)		;get object
	move o2,(q)		;and count
	caml o2,-1(o1)		;if something is still left
	jrst prvc1x		;no, done
	getnum o2		;compute index
	add o2,o1		;now get address of element
	move o1,(o2)		;and element itself
	call princ
	aos o2,(q)		;to next count
	move o1,-1(q)		;object
	caml o2,-1(o1)		;if something still left
	jrst prvc1x		;no, done
	move o1,[char 40]	;space
	call tyo
	jrst prvecl

;print an I/O channel
prchn:	movei w2,[asciz /CHN#/]
;common code to print funny pointers
prfun:	call tyout
	move w2,(q)		;print addr
	tlz w2,770000
	movei w4,8.		;in octal
	call prnmps
	pop q,o1
	ret

;print a constant I/O channel
prcch:	movei w2,[asciz /CCH#/]
	jrst prfun

;print an address
pradr:	movei w2,[asciz /ADR#/]
	jrst prfun		;common code

;print a special object
prspc:	movei w2,[asciz /SPC#/]
	jrst prfun

;print an array
prary:	movei w2,[asciz /ARY#/]
	jrst prfun

;print a constant array
prcar:	movei w2,[asciz /CAR#/]
	jrst prfun

prin1:	push q,o1		;save value for return
	getdsp (q)
	xct pr1tab(w2)

;;TYPES
pr1tab:	jrst prat1		; atom
	jrst prat1		;  constant atom
	jrst prls1		; cons
	jrst prls1		;  constant cons
	jrst prst1		; string
	jrst prst1		;  constant string
	jrst prchn		; channel
	jrst prcch		;  constant channel
	jrst prnum		; integer
	jrst prrea		; real
	jrst prbig
	jrst prvc1		; hunk
	jrst pradr		; address
	jrst prspc		; special
	jrst prary		;16
	jrst prcar		;17

noprt:	pop q,o1		;return original value
	ret

;;TY%STR
;print a string
prst1:	move o1,[char 42]	;quote
	call tyo
	move w2,(q)		;string to print
	push q,(q)		;prstr1 expects the arg to be on stack also
	call prstr1
	move o1,[char 42]	;close quote
	call tyo
	pop q,o1		;return thing that was printed
	ret

;;TY%STR
;;TY%ATM
;print an atom
prat1:	jumpe o1,prnil		;nil is special
	move w2,at%pna(o1)	;put byte ptr to pname in -1(p)
	tlz w2,770000		;clear type code
	push p,[010740,,0]	;W2 is addr of TY%SPC - data in next wd
	push p,w2
;first thing
	ildb w2,-1(p)
	jumpe w2,praten		;null atom???
	skipl w3,rdtab(w2)	;see if needs slash
	xct pratb2(w3)		;prat6 or prat2
;falls to here if read macro
prat2:	push p,w2		;save the thing
	move o1,[char "/"]
	call tyo		;do the slash
	pop p,w2
prat6:	makchr w2		;make it a char
	move o1,w2
	call tyo		;print it
;things other than first
prat5:	ildb w2,-1(p)		;get next byte to print
	jumpe w2,praten
	hrrz w3,rdtab(w2)	;see if needs slash
	xct prattb(w3)		;prat3 or prat4
prat3:	push p,w2
	move o1,[char "/"]	;do the slash
	call tyo
	pop p,w2
prat4:	makchr w2		;make it a char
	move o1,w2
 ;printing
	call tyo
	jrst prat5

;;READTABLE
pratb2:	jrst prat6	;letters
	jrst prat6	;lower case
	jrst prat2	;(
	jrst prat2	;)
	jrst prat2	;[
	jrst prat2	;]
	jrst prat2	;.
	jrst prat2	;,
	jrst prat2	;'
	jrst prat2	;/
	jrst prat2	;"
	jrst prat2	;space
	jrst prat2	;all end of lines
	jrst prat2	;digits
	jrst prat7	;+ -
	jrst prat2	;esc
	jrst prat2	;comment
	jrst prat2	;null

;special kludge for signs
prat7:	push p,w2	;save actual sign
	dmove w3,-2(p)	;get byte pointer
	ildb w2,w3	;peek at next char
	hrrz w3,rdtab(w2) ;see what it is
	pop p,w2	;get back sign
	caie w3,rd%dig	;if next is digit
	jrst prat6	;not - no quote needed
	jrst prat2	;is - this would look like a number

;;READTABLE
prattb:	jrst prat4	;letters
	jrst prat4	;lower case
	jrst prat3	;(
	jrst prat3	;)
	jrst prat3	;[
	jrst prat3	;]
	jrst prat3	;.
	jrst prat3	;,
	jrst prat3	;'
	jrst prat3	;/
	jrst prat3	;"
	jrst prat3	;space
	jrst prat3	;all end of lines
	jrst prat4	;digits
	jrst prat4	;+ -
	jrst prat4	;esc
	jrst prat3	;comment
	jrst prat3	;null


;print a list
;This routine supplies the ( ) around a list, calling PRIN1 recursively
; to print the items inside
prls1:	push q,(q)		;save original thing, for return value
  ;left parent
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prls1l:	move o1,(q)		;get car of list
	docar o1,o1
	call prin1
	move o1,(q)		;now cdr to next element
	docdr o1,o1
	movem o1,(q)
  ;now go to next.  There are several cases
  ; NIL - stop with right parent
  ; cons cell - go on
  ; other thing - use a final dot
	skipn o1		;if nil
	jrst prls1e		;then done
	scons o1		;continue if cdr is cons cell
	jrst prls1d		;not, do . )
	move o1,[char " " ]	;space before next elt
	call tyo
	jrst prls1l

;here if ends with . X rparent
prls1d:	movei w2,[asciz / . /]
	call tyout
	move o1,(q)
	call prin1		;now print the last thing
prls1e:	adjsp q,-1		;and forget it
	move o1,[char 51]	;rparent
	call tyo
	pop q,o1		;and return the arg
	ret	

;print a vector
;This routine supplies the #( ) around a vector, calling PRIN1 recursively
; to print the items inside
prvc1:	push q,[object ty%int,0] ;and count
  ;left parent
	move o1,[char 43]	;#
	call tyo
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prvc1l:	move o1,-1(q)		;get object
	move o2,(q)		;and count
	caml o2,-1(o1)		;if something is still left
	jrst prvc1x		;no, done
	getnum o2		;compute index
	add o2,o1		;now get address of element
	move o1,(o2)		;and element itself
	call prin1
	aos o2,(q)		;to next count
	move o1,-1(q)		;object
	caml o2,-1(o1)		;if something still left
	jrst prvc1x		;no, done
	move o1,[char 40]	;space
	call tyo
	jrst prvc1l

prvc1x:	move o1,[char 51]	;rparent
	call tyo
	adjsp q,-1		;get rid of count
	pop q,o1		;and return the arg
	ret	

prnil:	movei w2,[asciz /NIL/]
	call tyout
	pop q,o1		;and return the arg
	ret

;;TY%BIG
prbig:	move o1,(q)		;get the number, leaving it as ret val
	move w2,1(o1)		;value of first part
	jrst prnum0		;and joing INUM code

;;TY%INT
prnum:	move w2,(q)		;get the number, leaving it as ret val
	getnum w2		;numerical form
prnum0:	move w4,@[datsec,,.BASE];if base negative
	getnum w4
	jumpl w4,prnum1		;then don't use sign
	jumpge w2,prnum1	;if positive forget this
	push p,w2
	move o1,[char "-"]	;print sign
	call tyo
	pop p,w2		;get back number
	movm w2,w2		;print it in positive form
prnum1:	move w4,@[datsec,,.BASE] ; output base
	getnum w4
	movm w4,w4
	call prnmps		;print it
	skipe @[datsec,,.NOPOINT] ;see if need point
	jrst prnmrt		;no
	move w4,@[datsec,,.BASE] ;get back base
	getnum w4
	movm w4,w4
	setz w2,		;assume no point available
	cain w4,10.		;decimal
	move w2,[char "."]	;here is the point
	cain w4,8.		;octal
	move w2,[char "Q"]	;and octal point
	jumpe w2,prnmrt		;if didn' find one, return
	move o1,w2
	call tyo		;print it
prnmrt:	pop q,o1		;return arg
	ret

prrup:	dfmp w2,[10.0
		 0]
	sos (p)
	jrst prr1

prrdwn:	dfdv w2,[10.0
		 0]
	aos (p)
	jrst prr2

numdig==18.	;number of digits of precision to print

;;TY%REA
;-1(p) - negative flag
;(p) - exponent
prrea:	move o1,(q)
	dmove w2,1(o1)
	push p,[0]		;this is count of delayed zeros
	push p,[0]		;assume positive
	cail w2,0		;if negative
	jrst prr0		;not
  ;if negative, we want the positive form
	setom (p)		;set flag
	dmovn w2,w2		;and negate
prr0:	push p,[1]		;this will be exponent
	skipn w3		;check for zero
	tdne w2,[000777777777]
	jrst .+2		;not zero
	jrst prrz		;zero - don't try to adjust to above 1.0
prr1:	camge w2,[1.0]		;it must be at least 1.0
	jrst prrup
prr2:	caml w2,[10.0]		;but smaller than 10.0
	jrst prrdwn
;now scaled from 1.0 to 10.0
	dfad w2,[107560736521	;round at last digit
	 	 221552226422]
	caml w2,[10.0]		;in case this pushes us over
	jrst prrdwn
prrz:	ldb w4,[.bp 377_27.,w2]	;get binary exponent
	subi w4,200		;scale it
	tlz w2,377000		;clear exponent
	ashc w2,(w4)		;shift mantissa into .GT. 0 part
  ;-5(p) - delayed zeros
  ;-4(p) - negative
  ;-3(p) - exp
  ;-2(p),-1(p) - number being printed
  ;(p) - number of digits left to print
	push p,w2
	push p,w3
	push p,[numdig]
	move o1,[char "-"]
	skipe -4(p)			;if negative
	call tyo			;print the sign
	move w2,-3(p)			;look at precision
	caig w2,numdig			;if too big
	caige w2,0			;or too small
	jrst prre			;use e format

;this is for printing in F format
	move o1,[char "0"]		;use leading zero if exp = 0
	skipg -3(p)
	call tyo
	aos -3(p)
;loop for printing the digits
prrf3:	move o1,[char "."]		;need decimal pt?
	sosn -3(p)			;no
	call tyo			;yes
	sosge (p)			;run out of digits?
	jrst prrf4			;end of print
	dmove nil1,-2(p)		;get number into 1-2
	ldb w4,[.bp 377_27.,nil1]	;get integer part
	push p,w4			;save it for printing
	tlz nil1,377000			;clear it
	dmul nil1,[0
		   10.]			;now shift on dec digit
	dmovem w3,-3(p)			;and put it back for next
	move nil1,nil
	pop p,w4			;get back digit to print
  ;basically we now print w4 - but want to omit trailing zeros after dec. pt.
	skipge -3(p)			;can we delay zeros?
	jumpe w4,prrf5			;yes, if zero, delay it
	skipe -5(p)			;any delayed zero?
	call prrdel			;yes - do them
	add w4,[char "0"]		;convert to char
	move o1,w4			;and print it
	call tyo
	jrst prrf3

;here to delay a zero
prrf5:	aos -5(p)			;just add zero to total
	jrst prrf3

;here to print delayed zeros
prrdel:	push p,w4		;save thing we want to print
prrd1:	move o1,[char "0"]
	call tyo
	sosle -7(p)		;any more?
	jrst prrd1		;yes - do them
	pop p,w4		;get back real char
	ret
	
prrf4:	adjsp p,-6		;kill saved junk
	pop q,o1		;return the arg
	ret

;Here for E format
prre:	movei w2,[asciz /0./]		;print the 0.
	call tyout
;loop for printing the digits
prr3:	sosge (p)			;run out of digits?
	jrst prr4			;end of print
	dmove nil1,-2(p)		;get number into 1-2
	ldb w4,[.bp 377_27.,nil1]	;get integer part
	push p,w4			;save it for printing
	tlz nil1,377000			;clear it
	dmul nil1,[0
		   10.]			;now shift on dec digit
	dmovem w3,-3(p)			;and put it back for next
	move nil1,nil
	pop p,w4			;get back digit to print
	jumpe w4,prr5			;if zero, delay it
	skipe -5(p)			;any delayed zeros?
	call prrdel			;yes - do them
	add w4,[char "0"]		;convert to char
	move o1,w4			;and print it
	call tyo
	jrst prr3

;here to delay a zero
prr5:	aos -5(p)			;just add zero to total
	jrst prr3
	
prr4:	move o1,[char "E"]	;print the exp
	call tyo
	move w2,-3(p)		;exp
	maknum w2
	move o1,w2		;number part
	call prin1
	adjsp p,-6		;kill saved junk
	pop q,o1		;return the arg
	ret

;recursive printer, number in w2.  Will print 36-bit numbers in positive form
prnmps:	move w3,w2		;move w2 to w2,w3 as double word
	setz w2,
	tlze w3,400000		;move sign bit to low-order of high word
	movei w2,1
	div w2,w4		;now standard recursive printer
	push p,w3		;we will print this - last digit
	skipe w2		;but someone else has to print rest
	call prnmps		;(unless zero, of course)
	pop p,w3
	addi w3,"0"		;make digit
	makchr w3		;make char
	move o1,w3
	call tyo
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;other random print things
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
terpri:	push q,o1
	movei w2,[asciz /
/]
	call tyout
	pop q,o1
	ret

;lines0 - terpri if not at start of line
lines0:	move o2,@[datsec,,.curout]
	skipg ch%pos(o2)	;beyond start?
	ret			;at beginning, nothing to do
	jrst terpri

;lines(n) - N blank lines
lines:	move w2,o1
	getnum w2
	push p,w2		;(p) - number of lines to do
	call lines0		;to start of line
linesl:	sosge (p)		;now that many terpri's
	jrst cpopj1
	call terpri
	jrst linesl

cpopj1:	adjsp p,-1
	ret

print:	push q,o1		;save arg
	call terpri
	move o1,(q)		;get back arg
	call prin1
	move o1,[char 40]
	call tyo
	pop q,o1		;return arg
	ret


;;;;;Now the fun begins: explode and explodec, which work like prin1 and
;;;;;princ, but output to a list.  they generate a channel object pointing
;;;;;to the list they are building, and set up to use EXPPUT for writing
;;;;;char's.  Note that this program creates a dummy (NIL.NIL).  We need
;;;;;this dummy so that EXPPUT will have something to RPLACD to the first
;;;;;time around.

;common routine to do the explode/c.  the TYO routine and then then print
;routine is pushed on the stack
;;TY%CHN
explo:	push p,sp		;save sp since we rebind curout
	push q,o1		;save arg
	move o1,[.dumchn]	;get the dummy channel
	setzm ch%dat(o1)	;clear in order to prevent chaos if GC done at
				;the CONS below.  CH%DAT must be valid
	movei w2,ch%666-1	;make ch%dat be checked by GC
	hrrm w2,ch%spc(o1)
	move w2,-3(p)		;use special output routine that adds to list
	movem w2,ch%put(o1)
	setom w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	docons o2,nil,nil	;and put new dummy cell into data
	movem o2,ch%dat(o1)	;to append to
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	pop q,o1		;get back thing to print
	push q,o2		;save start of list we are building
	move w2,-2(p)		;the print routine
	call (w2)
	pop q,o1		;start of list we built
	docdr o1,o1		;car was a dummy
	jrst unbind		;rebind curout

;The actual explode and explodec
explod:	push p,[codsec,,expput]	;this for TYO
	push p,[codsec,,prin1]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

exploc:	push p,[codsec,,expput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

;And AEXPLODE and AEXPLODEC
aexplo:	push p,[codsec,,aexput]	;this for TYO
	push p,[codsec,,prin1]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

aexplc:	push p,[codsec,,aexput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

;common routine to do the flatsize/c. the print routine is pushed on the stack
;;TY%CHN
flsize:	push p,sp		;save sp since we rebind curout
	push q,o1		;save arg
	move o1,[.DUMCHN]	;get the dummy channel
	movei w2,ch%666		;ch%dat not GC'ed
	hrrm w2,ch%spc(o1)
	move w2,[codsec,,fltput] ;use special output routine that counts
	movem w2,ch%put(o1)
	setom w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	setzm ch%dat(o1)	;zero count
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	exch o1,(q)		;get back thing to print, save chan
	move w2,-2(p)		;the print routine
	call (w2)
	pop q,o1
	move w2,ch%dat(o1)	;get count
	maknum w2		;make into lisp number
	move o1,w2
	jrst unbind		;rebind curout

;The actual explode and explodec
flats:	push p,[codsec,,prin1]	;use this routine
	call flsize		;common explosion code
	adjsp p,-1
	ret

flatsc:	push p,[codsec,,princ]
	call flsize
	adjsp p,-1
	ret

;readlist
readls:	push p,sp		;save sp since we rebind curin
	push q,o1		;save arg
	call makchn		;returns a new channel object in o1
	sos ch%spc(o1)		;make ch%dat be checked by GC
	move w2,[codsec,,rdlget] ;use special input routine that read fr list
	movem w2,ch%get(o1)
	pop q,ch%dat(o1)	;put in list to read
	move o3,[%curin]	;rebind current input to this channel
	push sp,[%curin]
	push sp,at%val(o3)
	setval o3,o1
	move w2,-2(p)		;the read routine
	call read		;result will be in o1
	jrst unbind		;rebind curin

;maknam: special version of readlist that doesn't intern
maknam:	push p,sp
	move o3,[%dointern]	;set ..intern to false
	fasbind o3,nil
	call readls
	jrst unbind


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  read
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Here is the read table.  Each character is given a read class,
;which is then used by the dispatch tables.  This is just a way to
;make the tables smaller, since we only need the tables to be as
;long as the number of read classes, rather than 128 long.

;;READTABLE - anyone that has a table based on this should have a
;   comment saying ;;READTABLE
rd%let==0	;letters
rd%lc==1	;lower case
rd%lp==2	;(
rd%rp==3	;)
rd%lb==4	;[
rd%rb==5	;]
rd%per==6	;.
rd%com==7	;,
rd%quo==10	;'
rd%sl==11	;/
rd%sq==12	;"
rd%sp==13	;space
rd%eol==14	;all end of lines
rd%dig==15	;digits
rd%sgn==16	;+ -
rd%esc==17	;escape - end of line and super-close
;the following types will never get through TYI, and thus need not be
;in the read tables
rd%cmt==20	;comment
rd%nul==21	;null

rd%drm==400000,,0	;flag for read macro, of either kind
rd%dsm==200000,,0	;flag for splice macro - rd%drm also set

;The actual table is elsewhere, to keep the code pure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; READ
;;   This is complicated by the kill character, which is rubout in
;;   DDTIN mode.  In order to abort any reading, we must save the
;;   context at the start of read.  Then when the kill char is seen
;;   anywhere within READ, we restore the context and try again.
;;   Also, note that read macros can call READ recursively.  In this
;;   case, we want to kill up to the topmost call to READ.  Hence
;;   things are saved only initially.  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;Note that a top-level entrance binds RDTOP, whereas recursive
;;;;;entrances rebind it to itself.  This is to make it easy to tell
;;;;;when you have a final exit, because then restoring the old binding
;;;;;will give you NIL.

;;RDEXIT - normal exit from read.  All subroutines of READ should exit
;;  through this
rdexit:	pop sp,@[datsec,,.rdtop];saved value of RDTOP
	adjsp sp,-1		;RDTOP itself
	skipe @[datsec,,.rdtop]	;if this is final exit
	ret			;not - just exit now
	adjsp p,-3		;undo saved q and sp
	skipn sawfix		;asked for edit?
	ret			;no - done now
	jrst @[<%fixfn &addbts>+at%cal] ;yes - call his fixer

;;RDENT - standard entrance code to READ.
;Note that CRDCTX and RDEXIT depend upon this pushing 3 things on P
define rdenter
	skipe w2,@[datsec,,.rdtop];if first call to read
	jrst .+7		;not, go on
;toplevel call to READ
	setzm sawfix		;init for ^F
	push p,[codsec,,.-3]	;save context on .RDTOP
	push p,q
	push p,sp
	move w2,p
	tlo w2,(object(ty%adr,0))
;all calls to read
	move o2,[object ty%adr,<datsec,,.rdtop>]
	fasbind o2,w2
	termin

;READCONTEXT allows the user to write code that will be executed in
;read context, i.e. if ^Z or ^F is typed, the right thing will happen.

;;;;;READCONTEXT for compiled functions
;;;;;  call crdctx
;;;;;  jrst ret+1
;;;;;  code inside the readcontext
;;;;;  ret

crdctx:	rdenter
	move w2,-3(p)		;return address
	call 1(w2)		;call inner code
	jrst rdexit		;and exit canonically

;interpreted READCONTEXT - FSUBR
rdcntx:	push q,o1		;save in case of recylcing
	rdenter
	move o1,(q)		;get back O1
	call progn		;eval things to do
	adjsp q,-1
	jrst rdexit		;and exit canonically


;;;;;;end of READ context routines.  Here is the code itself
;;;;;;

;RDNAM - like read, but no interning
rdnam:	push p,sp
	move o3,[%dointern]	;set ..intern to false
	fasbind o3,nil
	call read
	jrst unbind

;;RDKILL - called by DDTIN I/O routine to kill a read
rdkill:	move w3,@[datsec,,.rdtop] ;retry read - old p
	tlz w3,770000
	move p,w3
	pop p,w2		;saved sp
	pop p,q			;saved q
	jrst cubin1		;place to go to is now top of P

;;READ - normal read entrance
read:	rdenter			;establish stack context
;loop for skipping leading spaces, etc
read1:	call tyi
read2:	skipl w2,rdtab(o1)
	xct readxt(w2)  	;to READ if should skip, to READY if not
	jrst rdmac

;readx - version of read for internal use - doesn't do tyi
readx:	rdenter
	jrst read2

;this table handles the first char encountered by READ
;;READTABLE
readxt:	jrst rdat	;letters
	jrst rdatlc	;lower case
	jrst rdlist	;(
	jrst read1	;)
	jrst rdsuls	;[ - super list
	jrst read1	;]
	jrst rdindt	;. - may be a float number
	jrst illcom	;,
	jrst rdquot	;'
	jrst rdsl1	;/
	jrst rdstr	;"
	jrst read1	;space
	jrst read1	;all end of lines
	jrst rdnum	;digits
	jrst rdneg	;+ -
	jrst read1	;esc

;here after initial slash - use next char
rdsl1:	call tyi
	hrrz w2,rdtab(o1)
	jrst rdat

;here if lower case - see if we raise it
rdatlc:	skipn @[datsec,,.raise]	;*raise?
	jrst rdat		;no - leave it
	subi o1,40		;raise is on, convert
	;jrst rdat

;;TY%ATM
;;TY%STR
;Here if nothing special - it is an atom
  ;no spec char - first char of atom - set up byte pointer
  ;free + 1 is the string descriptor - can't do it until the end
  ;free + 2 and following is the string, asciz
  ;byte pointer will be -1(p)
  ;o1 is the current char
rdat:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	push p,w3
	push p,w4		;byte ptr is now -1(p)
	setzm (w4)		;make sure low order bit is clear
	idpb o1,-1(p)		;put down 1st char
  ;other char's of atom
rdatlp:	call tyi
	hrrz w2,rdtab(o1)	;see what it is
	xct rdattb(w2)		;stop loop when char that can't be in atom

;;READTABLE
rdattb:	jrst rdatnc	;letters
	jrst rdatnl	;lower case
	jrst rdatsp	;(
	jrst rdatsp	;)
	jrst rdatsp	;[
	jrst rdatsp	;]
	jrst rdatsp	;.
	jrst rdatsp	;,
	jrst rdatsp	;'
	jrst rdsl2	;/
	jrst rdatsp	;"
	jrst rdatsp	;space
	jrst rdatsp	;all end of lines
	jrst rdatnc	;digits
	jrst rdatnc	;+ -
	jrst rdatsp	;esc

;here after initial slash - use next char
rdsl2:	call tyi
	hrrz w2,rdtab(o1)
	jrst rdatnc

;here if lower case - see if we raise it
rdatnl:	skipn @[datsec,,.raise]	;if raise
	jrst rdatnc		;no - leave it
	subi o1,40		;raise is on, and terminal, convert
	;jrst rdatnc

  ;go on to next char in atom
rdatnc:	idpb o1,-1(p)		;put the char in the string
	move w2,(p)		;clear next word
	setzm 1(w2)		;to make sure low order bit is off
	jrst rdatlp

;here when we come to char that can't be in an atom - stop
;this is the main place where we construct atoms
;at%val==0
;at%pro==1
;at%pna==2
;at%fun==3
;at%fev==4

;note that the loop clears the next word ahead of us.  thus we
;have an asciz string without explicitly needing to put a null
;there.

rdatsp:	call untyi		;put back break char
	idpb nil,-1(p)		;make ASCIZ
	skipe @[datsec,,.dointern] ;if interning on
	jrst iinter		;special INTERN will creat atom if needed
	xmovei w2,1(free)	;start of string
	move w3,(p)		;end of string
	move free,w3		;update free list
	sub w3,w2		;w3 is length in words
	tlo w3,(object(ty%spc,0)) ;special GC code
	movem w3,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
  ;We are going to have a JSP W3,@.+1 in the block.  As this is a local
  ;ref to .+1, better make sure it is not in 0 - 17, or we will get a 
  ;ref to the AC's, instead.
	hrrzi w3,at%dsp+1(free)	;RH of address where JSP will point
	caige w3,20		;OK if above AC's
	jrst [push free,nil	;in AC's - better move up
	      jrst .-2]		;and try again
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[jsp w3,@0]	;at%cal - jsp w3,@.+1
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	hrrm free,-1(free)	;put address into JSP
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
	adjsp p,-2		;get rid of byte ptr on stack
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	jrst rdexit

;;TY%STR
;here for string - very much like atom
rdstr:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	push p,w3
	push p,w4		;byte ptr is now -1(p)
	setzm (w4)		;clear first word of string
  ;characters in string
rdstlp:	call tyi
	hrrz w2,rdtab(o1)	;see what it is
	xct rdsttb(w2)		;stop loop when "

;;READTABLE
rdsttb:	jrst rdstnc	;letters
	jrst rdstnc	;lower case
	jrst rdstnc	;(
	jrst rdstnc	;)
	jrst rdstnc	;[
	jrst rdstnc	;]
	jrst rdstnc	;.
	jrst rdstnc	;,
	jrst rdstnc	;'
	jrst rdstnc	;/
	jrst rdsten	;"
	jrst rdstnc	;space
	jrst rdstnc	;all end of lines
	jrst rdstnc	;digits
	jrst rdstnc	;+ -
	jrst rdstnc	;esc

  ;go on to next char in string
rdstnc:	idpb o1,-1(p)		;put the char in the string
	move w2,(p)		;clear next word
	setzm 1(w2)
	jrst rdstlp

rdsten:	idpb nil,-1(p)		;make ASCIZ
	xmovei w2,1(free)	;start of string
	move w3,(p)		;end of string
	move free,w3		;update free list
	sub w3,w2		;w3 is length in words
	tlo w3,(object(ty%spc,0)) ;special GC code
	movem w3,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	move o1,w2		;and return it
	adjsp p,-2		;get rid of byte ptr on stack
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	jrst rdexit

;here when see an open paren - paren has been read, nothing on stack
;we are going to build up a list structure. Start with (NIL), so as
;to have something to NCONC new char's onto.
;  The super-paren kludge assumes that this section of code will
;  always be exited from rdlsen or rdlsun, or by an error

rdsuls:	;read superlist.  This sets a flag so ] matches
	skipa w2,[-1]		;super list flag
rdlist:	setz w2,
	push p,w2		;save flag
	docons o2,nil,nil
	push q,o2		;save list being built on stack
	push q,(q)		;start, end
rdlslp:	call tyi
	skipl w2,rdtab(o1)	;see what we have
	xct rdlstb(w2)
	tlnn w2,(rd%dsm)	;read macro - is it really splice?
	jrst rdls		;read macro - will be handled by READ
	jrst rdsmac		;yes - read splice macro

;;READTABLE
rdlstb:	jrst rdls	;letters
	jrst rdls	;lower case
	jrst rdls	;(
	jrst rdlsen	;)
	jrst rdls	;[
	jrst rdlsun	;]
	jrst rddot	;.
	jrst rdlslp	;,
	jrst rdls	;'
	jrst rdls	;/
	jrst rdls	;"
	jrst rdlslp	;space
	jrst rdlslp	;all end of lines
	jrst rdls	;digits
	jrst rdls	;+ -
	jrst rdlssn	;esc - supersuper close

  ;beginning of some object, call READX to process
rdls:	call readx		;o1 - new
	docons o2,o1,nil	;o2 - (new)
	pop q,o3		;o3 - old end
	dorpd o3,o2		;o2_ (...end new)
	push q,o2		;now start, new end
	jrst rdlslp

  ;splice macro
rdsmac:	call mascii		;o1 - char atom
	move o2,[%splicemacro]	;look up read macro defn
	move o6,o1		;save for error msg
	call xget		;o1 - lambda form
	jumpe o1,nrdmac		;no read macro defn
	move o2,nil		;no args
	call apply		;interpret the lambda
	move o2,nil
	call app		;fast copy
	pop q,o3		;o3 - old end
	dorpd o3,o1		;splice new to it
rdsmc1:	docdr o2,o3		;now go to end of list
	scons o2
	jrst rdsmc2
	move o3,o2
	jrst rdsmc1	
rdsmc2:	push q,o3		;we now have end of list
	jrst rdlslp		;now go read next item

xread:	rdenter
  ;this is a modified version of READ - it is changed to not allow
  ;close parens and friends
  ;loop for skipping leading spaces, etc
xread1:	call tyi
	skipl w2,rdtab(o1)
	xct xreadt(w2)  	;to READ if should skip, to READY if not
	jrst rdmac

;this table handles the first char encountered by READ after a dot
;;READTABLE
xreadt:	jrst rdat	;letters
	jrst rdatlc	;lower case
	jrst rdlist	;(
	jrst illdot	;)
	jrst rdsuls	;[ - super list
	jrst illdot	;]
	jrst rdindt	;.
	jrst illcom	;,
	jrst rdquot	;'
	jrst rdsl1	;/
	jrst rdstr	;"
	jrst xread1	;space
	jrst xread1	;all end of lines
	jrst rdnum	;digits
	jrst rdneg	;+ -
	jrst illdot	;esc

	
;here if we found a dot or decimal pt. - note that we are in rdlist
rddot:	call tyi		;o1 - peek at next
	hrrz w2,rdtab(o1)	;what is it?
	cain w2,rd%dig		;a digit?
	jrst rddot1		;yes - read a real number
	call untyi		;no - unread it and treat this as dot
;It is a dot. Better have closing item.
	call xread		;o1 - new
	pop q,o2		;o2 - old end
	dorpd o2,o1		;stick new onto end
	push q,o1
rddtlp:	call tyi		;now skip until find close paren
  ;blanks are OK
	skipl w2,rdtab(o1)	;see what we have
	xct rddttb(w2)		;blank space or end of list
	jrst illdot		;read macro illegal here

;here when the dot is a period in a real number.  We go to RDLS, just
;as we do to read any other "normal" token showing up in RDLSTB.  However
;we have to restore the dot to o1, since we just scanned ahead.
rddot1:	call untyi		;unread it and treat as decimal pt.
	move o1,[char "."]
	jrst rdls

;;READTABLE
rddttb:	jrst illdot	;letters
	jrst illdot	;lower case
	jrst illdot	;(
	jrst rdlsen	;)
	jrst illdot	;[
	jrst rdlsun	;]
	jrst illdot	;.
	jrst illdot	;,
	jrst illdot	;'
	jrst illdot	;/
	jrst illdot	;"
	jrst rddtlp	;space
	jrst rddtlp	;all end of lines
	jrst illdot	;digits
	jrst illdot	;+ -
	jrst rdlssn	;esc - supersuperend

;here when have read close paren. stack is START, END
  ;special entry for ] - matches [
  ;note that (p) is a flag, non-zero if this was opened by a [
  ;special entry for ESC is never matched
rdlsun:	skipe (p)		;was this opened by [?
	jrst rdlsen		;yes - everything is matched - normal
rdlssn:	call untyi		;no - save the ] for next level above	
rdlsen:	pop q,o1		;forget end
	pop q,o1		;get start
	docdr o1,o1		;our list is the cdr
	adjsp p,-1		;throw away super paren flag	
	jrst rdexit

;here for read macro
;o1 - contains char object
rdmac:	move w2,rdtab(o1)	;get flags
	tlne w2,(rd%dsm)	;make sure not splice
	jrst [perr /Splice macro must occur inside list/]
	call mascii		;o1 - char atom
	move o2,[%readmacro]	;look up read macro defn
	move o6,o1		;save for err msg
	call xget		;o1 - lambda form
	jumpe o1,nrdmac		;no read macro defn
	move o2,nil		;no args
	call apply		;interpret the lambda
	jrst rdexit		;value is returned in o1

nrdmac:	move o1,o6
	perr /Missing readmacro definition/

;here for quote
rdquot:	call read
	docons o2,o1,nil	;(thing)
	move o3,[%quote]
	docons o1,o3,o2		;(quote thing)
	jrst rdexit


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  This section is for reading numbers
;;  The first set of routines does not do any decoding, but is used in
;;    various cases where we don't know whether we have a number of not.
;;  Then there is the main number reader
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;Routines for checking whether we have a number or not.  These either
;;;;;exit to somewhere else or go somewhere into RDNUM.

;;;;;initial dot

;here for initial dot.  Either a decimal pt or illegal
rdindt:	call tyi		;peek at next
	hrrz w2,rdtab(o1)	;see what it is
	caie w2,rd%dig		;if not digit
	jrst illdot		;illegal dot
	call rdind1		;go process starting with initial dot
	jrst rdexit

;;;;;sign

;;TY%INT
;;TY%REA
;here for a - or + initially
rdneg:	push q,o1		;save sign for later
	call tyi		;see if next is decimal pt or digit
	hrrz w2,rdtab(o1)
	caie w2,rd%per
	cain w2,rd%dig
	jrst .+2
	jrst rdnng		;not a number
	call rdnum0		;now decode the number after it
	pop q,o2		;get back the sign
	camn o2,[char "+"]	;if negative
	jrst rdexit		;not - done
	gettyp o1		;see what we have
	cain w2,ty%rea		;if real, special code
	jrst rdnrea		;negate real
	cain w2,ty%big		;if bignum, special code
	jrst rdnbig		;negate bignum
	move w2,o1		;not real
	getnum w2		;negate inum
	movn w2,w2
	maknum w2
	move o1,w2
	jrst rdexit

;the reason we don't just use MINUS is that we want to negate in place,
;rather than cons'ing a new number cell
;negate real
rdnrea:	dmove w2,1(o1)		;negate it in place
	dmovnm w2,1(o1)
	jrst rdexit

rdnbig:	move w2,1(o1)		;negate it in place
	movnm w2,1(o1)
	jrst rdexit

rdnng:	call untyi		;undo the lookahead
	pop q,o1		;get back saved sign
	jrst rdat		;and treat it as atom

;;;;;; This is the main number reader
;;TY%INT
;;TY%REA
;;TY%BIG

;special entry if have already seen a dot - have digit now
rdind1:	push p,q
	push p,[0]
	push p,[0]
	push p,[char "."]
	jrst rdnl1e

;here for a digit
;RDNUM0 is a common routine called here and by the negative number
;handler.  RDNUM0 and all its subroutines return by simple RET.
;RDNUM is jrst'ed to by READ, so it must exit via RDEXIT
rdnum:	call rdnum0
	jrst rdexit

;this is the real work of rdnum
rdnum0:	push p,q		;save q, since we will hack on it
	push p,[0]		;clear working areas
	push p,[0]
	push p,[nil]
	jrst rdnl1e	
;loop one - pushes the char's on the stack
  ;-3(p) - saved q
  ;-2(p) - number of digits seen
  ;-1(p) - number of digits after point
  ;(p) - point character
rdnml1:	call tyi
rdnl1e:	hrrz w2,rdtab(o1)	;see what thing this is?
	cain w2,rd%dig		;digit?
	jrst rdnmdg		;yes - stack it
	cain w2,rd%per		;decimal pt?
	jrst rdnmpt		;yes - process it
	came o1,[char "q"]	;octal point?
	camn o1,[char "Q"]
	jrst rdnmoc		;yes - process octal
	jrst rdnmtr		;no - done with first loop

;digit
rdnmdg:	push q,o1		;stack next char
	aos -2(p)		;and count it
	aos -1(p)
	jrst rdnml1	
;decimal pt
rdnmpt:	setzm -1(p)		;get good count after pt
	movem o1,(p)		;save point
	jrst rdnml1
;octal pt
rdnmoc:	setzm -1(p)		;get good count after pt
	move o1,[char "Q"]	;normalize the point
	movem o1,(p)		;and save it
	hrrz w2,rdtab(o1)	;stop now, as don't allow 123Q45
	jrst rdnmt1		;exit from loop and don't recognize E

;now we have the terminator - see if this is a real number
rdnmtr:	skipn (p)		;if no point seen
	setzm -1(p)		;then no digits after point
	came o1,[char "E"]	;if terminator is exponent
	camn o1,[char "e"]
	jrst rdexp		;then real with exp
	skipe -1(p)		;else if something after point
	jrst rdreal		;normal real
;here if known not to be a real
	call untyi		;put back terminator
rdnmt1:

;-2(p) - saved q
;-1(p) - number of digits
;(p) - base
;w2,w3 - number being built
;w4 - new digit

	pop p,o2		;point
	adjsp p,-1		;throw away digits after point
	move w2,@[datsec,,.IBASE] ;compute base
	getnum w2		;internal value - this is the default
	jumpe o2,rdnmnb		;if no point given, that is it
	movei w2,10.		;if point, we have decimal
	camn o2,[char "Q"]	;except if Q
	movei w2,8.		;then octal
rdnmnb:	push p,w2		;save base
	setzb w2,w3		;clear number being built up

;nil1 is pointer to q
;now we go up the stack decoding the number
	xmovei nil1,1(q)	;last digit
	sub nil1,-1(p)		;first digit
rdnml2:	sosge -1(p)		;any digits left to scan?
	jrst rdnmx2		;no - done
	move w4,(nil1)		;get the digit
	sub w4,[char "0"]	;convert to value
	move w2,w3		;get low-order part of double result
	mul w2,(p)		;multiply old value by base
	jov .+1			;clear overflow
	add w3,w4		;add in new digit
	jov [addi w2,1		;propagate carry
	     jrst .+1]
	caile w2,1		;allow one bit of overflow
	jrst toobig
	aoja nil1,rdnml2	;go back for more digits

rdnmx2:	cain w2,1		;if one bit overflow
	tlo w3,400000		;set sign bit
	adjsp p,-2		;kill old p things
	pop p,q			;put back q
	move nil1,nil		;and nil1
	move w2,w3
	jrst retint		;return INUM or BIGNUM

toobig:	setz nil1,
	err /Number too big/


;rdint - read integer, results in w3
rdint:	call tyi
	hrrz w2,rdtab(o1)
	call rdsgn		;get a sign - returns on Q
	call rdpint		;get a pos. integer - returns in w3
	pop q,o2		;sign - nil if pos, non-nil if neg
	skipe o2
	movn w3,w3
	ret

;rdsgn - get nil if + or no sign, non-nil if -
rdsgn:	push q,[nil]		;assume no sign
	caie w2,rd%sgn
	ret			;right - none
	move o2,[%t]
	came o1,[char "+"]	;there is one, if negative
	movem o2,(q)		;return T
	call tyi
	hrrz w2,rdtab(o1)	;and get next char
	ret

;rdpint - get positive integer
rdpint:	push p,[0]		;number we are building
rdpinl:	caie w2,rd%dig		;more digits?
	jrst rdpinx		;no - return the 0
	move w3,(p)		;get old number
	tlne w3,774000		;too big to add another digit?
	jrst toobig		;yes
	imuli w3,10.		;shift by one digit
	move w2,o1		;and add in new one
	sub w2,[char "0"]
	add w3,w2
	movem w3,(p)		;put it back in stack
	call tyi
	hrrz w2,rdtab(o1)	;and advance a char
	jrst rdpinl

rdpinx:	pop p,w3		;return in w3
	ret

;real number readers:

;here if we saw E - go scan an exponent
rdexp:	call rdint		;read exp, returns in w3
	movn w3,w3		;subtract from digits after decimal
	addm w3,-1(p)

  ;-4(p) - saved q
  ;-3(p) - number of digits seen
  ;-2(p) - number of digits after point
  ;-1(p),(p) - next char

rdreal:	call untyi		;get rid of break char
	setzb w2,w3		;build up number in w2,w3
	setzm (p)		;clear new digit
	push p,[0]
	xmovei w4,1(q)		;last digit
	sub w4,-3(p)		;first digit
	jov .+1			;clear overflow
rdrl2:	sosge -3(p)		;any digits left to scan?
	jrst rdrx2		;no - done
	move nil1,(w4)		;get the digit
	sub nil1,[char "0"]	;convert to value
	fltr nil1,nil1		;float it
	movem nil1,-1(p)	;and put it in right place
	dfmp w2,[10.0
		 0]		;multiple old value by base
	dfad w2,-1(p)		;and add in new digit
	aoja w4,rdrl2		;go back for more digits

rdrup:	dfmp w2,[10.0
		 0]
	aos -2(p)
	jrst rdrx2

rdrdwn:	dfdv w2,[10.0
		 0]
	sos -2(p)
	jrst rdrx2

;we now have number in w2,w3
rdrx2:	skiple -2(p)		;digits after decimal pt?
	jrst rdrdwn		;yes - scale it down
	skipge -2(p)		;scale the other way?
	jrst rdrup
	jov toobig
	push free,[object(ty%spc,2)] ;now make real number object
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%rea,0))
	move o1,w4		;and return that
	push free,w2
	push free,w3
	adjsp p,-4		;kill off junk
	move nil1,nil		;clean up NIL
	pop p,q			;put back old q
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

;;TY%ATM
;;TY%STR
;intern works by doing EQUAL on PNAMEs of all atoms on the OBLIST
;until one is found that matches
intern:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new atom
	satom o1
	jrst [perr /Attempt to INTERN something that is not an atom/]
	move w2,at%pna(o1)	;addr of pname
	move w2,1(w2)		;first word of pname
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o2,@[<w3_30.>\<datsec,,obarr>] ;oblist
intrlp:
  ;o2 is oblist tail
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
	jumpe o2,intrno		;nothing in tail - add new entry to oblist
  ;first find the pname of the new atom into w2
	move w2,at%pna(o1)	;addr of pname
  ;now find the pname of the oblist atom into w3
	docar o3,o2		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst intrnx		;different, ignore
	aoj w2,
	aoj w3,
intrcp:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst intrnx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst intrys		;yes - we found it!
	aoja w3,intrcp		;no - loop
  ;didn't find one, try next thing on oblist
intrnx:	docdr o2,o2
	jrst intrlp

;yes - found it on oblist
;in this case we just want to return the atom on the oblist
;note that NIL is special
intrys:	docar o1,o2		;the atom we found
	adjsp p,-1		;kill hash
	camn o1,[%nil]		;if NIL, use 0
	movei o1,nil	
	ret

;no - ran out of oblist - add to it -- atom, pname
intrno:	pop p,w3		;hash
	move o2,@[<w3_30.>\<datsec,,obarr>] ;old bucket
	docons o3,o1,o2		;make new cell on oblist
	movem o3,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	ret			;returns new atom

;;TY%ATM
;;TY%STR
;IINTER is a special version of INTERN designed to be called from READ.
;It finds the new string at the start of free space.  If the atom is
;already there, no extra free space is used.  If it has to create a
;new atom, the atom structure must be made here.  It is JRST'ed to from
;RDATSP, and thus is in that stack context.  Thus it must kill some temps
;on the stack and return via RDATSP.
iinter:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new pname
	xmovei w2,1(free)	;start of string
	move w3,(p)		;end of string
	sub w3,w2		;w3 is length in words
	tlo w3,(object(ty%spc,0)) ;special GC code
	movem w3,(w2)		;as header
	move w2,2(free)		;start of string
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o2,@[<w3_30.>\<datsec,,obarr>] ;oblist
iintrl:
  ;o2 is oblist tail
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
	jumpe o2,iintrn		;nothing in tail - add new entry to oblist
  ;first find the pname of the new atom into w2
	xmovei w2,1(free)	;addr of length code
  ;now find the pname of the oblist atom into w3
	docar o3,o2		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst iintrx		;different, ignore
	aoj w2,
	aoj w3,
iintrc:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst iintrx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst iintry		;yes - we found it!
	aoja w3,iintrc		;no - loop
  ;didn't find one, try next thing on oblist
iintrx:	docdr o2,o2
	jrst iintrl

;yes - found it on oblist
;in this case we just want to return the atom on the oblist
;note that NIL is special
iintry:	docar o1,o2		;the atom we found
	adjsp p,-3		;kill hash and byte ptr on stack
	camn o1,[%nil]		;if NIL, use 0
	movei o1,nil	
	jrst rdexit

;no - ran out of oblist - add to it -- atom, pname
iintrn:	
  ;first create the new atom, put it in O1
	xmovei w2,1(free)	;start of string (actually length code)
	move free,-1(p)		;update free list
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
  ;We are going to have a JSP W3,@.+1 in the block.  As this is a local
  ;ref to .+1, better make sure it is not in 0 - 17, or we will get a 
  ;ref to the AC's, instead.
	hrrzi w3,at%dsp+1(free)	;RH of address where JSP will point
	caige w3,20		;OK if above AC's
	jrst [push free,nil	;in AC's - better move up
	      jrst .-2]		;and try again
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[jsp w3,@0]	;at%cal - jsp w3,@.+1
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	hrrm free,-1(free)	;put address into JSP
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
  ;Now do the actual INTERN
	pop p,w3		;hash
	move o2,@[<w3_30.>\<datsec,,obarr>] ;old bucket
	docons o3,o1,o2		;make new cell on oblist
	movem o3,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	adjsp p,-2		;get rid of byte ptr on stack
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	jrst rdexit

remob:	push q,o1		;save list of things to remob
remobl:	move o2,(q)		;get list back
	jumpe o2,remobx		;done if nothing more
	docar o1,o2		;we want to do CAR
	docdr o2,o2		;cdr for next time
	movem o2,(q)
	call remob1		;kill this one
	jrst remobl
remobx:	adjsp q,-1
	ret

;;TY%ATM
;;TY%STR
;remob1 works by doing EQUAL on PNAMEs of all atoms on the OBLIST
;until one is found that matches
remob1:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new atom
	satom o1
	jrst [perr /Attempt to REMOB something that is not an atom/]
	move w2,at%pna(o1)	;addr of pname
	move w2,1(w2)		;first word of pname
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o5,@[<w3_30.>\<datsec,,obarr>] ;bucket
	move o2,[object(ty%adr,o4)] ;start with this psuedo-atom
remolp:
  ;o2 is bucket tail, always one back from current to allow rplacd
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
  ;O4, O5 are a pseudo-atom whose CDR (O5) points to start of list
  ;first find the pname of the new atom into w2
	move w2,at%pna(o1)	;addr of pname
  ;now find the pname of the oblist atom into w3
	docdr o3,o2		;get to current tail
	jumpe o3,remoex		;nothing in tail - done
	docar o3,o3		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst remonx		;different, ignore
	aoj w2,
	aoj w3,
remocp:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst remonx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst remoys		;yes - we found it!
	aoja w3,remocp		;no - loop
  ;didn't find one, try next thing on oblist
remonx:	docdr o2,o2
	jrst remolp

;yes - found it on oblist
;in this case we remove it.  The atom is question is (CADR O2)
;note that NIL is special
remoys:	docdr o1,o2		;get next after one to remove
	docdr o1,o1
	camn o2,[object ty%adr,o4] ;at start of list?
	jrst remost		;yes - special
	dorpd o2,o1
remoex:	move o1,nil		;return nil
	adjsp p,-1		;remove saved index
	ret

;at start of bucket
remost:	pop p,w3		;hash
	movem o1,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	move o1,nil
	ret			;returns new atom

;;ty%atm
;;ty%str
gensym:	
;first update GNUM to be the next ascii number
	move w2,[.bp 376,gnum]
	movei w3,4
	movei
gensy1:	ldb w4,w2		;get last digit
	aos w4			;add one
	caile w4,"9"		;if in range
	jrst gensy3		;not
	dpb w4,w2		;yes - just put it back
;now we have an up to date name in GNUM
gensy2:	push free,[object ty%spc,2] ;string of two words
	move w2,free		;save pointer to this
	push free,gnum		;first is GNUM
	push free,[0]		;zero word for ASCIZ
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
  ;We are going to have a JSP W3,@.+1 in the block.  As this is a local
  ;ref to .+1, better make sure it is not in 0 - 17, or we will get a 
  ;ref to the AC's, instead.
	hrrzi w3,at%dsp+1(free)	;RH of address where JSP will point
	caige w3,20		;OK if above AC's
	jrst [push free,nil	;in AC's - better move up
	      jrst .-2]		;and try again
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[jsp w3,@0]	;at%cal - jsp w3,@.+1
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	hrrm free,-1(free)	;put address in JSP
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret			;return it uninterned

;here when a digit overflows
gensy3:	movei w4,"0"		;use 0 and carry
	dpb w4,w2
	add w2,[70000,,0]	;to prev digit
	sojg w3,gensy1
	jrst gensy2		;ran out of digits - wraparound

;;ty%atm
;;ty%str
;CSYM - set up GNUM
csym:	docar o1,o1		;this is fsubr - get the arg
	push q,o1
	call getstr
	move w2,1(o1)		;get first word
	movem w2,gnum		;use that
	pop q,o1
	ret

illdot:	err /Dot context error/

illcom:	err /Comma must separate elements of a list/
	
;main read-eval-print
;This page contains all code that depends upon the fact that
;this is a shallow binding implementation.  

topst:	movem p,savep'
	movem q,saveq'
	movem sp,savesp'
	move o1,[object ty%ccn,<datsec,,initfi>]
	call xinput
	move o2,nil		;no closing
	call inc
;here to restart top level command processing
toplev:	move w2,inprch		;reinit prompt
	movem w2,prmpch
	move o2,nil		;no args
	skipn o2,@[datsec,,initf] ;any init fun?
	jrst toplop		;no - do ours
	docons o1,o2,nil	;yes - make up (fn)
	call eval		;and eval it
	;if it returns, fall into normal loop
toplop:	move o1,@[datsec,,.curin] ;do talk if input is from terminal
	camn o1,@[datsec,,priin]
	call talk
	call chstlm		;reset stack limits if needed
	move o1,[object ty%int,1]
	call lines
	call read
	call eval
	push q,o1
	call lines0
	pop q,o1
	docons o2,o1,nil
	move o1,[%%PRINFNTOP]
	call apply
	jrst toplop

;INITFN - to set initf used above
initfn:	exch o1,@[datsec,,initf]
	ret

;;TY%ATM
define getval(dest,atom)
	move dest,at%val(atom)
	termin


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  apply
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;The basic function is EVAL.  McCarthy defines EVAL in terms of APPLY.
;The problem with that definition is that it requires one to CONS up a
;list of args to pass to APPLY, and we don't want to do those CONS's.
;So we do not have EVAL call APPLY. Actually it turns out that our APPLY
;uses the main low-level routine from Slow EVAL.

;uapply is what the user gets when he types (APPLY).  It has an optional
;stack or a-list as third
uapply:	movei w4,apply		;call eval
	jrst incont		;in context specified by user

;;;;;;;;;;;;;;;;here is the real APPLY


apply:	
applc1:	getdsp o1
	xct appltb(w2)

;;TYPES
appltb:	jrst applds		;atom - see what it is
	jrst applds		;constant atom
	jrst applex		;cons - treat as EXPR
	jrst applex		;constant cons
	jrst udf1		;string - error
	jrst udf1		;constant string
	jrst udf1		;channel
	jrst udf1		;constant channel
	jrst udf1		;integer - error
	jrst udf1		;real - error
	jrst udf1		;bignum - error
	jrst udf1		;hunk
	jrst udf1		;address
	jrst udf1		;special
	jrst udf1		;16
	jrst udf1		;17


;main dispatch for atomic CAR
;if an atom, see if ftn def.  If not, eval it
applds:	jumpe o1,udf1		;NIL is special, as at%fun(nil) is AC3
	skipe o3,at%fun(o1)	;see if ftn defn
	jrst appds2		;yes - use it
appds1:	getval o3,o1		;o1 - ftn defn
	came o3,[%.UNBOUND]
	camn o3,o1		;prevent loops
	jrst udf1
	move o1,o3
	jrst applc1		;now see if the value is useful

;if find a ftn defn, dispatch on its type
appds2:	docar o4,o3		;car of defn is type code
	camn o4,[%expr]
	jrst apple1
	came o4,[%lsubr]	;lsubr and subr are bound the same
	camn o4,[%subr]
	jrst apple2		;bind as EXPR
	camn o4,[%fexpr]
	jrst applf1
	camn o4,[%fsubr]
	jrst applf2		;bind as FEXPR
	camn o4,[%macro]
	jrst applm1		;bind as MACRO
	camn o4,[%msubr]
	jrst applm2
	jrst appds1		;not a function type, ignore it

;;;;the following code is modelled after EVSEXP, EVSFEX, and EVSMAC.
;;;;They set up the stack the same way.  These 3 routines are called
;;;;  from APPLTB directly [only applex] - has a form in it, in O1
;;;;  from APPDS2 - has (EXPR LAMBDA, etc., which requires CDR to
;;;;     get to the form.  This is in O3
;;;;O2 is the arg list
;;;;EVFORM wants the function to be in O3

;EXPR
;  apple1 - form in O3, needs CDR
;  apple2 - form in O3, doesn't need CDR
;  applex - form in O1
apple2:	skipa o1,o3
apple1:	docdr o1,o3
applex:	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[0]		;count of args will go here
	jumpe o2,appexx		;no more args
appexl:	pushcar q,o2		;push the first
	aos (p)
	docdr o2,o2		;go to next
	jumpn o2,appexl
appexx:	push q,nil		;dummy extra arg saying not FEXPR
	move o3,o1		;get CAR (functional form)
	jrst evform		;now handle the form

;FEXPR
;  APPLF1 - form in O3, needs CDR
;  APPLF2 - form in O3, doesn't need CDR
applf2:	skipa
applf1:	docdr o3,o3
	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[2]		;we have either 1 or 2 as he prefers
	push q,o2		;one arg - cdr form
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	push q,w2		;second arg - non-NIL, so this flags as FEXPR
	jrst evform		;now handle the form

;MACRO
;  APPLM1 - form in O3, needs CDR
;  APPLM2 - form in O3, doesn't need CDR
;The problem is that we have to call EVFORM and then get control back.
;To do so, we have to hack the stack to produce:
;  saved q
;  saved sp
;  addr here where we want control back
;  ret addr
applm2:	skipa
applm1:	docdr o3,o3
	docons o4,o1,o2		;make up pseudo-form
	push q,o4		;one extra arg for finmac
	push p,[codsec,,evsmrt]
	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[1]
	push q,o4		;one arg - whole form
	push q,nil		;dummy extra arg saying not FEXPR
	jrst evform		;now handle the form and return here

wnoa:	err /Too many arguments supplied/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  eval
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;ueval is what the user gets when he types (EVAL).  It has an optional
;stack or a-list as second arg
ueval:	movei w4,eval		;call eval
	move o3,o2		;incont wants context in o3
	jrst incont		;in context specified by user

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; EVAL comes in two versions.  Fast eval is based on a dispatch
;; directly to specialized code.  Some code is specialized for
;; the particular function, others for specific types, e.g. EXPR.
;;   Slow EVAL uses the full algorithm.  It is used for other cases,
;; and can handle such things as LABEL, FUNARG, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast EVAL.  This stage is optimized by use of the AT%FEV
;; word.  This contains the address of an evaluator for use if
;; that function is called.  This saves us decoding the kind of
;; thing the function is, and lets us go straight to specialized code
;; to invoke it.  Functions that are non-straightforward have
;; evaluators that point to slow EVAL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

eval:	getdsp o1
	xct evaltb(w2)		;handle depending upon type

;;TYPES
evaltb:	jrst evalat		;atom
	jrst evalat		;constant atom
	jrst evalcn		;cons
	jrst evalcn		;constant cons
	ret			;string
	ret			;constant string
	ret			;channel
	ret			;constant channel
	ret			;integer
	ret			;real
	ret			;bignum
	ret			;hunk
	ret			;address
	ret			;special
	ret			;16
	ret			;17

;EVALAT - here for an atom
evalat:	getval o2,o1
	camn o2,[%.UNBOUND]
	jrst evalub
	move o1,o2
	ret

;unbound error - here we establish an EVAL BLIP, as at EVALCN, so the
;debugger can process the error.  See the section below on stack hacking
;for what this means
evalub:	push p,sp
	push p,q		;save q for RETFROM
	push sp,nil		;eval blip
	push sp,o1		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	perr /Unbound atom/

;here if form is an expression
evalcn:	
;For the break package, we put some information on the SP.  See the
;section below on stack hacking for what this means.
;Note that all of the special-purpose evaluators end with
;adjsp p,-2 ? adjsp sp,-4.  If you change the code below, you must
;change these.  Try searching for ADJSP SP,-4.
	push p,sp		;save old sp for unbind
	push p,q		;save q for RETFROM
	push sp,nil
	push sp,o1		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
;now we xct a location.  this is used to do single stepping, or anything
;else requiring a hook into the EVAL process
	xct evhook
;now see what we have
	docar o3,o1		;o3 - car of form


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the heart of fast EVAL.  There are actually 3 main cases:
;;    - atom has a function definition that can be done by the fast
;;	  routines.  Then there is a direct dispatch to the routine.
;;    - atom has a function definition that cannot be done by the
;;        fast routines, probably because it has LABEL or FUNARG.
;;	  Then slow eval is called for the function type.  This is
;;	  still done by direct dispatch.
;;    - atom has no function definition, but does have a variable.
;;	  It is evaluated and control returns here to EVAL1 to check again.
;;    - not at atom.  This is done by the slow eval routine for EXPR.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

eval1:	getdsp o3
	xct eval1t(w2)

.scalar evhook

;;TYPES
eval1t:	jrst evdisp		;atom - dispatch on evaluator
	jrst evdisp		;constant atom - "
	jrst evsexp		;cons - must use slow expr eval
	jrst evsexp		;constant - "
	jrst udf		;string - error
	jrst udf		;constant string
	jrst udf		;channel
	jrst udf		;constant channel
	jrst udf		;integer - error
	jrst udf		;real - error
	jrst udf		;bignum - error
	jrst udf		;hunk - error
	jrst udf		;address
	jrst udf		;special
	jrst udf		;16
	jrst udf		;17

udf:	move o1,o3
udf1:	perr /Undefined function/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here is the main dispatch.  One of the following will happen:
;;    - Directly to routine in fast eval
;;    - To evaluator for its function type in slow eval
;;    - undefined, in which case we can still try for a variable value.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;main dispatch for atomic CAR
evdisp:	jumpe o3,udf		;NIL is special, as at%fun(nil) is AC3
	move w2,at%fev(o3)	;get evaluator for that atom
	jrst (w2)		;go there

;here if undefined function, try value
evund:	getval o2,o3		;o3 - ftn defn of car(form)
	came o2,[%.UNBOUND]
	camn o2,o3		;prevent loops
	jrst udf
	move o3,o2
	jrst eval1		;now see if the value is useful
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Experts for fast EVAL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;A form starting with an atom is by far the most common case.  Thus we
;have optimized for it.  Each atom has an "evaluator".  This is 
;basically the place to go when we see a form beginning with that
;atom.  Atoms are initialized having evaluators that point to evund,
;for undefined functions.  Others may point to general evaluators such
;as that for EXPR, SUBR, etc.  But common special cases are handled
; directly:
;  SUBR's with 0, 1, and 2 args have special tailored evaluators
;  the most common functions and forms, CAR, CDR, CONS, COND,...
;    all have evaluators going directly to code associated with the
;    functions.  This is a bit hairy, but it gains about a factor of
;    2 in execution speed.  Note that these evaluators all end as
;    follows:
;       adjsp p,-2	;pops off the saved sp and q
;	adjsp sp,-4	;pops off the eval blip
;The adjsp sp,-4 is done instead of JRST UNBIND.  this works if no one
;has bound anything during the process of EVAL.  This is surely OK for
;SUBR's and FSUBR's, since EVAL doesn't do any binding for them.  However
;it may not work if FUNARG or LABEL have been used, which do in fact bind.
;However these forms use stage two.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast EXPR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;we have specialists for exprs with 0, 1, and 2 args
evexp0:	move o3,at%fun(o3)	;(expr lambda nil
	docdr o3,o3		;(lambda nil
	docdr o1,o1		;make sure he didn't give any args
	jumpn o1,wnoa
	docdr o3,o3		;(nil exprs...
	pushcdr q,o3		;(exprs
	jrst evexl

evexp1:	move o3,at%fun(o3)	;(expr lambda (x)
	docdr o3,o3		;(lambda (x)
	docdr o3,o3		;((x) exprs...
	pushcdr q,o3		;(exprs ...
	docar o3,o3		;(x)
	pushcar q,o3		;x
	docdr o2,o1		;arg list
	docar o1,o2		;first arg
	docdr o2,o2		;make sure he didn't give too many args
	jumpn o2,wnoa
	call eval
	pop q,o2		;formal
	fasbind o2,o1
	jrst evexl

evexp2:	move o2,at%fun(o3)	;(expr lambda (x y)
	docdr o2,o2		;(lambda (x y)
	docdr o2,o2		;((x y) exprs...
	pushcdr q,o2		;(exprs ...
	docar o2,o2		;o2 - (x y)
	docdr o3,o2		;(y)
	pushcar q,o3		;STACK - y
	pushcar q,o2		;STACK - x
	docdr o3,o1		;arg list
	docar o1,o3		;o1 - first arg
	docdr o3,o3		;cdr arg list
	pushcar q,o3		;STACK - second arg
	docdr o3,o3		;if more args, error
	jumpn o3,wnoa
	call eval		;eval first arg
	exch o1,(q)		;get second arg, save first
	call eval
	move o2,-2(q)		;second formal
	fasbind o2,o1		;bind second
	dmove o1,-1(q)		;get first arg and value
	fasbind o1,o2
	adjsp q,-3
	jrst evexl
	

;here to eval expr.  o3 has ftn lambda form.  This is the optimized entry
evexpr:
	move o3,at%fun(o3)
	docdr o4,o3		;skip EXPR
	docdr o4,o4
	docar o2,o4		;o2 - formals
evexpp:	docdr o1,o1		;o1 - actuals
	pushcdr q,o4		;save tail, pointing to things to do
	call evbind		;eval and bind args -- expr
	setz o1,		;nil if no expr found
evexl:	move o2,(q)		;get back expr's
	jumpe o2,evexx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evexl		;now try for next
evexx:	adjsp q,-1		;forget the expr
	adjsp p,-1		;forget saved q
	jrst unbind

;;;;;;EVBIND - routine used to evaluate and bind args in fast EXPR

;evbind(actuals,formals)
;o1 - actuals, o2 - formals
;return with new bindings added, evaluation having been done
evbind:	jumpe o2,evbin1		;exit if no more formals
	push q,o2		;save formals
	push q,o1		;save actuals
	docar o1,o1		;first actual
	call eval		;eval it
	exch o1,(q)		;get back actual list, save result
	move o2,-1(q)		;get back formal list
	docar o3,o2		;get this formal
	movem o3,-1(q)		;and put it in stack
	docdr o1,o1		;now cdr both lists
	docdr o2,o2
	call evbind		;handle cdr's first
	pop q,o1		;get back this actual
	pop q,o2		;get back this formal
	fasbind o2,o1		;bind formal to actual
	ret

;here when nothing to do
evbin1:	jumpn o1,wnoa		;if there are actuals, error
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast LEXPR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval lexpr.  o3 has ftn lambda form.  This is the optimized entry
evlexp:	move o3,at%fun(o3)
	docdr o3,o3		;skip the EXPR
	docdr o4,o3
	pushcar q,o4		;formal - this is an atom
	docdr o1,o1		;o1 - actuals
	pushcdr q,o4		;tail of things to do
;we bind these on the stack.  But since there are a variable number,
;we need something to tell us how many there are.  The pseudo-variable
;LXVARS will do that.
	push sp,[%lxvars]	;save old value
	push sp,@[datsec,,.lxvars]
	move w2,[object ty%adr,0] ;and put ADR object for Q into it
	ior w2,q
	movem w2,@[datsec,,.lxvars]
	push p,[0]		;place to count args
	call evonst		;eval and put on stack
;we now have the expression list and formal on the stack
;below the args.  We have to look at .lxvars to find where this is
	move w2,@[datsec,,.lxvars] ;q after those things were pushed
	pop w2,o2		;list of things to do
	pop w2,o1		;formal
	move w2,(p)		;count of args
	maknum w2		;legit lisp number
	bind o1,w2		;find the formal to the count
	push sp,[%lxnum]	;also save number for validity checking
	push sp,@[datsec,,.lxnum]
	movem w2,@[datsec,,.lxnum]
	push q,o2		;and push the list of things
	setz o1,		;nil if no expr found
evlxl:	move o2,(q)		;get back expr's
	jumpe o2,evlxx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evlxl		;now try for next
evlxx:	move w2,@[datsec,,.lxvars] ;get back the q
	tlz w2,770000		;turn into pure address
	move q,w2		;and restore it
	adjsp q,-2		;forget the two saved things
	adjsp p,-2		;forget saved q
	jrst unbind

;;;;;;EVONST - routine used by Fast Lexpr (and many others)


;evonst(actuals)
;o1 - actuals
;return with new bindings on stack
evonst:	jumpe o1,evonsx		;stop when no more args
	push q,o1		;save actuals
	docar o1,o1		;first actual
	call eval		;eval it
	aos -1(p)		;count args
	exch o1,(q)		;get back actual list, save result
	docdr o1,o1		;now cdr arg list
	jumpn o1,evonst		;and try again if more
evonsx:	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast MACRO's.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;here to eval macro - o3 (MACRO lambda ...
evmacr:	move o3,at%fun(o3)
	docdr o3,o3		;get the expr
	docdr o3,o3
	docar o2,o3		;o2 - formal list
	jumpe o2,wnoa		;make sure there is at least one formal
	docar o4,o2		;o4 - first formal
	fasbind o4,o1		;bind to form
	push q,o1		;save form
	docdr o3,o3		;o3 - tail pointing to first expr to do
	push q,o3		;save tail
	setz o1,		;nil if no expr found
evmal:	move o2,(q)		;get back expr's
	jumpe o2,evmax		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evmal		;now try for next
evmax:	adjsp q,-1		;forget the expr
;This is the entry point from MSUBR code
domacr:	adjsp p,-1		;forget saved Q
	pop p,w2		;now do special unbind that returns
	call unbin1
;now we make the MACROEXPANSION thing
;we have to take the old cell that was his form and smash it, since
;we don't know who points to it.
finmac:	skipn @[datsec,,.mexp]	;expand macros?
	jrst nomexp		;no
	pop q,o2		;o2 - original form
	docdr o3,o2		;o3 - old cdr
	docar o4,o2		;o4 - old car
	docons o5,o4,o3		;o5 - copy of that cell
	docons o4,o5,nil	;o4 - (-old cell-)
	docons o3,o1,o4		;o3 - (exp old-cell)
	move o4,[%mexp]
	dorpa o2,o4
	dorpd o2,o3		;o1 - (mexpan  exp old-cell)
	move o1,o2
	jrst eval		;now eval the result

nomexp:	adjsp q,-1		;prune stack
	jrst eval		;now eval the result

;here to do (mexpansion)
mexp:	docar o1,o1		;get expansion
	jrst eval		;eval it


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast FEXPR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval fexpr. - o3 (FEXPR lambda...
evfexp:	move o3,at%fun(o3)
	docdr o3,o3		;get the expr
	docdr o3,o3
	docar o2,o3		;o2 - formal list
	jumpe o2,wnoa		;make sure there is at least one formal
	docar o4,o2		;o4 - first formal
	docdr o1,o1		;o1 - cdr form
	fasbind o4,o1		;bind to cdr form
	docdr o2,o2		;another formal?
	jumpe o2,evfe1		;no- that's it
  ;here if we have a second formal - it gets a SPDL pointer
	move w2,sp		;top of stack
	sub w2,[basesp+1]	;convert to offset from start
    ;note - the canonical code for above is basesp-1.  However we have
    ;just added a binding which we don't want counted.  So by using
    ;a base 2 too big we get the right result.
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	docar o2,o2		;o2 - second formal
	bind o2,w2		;bind it to spdl pointer
evfe1:	pushcdr q,o3		;save tail of form - list of things to do
	setz o1,		;return nil if nothing to do
	jrst evexl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast SUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;special evaluators for common cases.  Note that these exit by doing
;adjsp P instead of popping.  This is because no bindings other than
;the eval blip can possibly have been done, so we just get rid of
;the blip. We know that because evaluators are always called directly
;from the beginning of EVAL.

evsub2:	move o2,at%fun(o3)
	docdr o2,o2
	pushcar p,o2		;stack the addr to go to
	docdr o2,o1		;arglist
	docar o1,o2		;o1 - first arg
	docdr o2,o2		;cdr arg list
	pushcar q,o2		;STACK - second arg
	docdr o2,o2		;make sure no extra args
	jumpn o2,wnoa
	call eval		;do first arg
	exch o1,(q)
	call eval		;do second arg
	move o2,o1		;move to second place
	pop q,o1		;and this to first
	pop p,w2
	call (w2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

evsub1:	move o2,at%fun(o3)
	docdr o2,o2
	pushcar p,o2		;stack the addr to go to
	docdr o2,o1		;one arg only
	docar o1,o2
	docdr o2,o2		;make sure no extra args
	jumpn o2,wnoa
	call eval
	pop p,w2
	call (w2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

evsub0:	move o2,at%fun(o3)
	docdr o1,o1		;make sure no args
	jumpn o1,wnoa
	docdr o2,o2
	docar o2,o2		;the addr is (cadr form)
	call (o2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

;;;;;;;;;;;FAST SUBR - general form

;here to eval subr.  Have  o3 - (SUBR addr, #args)
evsubr:	move o3,at%fun(o3)
	docdr o1,o1		;actuals
	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	docar w2,o3		;#args
	getnum w2
  ;o1 - actuals, w2 - # args, w3 - addr
	call evstac		;value
	adjsp p,-1		;forget saved Q
	jrst unbind

;;;;;;;;;;EVSTACK - subroutine for stage 1 subrs

;evstack(actuals, addr)
;o1 - actuals, w2 - # args, w3 - addr
evstac:	jumpe w2,(w3)		;if no args, just call the thing
	push p,w3		;save the routine to call
	push p,w2		;need two copies of # args
	push p,w2
;evaluate args and put them on stack
evsta1:	push q,o1		;save list of args for next arg
	docar o1,o1		;o1 - current arg
	call eval		;eval it
	exch o1,(q)		;put value on stack and get back actual list
	docdr o1,o1		;next arg
	sosle (p)		;any more formals?
	jrst evsta1		;yes - eval next
;pop the args from the stack to the AC's
	jumpn o1,wnoa		;if any more actuals, too many
	move w2,-1(p)		;new copy of count - (p) is now zero
evsta2:	pop q,o1-1(w2)		;now pop the args to the last AC needed
	sojg w2,evsta2		;and do so for all formals
;now go do the thing
	adjsp p,-2		;get rid of saved copies of # args
	pop p,w2		;address to go to
	jrst (w2)		;do it

;;;;;;;;;;;FAST LSUBR - general form

;here to eval lsubr.  Have  o3 - (SUBR addr)
evlsub:	move o3,at%fun(o3)
	docdr o1,o1		;actuals
	docdr o3,o3
	docar w3,o3		;addr
  ;o1 - actuals, w3 - addr
	push p,[object ty%int,0] ;# args
	push p,w3		;save ftn addr temporarily
	jumpe o1,evls2		;done if no more args
evls1:	pushcdr q,o1		;save CDR actuals for later
	aos -1(p)
	docar o1,o1		;get current one
	call eval		;EVAL it
	exch o1,(q)		;save this on Q and get back CDR
	jumpn o1,evls1
evls2:	pop p,w3		;get back ftn addr
	pop p,o1		;number of args is the one argument
	call (w3)		;call the ftn
	pop p,q			;get back Q from the EVAL blip
	jrst unbind

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast MSUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval msubr.  Have o3 as (MSUBR addr), O1 as form
evmsub:	push q,o1		;save original form for MACROEXP...
	move o3,at%fun(o3)
	docdr o3,o3
	docar o4,o3		;car of fsubr prop is the ftn addr
	call (o4)
	jrst domacr		;let common code handle the rest

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast FSUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval fsubr.  Have o3 is (FSUBR addr 2nd-arg?)
evfsub:	move o3,at%fun(o3)
evalfs:	docdr o1,o1		;need to pass cdr form
	docdr o3,o3
	docar o4,o3		;car of fsubr prop is the ftn addr
	docdr o3,o3		;second arg?
	jumpe o3,evfs1		;no, forget the context pointer stuff
  ;put the spdl pointer in the second arg, if requested
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	move o2,w2		;put it in argument 2
  ;now call and go
evfs1:	call (o4)
	adjsp p,-1		;forget saved Q
	jrst unbind



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Slow EVAL.  First we evaluate arguments if necessary.  Then
;; we process things such as LABEL, FUNARG, and LAMBDA.  Processing
;; LAMBDA executes the funtion.  Entry is always at one of
;;   EVSEXP - slow expr
;;   EVSFEX - slow fexpr
;;   EVSMAC - slow macro
;; At entry, the form in in o1 and CAR in o3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evsexp:	push q,o3		;save O3
	push p,[0]		;count of args will go here
	docdr o1,o1
	call evonst		;puts args on stack
	push q,nil		;flag as not FEXPR binding
	move w2,-1(p)		;get Q back
	move o3,1(w2)		;get CAR (functional form) from Q+2
	jrst evform		;now handle the form

evsfex:	push q,nil		;dummy
	push p,[2]		;we have either 1 or 2 as he prefers
	pushcdr q,o1		;one arg - cdr form
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	push q,w2		;second arg - not NIL, so flagged as FEXPR
	jrst evform		;now handle the form

;before this, P is
;  saved q
;  saved sp
;  ret addr
;The problem is that we have to call EVFORM and then get control back.
;To do so, we have to hack the stack to produce:
;  saved q
;  saved sp
;  addr here where we want control back
;  ret addr
evsmac:	push q,o1		;one extra arg for finmac
	push p,q		;move stack up one as shown above
	move w2,[codsec,,evsmrt] ;desired continuation addr
	exch w2,-2(p)
	movem w2,-1(p)
	push q,nil		;dummy
	push p,[1]
	push q,o1		;one arg - whole form
	push q,nil		;flag not FEXPR binding
	jrst evform		;now handle the form and return here
;when we get here, we are in the right context for finmac, i.e. just
;saved exp on q and ret addr on p.
evsmrt:	jrst finmac		;execute it and make the MACROEXPANSION

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Now we are have bindings done.  We need to interpret the form, which
;; is probably a lambda
;;     o3 - the current version of the CAR of the form (i.e. the ftn)
;;     (p) - the number of args
;;   -1(p) - saved Q, for exiting
;;   -2(p) - saved sp
;;   -3(p) - ret addr
;;   on Q - the args themselves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evform:	getdsp o3
	xct eval2t(w2)

;;TYPES
eval2t:	jrst evfora		;atom - eval it
	jrst evfora		;constant atom
	jrst evforc		;cons - try it
	jrst evforc		;constant cons
	jrst udf		;string - error
	jrst udf		;constant string
	jrst udf		;channel
	jrst udf		;constant channel
	jrst udf		;integer - error
	jrst udf		;real - error
	jrst udf		;bignum - error
	jrst udf		;hunk - error
	jrst udf		;address
	jrst udf		;special
	jrst udf		;16
	jrst udf		;17


;atom found during slow eval.  Let't hope it has a ftn defn.
evfora:	jumpe o3,udf		;if NIL, done for
	skipe o2,at%fun(o3)	;else first try ftn defn
	jrst evfun
	getval o2,o3		;If no ftn defn, try the value instead
	camn o2,[%.UNBOUND]
	camn o2,o3		;prevent loops
	jrst udf
	move o3,o2
	jrst evform		;now see if the value is useful

evfun:	move o3,o2
	scons o3
	jrst evform
	docar o4,o3
	came o4,[%EXPR]
	camn o4,[%FEXPR]
	docdr o3,o2
	camn o4,[%MACRO]
	docdr o3,o2
	jrst evform

;cons found during slow eval.  If it is LAMBDA, LABEL, or FUNARG,
;we do them.  Else, just eval the thing.
evforc:	docar o4,o3		;should be (lambda, (subr, ...
	camn o4,[%LAMBDA]
	jrst evforl
	camn o4,[%LABEL]
	jrst evforb
	camn o4,[%FUNARG]
	jrst evforn
	camn o4,[%SUBR]
	jrst evfors		;yes - do subr
	camn o4,[%FSUBR]	;can this ever be valid?
	jrst evforf
	camn o4,[%LSUBR]
	jrst evfrls
	camn o4,[%MSUBR]	;or this?
	jrst evfrma

;not special form, just eval it again
	move o1,o3		;and eval car
	call eval
	move o3,o1
	jrst evform		;now see if we are any better off

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Now we come to the experts on different form types.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  LAMBDA, including wacky LEXPR lambda's.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval expr the hard way.  We must check for LEXPR
evforl:	docdr o3,o3
	docar o2,o3		;o2 - formals
	scons o2		;list?
	jumpn o2,ev2l		;no - lexpr (NIL is not a cons, but is a list)
;normal expr, have to bind the variables
	jumpe o2,ev2ex		;no variables, forget it
	move w2,-1(p)		;get back Q, first var is this +2
ev2el:	docar o1,o2		;get the first formal
	move o4,nil		;default if no args left
	sosl (p)		;if args left
	move o4,2(w2)		;get first arg
	bind o1,o4		;bind it
	docdr o2,o2		;next formal
	addi w2,1
	jumpn o2,ev2el
ev2ex:	skipe (q)		;check args if not fexpr
	jrst .+3		;if fexpr, extra arg is OK
	skiple (p)		;better not be any actuals left
	jrst wnoa
;now execute the code.  It is cdr(o3)
	setz o1,		;nil if no expr found
	pushcdr q,o3
ev2exl:	move o2,(q)		;get back expr's
	jumpe o2,ev2exx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst ev2exl		;now try for next
ev2exx:	move q,-1(p)		;restore saved Q
	adjsp p,-2		;forget number of args, saved Q
	jrst unbind

;;;;;;;;;;;Formal is an atom.  This is presumably LEXPR.
ev2l:	skipge (p)
	jrst [err /Atomic argument list illegal for FEXPR/]
;we bind these on the stack.  But since there are a variable number,
;we need something to tell us how many there are.  The pseudo-variable
;LXVARS will do that.
	push sp,[%lxvars]	;save old value
	push sp,@[datsec,,.lxvars]
	move w2,[object ty%adr,1] ;and put ADR object for Q into it
	add w2,-1(p)		;first var is this +2
	movem w2,@[datsec,,.lxvars]
	move w2,(p)		;count of args
	maknum w2		;legit lisp number
	bind o2,w2		;bind the formal to the count
	push sp,[%lxnum]	;also save number for validity checking
	push sp,@[datsec,,.lxnum]
	movem w2,@[datsec,,.lxnum]
	pushcdr q,o3		;and push the list of things
	setz o1,		;nil if no expr found
ev2ll:	move o2,(q)		;get back expr's
	jumpe o2,ev2lx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst ev2ll		;now try for next
ev2lx:	move q,-1(p)		;restore saved Q
	adjsp p,-2		;forget number of args, saved Q
	jrst unbind


;;;;;;;;;;;;;;;;;ROUTINES USED BY ALL LEXPR's

;now the kludges for dealing with args within the lexpr
;ARG N - get that argument
lxarg:	skipn w3,@[datsec,,.lxvars] ;make sure we are in an lexpr
	jrst [perr /ARG called when not in LEXPR/]
	caml o1,[object ty%int,0] ;make sure his arg # is legit
	camle o1,@[datsec,,.lxnum] ;number of args
	jrst [perr /ARG called with invalid arg number/]
	move w2,o1		;get bare number version of his arg
	getnum w2
	add w2,w3		;index into the stack of args
	move o1,(w2)		;and get what he wanted
	ret

;SETARG N VALUE - set that argument
lxsarg:	skipn w3,@[datsec,,.lxvars] ;make sure we are in an lexpr
	jrst [perr /SETARG called when not in LEXPR/]
	caml o1,[object ty%int,0] ;make sure his arg # is legit
	camle o1,@[datsec,,.lxnum] ;number of args
	jrst [perr /SETARG called with invalid arg number/]
	move w2,o1		;get bare number version of his arg
	getnum w2
	add w2,w3		;index into the stack of args
	movem o2,(w2)		;and put down what he wanted
	move o1,o2		;and return it
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  LABEL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval label - o3 (LABEL FOO lambda-exp)
evforb:	docdr o3,o3		;get the var to be bound
	docar o2,o3		;o2 - var
	docdr o3,o3		;and the thing to be bound to
	docar o3,o3		;o3 - exp
	bind o2,o3		;bind it
	jrst evform		;and go process what we have

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FUNARG - stage 2 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval funarg - o3 (FUNARG fn . bcp)
evforn:	docdr o3,o3
	docdr o1,o3		;o1 - bcp
	gettyp o1		;see what it is
	cain w2,ty%int		;a stack pointer
	jrst evfnst		;yes, play with stack first
;here if it is an alist
evfnal:	docar o4,o1		;first pair
	docar o5,o4		;variable
	xtype o5		;make sure it is
	caie w2,ty%xat
	jrst [move o1,o5
	      perr /Attempt to use something other than an atom as a variable/]
	docdr o4,o4		;value
	bind o5,o4		;bindit
	docdr o1,o1		;next pair
	jumpn o1,evfnal		;if any
	docar o3,o3		;get the function part
	jrst evform		;done - go process it, forcing unbinding

;here if it is a stack pointer
evfnst:	pushcar q,o3		;save his ftn
	call upstak		;go to place he wants
	pop q,o3		;get back ftn
	jrst evform		;go process it, forcing unbinding

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SUBR
;;   o3 - the current version of the CAR of the form (i.e. the ftn)
;;   (p) - the number of args
;; -1(p) - saved Q, for exiting
;;  on Q - the args themselves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evfors:	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	docar w2,o3		;#args
	getnum w2
  ;w2 - # formals, w3 - addr
	movei w4,o1-1		;first AC to use
	jumpe w2,ev2sx		;no variables, forget it
	move nil1,-1(p)		;get back Q, first var is this +2
ev2sl:	move o6,nil		;default if no args left
	sosl (p)		;if args left
	move o6,2(nil1)		;get first arg
	push w4,o6		;put it in AC
	addi nil1,1
	sojg w2,ev2sl
ev2sx:	setz nil1,
	skipe (q)		;if bound as FEXPR, skip test
	jrst .+3
	skiple (p)		;better not be any actuals left
	jrst wnoa
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind

;;;;EVFRLS - LSUBR. This has to merge with the normal calling convention
;;;; which is
;;;;   push q,arg1
;;;;   push q,arg2
;;;;     ...
;;;;   move o1,[object ty%int,#args]
;;;;   call ftn
;;;;   adjsp q,-#args

evfrls:	docdr o3,o3
	docar w3,o3		;addr
  ;w3 - addr
	skipn (q)		;if (Q) is NIL, it is a dummy
	adjsp q,-1		;so forget it  [if non-NIL, this was bound
				; as an FEXPR, in which case there is big 
				; trouble somewhere]
	pop p,o1		;number of args
	tlo o1,(object(ty%int,0)) ;make it legit
	call (w3)		;call the routine
	pop p,q
	jrst unbind

;;EVFRMA - MSUBR.  An MSUBR is treated like a SUBR with one arg

evfrma:	docdr o3,o3
	docar w3,o3		;addr
  ;w3 - addr
	move w2,-1(p)		;get back Q, first var is this +2
	move o1,nil		;default if no args left
	sosl (p)		;if args left
	move o1,2(w2)		;get first arg
	skipe (q)		;if bound as FEXPR, skip test
	jrst .+3
	skiple (p)		;better not be any actuals left
	jrst wnoa
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind

;;;FSUBR - one or two args, we have to manufacture the second

evforf:	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	move w4,(p)		;how many args?
  ;w3 - addr, w4 - # args
	move w2,-1(p)		;get back Q, first var is this +2
	move o1,nil		;default if no arg
	sosl (p)		;if arg left,
	move o1,2(w2)		;get arg
	jumpe o3,evff1		;forget this if they don't want 2nd arg
	move o2,nil		;default if no arg
	sosl (p)		;if arg left
	move o2,3(w2)		;get arg
evff1:	skipe (q)		;if bound as fexpr
	jrst .+3		;don't care if passed extra arg
	skiple (p)		;if args left
	jrst wnoa		;we are in trouble
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Various version of LIST, some for compiler only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;TY%INT
;LIST - LSUBR
dolist:	movei o2,nil		;start at end of list - NIL
	move w4,q		;can't pop the real Q, so get copy to POP
dols1:	tdnn o1,[377777777]	;more args? - this requires o1 .ge. 0
	jrst dols2		;no - exit
	pop w4,o3		;yes - get next
	docons o4,o3,o2		;and make new list elt
	move o2,o4
	soja o1,dols1
dols2:	move o1,o2		;value being built up is in O2
	ret

;;TY%CON
;LIST1 - 5, for compiler
list1==ncons
list5:	push free,o5
	push free,nil
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list4:	move o6,nil
	push free,o4
	push free,o6
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list3:	move o6,nil
	push free,o3
	push free,o6
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list2:	move o6,nil
	push free,o2
	push free,o6
	xmovei o6,-1(free)
	tlo o6,(object(ty%con,0))
	push free,o1
	push free,o6
	xmovei o1,-1(free)
	tlo o1,(object(ty%con,0))
	caml free,lastl		;make sure there is space
	 call sgc		;special version of GC that saves AC's
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Routines to support compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function calling from compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;Typical function call:
;	move o1,arg1
;	move o2,arg2
;	movei n,2	;two args
;	call @[object ty%atm,atom+at%cal]
;
;In the atom header:
;at%cal:  jsp w3,@.+1
;at%dsp:  object ty%iadr,addr
;
;This code is very carefully coordinated with the action of the GC.
;Here is what lies behind the use of OBJECT TY%ATM,ATOM+AT%CAL:
;  the object types for atom and const atom must be 0 and 1, since
;	the type field will look like an index field.  Since 0 is
;	no indexing, and 1 is NIL1, which is always 0, the type
;	code is harmless here.
;  type codes are required because atoms may get relocated.  So
;	constant space must be swept by the GC.
;  there is a problem with ATOM+AT%CAL.  This is the address of
;	the JSP in the atom header.  This means that we have something
;	that looks to the GC like an atom pointer, but it is pointing
;	somewhere other than the beginning of the atom.  I settle
;	this by having the GC explicitly look at the pointer to
;	see whether it could be pointing at AT%CAL.  This is
;	feasible because that word is always JSP W3,@.+1   Another
;	possibility is to use a separte type code for references
;	into the middle of atoms.  The problem with this is that
;	type code must be 0 and 1 for these references, as explained
;	above.  But to get to the value cell, we are going to need
;	to do @[OBJECT TY%ATM,ATOM], and for the same reason that
;	type code is going to have to be 0 or 1.  So it looks like
;	we are just going to have to live with having the GC know
;	whether a pointer is into the middle of the atom or not.
;	Of course we don't dare print such pointers, as PRINT would get
;	very confused.  But they are strictly internal, so...
;Similarly, the TY%IADR is actually TY%CAT.  Here is why:
;   We need something whose type code is 0 or 1, so we don't get
;	unintended indexing.
;   We can't have the GC ignore it because that would require a TY%SPC
;	word, which would expand the size of an atom header by one.
;   Since the innards of an atom will never be printed, all we care is
;	that the type code is one ignored by the GC, hence TY%CAT works
;	fine.

;CALEXP - for functions known to have EXPR values.  Note that ALIAS
;has already validated the formals.
calexp:	push p,sp		;save sp for unbind
	xmovei o6,-at%dsp(w3)	;get address of start of atom
	move o6,at%fun(o6)	;ftn defn
	docdr o6,o6		;(lambda ...
	docdr o6,o6		;((args)...
	pushcdr q,o6		;save (forms ...) for later
	docar o6,o6		;(args ...)
	move w3,[xwd -5-1,o1-1]	;first actual
	jumpe o6,calex2		;if no formals, forget this
calex1:	aobjp w3,[err /Compiled code has called EXPR with more than 5 arguments/]
	pushcar sp,o6		;save old arg
	push sp,@(o6)		;at%val save old value
	move o1,(w3)		;get actual
	movem o1,@(o6)		;at%val set new value
	docdr o6,o6
	jumpn o6,calex1
calex2:	pop q,o1
	call progn		;now eval forms as progn
	jrst unbind

;CALFEX - for functions known to have FEXPR values.  Note that ALIAS
;has already validated the formals.
calfex:	push p,sp		;save sp for unbind
	xmovei o6,-at%dsp(w3)	;get address of start of atom
	move o6,at%fun(o6)	;ftn defn
	docdr o6,o6		;(lambda ...
	docdr o6,o6		;((args)...
	docar o3,o6		;(args ...)
	jumpe o3,calfe2		;if no formals, forget this
	pushcar sp,o3		;save old arg
	push sp,@(o3)		;at%val docar save old value
	movem o1,@(o3)		;at%val docar set new value
	docdr o3,o3
	jumpe o3,calfe2		;if no more formals, forget this
	move w2,sp		;top of stack
	sub w2,[basesp+1]	;convert to offset from start
    ;note - the canonical code for above is basesp-1.  However we have
    ;just added a binding which we don't want counted.  So by using
    ;a base 2 too big we get the right result.
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	pushcar sp,o3		;save old arg
	push sp,@(o3)		;at%val docar  save old value
	movem w2,@(o3)		;at%val docar  set new value
calfe2:	docdr o1,o6		;get list of things to do
	call progn		;now eval forms as progn
	jrst unbind

;CALLEX - LEXPR called from compiled code.
;we need to build
;  p:  # args
;	q
;	sp
;	ret addr
;  q:  nil
;	argn
;	...
;	arg2
;	arg1
;	junk
callex:	move w4,o1
	tlz w4,770000		;get bare number for # args
	push p,sp
	move w2,q		;now compute Q at bottom of args
	sub w2,w4
	subi w2,1		;this is JUNK shown above
	push p,w2		;Q
	push p,w4		;# args
	push q,nil		;extra NIL at top for slow eval
	xmovei o6,-at%dsp(w3)	;get address of start of atom
	move o6,at%fun(o6)	;ftn defn
	docdr o3,o6		;(lambda...
	docdr o3,o3		;((args) ...
	docar o2,o3		;o2 - arg
	jrst ev2l		;now let slow eval do it

;CALUND is last resort, for functions we don't know anything about.
;note that this is called by PUSHJ P, into the atom block
;in the atom block it is JSP W3,here, with W3 getting
;the next word (AT%DSP) of the atom.  The compiler is supposed to
;have loaded N with the number of args in such cases.
calund:	xmovei o6,-at%dsp(w3)	;get address of start of atom
	camge o6,[datsec,,endobl] ;if not in GC'ed space,
	tlo o6,(object(ty%cat,0)) ;then consider it constant atom
	push q,o1
	move o1,at%fun(o6)	;see if we have ftn defn
	jumpe o1,calunn		;no - eval it
	docdr o1,o1		;yes, have one, now what is it
calunv:	sncons o1		;if atom
	jrst calun0		;no - error for now
;here if we find a ftn defn that is an atom - just call it
	move o6,o1
	pop q,o1
	jrst at%cal(o6)		;go to the JSP in the atom

;;TY%CON - we do our own CONS to save AC's
;here if no ftn defn - eval the atom
calunn:	getval o1,o6
	came o1,[%.UNBOUND]
	jrst calunv		;found something - use it
;here if we can't figure out what is going on - let APPLY do it
;the compiler is supposed to have loaded N in such cases
calun0:	jumpl n,calunx		;compiler hasn't told us number of args
	move o1,(q)		;get first arg
	movem o6,(q)		;and save atom
	movei w2,o1-1(n)	;location of last arg
	setz o6,		;build up arg list in O6
calun1:	caige w2,o1		;any args left?
	jrst calun2
;here we cons (w2) onto arg list on O6
	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,(w2)		; set up car
	push free,o6		; and cdr
	xmovei o6,-1(free)	; make address into cons cell
	tlo o6,(object(ty%con,0))
	soja w2,calun1	

calun2:	seto n,			;invalidate N
	move o2,o6		;arg list to o2
	pop q,o1		;thing to call to o1
	jrst apply		;and let APPLY do its thing

;This is used in case of total failure.  At the moment it is
;used when the compiler didn't set N, in which case we can't use N.
calunx:	push p,q		;save q for RETFROM
	push sp,nil		;eval blip
	push sp,o6		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	move o1,o6
	perr /Called undefined function from compiled code/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Support functions for compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;LEXENT - %LEXPR-ENTRY
;sets up N for magic access to args
lexent:	move w3,q		;have to compute Q at base of args
	sub w3,o1		;O1 is a Lisp int, so have to remove types
	tlc w3,(<<100-ty%int>_30.>#<o1_30.>) ;and also add the AC ref.
	push p,w3		;save it for the user to reference
	call (w2)		;now do his code
	adjsp p,-1		;clean up stack
	ret			;and return

;set up O2 to be a stack pointer as needed to call an FSUBR
setfsp:	move o2,sp		;top of stack
	sub o2,[basesp-1]	;convert to offset from start
	lsh o2,-1		;divide by two - two words per "cell"
	maknum o2		;spdl pointer now in w2
	ret

;lb1-lb5 are for lambda binding.
;  jsp w2,lb3
;  setam o1,@[object ty%atm,foo]
;  setam o2,@[object ty%atm,bar]
;  setam o4,@[object ty%atm,baz]
;LB3 is supposed to save the old bindings of the atoms on
;SP, and then return.  The SETAM's (which are equivalent to MOVEM's)
;will then put in the new bindings.  This code depends critically
;upon having SETAM's instead of MOVEM's.  SETAM has the highorder
;bit on, which means that when you use it in an index register you
;get local addressing.

lb5:	move w3,4(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb4:	move w3,3(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb3:	move w3,2(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb2:	move w3,1(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb1:	move w3,0(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
	jrst (w2)

;now ub1 to ub5 unbind 1 to 5 things from the SP stack
ub5:	pop sp,@-1(sp)
	adjsp sp,-1
ub4:	pop sp,@-1(sp)
	adjsp sp,-1
ub3:	pop sp,@-1(sp)
	adjsp sp,-1
ub2:	pop sp,@-1(sp)
	adjsp sp,-1
ub1:	pop sp,@-1(sp)
	adjsp sp,-1
	ret

udflab:	perr /GO to undefined label in compiled code/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; functions to support LAP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;TY%INT - this entire section uses GETNUM and MAKNUM to handle
; numbers that can be addresses.  This works because the we don't
; allow addresses above 29 bits.  In principle we should use more
; complete code that allows full-size numbers.

define ldint(dest,source)
	move dest,source
	getnum dest
	termin	

;o1 - address
;o2 - opcode
;o3 - reg
;o4 - rest of instruction
;  build instruction (in w3) and put in address
dinst:	ldint w3,o4		;rightmost part
	ldint w4,o3		;reg field
	dpb w4,[.bp 17_23.,w3] ;to reg field in instruction
	ldint w4,o2		;opcode
	dpb w4,[.bp 777_27.,w3] ;to code place
	ldint w4,o1		;place to put it
	movem w3,(w4)		;do so
	ret

;o1 - address to put it
;o2 - atom to call
;  put pointer to AT%CAL word from atom in address
dfnlk:	addi o2,at%cal		;make pointer point to call word
	;pjrst dobj		;now put it there

;o1 - address to put it
;o2 - atom whose value to refer to
;  put pointer to value cell in address
dvalr:	;addi o2,at%val
	;pjrst dobj

;o1 - address to put it
;o2 - lisp object
;  put lisp object in address
dobj:	ldint w4,o1		;get absolute address
	movem o2,(w4)		;put lisp object there
	ret

;o1 - address to put it
;o2 - number
dconst:	ldint w3,o1		;w3 - address
	move o1,o2
	call getint		;w2 - value
	movem w2,(w3)
	ret

;o1 - is this a constant atom?
catmp:	gettyp o1
	caie w2,ty%cat
	jrst retnil
	jrst rett

;o1 - size of GC'ed area
;o2 - size of non-GC'ed area
; allocate BPS
albps:	ldint w3,o1		;amount of GC'ed space
	ldint w4,o2		;amount of non-GC'ed space
	move o1,bpsend		;next BPS to alloc
	maknum o1		;make legit number
	move w2,bpsend		;old start of BPS
	add w2,w3		;get to start of non-GC'ed
	move w3,w4		;make SPC pointer
	tlo w3,(object(ty%spc,0))
	movem w3,(w2)		;and put at start of non-GC'ed
	add w2,w4		;now advance BPS beyond it all
	addi w2,1		;include the SPC pointer
	movem w2,bpsend
	ret

;o1 - ftn (an atom)
;o2 - address
;o3 - SUBR, FSUBR, ...
;o4 - number of args
sftne:	tlc o2,(object ty%int#ty%adr,0) ;turn integer into address
	move o5,nil		;assume NIL cdr
	camn o3,[%MSUBR]	;if MSUBR, that's always the case
	jrst sftne1
	camn o3,[%FSUBR]
	jrst sftne2		;FSUBR's are special
;otherwise, presumably SUBR, accept number of args as given
sftne0:	docons o5,o4,nil	;(n)
sftne1:	docons o4,o2,o5		;(addr n)
	docons o2,o3,o4		;(tag addr n)
	jrst alias		;now do it

;here if FSUBR
sftne2:	came o4,[object ty%int,1] ;if one arg
	jrst sftne0		;not one - pass number
	jrst sftne1		;is one - the is defaulted, no number arg

;=*=    =====================================================
;=*=	      support function for loading .FLAP files
;=*=    =====================================================
;=*=  the format of the file is as follows:
;=*=	in ascii, the following:
;=*= SIZE: #of-linkwds #of-codewds
;=*= CONSTANTS: #of-constants <constant forms>
;=*= VARIABLES: #of-variables <variable names>
;=*= FUNCTIONS: #of-functions <function names>
;=*= BINARY:
;=*=	==================================================
;=*=  the LISP function FLAP reads up to here, closes the file,
;=*=  re-opens it in 36-bit mode, sets the input pointer back to
;=*=  this point,  and calls %bflap.  It has allocated the space,
;=*=  filled in the constants, variables, and function pointers;
;=*=  re-opened the file in 36-bit mode and repositioned the
;=*=  pointer to here.  
;=*=	==================================================
;=*=	then binary, ie 36-bit words:
;=*=   666   this as the value of a word as a synchronizer
;=*=   #of-codewords   as a binary value this time
;=*= the code for the functions. the left half of each word is absolute.
;=*= the right half is cnnnnn octal, where c is a code:
;=*= c = 0 or 7  the right half is absolute, leave untouched
     ;=*=     1  rh becomes the nnnnn'th constant
     ;=*=     2  rh is nnnnn'th variable
     ;=*=     3  rh is nnnnn'th function
     ;=*=     4  rh is nnnnn'th internal entry
     ;=*=     5  rh is addr of this word - nnnnn
     ;=*=     6  rh is addr of this word + nnnnn
;=*=   minus #of words of above to be translated (rest are absolute)
;=*=   #of-fns-defined
;=*= a word for each fn definition:  byte (4)what (15)which (17)where
;=*=     what - what kind of entry point, 0-5 = expr of that many args,
;=*=			8 = fexpr, 9 = lexpr, 10 = macro
;=*=     which - index into the function table (above) for this fn
;=*=     where - entry point as offset past beginning of code

;=*= args are: curpos, constants, variables, functions, code
;=*= each is a lisp number giving the beginning address of
;=*= that area.  the first three areas are already filled in.

;;CH%TYP		we grab the current jfn
%bflap:	getnum o1
	push p,o1
	move o1,@[datsec,,.curin]
	push p,ch%jfn(o1)	;=*= a jfn--
	irp x,,[o2,o3,o4,o5]	;=*= --and 4 orgs
	getnum x
	push p,x
	setz x,
	termin
	sos -1(p) ? sos -2(p) ? sos -3(p)	;=*= fencepost factor
	
	hrrz nil1,-4(p)		;=*= find our starting point
	move w2,-5(p)		
	sfptr
	 erjmp .+1
%bfl01:	bin
	caie w2,666		;=*= the end-of-text/beginning-of-binary flag
	 jrst %bfl01
	bin			;=*= next wd is codesize count
	movn w3,w2		;=*= SIN params: -byte count
	move w2,(p)		;=*= byte pointer
	hrli w2,444400		;=*= full word!
	sin
	bin			;=*= get -# of wds to translate
	hrls w2
	hrr w2,(p)		;=*= w2= aobjn code pointer
%bfl05:	ldb w3,[.bp 700000,(w2)]	;=*= reloc code
	ldb w4,[.bp 077777,(w2)]	;=*= reloc parameter
	xct    [skipa	 	;=*= 0 = absolute
		add w4,-3(p)	;=*= 1 = constant
		add w4,-2(p)	;=*= 2 = variable
		add w4,-1(p)	;=*= 3 = function
		move w4,%bfltv(w4) ;=*= 4 = internal entry
		jrst [movns w4	;=*= 5 = backwards ref
		      addi w4,(w2) ? jrst .+1]
		addi w4,(w2)	;=*= 6 = forward ref
		skipa](w3)	;=*= 7 = absolute
	 hrrm w4,(w2)
	aobjn w2,%bfl05

	bin			;=*= next is number of fns defined
	move n,w2		;=*= save for countdown
	jumpe n,%bfl20		;anything there?

%bfl07:	hrrz nil1,-4(p)		;=*= jfn
	bin			;=*= next wd 
	setz nil1,		;=*= leave gronked as briefly as possible
	ldb w4,[.bp 74^12,w2]	;=*= type
	caile w4,7		;=*= is it a subr?
	 jrst %bfl10
	move o2,w4		;=*= yes, this is # of args
	maknum o2		;=*= we make (SUBR addr #args)
	docons o2,o2,nil
	skipa
%bfl10:	 setz o2,		;=*= otherwise (type addr)
	ldb o3,[.bp 377777,w2]	;=*= entry point
	add o3,(p)		;=*= code org
	tlo o3,(object ty%adr,0)
	docons o3,o3,o2		;=*= cons the address constant
	move o2,%bflta(w4)
	docons o2,o2,o3		;=*= this completes the fundef form
	move o1,%bflev(w4)	;=*= the form evaller for EVAL
;=*= find the atom--this has to be after the conses (above)
;=*= so that the atom will hold still while we hack on it.
	ldb w3,[.bp 377774^5,w2]	;=*= which function
	add w3,-1(p)		;=*= function table org
	move w3,(w3)		;=*= get the fn ptr wd itself
	ldb w4,[.bp 377777,w2]	;=*= entry point
	add w4,(p)		;=*= code org
	tlo w4,(object ty%iadr,0)	;=*= make it an internal address
;;TY%ATM		internal form hacked on here
	movem w4,at%dsp-at%cal(w3)	;=*= plug in code pointer
	movem o1,at%fev-at%cal(w3)	;=*= plug in funtype entry
	movem o2,at%fun-at%cal(w3)	;=*= plug in fundef form
	sojg n,%bfl07
%bfl20:	hrrz nil1,-4(p)		;jfn
	rfptr
	 erjmp [err /Can't find file position in FLAP/]
	setzb nil1,o1
	adjsp p,-6		;=*= 5 orgs and a jfn
	jrst retint
				;=*= function type atom table:
%bflta:	repeat 6, %SUBR
	0 ? 0
	%FSUBR ? %LSUBR ? %MSUBR
				;=*= eval routine entry table:
%bflev:	irp x,,[evsub0,evsub1,evsub2,evsubr,evsubr,evsubr,0,0
		evfsub,evlsub,evmsub]
	object(ty%adr,x(codsec)) ? termin
				;=*= internal entry point table:
%bfltv:	0
	bnderr
	cerrse			;=*= %errset
	free
	getbar
	getint
	lb1			;=*= %lambdabind 1 through 5
	lb2
	lb3
	lb4
	lb5
	lexent			;=*= %lexpr-entry
	retint
	retrea
	setfsp			;=*= %set-bcp
	setbar
	ub1			;=*= %unbind 1 through 5
	ub2
	ub3
	ub4
	ub5
	udflab			;=*= %undeflabel
	cwthin			;=*= %within
	cwthou			;=*= %without
	crdctx			;%readcontext
	atomp			;atom
	litat			;litatom
	cons			;cons
	xcons			;xcons
	ncons			;ncons



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; end of apply and eval - some other stuff that depends upon
;; the representations of values and bindings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;SET - ident to set, new value
; first look to see if we know where to put it
;o1 - atom, o2 - new value
set: 	skipe o1		;don't let him bind t or nil
	camn o1,[%T]
	jrst illrb1
	satom o1
	jrst illvar		;must be an atom
	setval o1,o2
	move o1,o2		;return new value
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the code for hacking on the stack, for use by BREAK
;; and friends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;The stack contains pairs of the following sorts:
;  saved values of variables when they are rebound:
;	value
;	atom
;  saved values of internal variables when they are rebound.  (These
;  internal variables are declared by DECLFU after the OBLIST.)
;	value
;	variable's addr - this is TY%ADR
;  EVAL BLIP - shows every expression that EVAL has seen
;	expression
;	blip giving saved value of P (with Q pushed onto P at that point)

;going up the stack is simple:  look at each pair.  If the bottom one
;is NIL, ignore it, else use it as an address and move the top one into it.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  These are UNBIND and INCONT, the stack experts for EVAL and APPLY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;UNBIND unwinds the SP stack.  Since this contains saved values of all
;variables that have been changed, this returns us to an old variable-
;binding context.  The context to return to is passed on P (or in W2, if
;you call UNBIND1).  We must check for EVAL blips, which are the one
;thing this do not have saved values.  The type code for an EVAL blip
;is an isolated bit, so we can just check that bit.

;Note that UNBIND and CUNBIND are designed so that we can ^C out and
;restart the core image, and the restart code will continue the unbind
;without losing anything.  For this reason, SP is not popped until the
;value has been assigned, and the file closing is handled carefully also.

unbind:	pop p,w2		;saved sp
	jrst unbin1

unbinl:	adjsp sp,-2
unbin1:	camg sp,w2
	ret
	dmove o2,-1(sp)
	jumpe o2,unbinl		;ignore eval blips
	setval o2,o3		;restore binding
	jrst unbinl

;CUBIND and CUBIN1 are special versions that also close any
;stacked files
cubind:	pop p,w2		;saved sp
	jrst cubin1

cubinl:	adjsp sp,-2
cubin1:	camg sp,w2
	jrst unbclo
	dmove o2,-1(sp)		;uninterruptible, so this code is reentrant
	jumpe o2,cubinl		;ignore eval blips
	setval o2,o3		;restore binding
	jrst cubinl

unbclo:	move o2,@[datsec,,.CFILE] ;list of files to close
	jumpe o2,cpopj		;done if nothing left on list
	docar w2,o2		;look at first
	tlz w2,770000		;make bare address
	camle sp,w2		;if have gotten to that point
	ret			;no - return
	push q,o1		;yes - save thing being returned
	docdr o2,o2		;get the file to close
	docar o1,o2
	call xclose		;close it
	move o2,@[datsec,,.CFILE]
	docdr o2,o2		;advance for next time
	docdr o2,o2
	movem o2,@[datsec,,.CFILE]
	pop q,o1		;get back value
	jrst unbclo		;and try again

;INCONT - does eval or apply in a certain context
;o1 & o2 are not changed.  They are presumably the args to *EVAL or
; *APPLY.
;o3 is the stack pointer or A-list
;w4 is the function to call.
incont:	jumpe o3,(w4)		;if no funny arg, forget it
	gettyp o3		;see what it is
	cain w2,ty%int		;a stack pointer
	jrst incns		;play with stack first

;;;;;;this code is done if the user passes an ALIST
;;;;the code under repeat 0 is designed to rplacd the new values
;;;;into the A-list.  this has been removed as it was an unauthorized
;;;;change to the semantics of Lisp.

;here for an a-list (we hope)
	push p,sp		;establish backup point for unbind
repeat 0,[push q,o3]		;save original list
;loop over alist binding
incn1:	docar o4,o3		;first pair
	docar o5,o4		;variable
	xtype o5		;make sure it is
	caie w2,ty%xat
	jrst [move o1,o5
	      perr /Attempt to use something other than an atom as a variable/]
	docdr o4,o4		;value
	bind o5,o4		;bindit
	docdr o3,o3		;next pair
	jumpn o3,incn1		;if any
;do the eval or apply
	call (w4)		;now eval in that context
repeat 1,[jrst unbind]

repeat 0,[
	move w2,(p)		;w2 - original sp
	pop q,o4		;o4 - original alist
;loop over alist unbinding
	jumpe o4,incn3		;end of alist?
incn2:	move o2,1(w2)		;no - o2 - variable
	move o3,2(w2)		;o3 - old value
	docar o5,o4		;o5 - pair
;;TY%ATM
	exch o3,at%val(o2)	;o3 now has new value, old restored in v. cell
	dorpd o5,o3		;put new value in alist
	docdr o4,o4		;o4 - cdr the alist
	addi w2,2		;and to next place in stack also
	jumpn o4,incn2		;any more to do?
incn3:	pop p,sp		;now restore SP
	ret			;that's it
]  ;repeat 0

;;;;;;here if he supplied a stack index
incns:	push p,sp		;save current sp for unbind
	push q,o1		;save args
	push q,o2
	push p,w4
	move o1,o3		;and move stack index to arg position
	call upstak		;common routine to go to stack context
	pop q,o2
	pop q,o1
	pop p,w4
	call (w4)		;now do what the user wanted
	jrst unbind		;and go back to normal context
	
	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  These are the UCI Lisp stack mungers, for wizards only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

adjust==0
;The second argument to GETSTK indicates what to do when the arg
;is out of range.  There are two choices:
;  ADJUST - adjust to be in range
;  address - go there

define getstk(ac,stkerr)	;convert AC from INUM to stack addr
	getnum ac		;convert to bare number
	lsh ac,1		;to offset
	add ac,[basesp-1]	;to address
ife stkerr,[
	camge ac,[basesp-1]	;if impossible
	move ac,[basesp-1]
	camle ac,sp
	move ac,sp
] ;ife stkerr
ifn stkerr,[
	caml ac,[basesp+1]	;if impossible
	camle ac,sp
	jrst stkerr		;then go here
] ;ifn stkerr
	termin

;spdlpt - return top of stack as INUM
spdlpt:	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2
	move o1,w2
	ret

;stkptr(i) - return pseudo-pointer to stack
stkptr:	getstk o1,retnil	;convert to address
	subi o1,1		;pointer to CAR
	tlo o1,(object ty%ccn,0) ;call it constant so not GC'ed
	ret

;spdlft(i) - return ith "CAR" from stack
spdlft:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
	move o1,-1(w2)		;CAR of stack pair
	ret

;spdlrt(i) - return ith "CDR" from stack
spdlrt:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
	move o1,(w2)		;CDR of stack pair
	ret

;nextev(i) - return INUM for next eval blip (entry with NIL CAR)
nextev:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
nxtev1:	camge w2,[basesp+1]	;below base?
	jrst retnil		;yes - failed
	skipn -1(w2)		;is it eval blip?
	jrst nxtev2		;yes - done
	subi w2,2		;no - try next
	jrst nxtev1
nxtev2:	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2
	move o1,w2
	ret

;internal form of NEXTEV - returns stack addr in W2, addr of CDR (top word)
inextv:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
inxtv1:	camge w2,[basesp+1]	;below base?
	jrst retnil		;yes - failed
	skipn -1(w2)		;is it eval blip?
	ret			;yes - done
	subi w2,2		;no - try next
	jrst inxtv1

evalv:	move w2,o2		;stack arg in in o2
	getstk w2,adjust
	getval o2,o1		;get current binding of variable
	move w3,sp
;w2 - limit of search
;w3 - copy of SP, used for search
;o1 - variable
;o2 - best value
evalv1:	camg w3,w2
	jrst evalv2		;done
	pop w3,o4		;value
	pop w3,o3		;var
	camn o3,o1		;if the one we want
	move o2,o4		;then use the value
	jrst evalv1

evalv2:	move o1,o2		;now return value
	ret

;go to specified context and return with given value (value in O2)
outval:	move o6,o2		;save value to return
	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
	addi w2,2		;unbind all up to saved P
	call cubin1		;unbind to W2, closing files we pass
	pop sp,w2		;W2 is now saved P (with TY%ADR set)
	tlz w2,770000		;clear ty%ADR
	pop sp,o1		;dummy
	pop sp,o1		;expression being eval'ed
	move p,w2
	pop p,q			;restore the rest from saved info
	pop p,sp
	move o1,o6		;get back thing to return
	ret			;and do so

;go to specified context and try given form (form in O2)
sprevl:	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
	movem o2,(w2)		;save form in SPDL place
	jrst spred1		;and let spredo finish

;go to specified context and try again
spredo:	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
spred1:	addi w2,2		;unbind all up to saved P
	call cubin1		;unbind to W2, closing files we pass
	pop sp,w2		;W2 is now saved P (with TY%ADR set)
	tlz w2,770000		;clear ty%ADR
	pop sp,o1		;dummy
	pop sp,o1		;expression being eval'ed
	move p,w2
	pop p,q			;restore the rest from saved info
	pop p,sp
	jrst eval		;now go try again


;upstack(i) - internal routine that moves us up the stack to position i
;the caller should do
;  push p,sp
;  call upstak
;  do your thing
;  jrst unbind
upstak:	move w2,o1		;w2 - his stack index
	getstk w2,adjust	;convert to actual SP index
	move w3,sp		;save current sp as stopping point
;loop over sp, restoring bindings
upst1:	caml w2,w3		;still in the past?
	jrst upst2		;no - done
	pop w3,o3		;value
	pop w3,o4		;var
	jumpe o4,upst1		;is eval blip
	push sp,o4		;restore binding
	push sp,at%val(o4)	;  (save current)
	setval o4,o3		;  (restore old)
	jrst upst1
upst2:	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The JSYS interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;code still being designed


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The rest of this stuff should be done in Lisp and compiled.
;; It will be eventually.  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;COND - arg is CDR FORM - this is the normal form
docond:	push q,o1		;cond so far
  ;loop over conditions
docnlp:	jumpe o1,docon1		;no possibilities left, return nil
	docar o1,o1		;now find test
	docar o1,o1
	call eval		;do test
	jumpe o1,docnnx		;failed, try next
	move o2,(q)		;cond tail
	docar o2,o2		;this clause
docnl2:	docdr o2,o2		;the rest of the clause
	jumpe o2,docon1		;nothing else - return what we have (in o1)
	movem o2,(q)		;save clause tail for next time
	docar o1,o2
	call eval		;next item - result in o1 - returned if last
	move o2,(q)		;get back tail
	jrst docnl2		;and see if any more to do

;here to advance to next clause
docnnx:	move o1,(q)
	docdr o1,o1
	movem o1,(q)
	jrst docnlp

docon1:	adjsp q,-1		;throw away saved part of form
	ret

;COND - this is the optimized form, called directly from eval
evcond:	docdr o1,o1		;o1 has the COND in it
	push q,o1		;cond so far
  ;loop over conditions
evcnlp:	jumpe o1,evcon1		;no possibilities left, return nil
	docar o1,o1		;now find test
	docar o1,o1
	call eval		;do test
	jumpe o1,evcnnx		;failed, try next
	move o2,(q)		;cond tail
	docar o2,o2		;this clause
evcnl2:	docdr o2,o2		;the rest of the clause
	jumpe o2,evcon1		;nothing else - return what we have (in o1)
	movem o2,(q)		;save clause tail for next time
	docar o1,o2
	call eval		;next item - result in o1 - returned if last
	move o2,(q)		;get back tail
	jrst evcnl2		;and see if any more to do

;here to advance to next clause
evcnnx:	move o1,(q)
	docdr o1,o1
	movem o1,(q)
	jrst evcnlp

evcon1:	adjsp p,-2
	adjsp sp,-4
	adjsp q,-1		;throw away saved part of form
	ret


;QUOTE - stack is cdr form
evalqu:	docar o1,o1
	ret

;optimized form of QUOTE
evquot:	docdr o1,o1
	docar o1,o1
	adjsp sp,-4
	adjsp p,-2
	ret

;FUNCTION 
;stack is cdr form, alist.
;functi:push q,[%FUNARG]	;cdr form, alist,  FUNARG
;	err /FUNARG not implemented/

;;TY%ATM
;ALIAS(atom,defn)
;o1 - atom, o2 - defn
;defn is one of (LAMBDA ...), (FEXPR LAMBDA ...), (MACRO LAMBDA ...),
;   (SUBR ADDR #),  (FSUBR ADDR . want-BPC?), (MSUBR ADDR).  ALIAS is
;   reponsible for setting up AT%FEV, the special evaluator word.  Take a
;   look at EVAL for an explanation of it.  There are two major
;   possibilities: if the form is a simple one that we have optimized code 
;   for, we analyze it and put the special evaluator address in.  Otherwise
;   we put in the address of code in slow EVAL that handles that
;   binding type (i.e. EXPR/SUBR,  FEXPR/FSUBR, MACRO/MSUBR).
alias:	satom o1
	jrst [perr /Attempt to ALIAS something that is not an atom/]
	jumpe o1,[err /Attempt to ALIAS NIL/]
	jumpe o2,alnil
	snatom o2
	jrst aliasa
	scons o2
	jrst illftn
	move o6,[object ty%iadr,<codsec,,calund>]
	docar o4,o2		;get keyword
	camn o4,[%SUBR]
	jrst alsubr
	camn o4,[%LSUBR]
	jrst allsub
	camn o4,[%FSUBR]
	jrst alfsub
	camn o4,[%EXPR]
	jrst alexpr
	camn o4,[%FEXPR]
	jrst alfexp
	camn o4,[%MACRO]
	jrst almacr
	camn o4,[%MSUBR]
	jrst almsub
	jrst illftn
;arg is atom, just copy all cells
aliasa:	move o6,at%dsp(o2)
	move o3,at%fev(o2)
	move o2,at%fun(o2)
	;jrst alexit
alexit:	tlz o6,770000		;change type code to TY%IADR
	tlo o6,(object(ty%iadr,0)) ;so jsp w2,@.+1 works
	movem o6,at%dsp(o1)	;place for compiled code to go
	movem o3,at%fev(o1)	;evaluator
	movem o2,at%fun(o1)
	move o1,o2
	ret

alnil:  move o2,nil		;at%fun - no ftn defn
	move o3,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	move o6,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	jrst alexit

illftn:	err /Ill-formed function/

illarg:	move o1,o5
	perr /Formal parameter not an atom, or is NIL or T/

;argval - validates the formal arguments.  I.e. makes sure they are
;all legal atoms.  This lets us use FASBIND in fast eval.
argval:	docdr o4,o2		;(lambda ...
	docdr o4,o4		;((x y) ...
	docar o4,o4		;(x y) ...
argvll:	scons o4
	jrst alexit		;done if no args or lexpr
	docar o5,o4		;x
	satom o5
	jrst illarg		;must be atom
	jumpe o5,illarg		;non-nil
	camn o5,[%t]		;and not t
	jrst illarg
	docdr o4,o4		;next arg
	jrst argvll

;fsubr - always fast
alfsub:	move o3,[object ty%adr,<codsec,,evfsub>]
alfsb1:	docdr o6,o2		;cdr
	scons o6
	jrst illftn
	docar o6,o6		;cadr, i.e. jump address
	gettyp o6
	cain w2,ty%adr		;ok if addr
	jrst alexit
	cain w2,ty%int		;or integer
	jrst alexit
	jrst illftn

;lsubr - always fast
allsub: move o3,[object ty%adr,<codsec,,evlsub>]
	jrst alfsb1		;process same as LSUBR

;msubr - always fast
almsub:	move o3,[object ty%adr,<codsec,,evmsub>]
	jrst alfsb1		;process same as FSUBR

;fexpr - fast if it is a lambda
alfexp:	docdr o4,o2
	scons o4
	jrst slfexp		;atom - slow fexpr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slfexp
	move o6,[object ty%iadr,<codsec,,calfex>] ;here from compiled code
	move o3,[object ty%adr,<codsec,,evfexp>] ;fast
	jrst argval		;exit validating args

;here if fexpr turns out to be slow
slfexp:	move o3,[object ty%adr,<codsec,,evsfex>] ;slow fexpr
	jrst alexit

;macro - fast if it is a lambda
almacr:	docdr o4,o2
	scons o4
	jrst slmacr		;atom - slow fexpr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slmacr
	move o3,[object ty%adr,<codsec,,evmacr>] ;fast
	jrst argval		;exit validating args

;here if macro turns out to be slow
slmacr:	move o3,[object ty%adr,<codsec,,evsmac>] ;slow fexpr
	jrst alexit

;exprs's are special because they may be lexprs
;a normal expr is fast if it is a lambda
alexpr:	docdr o4,o2
	scons o4
	jrst slexpr		;atom - slow expr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slexpr
;we now know it is fast, but is it an expr or lexpr?
	move o6,[object ty%iadr,<codsec,,calexp>] ;here from compiled code
	docdr o4,o4
	docar o5,o4
	jumpe o5,alexp0		;nil is atom but still not lexpr
	scons o5		;is it atom?
	jrst allexp		;yes - lexpr
;now we have normal expr.  We check the number of args, as 0, 1, and
;2 have optimized code
	move o3,[object ty%iadr,<codsec,,evexpr>] ;default if not lexpr
	docdr o5,o5		;already checked for nil, which is 0
	jumpe o5,alexp1		;if cdr is nil, 1 arg
	docdr o5,o5
	jumpe o5,alexp2		;2 args
	move o3,[object ty%adr,<codsec,,evexpr>] ;normal fast expr
	jrst argval		;exit validating args

;here for exprs with known numbers of args
alexp0:	move o3,[object ty%adr,<codsec,,evexp0>]
	jrst argval
alexp1:	move o3,[object ty%adr,<codsec,,evexp1>]
	jrst argval
alexp2:	move o3,[object ty%adr,<codsec,,evexp2>]
	jrst argval

;here if expr turns out to be lexpr
allexp:	move o6,[object ty%iadr,<codsec,,callex>]
	move o3,[object ty%adr,<codsec,,evlexp>]
	jrst alexit

;here if expr turns out to be slow.  Slow eval will figure out whether
;it is lexpr or not.
slexpr:	move o3,[object ty%adr,<codsec,,evsexp>] ;slow expr
	jrst alexit

;subrs are special because we have special code depending upon the
;number of args
alsubr:	docdr o4,o2		;addr
	scons o4
	jrst illftn
	docar o6,o4		;the address itself
	gettyp o6		;make sure it is an address
	cain w2,ty%int
	jrst .+3
	caie w2,ty%adr
	jrst illftn
	docdr o4,o4		;number of args
	docar o4,o4		;the number itself
	move o3,[object ty%adr,<codsec,,evsubr>] ;the default subr evaluator
	camn o4,[object(ty%int,0)]
	move o3,[object ty%adr,<codsec,,evsub0>]
	camn o4,[object(ty%int,1)]
	move o3,[object ty%adr,<codsec,,evsub1>]
	camn o4,[object(ty%int,2)]
	move o3,[object ty%adr,<codsec,,evsub2>]
	jrst alexit
	

;;TY%ATM
;FUNDEF(atom)
fundef:	satom o1
	jrst retnil
	skipe o1		;NIL can't be defined
	move o1,at%fun(o1)
	ret

;SETQ - quote first arg and call set
;o1 is cdr form
setq:	pushcar q,o1		;save variable to bind to
	docdr o1,o1
	docar o1,o1		;now have form for value. eval it
	call eval		;o1 is now value
	pop q,o2		;o2 is variable
	skipe o2		;don't let him bind t or nil
	camn o2,[%T]
	jrst illrb2
	satom o2		;better be an atom
	jrst illvr2
	setval o2,o1
	ret			;return value set returned

;EVSETQ - direct call version
;o1 is cdr form
evsetq:	docdr o1,o1
	pushcar q,o1		;save variable to bind to
	docdr o1,o1
	docar o1,o1		;now have form for value. eval it
	call eval		;o1 is now value
	pop q,o2		;o2 is variable
	skipe o2		;don't let him bind t or nil
	camn o2,[%T]
	jrst illrb2
	satom o2		;better be an atom
	jrst illvr2
	setval o2,o1
	adjsp sp,-4
	adjsp p,-2
	ret			;return value set returned

illvr2:	move o1,o2
illvar:	perr /Only atoms may be used as variables/

illrb2:	move o1,o2
illrb1:	perr /Trying to set T, NIL, or something that isn't a variable/
illreb:	err /Trying to set T, NIL, or something that isn't a variable/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the kludge of the year: PROG and all its friends.
;; GO and RETURN do non-local things to the interpretation of
;; PROG.  I implement this by special variables that GO and
;; RETURN can use to communicate with PROG.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;PROG - cdr form
;1 - loop over all variables
;2 - make up the golist from all tags
;3 - set up funny variables for GO and RETURN
;4 - interpret the PROG
prog:	push q,o1		;save the form
	docar o1,o1		;get the start of the prog - the var list
	jumpe o1,progg2
;1 - loop over all variables, setting up bindings on the alist
progg1:	docar o2,o1		;first var
	bind o2,nil		;bind it to nil
	docdr o1,o1
	jumpn o1,progg1
progg2:	
;2 - make up the golist from all tags
	move o1,(q)		;o1 - tail into code
	move o3,nil		;o3 - list of tags
progg3:	docdr o1,o1		;loop over code searching for atoms
	jumpe o1,progg4		;see if done
	docar o2,o1		;get car of the tail we are looking at
	satom o2		;better be an atom
	jrst progg3		;no - look again
	docdr o1,o1		;yes - cdr of the tail is the code the tag
				;  refers to
	docons o4,o2,o1		;o4 - (atom . tail)
	docons o2,o4,o3		;o2 - ((atom.tail) old list)
	move o3,o2		;o3 - now updated
	skipe o1		;check for null tail (label at end of prog)
	jrst progg3		;search on
progg4:	
;3 - set up funny variables for GO and RETURN
	push p,sp		;save stack values for nonlocal exit
	push p,q
  ;GOLIST
	move o1,@[datsec,,.GOLIST]
	push sp,[%GOLIST]
	push sp,o1		;save old value
	movem o3,@[datsec,,.GOLIST]  ;now new value
  ;similar for return.  This is a kludge giving stack values for
  ;RETURN to use to do a non-local exit
	move o1,@[datsec,,.PRET]
	push sp,[%PRET]
	push sp,o1		;save old value
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.PRET]
  ;now for NEXT.  This is use to implement GO.
	move o1,@[datsec,,.PNEXT]
	push sp,[%PNEXT]
	push sp,o1		;save old value
;4 - interpret the PROG
  ;make up the "PC", i.e. the place in the form where we are interpreting
	move o1,(q)
	docdr o1,o1		;get to code (car is the vars)
	movem o1,@[datsec,,.PNEXT] ;and put it into PC
  ;construct saved environment for GO
	push p,sp
	push p,q
	move o1,@[datsec,,.PTOP]
	push sp,[%PTOP]
	push sp,o1
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.PTOP]
  ;main loop
progg5:	move o1,@[datsec,,.PNEXT] ;get next thing to interpret
	jumpe o1,progg6		;exit if end
	docdr o2,o1		;save next for later
	movem o2,@[datsec,,.PNEXT];cdr the pc
	docar o1,o1		;get the thing to execute
	xtype o1		;if atom, ignore it
	cain w2,ty%xat
	jrst progg5
	call eval		;eval the thing
	jrst progg5		;and continue at new PC
progg6:	adjsp p,-3		;undo saved Q and SP
	adjsp q,-1		;undo saved form
	move o1,nil		;always return nil
	jrst unbind

;Now here are the things that only work inside PROG's
;GO tag - looks up the tag in GOLIST, sets NEXT to it, and returns
; to top level of PROG interpreter
go:	
  ;get tag atom
	docar o1,o1		;o1 - tag
go1:	xtype o1		;if it is an atom, use it
	cain w2,ty%xat
	jrst go2		;here if atom, atom in o1
	call eval		;else eval it - result back in o1
	jrst go1
  ;now find place in PROG that tag points to
go2:	move o2,@[datsec,,.GOLIST] ;tag is already in o1
	move o6,o1		;save 
	call assoc		;returns pair
	jumpe o1,[move o1,o6
		  perr /GO - unknown tag/]
	docdr o1,o1		;value of tag
  ;put the place into the PC for next PROG cycle
	movem o1,@[datsec,,.PNEXT] ;put it in PC
  ;return to top level of PROG
	move w2,@[datsec,,.PTOP] ;P
	tlz w2,770000		;make real address
	move p,w2		;restore saved P - Q and SP are there
	pop w2,q		;restore saved Q
	pop w2,w3		;restore save SP
	addi w3,2		;make sure we don't unbind PTOP
	push p,[codsec,,progg5]	;place to go - top of PROG
	push p,w3		;unbind SP to here - saved SP
	jrst cubind

;RETURN - do a non-local return from anywhere inside a prog.
;PROG sets up the variables PRET with the stack values to use.
;return value
;O1 has user's value.  This routine doesn't need to touch it
return:	move w2,@[datsec,,.PRET] ;P
	tlz w2,770000		;make real address
	move p,w2		;restore saved P - Q and SP are there
	pop p,q			;restore saved Q
	adjsp q,-1		;forget saved form
	jrst cubind		;unbind, closing files

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some nicer control constructs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;cdr form
progn:	jumpe o1,prognx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
prognl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o2,prognl		;if more to do, do it
prognx:	ret			;returned value is in o1

;AND - like progn but return as soon as false
mand:	jumpe o1,mandx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
mandl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpe o1,mandx		;if nil, return now
	jumpn o2,mandl		;if more to do, do it
mandx:	ret			;returned value is in o1

;version of and for direct dispatch
evand:	docdr o1,o1
	jumpe o1,evandx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
evandl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpe o1,evandx		;if nil, return now
	jumpn o2,evandl		;if more to do, do it
evandx:	adjsp sp,-4
	adjsp p,-2
	ret			;returned value is in o1


;OR - like progn but return as soon as true
mor:	jumpe o1,rett		;if nothing to do, return T
	move o2,o1		;use o2 for list of forms
morl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o1,morx		;if non-nil, return now
	jumpn o2,morl		;if more to do, do it
morx:	ret			;returned value is in o1

;direct call version of or
evor:	docdr o1,o1
	jumpe o1,evrett		;if nothing to do, return T
	move o2,o1		;use o2 for list of forms
evorl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o1,evorx		;if non-nil, return now
	jumpn o2,evorl		;if more to do, do it
evorx:	adjsp sp,-4
	adjsp p,-2
	ret			;returned value is in o1

evrett:	move o1,[%t]
	adjsp sp,-4
	adjsp p,-2
	ret


;not = null
not:	tdzn o1,o1		;negate O1
	move o1,[%T]
	ret

;evnot - direct call version of above
evnot:	docdr o1,o1
	docar o1,o1		;get arg
	call eval
	tdzn o1,o1
	move o1,[%T]
	adjsp sp,-4
	adjsp p,-2
	ret

;atom
atomp:	scons o1
	skipa o1,[%T]		;if not cons, is atom
	move o1,nil
	ret

;evatom - direct call version of above
evatom:	docdr o1,o1
	docar o1,o1
	call eval
	scons o1
	skipa o1,[%T]
	move o1,nil
	adjsp sp,-4
	adjsp p,-2
	ret

;stringp
strp:	xtype o1
	caie w2,ty%xst
	jrst retnil
	jrst rett

;consp
consp:	scons o1
	move o1,nil		;isn't a cons
	ret

;litatom
litat:	snatom o1
	skipa o1,[%T]		;is an atom
	move o1,nil		;isn't
	ret

;boundp - say whether we are bound
boundp:	satom o1		;better be an atom
	jrst retnil
	getval o2,o1
	came o2,[%.UNBOUND]
	jrst rett
	jrst retnil

;unbound - return the thing that unbound atoms are [un]bound to
unbnd:	move o1,[%.UNBOUND]
	ret

;domap - execute map function.  call by
;  push p,[car or not]
;  push p,[applier]
;  call domap
;car or not is either DOCAR O5,O1 or MOVE O5,O1, depending upon
;  whether we are passing CAR's to the function.
;applier is a code that takes the function being mapped in o1 and
;  applies it to an arg list in o2.  It takes the returned value
;  and updates O4.
;in order to get clean semantics, here is what we do:
;  the list tails or CAR's are set to var's O1 to O5
;  the expression to be done inside the loop is (EVAL '(FTN O1 O2 ...))
;Here is stack usage

;P:	old Q
;	old SP
;	ret addr
;	applier	;-3
;	car?	;-4

;Q:	expr to be evaled, i.e. (FTN O1 O2 ..)
;	global for arg n
;	arg n
;	...
;	global for arg 2
;	arg 2
;	global for arg 1
;	arg 1
;	nil
;	ftn
;(P)-->	

;Because we are going to call APPLY, we have to make up a list of arguments.
;At the same time we bind the O1 .. O5, and make up (FN O1 O2 ..)

domap:	push p,sp
	push p,q		;save pointer to bottom of stack frame
	move o3,nil		;o3 - template.  We just build up list with
				;  NIL's in it.
	jumpn o1,map1en		;if there are args, go to entrance of loop
tfa:	err /Too few arguments supplied/

;This loops over all the args, pushing values onto the Q stack.
;Note that the first arg is the ftn.
;  o1 - car, first arg
;  o2 - rest of arg lit
;  o4 - tail of MAPTAB
map1en:	move o4,[%MAPTAB]	;(NIL (O1.(O1))  (O2.(O1 O2)) ...)
map1lp:	jumpe o4,[err /Too many args to MAPxxx function/]
	doboth o1,o1		;o1 - car, first arg; o2 - rest of arg list
	push q,o2		;arg value will go here, now saved CDR list
	push q,o4		;save maptab tail
	call eval
	pop q,o3		;get back maptab tail
	exch o1,(q)		;put value into stack, get back CDR arg list
	doboth o3,o3		;o3 - current MAPTAB entry, o4 - cdr MAPTAB
	docar o5,o3		;need caar - var to bind to
	push q,o5		;push var to bind it to
	push sp,o5		;save old value
	push sp,at%val(o3)
	jumpn o1,map1lp		;more args
;here when all args done.  Better have at least one arg
	skipn (q)
	jrst tfa		;make sure we saw one real arg
	move w3,(p)		;get ftn from bottom of stack
	move o1,1(w3)		;and make up form to eval
	docdr o5,o3		;o5 - (O1 O2 ...)
	docons o2,o1,o5		;o2 - form to eval
	push q,o2
;Now the stacks are set as documented at the beginning.  Start the actual
;mapping.

;outer loop - loop down args until the first one runs out
; init for inner loop which loops over the args for one call
map2lp:	move w3,(p)		;addr of bottom of arg stack
	addi w3,5		;choose offset so = Q when done
;inner loop - loop over the args, setting them into the var's
map3lp:	move o2,-2(w3)		;o1 - next arg
	scons o2
	jrst map2ex		;done when first arg is exhausted
	xct -4(p)		;move o2 or car(o2) to o5
	movem o5,@-1(w3)	;store into value cell of right var
;this is a horrible hack, but SOME and SUBSET look at the value of
;O2 and O5 respectively.  So nothing should interfere with them
;between here and the CALL at MAP3EX+1
	docdr o1,o2		;cdr the arg for next time
	movem o1,-2(w3)
	caml w3,q		;see if done
	jrst map3ex		;yes
	addi w3,2		;no, next arg
	jrst map3lp

map3ex:	move o1,(q)		;get the arg to EVAL
	call @-3(p)		;call the EVAL routine
	jrst map2lp		;try CDR of all the args

map2ex:	pop p,q			;kill Q list
	jrst unbind		;caller will adjust P and supply ret val

;  push p,[car or not]
;  push p,[evaller]
;  call domap


;maplist - this one returns cons'ed list of the results
maplis:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[move o5,o2]	;pass tails, not car
	push p,[codsec,,domlis] ;cons the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;mapcar - this one returns cons'ed list of the results, passing CAR of args
mapcar:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domlis] ;cons the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;this is the applier when results must be consed
domlis:	call eval
	docons o2,o1,nil	;new cell for returned list
	move w3,-1(p)		;pointer to results end
	move o3,(w3)		;old end
	dorpd o3,o2		;put new cell onto list
	movem o2,(w3)		;and make it new end
	ret

;subset - this one returns cons'ed list of the list elements for which
;  the ftn returned T
subset:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domsel] ;cons the items, selectively
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;this is the applier for select - cons's the O1 values if return is T
domsel:	push q,o5		;save value to CONS if return is T
	call eval
	pop q,o5
	jumpe o1,cpopj		;nothing if returned false
	docons o2,o5,nil	;new cell for returned list
	move w3,-1(p)		;pointer to results end
	move o3,(w3)		;old end
	dorpd o3,o2		;put new cell onto list
	movem o2,(w3)		;and make it new end
	ret

;mapcon - this one returns nconc'ed results
mapcon:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[move o5,o2]	;not car
	push p,[codsec,,domcon] ;nconc the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret
	
;mapcan - this one returns nconc'ed results, taking CAR of args
mapcan:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domcon] ;nconc the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret
	
domcon:	call eval
	jumpe o1,cpopj		;nul - leave result alone
;here to nconc new results on.  This would be easy if we wanted to keep
;nconcing the new stuff to the whole list.  But we prefer to remember the
;tail as the current place to nconc to.  This is why we have to treat nil
;specially, because we can't use it, since nconc doesn't really do anything
;to nil
	move w3,-1(p)		;get Q as left by mapcon
	move o2,o1		;new value
	exch o1,(w3)		;end, saving new as new end
	call nconc		;
	ret

;map - this one returns NIL
mapnul:	push p,[move o5,o2]	;not car
	push p,[codsec,,eval] 
	call domap
	adjsp p,-2
	move o1,nil
	ret

;mapc - this one returns nil, and uses the car's
mapc:	push p,[docar o5,o2]	;car
	push p,[codsec,,eval]
	call domap
	adjsp p,-2
	move o1,nil
	ret

;some - this one returns the list 
;  the ftn returned T
some:	push q,nil		;return NIL if all else fails
	push p,[docar o5,o2]	;car
	push p,[codsec,,domsom] ;stop when non-NIL return
	call domap
	adjsp p,-2
	pop q,o1		;results
	ret

;this is the applier for SOME
domsom:	push q,o2		;save value to return if return is T
	call eval
	pop q,o5
	jumpe o1,cpopj		;nothing if returned false
	move w3,-1(p)		;pointer to results end
	movem o5,(w3)		;return this
	setzm -2(q)		;and cause the loop to stop
	ret

;every - this one returns T or NIL
every:	push q,[%T]		;return NIL if all work
	push p,[docar o5,o2]	;car
	push p,[codsec,,domeve] ;stop when NIL return
	call domap
	adjsp p,-2
	pop q,o1		;results
	ret

;this is the applier for EVERY
domeve:	call eval
	jumpn o1,cpopj		;continue if returned T
 ;returned false - stop
	move w3,-1(p)		;pointer to results end
	setzm (w3)		;return NIL
	setzm -2(q)		;and cause the loop to stop
	ret

;CERRSET
;special entry for compiled code
;  move o1,tag
;  call w2,cerrset
;  jrst addr after RET
;  ..code within errset..
;  ret
cerrse:	
  ;construct saved environment for ERRSET
	move w4,(p)		;get ret addr
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w3,p
	tlo w3,(object(ty%adr),0)
	movem w3,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG] ;save F for ERROR
	movem o1,@[datsec,,.ERRFLAG]
	call 1(w4)		;call internal routine
	docons o2,o1,nil	;make list of it - to o2
	move o1,o2		;return list
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst unbind


;(ERRSET E "F")
;if all goes well, return (LIST E)
;ERR and the system error handler return to here
;o1 is cdr form
errset:	
  ;construct saved environment for ERRSET
	docdr o2,o1
	camn o2,nil		;if flag not specified
	skipa o2,[%t]		;then default  o2 _ T
	 docar o2,o2		;else o2 _ F
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG]	;save F for ERROR
	movem o2,@[datsec,,.ERRFLAG]
	docar o1,o1		;o1 _ E
	call eval		;result of expr to o1
	docons o2,o1,nil	;make list of it - to o2
	move o1,o2		;return list
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst unbind		;restores old TOPERR

;(ERR code)
;causes most recent ERRSET to return code, except if code = ERRORX,
;  goes to most recent one for which the flag was ERRORX
;code in o1
uerr:	camn o1,[%ERRORX]
	jrst uerrx
	move w2,@[datsec,,.TOPERR] ;saved p
	jumpe w2,restac		;if none saved, just go to top level
	tlz w2,770000		;turn into bare address
	move p,w2		;restore it
	pop p,q			;p now has SP, Q - get back Q
	jrst cubind		;unbind, closing files

;uerrx - search for ERRORX
uerrx:	move w2,@[datsec,,.TOPERR] ;saved p
	jumpe w2,restac		;if none saved, just go to top level
	tlz w2,770000		;turn into bare address
	move p,w2		;restore it
	pop p,q			;p now has SP, Q - get back Q
	move o2,@[datsec,,.ERRFLAG] ;check most recent errset flag
	camn o2,[%ERRORX]	;if it is ERRORX
	jrst cubind		;unbind, closing files
	pop p,w2		;not done, try again
	call cubin1		;special bind that returns, closing files
	jrst uerrx



;Real Lisp errors, user and system versions.  Break.

;*rset
rset:	exch o1,@[datsec,,rsetf]
	ret

;perror - internal error printer when there is a Lisp object to print
;  in this case the regular arg is in O6 and the Lisp thing in O1
perror:	move w4,[codsec,,errprb] ;routine to print ASCIZ from o6 and thing O1
	jrst errr1

;uerror - error for user. PRINT's its arg
uerror:	skipa w4,[codsec,,uerrpr] ;routine to print error

;error - internal error printer
error:	move w4,[codsec,,errprt] ;special routine for ASCIZ strings
errr1:	move w2,@[datsec,,.TOPERR] ;saved p
	setzb nil,nil1		;in case of funny context
;if most recent ERRSET is NIL, then ERR NIL [not possible if no ERRSET]
	move o2,nil		;pretend flag is NIL if no ERRSET
	jumpn w2,error2		;it's there - use ERRSET if it is NIL
;if no errset, or not NIL, then probably print message.  Flag from
;errset is in O2.
error1:	
   ;*RSET=ERRORX means no print
	move o3,@[datsec,,rsetf] ;*RSET
	camn o3,[%ERRORX]
	jrst error3
   ;ERRSET flag = 0 means use selected channel
	camn o2,[object ty%int,0]
	jrst error4
   ;print on tty
	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push q,o1
	push p,w4
	push q,o6
	call terpri
	pop q,o6
	pop p,w4
	pop q,o1
	call (w4)		;print the thing
	pop sp,@[datsec,,.curout] ;put back I/O channel
	adjsp sp,-1
	jrst error3
   ;print on selected output
error4:	push q,o1
	push p,w4
	push q,o6
	call terpri
	pop q,o6
	pop p,w4
	pop q,o1
	call (w4)
   ;print is done, now break if *RSET is on
error3:	move o1,nil		;for err NIL
	skipn o3,@[datsec,,rsetf] ;*RSET
	jrst uerr		;*RSET is off, ERR NIL
;;;;;;now the break
	push sp,[%%HOOKSTACK]
	push sp,@[datsec,,.%hookstack]
	push sp,[object ty%adr,evhook]
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[%RDTOP]	;save status of RDTOP kludge and clear it
	push sp,@[datsec,,.RDTOP]
	setzm @[datsec,,.RDTOP]
	call clrin		;clear input buffer, just in case
	move o3,[%t]		;turn back on interning
	movem o3,@[datsec,,.dointern] ;in case inside maknam
	docons o2,o3,nil	;(NIL)
	move o3,[%errorx]
	docons o1,o3,o2		;(errorx nil)
	call eval
	jrst restac

;o1 - thing to eval
hook:	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	call clrin
	push q,o1		;save thing
	docons o2,o1,nil	;now call hook 1 on it
	move o1,[%HOOK1]
	call apply
	move w2,o1		;result is number - get it
	getnum w2
	caig w2,3
	caige w2,0
	movei w2,0
	jrst @[	codsec,,hooks
		codsec,,hookx
		codsec,,hookg
		codsec,,hookb](w2)

hooks:	setz nil1,
	move o1,(q)		;get back thing
	adjsp sp,-2		;skip hook
	move w2,[call delhok]
	movem w2,evhook
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-5		;%CUROUT + eval blip
	adjsp p,-3		;saved sp and q, plus our ret addr
	call eval
	pop q,o2		;original to o2
	jrst stpdis		;show results

;execute
hookx:	setz nil1,
	move o1,(q)		;get back thing
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-5
	adjsp p,-3		;saved sp and q, plus our ret addr
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	call eval
	pop q,o2		;original to o2
	pop sp,evhook		;put back hook
	adjsp sp,-1
	jrst stpdis		;show results

;go
hookg:	setz nil1,
	pop q,o1		;get back thing
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	move w2,[jfcl]
	movem w2,evhook
	ret

hookb:	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	err /Break from single stepper/
	
;stpdis - display results
;o1 - results
;o2 - original
stpdis:	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	push q,o1
	docons o3,o2,nil
	docons o2,o1,o3		;now call hook 1 on it
	move o1,[%HOOK2]
	call apply
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	pop q,o1
	ret

;DELHOK - set up hook that triggers next time
delhok:	move w2,[call hook]
	movem w2,evhook
	ret

;SSTEP
sstep:	setzm @[datsec,,.%HOOKSTACK]	;start fresh stack
	push sp,[object ty%adr,evhook]
	push sp,evhook
	move w2,[call hook]
	movem w2,evhook
	docar o1,o1
	call eval
	pop sp,evhook		;put back hook
	adjsp sp,-1
	ret

;uerrpr - printer for ERROR.  Uses PRINC
uerrpr:	scons o1		;if cons
	jrst princ		;not - just do princ
;(mapc 'printc o1)
uerrpl:	jumpe o1,retnil		;nothing left to do, done
	pushcdr q,o1
	docar o1,o1		;and do this
	call @[datsec,,<%printc&777777>+at%cal]
	pop q,o1
	jrst uerrpl

;errset - If most recent flag was NIL, just do ERR NIL
;if not, leaves the flag in O2 and go to ERROR1
error2:	tlz w2,770000		;turn into bare address - W2 is P
	pop w2,w3		;w3 _ q
	move o2,@[datsec,,.ERRFLAG] ;get most recent flag
	jumpn o2,error1		;if non-NIL flag, ignore errset
	move p,w2		;restore P - SP still on P
	move q,w3		;restore Q	
	move o1,nil		;now return NIL
	jrst cubind		;unbind, closing files

;error printer that first prints a thing in O1
errprb:	push q,o6
	push q,o1
	move o1,[object ty%cst,<codsec,,[asciz /? /]-1>]
	call princ		;without " "
	pop q,o1
	call prin1
	call terpri
	pop q,o1

;special error printer for ASCIZ strings
errprt:	push q,o1		;print ?
	move o1,[object ty%cst,<codsec,,[asciz /? /]-1>]
	call princ		;without " "
	pop q,o1		;now make original arg into string
	hrli o1,(object ty%cst,<codsec,,0>) ;make string ptr
	subi o1,1
	call princ		;and print without " "	
	ret

;This page is functions that could be produced by the compiler,
;and do not depend upon any representations.

copy:	scons o1
	ret			;if not cons cell, then same
;copy car and cdr recursively
	push q,o1		;save original
	docar o1,o1
	call copy		;copy car recursively
	exch o1,(q)		;save copy, get back original
	docdr o1,o1		;copy cdr recursively
	call copy		;copy cdr recursively
	pop q,o2		;back back copy of car to o2
	docons o3,o2,o1		;cons the copies
	move o1,o3		;and return copy
	ret

;The EMACS interface

.scalar edfork,edpc
.vector edacs(20)

;offsets into the editor's (teco's) buffer block
;  all values are byte offsets from the begining of the section unless 
;  otherwise noted. (see INFO:TECORD.INFO for more information)
bufbeg==0			;BEG - start of the buffer
bufbgv==1			;BEGV - virtual start of buffer
bufpt==2			;PT - point in this buffer
bufgpt==3			;GPT - start of gap
bufvz==4			;VZ - virtual end of buffer
bufz==5				;Z - end of buffer
bufext==6			;EXTRAC - size of gap
bufcal==7			; - routine to call for protocol service
bufarg==10			; - argument for above routine
				;   if arg >= 0  then
				;	buffer must be at least that large
				;   else teco will do a jcl read
bufmod=11			;MODIFF - if the buffer was modified
bufrdo=12			;RDONLY - if the buffer is read only


;edkill - kill the current editor fork if it exists
edkill:	skipn nil1,edfork	;is there one?
	 ret			;no, just return
	kfork			;kill it
	rfrkh			;release it's handle
	erjmp .+1		;ignore errors
	setzm edfork		;clear these
	setzm edpc
	setzb nil1,o1
	ret			;end of edkill

;gedfrk - make sure we have an editor fork.  Creating it if needed.
gedfrk:	skipe edfork		;have one already?
	jrst gedfrx		;yes - just return its number
	setzm edpc		;say fork not started
	movsi nil1,(cr%cap)	;pass cap's (mostly ^C)
	cfork
	 jrst [err /Can't create editor fork/]
	movem nil1,edfork	;save fork handle
	movei w2,edsec		;make section for him
	call maksec
	 jrst [err /Can't make section for editor/]
	hrlz nil1,edfork	;fork,,0
	move w2,[.fhslf,,edsec*1000] ;self,,editor section
	move w3,[pm%cnt\pm%rwx\1000] ;the whole section, r/w/x
	pmap
	move nil1,[gj%old\gj%sht]
	hrroi w2,[asciz /SYS:EMACS.EXE/]
	gtjfn
	 jrst [err /Can't open SYS:EMACS.EXE/]
	hrl nil1,edfork		;fork,,jfn
	get			;get EMACS into memory
	setz nil1,
gedfrx:	move w2,edfork		;return the editor's fork handle
	maknum w2		;as a legit number
	move o1,w2
	ret			;end of gedfrk

;edcall - call the editor's FS Superior handler with an arg of O1.
edcall:	skipn edpc		;has editor been run already?
	 jrst [	push q,o1	;no, run then stop the editor
		call edcret
		pop q,o1
		jrst .+1 ]
	call edregs		;get the editor's ACs
	move w3,w2		;save the address of the buffer block
	hrli w3,edsec		;create an extended addressing pointer
	call getint		;get the word integer form of the arg	
	movem w2,bufarg(w3)	;save the argument for FS Superior
	push p,edpc		;save the old pc
	movei w3,bufcal(w3)	;get the address of  FS Superior
	movem w3,edpc
	setz o1,
	call edrun		;run it
	pop p,edpc
	ret			;end of edcall

;edjcl - pass some jcl (a string in O1) to the editor
; returns the string
edjcl:	xtype o1
	caie w2,ty%xst		;is arg a string
	 jrst [perr /Not string/]
	move nil1,[<440700,,0>+<1(o1)>]	;point to the user's string
	rscan
	 jrst [err /Can't do RSCAN/]
	setz nil1,
	ret			;end of edjcl

;edregs - read the editor's registers into edacs
; and return the address of the editor's buffer block
edregs:	move nil1,edfork
	move w2,[codsec,,edacs]	;where to put them acs
	rfacs			;get the acs
	setz nil1,
	move w2,edacs+2		;return address of editor's buffer block
	hrli w2,edsec
	ret			;end of edregs

;edrun - start or continue the editor.
; If O1 is non-NIL start the editor, else if it is NIL continue the
; editor unless it wasn't started
edrun:	movei w4,ourtym		;save current terminal status
	call gettym
	skipe edpc		;if editor not started,
	skipe o1		; and start wanted
	 skipa			;then start the editor
	 jrst [	xmovei w4,edtym	;else continue editor
		call settym	;set up EMACS's
		move nil1,edfork
		move w2,edpc
		sfork
		jumpa edwait ]	;and wait for the return
	move nil1,edfork	;start emacs
	setzb w2,edpc		;normal start by default, signal a start
	sfrkv
edwait:	wfork			;wait for it to get back to us
	call edchex		;check for ^C (must be right after wfork)
	xmovei w4,edtym		;get status from editor
	call gettym
	move nil1,edfork
	rfsts
	movem w2,edpc		;save PC for continue
	xmovei w4,ourtym	;and put back ours
	call settym
	setz nil1,		;fix nil
	call edregs		;get the registers of the editor
	move w2,edacs+3		;return the number arg from the FS EXIT
	jrst retint		;end of edrun

;EDCHEX - check exit from editor.  This is to be called
; immediately after each WFORK.  It checks to see if the editor was
; ^C'ed.  If so, it does HALTF, and continues the editor when it is
; continued.  It returns to the instruction before its call, so that
; had better be a wfork.
edchex:	push p,nil1		;save AC1, the fork
	rwm			;look at interrupts
	tlne w2,(1_34.)		;level 1 in progress?
	 jrst edchcc		;yes - ^C
	pop p,nil1		;no, continue normally
	ret			;end of edchex

edchcc:	movei w4,edtym		;save editor terminal status
	call gettym
	movei w4,ourtym		;restore out terminal status
	call settym
	haltf
	movei w4,edtym		;restore editor terminal status
	call settym
	pop p,nil1
	tlo nil1,(sf%con)	;continue fork
	sfork
	tlz nil1,(sf%con)
	sos (p)			;return to WFORK
	sos (p)
	ret			;end of edchcc


tymlen==5		;length of block used to save term params

	.vector ourtym(tymlen),edtym(tymlen)

;gettym - move current terminal parameters into block whose addr is in W4
gettym:	movei nil1,.fhjob	;get job's interrupt word
	rtiw
	dmovem w2,3(w4)
	movei nil1,.priou
	rfmod
	movem w2,0(w4)
	rfcoc
	dmovem w2,1(w4)
	setz nil1,
	ret			;end of gettym

;settym - set terminal parameters from block whose addr is in W4
settym:	movei nil1,.fhjob
	dmove w2,3(w4)
	stiw
	 erjmp .+1
	movei nil1,.priou
	move w2,0(w4)
	sfmod
	stpar
	dmove w2,1(w4)
	sfcoc
	setz nil1,
	ret			;end of settym

;edput - low-level I/O routine
;o2 - channel
;w2 - char
edput:	sosge ch%dat(o2)	;any space left?
	jrst [ 	push p,w2	;make sure these are preserved
		push p,w3
		move o1,o2	;use current channel
		aos ch%dat(o2)	;undo failing SOS
		call edclip	;account for use so far
	       	move o1,[object ty%int,5620.]	;make gap 1K words
		call gedbuf	;try to expand the buffer
		move w2,edacs+2	;see what we got
		hrli w2,edsec
		move w3,bufext(w2)
		movem w3,ch%dat(o2)	;remeber new buffer space
		pop p,w3
		pop p,w2
		jrst edput]	;and try again
	movsi w3,edsec		;byte pointer is indexed off here
	idpb w2,ch%jfn(o2)
	ret			;end of edput

;edget - low-level I/O routine
;o2 - channel
;w2 - char or $eof$ error on end of buffer
edget:	sosge ch%dat(o2)	;any chars left?
	jrst edeof		;no, throw EOF
	hrlzi w3,edsec		;byte pointer is indexed off section
	ildb w2,ch%jfn(o2)
	ret			;end of edget

edeof:	move w2,ch%dat(o2)	;how bad is it?
	came w2,[-1]		;one overrun
	jrst eofbad		;too many - EOF error
	movei w2,33		;at end, give him an ESC
	ret

;errio - low-level I/O routine for an error caused by an illegal
; use of a channel
errio:	err /Illegal use of channel/

;edclrb - clear the buffer
edclrb:	call edcret		;make sure we have a valid buffer
	call edregs		;get editor ACs
	move w3,bufz(w2)	;compute physical size
	sub w3,bufbeg(w2)
	add w3,bufext(w2)
	movem w3,bufext(w2)	;now call it all gap
	move w3,bufbeg(w2)	;everything else at start
	movem w3,bufbgv(w2)
	movem w3,bufpt(w2)
	movem w3,bufgpt(w2)
	movem w3,bufvz(w2)
	movem w3,bufz(w2)
	move w2,bufext(w2)	;return size
	jrst retint

;edwrit - return a channel for writing into a buffer at point
edwrit:	call edcret		;make sure we have a valid buffer
	move o1,[object ty%int,5620.]
	call gedbuf
	call makchn		;returns a new channel object in o1
	move w2,[codsec,,edput] ;use special output routine that puts into buf
	movem w2,ch%put(o1)
  ; now adjust the buffer so there is a reasonable size gap
	move w2,edacs+2
	hrli w2,edsec
	move w3,bufext(w2)	;tell EDGET the gap size
	movem w3,ch%dat(o1)
	move w3,bufpt(w2)	;get start of insert
	adjbp w3,[440703,,0]	;build a byte pointer to it
	movem w3,ch%jfn(o1)	;save it in channel control block
	ret			;end of getbuf

;edgap - ask the editor to move the gap to the end
edgap:	setz o1,		;don't kill currect editor
	skipe edfork		;has the editor been run?
	skipn edpc
	 jrst [	err /Editor has'nt been run/]
	call edregs		;get address of editor's buffer block
	push p,bufpt(w2)	;save old point
	move w3,bufz(w2)	;put point at end
	movem w3,bufpt(w2)
	setzm bufarg(w2)	;ask for the gap to be closed
	push p,edpc		;save old pc
	movei w2,bufcal(w2)	;get FS Superior address
	movem w2,edpc		;and start there
	setz o1,
	call edrun
	move w2,edacs+2
	hrli w2,edsec
	pop p,edpc		;restore old pc
	pop p,bufpt(w2)		;restore point
	ret			;end of edgap

;edread - return a channel for reading from the buffer
edread:	call edgap		;close the gap
	call makchn		;returns a new channel object in o1
	move w2,[codsec,,edget] ;use special input routine that read fr list
	movem w2,ch%get(o1)
	call edregs		;get address of editor's buffer block
	move w3,bufbgv(w2)	;begin of buffer (bytes from start of section)
	adjbp w3,[440703,,0]	;w3 gets byte pointer relative to section
	movem w3,ch%jfn(o1)
	move w3,bufvz(w2)	;end
	sub w3,bufbgv(w2)	;- begin
	movem w3,ch%dat(o1)	;--> length
	ret			;end of edread

;edcret - make sure the editor has a valid buffer
;  run the editor (and tell it to stop) if needed
edcret:	call gedfrk		;make sure we have an editor	
	skipe edpc		;has the editor been run?
	 ret			;yes, done
	move o1,[makstr /EMACS 0FSEXIT/] ;tell him to return
	call edjcl
	call edrun		;start it
	ret			;end of edcret

;gedbuf - make the gap O1 bytes at point
;  returns  the size of the buffer.
gedbuf:	move w2,o1		;get the real size
	getnum w2
	push p,w2		;save the size
	call edcret		;make sure we have a buffer in the editor fork
	call edregs		;get address of editor's buffer block
	move w3,bufpt(w2)	;is it in right place?
	came w3,bufgpt(w2)
	 jrst gedbu0		;no
	move w3,bufext(w2)	;gap size
	caml w3,0(p)		;is it big enough?
	 jrst gedbu1		;yes - nothing to do
;here if we need to ask for more space
gedbu0:	move w3,0(p)		;total buffer size we need (in chars)
	movem w3,bufarg(w2)
	push p,bufpt(w2)	;this is going to move PT to after new space
	push p,edpc		;save old editor pc
	movei w2,bufcal(w2)	;addr to start him at
	movem w2,edpc		;start editor here
	setz o1,
	call edrun
	pop p,edpc		;restore original editor pc
	call edregs		;get the editor's buffer block again
	pop p,w3		;old PT
	sub w3,bufpt(w2)	;old - new PT (negative)
	addm w3,bufpt(w2)	;adjust things to move point back
	addm w3,bufgpt(w2)
	addm w3,bufvz(w2)
	addm w3,bufz(w2)
	movn w3,w3		;now add this garbage into gap
	addb w3,bufext(w2)	;w3 also gets gap size
	camge w3,0(p)		;is it big enough?
	jrst [err /EMACS couldn't make big enough buffer/]	;no
gedbu1:	pop p,w2		;cleanup wanted size
	move w2,w3		;return the buffer size
	jrst retint		;end of gedbuf


;edclip chan - call after done writing - updates point, etc.
edclip:	skipn o1		;if channel =  nil
	 move o1,@[datsec,,.curou]	;use the current output channel
	move w3,ch%put(o1)	;is this an editor channel
	came w3,[codsec,,edput]
	 jrst [ perr /not an editor channel/]	;no, die
	call edregs		;get the address of the editor's buffer block
	move w3,bufext(w2)	;gap when we started
	sub w3,ch%dat(o1)	;- gap now - this is number of char's written
	addm w3,bufz(w2)	;adjust everything
	addm w3,bufvz(w2)
	addm w3,bufgpt(w2)
	addm w3,bufpt(w2)
	movn w3,w3
	addm w3,bufext(w2)
	setzm ch%dat(o1)	;say there is no more space in the buffer
	ret			;end of edclip

;The LINK interface

;LINK does all the work for LOADREL.  We look at BPSEND to find where
;the load should start, and tell LINK by /SET:.LOW:nnn.  We load
;the files the user asked for into section LNKSEC, and then XBLT
;them to the final place in section CODSEC.  Symbols are slightly
;hairy.  The startup code writes out a file ELISP.REL that has all the
;symbols the user is likely to need.  So we tell LINK to look at that
;file.  The bigger problem is getting symbols back.  We have to do that
;because that is the only way to get the entry points.  We can't
;just take back the whole symbol table from the load, because most
;of it will be from ELISP.REL, which is just a copy of symbols we
;already have.  Also, JOBDAT will be there, and we don't really need
;a copy of it either.  Fortunately ELISP and JOBDAT are at the end
;of the load, so what we do is simply stop copying when we get to
;ELISP or JOBDAT.  Another problem is where to put the symbols that
;we get from the load.  My first thought was to reserve a section for
;symbols, and just copy them there.  Alas, DDT is only capable of
;understanding symbols in the section it is running in.  So the
;symbols have to be in CODSEC.  It is nearly impossible to get a
;discontiguous piece for them, since DDT is at the top of the section.
;So I just leave them where they lie, namely at the end of each load.
;I.e. the symbols for this core image are at the end of the original
;code, and each time we do LOADREL, symbols will be at the end of the
;section loaded.  I construct a linked list of symbol blocks,
;pointed to by SYMLST.  This is used by GETSYM.  Alas, DDT doesn't
;understand, so DDT will only see the initial symbols.  Another
;reasonable approach would be to put the symbols right below DDT
;and work down until you meet the code.  I'll let that wait for
;another day...  Note that the block of code loaded by LOADREL
;must be protected by a TY%SPC word, so the GC doesn't try to SCAN it!!
	
.scalar lnkfrk,symlst
		;symlst is the head of a linked list of symbol tables.
		;It points to a block that looks like
		;  ptr to next block
		;  aobjn word for symbol table

lnknam:	asciz /000LNK.TMP;T/

;LOADREL - takes commands to LINK on O1, returns NIL
loadr:	call getstr		;validate the string
	push q,o1		;save string until we have a place to put it
  ;make up .TMP file name
	gjinf			;job number to W3
	move w2,w3		;job number in W2
	setz w4,		;build up in W4
	idivi w2,10.		;low digit to W3
	lshc w3,-7		;shift to W4
	idivi w2,10.
	lshc w3,-7
	idivi w2,10.
	lshc w3,-7		;now have all 3 digits at top end of W4
	add w4,[ascii /000LN/]	;turn into ASCII
	movem w4,lnknam		;and make up full file spec
	movsi nil1,(gj%fou\gj%sht) ;now open it
	hrroi w2,lnknam
  ;open the .TMP file
	gtjfn
	 erjmp [err /Can't create nnnLNK.TMP/]
	move w2,[<7_30.>\of%wr]	;open for text output
	openf
	 erjmp [err /Can't create nnnLNK.TMP/]
  ;now write the LINK command.  Also leaves 1 word for the GC skip pointer
  ;/START:START/PATCHS:0/ONLY:LOW/SET:.LOW.:nnn  ELISP:ELISP.REL, user string
	hrroi w2,[asciz \/start:start/patchs:1/only:low/set:.low.:\]
	setz w3,
	sout
	aos w2,bpsend		;advance past skip pointer
	move w3,[object(ty%spc,0)]
	movem w3,-1(w2)		;put in dummy skip pointer (don't know size)
	tlz w2,777777
	movei w3,8.
	nout
	 jfcl
	hrroi w2,[asciz \ elisp:elisp.rel, \]
	setz w3,
	sout
	pop q,o1		;get back user string
	move w2,[<440700,,0>+<1(o1)>] ;
	sout
	closf	
	 erjmp [err /Can't close nnnLNK.TMP/]
 ;now creat subfork
	skipe lnkfrk		;if already have fork
	jrst loadr1		;don't need to create section again
	movei w2,lnksec		;make section for him
	call maksec
	 jrst [err /Can't make section for LINK/]
loadr1:	skipn nil1,lnkfrk	;if already have fork
	jrst loadr2
	kfork			;kill it
loadr2:	movsi nil1,(cr%cap)	;pass cap's (mostly ^C)
	cfork
	 jrst [err /Can't create LINK fork/]
	movem nil1,lnkfrk	;save fork handle
	hrlz nil1,lnkfrk	;fork,,0
	move w2,[.fhslf,,lnksec*1000] ;self,,link section
	move w3,[pm%cnt\pm%rwx\1000] ;the whole section, r/w/x
	pmap
	move nil1,[gj%old\gj%sht]
	hrroi w2,[asciz /SYS:LINK.EXE/]
	gtjfn
	 jrst [err /Can't open SYS:LINK.EXE/]
	hrl nil1,lnkfrk		;fork,,jfn
	get			;get LINK into memory
	move nil1,lnkfrk	;start LINK
	hrlzi w2,1		;CCL start
	sfrkv
	wfork			;wait for it to get back to us
	call edchex		;check for ^C
  ;now remove ELISP module from symbol table, as we already have it
	move w2,@[lnksec,,116]	;aobjn word for symbol table
	hlre w3,w2		;W3 - neg count
	hrli w2,lnksec		;W2 - address
   ;set W4 to last PNAME except the ELISP one.  Since the ELISP table
   ;is last in memory, we use this as the real end of symbol table, and
   ;thus save all the space taken up by the ELISP table
loadr4:	move nil1,(w2)		;get symbol
	tlne nil1,740000	;ignore if not PNAME
	jrst loadr3
	came nil1,[.rsqz 0,JOBDAT] ;ignore JOBDAT
	camn nil1,[.rsqz 0,ELISP] ;and ELISP
	jrst loadr3		;no
	move w4,w2		;yes - we have a PNAME
loadr3:	addi w3,2
	addi w2,2
	jumpl w3,loadr4
  ;now W4 is address of last PNAME symbol
	addi w4,2		;count the PNAME
	hrrm w4,@[lnksec,,121]	;this is revised .JBFF
	hll w4,@[lnksec,,116]
	sub w4,@[lnksec,,116]	;now have size of symbol table
	movn w4,w4		;negate
	hrlm w4,@[lnksec,,116]	;and revise the magic word
  ;now copy the thing into our address space
	move w2,@[lnksec,,121]	;.JBFF in core image we just loaded
	hll w2,bpsend
	sub w2,bpsend		;compute size of thing loaded
	move w3,bpsend		;place we loaded it
	hrli w3,lnksec
	move w4,bpsend		;place it should go
	addm w2,-1(w4)		;fill in count in GC skip pointer
	aos -1(w4)		;plus 2 for SYMLST entry
	aos -1(w4)
	xblt w2,		;now copy from LNKSEC to final place
  ;now link the symbol table from this piece into the list
	move w2,@[lnksec,,121]	;.JBFF again
	hrli w2,codsec		;in code section this time
	subi w2,1		;last loc used
	push w2,symlst		;next in list
	movem w2,symlst		;this one is now first
	push w2,@[lnksec,,116]	;AOBJN word for this one
	addi w2,1		;first beyond
	movem w2,bpsend		;update BPSEND
	setzb nil1,o1		;return NIL
	ret

;GETSYM - atom or string, returns value, looking up in DDT symbol table
; If more than one value, uses global if possible
getsym:	call getstr		;validate as string
	move w2,[<440700,,0>+<1(o1)>] ;one-word byte pointer to string
	setz w4,		;result will go in W4
	movei w3,6		;maximum of 6 chars
gets0:	ildb nil1,w2
	jumpe nil1,gets1	;done at null
	cain nil1,44		;convert specials
	jrst [movei nil1,46
	      jrst gets2]
	cain nil1,45
	jrst [movei nil1,47
	      jrst gets2]
	cain nil1,56
	jrst [movei nil1,45
	      jrst gets2]
	cail nil1,60		;convert numbers
	caile nil1,71
	jrst gets3		;not number
	subi nil1,60-1
	jrst gets2
gets3:	cail nil1,140		;upper case
	subi nil1,40
	cail nil1,101		;if letter
	caile nil1,132
	jrst gets4		;not
	subi nil1,101-13
	jrst gets2
gets4:	movei nil1,0		;all other - blank
gets2:	imuli w4,50		;shift to accept new char
	add w4,nil1
	sojg w3,gets0		;loop if more char's
  ;all char's done - W4 now has the symbol
gets1:	push p,[0]		;-1(p) - flags
	push p,[0]		;(p) - value
	move w2,symlst		;address of first symbol table
getsnt:	move w3,1(w2)		;AOBJN pointer
getslp:	move nil1,(w3)		;first symbol
	tlce nil1,740000	;if PNAME
	tlcn nil1,740000	;or block name
	jrst getsig		;ignore it
	xor nil1,w4		;else test
	tdne nil1,[037777,,777777] ;any signif bits different?
	jrst getsig		;yes - ignore it
	tlne nil1,040000	;if global, use it and return
	jrst getsgl
	skipe -1(p)		;else use only if nothing there already
	jrst getsig		;something there, ignore new one
	movem nil1,-1(p)	;use new value: save flags
	move nil1,1(w3)		;value
	movem nil1,(p)		;save it
	jrst getsig		;now continue
;here if we find a global - use it now
getsgl:	move w2,1(w3)		;value
	setz nil1,
	adjsp p,-2
	jrst retint

;here to continue search
getsig:	aobjp w3,getsen		;proceed to next symbol
	aobjn w3,getslp
;here if run out for this table
getsen:	move w2,(w2)		;next table
	jumpn w2,getsnt		;process next table
;here when run out of tables to search
	pop p,w2		;value (if any)
	pop p,w3		;flags
	setz nil1,
	tlnn w3,740000		;found anything?
	jrst retnil		;no
	jrst retint		;yes - return integer


	consta			;make sure all pure stuff is down

	variab			;then all variables

inprch:	asciz /*/		;initial prompt

erchin:	"G"-100,,3		;initial ATI specification for ERRCH

rdtab:	rd%nul			;null - should never get through
	rd%let			;^A
	rd%let			;^B
	rd%let			;^C
	rd%let			;^D
	rd%let			;^E
	rd%let			;^F
	rd%eol			;^G - eol
	rd%let			;^H
	rd%sp			;^I - spacing
	rd%eol			;^J - lf
	rd%eol			;^K - vert tab
	rd%eol			;^L - form feed
	rd%eol			;^M - cr
	rd%let			;^N
	rd%let			;^O
	rd%let			;^P
	rd%let			;^Q
	rd%let			;^R
	rd%let			;^S
	rd%let			;^T
	rd%let			;^U
	rd%let			;^V
	rd%let			;^W
	rd%let			;^X
	rd%cmt			;^Y - comment
	rd%cmt			;^Z - comment
	rd%esc			;esc
	rd%let			;^\
	rd%let			;^]
	rd%let			;^^
	rd%let			;^_
	rd%sp			;40 - space
	rd%let			;!
	rd%sq			;"
	rd%let			;#
	rd%let			;$
	rd%let			;%
	rd%let			;&
	rd%drm\rd%let		;'
	rd%lp			;(
	rd%rp			;)
	rd%let			;*
	rd%sgn			;+
	rd%com			;,
	rd%sgn			;-
	rd%per			;.
	rd%sl			;/
	repeat 10.,rd%dig	;0 - 9
	rd%let			;:
	rd%let			;;
	rd%let			;<
	rd%let			;=
	rd%let			;>
	rd%let			;?
	rd%let			;@
	repeat 26.,rd%let	;A - Z
	rd%lb			;[
	rd%let			;\
	rd%rb			;]
	rd%let			;^
	rd%let			;_
	rd%let			;`
	repeat 26.,rd%lc	;a - z
	rd%let			;{
	rd%let			;|
	rd%let			;}
	rd%let			;~
	rd%let			;delete

chntab:	<2_30.>\<codsec,,cncint>	;0 - ^C
	<2_30.>\<codsec,,cndint>	;1 - ^D
	<2_30.>\<codsec,,cneint>	;2 - ^E
	<2_30.>\<codsec,,cngint>	;3 - ^G
	<2_30.>\<codsec,,cnhint>	;4 - ^H
	<2_30.>\<codsec,,cnbint>	;5 - ^B
	0	;6
	0	;7
	0	;8
	<2_30.>\<codsec,,pdlovr>	;9 - PDL overflow (impossible)
	0	;10
	<2_30.>\<codsec,,illins>	;11 - file data error
	0	;12 - disk full
	0	;13
	0	;14
	<2_30.>\<codsec,,illins>	;15 - ill instruction
	<2_30.>\<codsec,,illmem>	;16 - ill mem read
	<2_30.>\<codsec,,illmem>	;17 - ill mem write
	0	;18
	0	;19
	<2_30.>\<codsec,,sysres>	;20 - system resources
	0	;21
	0	;22
	0	;23
	<1_30.>\<codsec,,cnyint>	;24 - ^Y
repeat 13.,[0]

gnum:	ascii /G0000/

rerdch:	32		;^Z

fixch:	6		;^F

fremap:	-1		;64 bits
	777777777400

;Start of OBLIST.  This has to go up in the section where garbage
;collection is done.

	normal==.	

	offset -400000
	loc 400020	;stay out of the AC's

nbuck==127.

;clear bk0 to bk126 to nil

bk0==0 	;don't know why the repeat won't do this

define clrbuk(#buk)
bk!buk==0
termin

repeat nbuck,[
clrbuk .rpcnt]

define getbuk(#buk)
bk!buk
termin

define setbuk(#buk,val)
bk!buk==<object ty%ccn,<datsec,,val>>
termin

define buklnk(atname)
bucket==<.1stwd asciz /atname/>_<-1>
zz==bucket/nbuck
zz==zz*nbuck
bucket==bucket-zz

getbuk bucket
setbuk bucket,.-2
termin

define buknum(atname)
bucket==<atname>_<28.>
zz==bucket/nbuck
zz==zz*nbuck
bucket==bucket-zz

getbuk bucket
setbuk bucket,.-2
termin

;macros for defining atoms

;a simple atom

define declat(atname,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;a simple atom for the character table - its name is one character,
;which is specified as a number.

define declch(#atname,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buknum atname

ch!atname=object ty%cat,<datsec,,.>


;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	atname_29.
nxtent::
termin

;an atom with SUBR property


define declsu(atname,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+13>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsubr>
]
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%int,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;DECLLS - LSUBR

define declls(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+11>
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evlsub>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%LSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;special version of DECLSU for subr's with special routines designed
;to be called directly from EVAL

define declxs(atname,addr,numarg,evaddr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+13>
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evaddr>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%int,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;special version of DECLSU that lets the user supply the name for generated
;symbols, in case of things no unique to 6 char's

define declss(atname,lab,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+13>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsubr>
]
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%int,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with SUBR property, atom name starts with *


define starsu(atname,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+13>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evsubr>
]
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%int,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;an atom with FSUBR property

define declfs(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+11>
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evfsub>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;declsp - for special forms that dispatch directly to code

define declxf(atname,addr,evaddr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+11>
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evaddr>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with FSUBR property, name starting with *

define starfs(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+11>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evfsub>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;an atom with a value



define declva(atname,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: value
	nil
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

define declsv(atname,prefix,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!prefix=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!prefix:: value
	nil
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with a value, that begins with a *.  The * is not part of atname

define starva(atname,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: value
	nil
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;This one is defined for MACROEXPANSION.  It has
;FSUBR prop
;VALUE
;an extra argument giving the suffix for the generated labels
;   (since MACROEXPANSION will conflict with MACRO)

define declfv(atname,lab,addr,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!lab::	value
	nil
	object ty%cst,<datsec,,.+11>
	object ty%ccn,<datsec,,.+4>
	object ty%adr,<codsec,,evfsub>
	jsp w3,@.+1
	object ty%iadr,<codsec,,addr>
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;declbn - this is designed for LAMBDABIND and UNBIND, which LAP
; uses to get at LB1, LB2, ... LB5.  The idea is that
; (GET 'LAMBDABIND 3) should be LB3.

define labnam(prefix,#n)
	 prefix!n termin

define declbn(atname,prefix,howmany,\nxtent,plis)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
;property list
plis::
zzz==howmany
repeat howmany-1,[
	object ty%int,zzz
	object ty%ccn,<datsec,,.+1>
	object ty%int,<labnam prefix,zzz>
	object ty%ccn,<datsec,,.+1>
zzz==zzz-1
]
	object ty%int,1
	object ty%ccn,<datsec,,.+1>
	object ty%int,prefix!1
	nil
nxtent::
termin

;DECLSY - an atom with a SYM property

define declsy(atname,value,\plis,nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: %.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
plis::
	%SYM
	object ty%ccn,<datsec,,.+1>
	value
	nil
nxtent::
termin

;DECSSY - an atom with a SYM property, with your own prefix

define decssy(atname,prefix,value,\plis,nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!prefix=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!prefix:: %.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+5>
	nil	
	object ty%adr,<codsec,,evund>
	jsp w3,@.+1
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
plis::
	%SYM
	object ty%ccn,<datsec,,.+1>
	value
	nil
nxtent::
termin



;Here is the oblist, the list of all atoms.  Note that the space used by
;the atoms and their property lists is not in free space.  so if they are
;changed, the GC won't recover the space.

declsu ABS,absf,1
declsu ADD1,add1,1
declsu AEXPLODE,aexplo,1
declss AEXPLODEC,aexpc,aexplc,1
declsu ALIAS,alias,2
declss %ALLOCATE-BPS,albps,albps,2
declxf AND,mand,evand
declsu ANTHCHAR,anthch,2
starsu APPEND,app,2
declls APPEND,uapp
declss APPLY,uapply,uapply,3
starsu APPLY,apply,2
declsu ARG,lxarg,1
declsu ASCII,mascii,1
declsu ASSOC,assoc,2
declxs ATOM,atomp,1,evatom
declsy %ATOM,<object ty%int,atomp>
declva BASE,<object ty%int,10.>
declsu %BFLAP,%bflap,5
declsu BINOUT,binout,1
declsu BININ,binin,0
declsv #%BKSAVE,bksave,nil
declsy BNDERR,<object ty%int,bnderr>
ifn old,[
starsu BOOLE,sboole,3
] ;ifn old
declls BOOLE,boole
declsu BOUNDP,boundp,1
declxs CAR,car,1,evcar
declxs CDR,cdr,1,evcdr
declsu CHRCT,chrct,0
declsu CHRPOS,chrpos,0
declsu CHRVAL,chrval,1
declsu CLOSEF,closef,2
declsu CLOSEIO,xclose,1
declsu CLRBFI,clrbfi,0
declxf COND,docond,evcond
declxs CONS,cons,2,evcons
declsy %CONS,<object ty%int,cons>
declsu CONSP,consp,1
declss %CONSTANT-ATOMP,catmp,catmp,1
declat CONTINUOUS
declsu COPY,copy,1
declfs CSYM,csym
declsu CURPOS,curpos,1
declsu CURRENTIN,inch,0
declss CURRENTOUT,outch,outch,0
declsu DATE,date,0
declsu DEBUGINT,debint,1
declsu DELETEF,delete,2
declss %DEPOSIT-CONSTANT,dconst,dconst,2
declss %DEPOSIT-FUNCTION-LINKAGE,dfnlk,dfnlk,2
declss %DEPOSIT-INSTRUCTION,dinst,dinst,4
declss %DEPOSIT-OBJECT-POINTER,dobj,dobj,2
declss %DEPOSIT-VALUE-REFERENCE,dvalr,dvalr,2
declsu DDT,calddt,0
declsu DDTIN,ddtin,1
starsu DIF,diff,2
declsu DIVIDE,divid,2
declsu DTIME,dtime,0
declsu EDITCH,setedc,1
declss %EDITOR-BUFFER-SIZE,gedbuf,gedbuf,1
declss %EDITOR-CALL-FORK,edcall,edcall,1
declss %EDITOR-CLEAR-BUFFER,edclrb,edclrb,0
declss %EDITOR-CLIP-BUFFER,edclip,edclip,1
declss %EDITOR-CREATE-FORK,edcret,edcret,0
declss %EDITOR-GET-FORK,gedfrk,gedfrk,0
declss %EDITOR-KILL-FORK,edkill,edkill,0
declss %EDITOR-READ-CHANNEL,edread,edread,0
declss %EDITOR-RUN-FORK,edrun,edrun,1
declss %EDITOR-SET-JCL,edjcl,edjcl,1
declss %EDITOR-WRITE-CHANNEL,edwrit,edwrit,0
declsu ERR,uerr,1
declsu ERRCH,errch,1
declss ERROR,ueror,uerror,1
declat ERRORX
declfs ERRSET,errset
declsy %ERRSET,<object ty%int,cerrse>
declxs EQ,eq,2,eveq
declsu EQSTR,eqstr,2
declsu EQUAL,equal,2
declss EVAL,ueval,ueval,2
starsu EVAL,eval,1
declsu EVALV,evalv,2
declfs EVERY,every
declsu EXIT,exit,2
declsu EXPLODE,explod,1
declss EXPLODEC,expc,exploc,1
declat EXPR
declat FEXPR
declsu FIX,fixf,1
declat FIXFN
declat FIXNUM
declsu FLATSIZE,flats,1
declss FLATSIZEC,fltsc,flatsc,1
declat FLONUM
declsu FNTH,fnth,2
declsy FREE,<object ty%int,free>
declat FSUBR
declat FUNARG
declsu FUNDEF,fundef,1
declsu GC,ugc,0
declsu GCD,gcd,2
declsu GCGAG,xgcgag,1
declsu GCLEFT,gcleft,0
declsu GCTIME,gctime,0
declva GCTRIGGER,nil
declsu GENSYM,gensym,0
declsu GET,xget,2
declsy GETBAR,<object ty%int,getbar>
declsu GETBARRAY,getbar,3
starsu GETSYM,getsym,1
declsu GTFDB,xgtfdb,2
declsu GETIARRAY,getiar,2
declsy GETINT,<object ty%int,getint>
declsu GETRARRAY,getrar,2
declsu GETL,getl,2
declsu GETVECTOR,getvec,2
declfs GO,go
starsu GREAT,greatp,2
declat HOOK1
declat HOOK2
declva %HOOKSTACK,nil
declva IBASE,<object ty%int,10.>
declat IN
declsv #%INDENT,indent,nil
declsu INITPROMPT,iniprm,1
declsu INITFN,initfn,1
declsu INTERN,intern,1
declat INUM
declsu INUMP,inump,1
declsu JFNS,xjfns,2
declat LABEL
declbn %LAMBDABIND,lb,5
declat LAMBDA
starsu LESS,lessp,2
declsu LENGTH,length,1
declsu LEXORDER,lexord,2
decssy %LEXPR-ENTRY,lexent,<object ty%int,lexent>
declsu LINELENGTH,lineln,1
declsu LINES,lines,1
declls LIST,dolist
declsu LIST1,list1,1
declsu LIST2,list2,2
declsu LIST3,list3,3
declsu LIST4,list4,4
declsu LIST5,list5,5
declsu LITATOM,litat,1
declsy %LITATOM,<object ty%int,litat>
declsu LOADREL,loadr,1
declsu LSH,lshf,2
declat LSUBR
declat MACRO
declfv MACROEXPANSION,mexp,mexp,%t
declsu MAKNAM,maknam,1
declsu MAKEARRAY,makary,1
declsu MAKECARRAY,makcar,1
declsu MAKEVECTOR,makvec,1
declfs MAP,mapnul
declfs MAPC,mapc
declfs MAPCAR,mapcar
declfs MAPCAN,mapcan
declfs MAPCON,mapcon
declfs MAPLIST,maplis
declsu METER,umeter,1
declsu MINUS,minus,1
declsu MINUSP,minusp,1
declsu MODCHR,modchr,2
declat MSUBR
declsu MYDIR,mydir,0
declsu MYUSER,myuser,0
declsy N,<object ty%int,n>
starsu NCONC,nconc,2
declls NCONC,unconc
declsu NCONS,ncons,1
declsy %NCONS,<object ty%int,ncons>
declat NEW
declat NEWVERSION
declsu NUMTYPE,numtyp,1
declsu NEXTEV,nextev,1
declsu NEXTF,nextf,1
declsy NIL1,<object ty%int,nil1>
declxs NOT,not,1,evnot
declsu NTHCHAR,nthchr,2
declxs NULL,not,1,evnot
declsu NUMBERP,nump,1
declsy O1,<object ty%int,o1>
declsy O2,<object ty%int,o2>
declsy O3,<object ty%int,o3>
declsy O4,<object ty%int,o4>
declsy O5,<object ty%int,o5>
declsy O6,<object ty%int,o6>
declva OBLIST,<object ty%ccn,<datsec,,obarr>>
declat OLD
declsu OPENF,xopenf,2
declfs OPENIN,xinput
declfs OPENOUT,xoutput
declxf OR,mor,evor
declat OUT
declsu OUTVAL,outval,2
declsy P,<object ty%int,p>
declsu PLIST,plist,1
starsu PLUS,plus,2
declat PNAME
declsu PRIN1,prin1,1
declsu PRINC,princ,1
declat %PRINFNTOP
declat PRINLEV
declss PRINT,prin,print,1
declat PRINTC
declfs PROG,prog
declfs PROGN,progn
declsu PROMPT,prompt,1
declsu PUTPROP,putp,3
declsy Q,<object ty%int,q>
declxf QUOTE,evalqu,evquot
starsu QUO,quot,2
starva RAISE,nil
declsu RDNAM,rdnam,0
declsu READ,read,0
declsu READCH,readch,0
declfs READCONTEXT,rdcntx
decssy %READCONTEXT,rdctx,<object ty%int,crdctx>
declsu READLIST,readls,1
declat READMACRO
declsu READP,readp,0
declsu REMAINDER,rem,2
declfs REMOB,remob
declsu REMPROP,remp,2
declsu RENAMEF,rename,3
declsu REREADCH,setrrd,1
declsy RETINT,<object ty%int,retint>
declsy RETREA,<object ty%int,retrea>
declsu RETURN,return,1
declsu RPLACA,rplaca,2
declsu RPLACD,rplacd,2
declsu RPLACPLIST,rplacp,2
starsu RSET,rset,1
declsu SASSOC,sassoc,3
declfs SAVEIMAGE,xsave
declsu SELECTIN,inc,2
declss SELECTOUT,outc,outc,2
declsu SET,set,2
declsu SETARG,lxsarg,2
declsy SETBAR,<object ty%int,setbar>
declsu SETBARRAY,setbar,4
declsu SETCHR,setchr,2
decssy %SET-BCP,setbcp,<object ty%int,setfsp>
declss %SET-FUNCTION-ENTRY,sftne,sftne,4
declsu SETIARRAY,setiar,3
declxf SETQ,setq,evsetq
declsu SETPOS,setpos,2
declsu SETRARRAY,setrar,3
declsu SETVECTOR,setvec,3
declfs SOME,some
declsy SP,<object ty%int,sp>
declsu SPDLFT,spdlft,1
declsu SPDLPT,spdlpt,0
declsu SPDLRT,spdlrt,1
declsu SPEAK,speak,0
declsu SPREDO,spredo,1
declsu SPREVAL,sprevl,2
declat SPLICEMACRO
declat SPRINT
declfs SSTEP,sstep
starsu STCONCAT,concat,2
declva %%STKLIM,nil
declsu STRINGP,strp,1
declsu STKPTR,stkptr,1
declsu SUB1,sub1,1
declat SUBR
declfs SUBSET,subset
declat SYM
declva T,%t
declsu TALK,talk,0
declsu TERPRI,terpri,1
declsu TIME,runtim,0
starsu TIMES,times,2
declss **TOP**,top,restar,0
declsu TTYECHO,ttecho,0
declsu TTYPAUSE,ttpaus,1
declsu TYI,tyi,0
declsu TYO,tyo,1
declbn %UNBIND,ub,5
declsu UNBOUND,unbnd,0
declsy %UNDEFLABEL,<object ty%int,udflab>
declsu UNTYI,xuntyi,1
declsu UPTIME,uptime,0
declsu VECTORBLT,vecblt,5
declsu VECTORLENGTH,veclen,1
declsu VECTORP,vecp,1
declat WILD
declfs WITHIN,within
decssy %WITHIN,wthin,<object ty%int,cwthin>
declfs WITHOUT,withou
decssy %WITHOUT,wthou,<object ty%int,cwthou>
declsy W2,<object ty%int,w2>
declsy W3,<object ty%int,w3>
declsy W4,<object ty%int,w4>
declsu XCONS,xcons,2
declsy %XCONS,<object ty%int,xcons>
declsu ZEROP,zerop,1
declat $EOF$
starva NOPOINT,%t
declsy NIL,<object ty%int,nil>

;now atoms for character mapping

chval==0

repeat 200,[
ifn chval-"T",[ifn chval-"N",[ifn chval-"Q",[ifn chval-"P",[declch chval]]]]
chval==chval+1]

obarr:

;now deposit the buckets here

define defbuk(#buk)
bk!buk
termin

repeat nbuck-1,[
defbuk .rpcnt
object ty%ccn,<datsec,,.+1>]

defbuk nbuck-1
nil

;array to go from integer character's to char atoms

define defchr(#chr)
ifn chr-"T",[ifn chr-"N",[ifn chr-"Q",[ifn chr-"P",[ch!chr]]]]
ife chr-"T",%T
ife chr-"N",%N
ife chr-"Q",%Q
ife chr-"P",%P
termin

chval==0

charar:	
repeat 200,[
defchr chval
chval==chval+1]


;everything below here is not on the oblist, but will be translated by the
;GC.  This is the place to put variables that you want the GC to look at.

;first we have a list of values used internally.  These are required to
;be atoms, but we don't want the user using them.  So we keep them off
;the OBLIST.

declat .UNBOUND

;;TY%ATM - the usefulness of this depends upon at%val=0.
;DECLFU for declaring funny things.  These are repositories for storing
;values that must be stacked and restored.  They differ from atoms only
;in that 

define declfu(obj,val)
%!obj=object ty%adr,<datsec,,.>
.!obj:	val
termin

declfu GOLIST,nil		;goto list for prog
declfu PRET,nil			;saved context to RETURN out of prog
declfu PNEXT,nil		;PC for prog interpreter
declfu PTOP,nil			;saved context in prog interpreter for GO
declfu TOPERR,nil		;saved context for ERRSET/ERR
declfu ERRFLAG,nil		;saved flag for ERRSET/ERR
declfu CURIN,nil		;current input channel
declfu CUROUT,nil		;current output channel
declfu DOINTERN,%t		;flag controlling whether READ calls INTERN
declfu SAVEP,nil		;used to flag saved P for eval blip
declfu LXVARS,nil		;addr of base of variables for LEXPR
declfu LXNUM,nil		;number of variables
declfu RDTOP,nil		;saved context for aborting READ
declfu CFILES,nil		;list of files to close
declfu GCGAG,nil		;print message at GC
declfu DEBIOK,%t		;OK to interrupt on ^E, ^Y, etc.
  ;cfiles contains alternate saved SP, channel.  The idea is that if
  ;SP is ever restored to less than the saved value, that channel
  ;should be closed, and the entry popped off CFILES.

;initfi is ("file"), i.e. arg for XINPUT, which is FEXPR
initfi:	object ty%cst,<datsec,,.+2>
	0
	object ty%spc,<infien-initfi-3>
	asciz /BOOT.INIT/
infien:

;(NIL (O1.(O1)) (O2.(O1 O2))  (O3.(O1 O2 O3)) ... O5)
;used in DOMAP

%maptab=object ty%ccn,<datsec,,.>
maptab:	nil
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt1>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt2>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt3>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt4>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt5>
	nil

mapt1:	%o1
	object ty%ccn,<datsec,,maptl1>

mapt2:	%o2
	object ty%ccn,<datsec,,maptl2>

mapt3:	%o3
	object ty%ccn,<datsec,,maptl3>

mapt4:	%o4
	object ty%ccn,<datsec,,maptl4>

mapt5:	%o5
	object ty%ccn,<datsec,,maptl5>

maptl1:	%o1
	nil

maptl2:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	nil

maptl3:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	nil

maptl4:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	object ty%ccn,<datsec,,.+1>
	%o4
	nil

maptl5:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	object ty%ccn,<datsec,,.+1>
	%o4
	object ty%ccn,<datsec,,.+1>
	%o5
	nil

tail==ch%666-5

;;TY%CHN
binchn:	object ty%spc,ch%666
	0
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

.binchn==<object ty%cch,<datsec,,binchn>>

;;TY%CHN
inchn:	object ty%spc,ch%666
	.priin
	72.
	72.
	codsec,,trmget
	codsec,,norput
	block tail

;;TY%CHN
outchn:	object ty%spc,ch%666
	.priou
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

;DUMCHN is a dummy channel for use by EXPLODE and similars.  Note
;that this makes all such routines non-reentrant.
;;TY%CHN
dumchn:	object ty%spc,ch%666
	0
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

oldopt:	%OLD
	object ty%ccn,<datsec,,.+1>
	%UEROR
	nil

.dumchn==<object ty%cch,<datsec,,dumchn>>

rsetf:	nil		;*rset value
initf:	nil		;init function
priin:	object ty%cch,<datsec,,inchn> ;initial value for curin
priout:	object ty%cch,<datsec,,outchn> ;initial value for curout

endobl:

	offset 0

	loc normal

	end start
    