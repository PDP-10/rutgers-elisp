;;-*-midas-*-
	title ELISP BOOT
	.symtab  8009.,8009.
	.decsav			;produce an .EXE file

.qmtch=1			;use "X" for characters instead of "X

	loc 140

smap%=jsys 767
xsir%=jsys 602
meter%=jsys 766
define xblt(ac,foo)
	extend ac,[020_27.] termin
define cmpsle(ac,foo)
	extend ac,[003_27. ? 0 ? 0] termin
define cmpse(ac,foo)
	extend ac,[002_27. ? 0 ? 0] termin

;This version of Lisp is supposed to be very modular.  Nobody is
;supposed to use any knowlege about the representations of anything
;without declaring it at the beginning of the page.  Nobody is
;supposed to refer to variables in other pages without declaring it.
;The following information is classified.  Those with a need to
;know will list "memory structure" at the top of their page.

;memory structure.  this is more complex than it should be because
;of the way the KL's pager works.  The original structure caused
;thrashing.  There are two constraints:
;  the page table is organized in 4-page groups.  All 4 pages
;	must be from the same section.  so if you have code in
;	page 1000 trying to refer to data in page 3000, there will
;	be thrashing, since these are page 0 from two different
;	sections.  Special tricks are used in the hardware to
;	protect from interference between user programs and the
;	monitor, and between odd and even section numbers.  to
;	make the protection against the monitor work, one should
;	avoid pages 300-377 and 700-777 in any even section.
;  in extended code, the PDL is not protected against overflow.
;	This means that there should be non-existent pages or
;	(better) sections around the stack, so that overflow is
;	caught.

;here are the sections.  However the stacks do not begin at the start
;of the section, but are staggered, to prevent interference.  The
;stack that grows the slowest is started first, so as to avoid the
;possibility of having two stacks cross each other and thus 
;interfere.  The offsets are shown below, where QSEC, etc., are
;defined.
;	1 - code
;       2 - EMACS
;       3 - LINK
;	4 - Q pdl (data)
;       5 - I/O buffers
;	6 - P pdl (control)
;	10 - evalstack
;	12 up - data space, 2 spaces of equal size used alternately

;Everything in Q is a legal Lisp "object".  The structure of objects
;will be described in a minute.  Basically, they are things with
;type codes, so that the GC can tell how to handle them.  There are
;no "protected AC's".  When you call CONS, or anything else that
;can cause a GC, all Lisp objects are supposed to be on Q, so that
;GC can find them.  GC starts by pushing OBLIST onto Q.

;Lisp objects take up a full word.  We intend to be able to use the
;full 30-bit address space of the DEC-20.  Thus an object consists
;of:
;  1 bit - zero, to indicate that this object (if it is an address)
;	is to be treated as global by the hardware (i.e. that it
;	is a 30-bit address, not an 18-bit one)
;  5 bits - a type code, types defined below
;  30 bits - the object itself.  Nobody is supposed to depend upon
;	the structure of a type of object without declaring it.
;	Every attempt is made to confine such knowlege to a few
;	pages.  The GC will, however, know at least whether something
;	is a pointer into list space or not.

;CHKQUO should be put after any JSYS that can cause quota exceeded.
; Note that it does not handle first-part-done properly, and should
; not be used (at least without fixing) after ILDB's, etc.  (If you
; need to fix it, the code is at MAPERR - however you might just
; as well use MAPERR itself in that case.  MAPERR differs by handling
; a few more cases, such as missing pages from read-only files.)
define chkquo
	ercal quochk	termin

addbts==7777777777	;address bits

define object(type,val)
  <.byte 6,30. ? type ? val> termin

define gettyp (x)
	ldb w2,[.bp 37_30.,x] termin

define getsiz(to,ob)
	ldb to,[.bp 007777777777,(ob)] termin

;;TY%NUM
;Numtyp is for differentiating types when we already know 
; something is a number.
define nmtype (x)
	ldb w2,[.bp 17_30.,x] termin

; check ob for number, then determine numerical type
define xnmtyp (x)
	tlnn x,200000
	 jrst notnum
	ldb w2,[.bp 16_30.,x] termin

; determine numerical type
define nmtypx (x)
	ldb w2,[.bp 16_30.,x] termin

define skpnum (x)
	tlnn x,200000 termin

;integer of any type
define skpint (x)
	camge x,[object ty%big,0] termin

define skpnnt (x)
	caml x,[object ty%big,0] termin

;;TY%ATM
define satom (x)
	tlne x,360000	;skip if atom or constant atom
	termin

define snatom (x)
	tlnn x,360000	;skip if not atom or constant atom
	termin

define scons (x)
	tlnn x,340000	;non-skip if higher than CONS
	tlnn x,020000	;skip if exactly CONS
	termin

define smcons (x)	;skip if a movable (i.e. not constant) CONS
	tlnn x,350000	;non-skip if higher than CONS, or constant
	tlnn x,020000	;skip if exactly CONS
	termin

define sncons(x)
	xtype x
	cain w2,ty%xcn	;skip if not cons or constant cons
	termin

define chcons(x)
	tlnn x,340000	;non-skip if higher than CONS
	tlnn x,020000	;skip if exactly CONS
	jrst notcns
	termin

define xtype (x)
	ldb w2,[.bp 36_30.,x] termin

;xtype is like gettyp but ignores the low order bit.

define xtypea (a,x)
	ldb a,[.bp 36_30.,x] termin

;here are the currently defined types.  Representations are described
;here.  This information is, however, classified.
;note that the atom has to be 0 so that NIL is taken as an atom
;any table that lists all type should by commented ;;TYPES

;Note that the types with constant equivalents should be defined so 
;that they form even/odd pairs.  This lets us ignore the low order
;bit to see if we have an atom when we don't care whether it is
;constant or not.

;;TYPES - note that code in several places depends upon the fact
;   that ty%atm and ty%xat are 0.  There are several dependencies 
;   on the typecode values of immediate numbers also.
;Warning:  compiled code uses the fact that atoms and constant
; atoms are 0 and 1, and that ac 1 always has 0 in it.  Thus we can
; do things like @[object ty%cat,foo].  Also, in compiled code
; when you want an indirect reference to an absolute address, you
; use @[object ty%iadr,addr], where TY%IADR is defined as the same
; as TY%CAT.  Only the GC will ever look at these references, and
; as far as the GC is concerned, TY%CAT and TY%ADR are the same, i.e.
; constants.  It would be better from a type point of view to use
; TY%ADR, but an indirect reference to such an object would end
; up being indexed by the AC whose number is the same as the code
; for TY%ADR.  TY%IADR is better because its code is 1, and AC 1
; always has a zero in it.
;The numeric types are the latter half of the table for easy
;manipulation of immediate numbers.  In particular, immediate
;integers are the last four types
ty%atm==0	;atom
ty%cat==1	;constant atom
  ty%xat==0	;some kind of atom
ty%iadr=1	;internal address, for use by LAP. You better not print this!
ty%con==2	;cons cell (two words)
ty%ccn==3	;constant cons cell
  ty%xcn==1	;some kind of cons
ty%str==4	;string (see below)
ty%cst==5	;constant cstring
  ty%xst==2	;some kind of string
ty%chn==6	;I/O channel
ty%cch==7	;constant I/O channel
  ty%xch==3	;some kind of channel
ty%eht==10	;EQ hash table  (GC causes rehash)
ty%oht==11	;other kinds of hash table
  ty%xht==4	;a hash table
ty%vec==12	;vector (starts with size as INUM)
		;type 13 currently undefined
ty%adr==14	;address (30 bit unsigned integer)
ty%spc==15	;beginning of a non-GC'ed block
ty%ary==16	;array (starts with size as TY%SPC)
ty%car==17	;constant array
  ty%xar==7	;some kind of array

ty%num==20	;the upper half is all the numbers
	;;types 21,27,31, and 33 are not defined
;the types are in reverse coercion precedence order, except
; for complex, which I don't really expect to implement.
; (I would have put them right too, but iflons must
; begin on a boundary = 2 mod 4).
  ty%xfl==10	;this is the offset into an "xtype" table for numbers
ty%flo==20	;long float
ty%cfl==21	;constant long float (ie, stack allocated)
;;ty%ifl	incant when you hack iflons
  ty%xif==11
ty%lnf==22	;low negative float (immediate 32 bit float)
ty%hnf==23	;high negative float
ty%lpf==24	;low positive float
ty%hpf==25	;high positive float
ty%crt==26	;constant ratios (stack allocated)
	;; type 26 is also the jsp in atom blocks
  ty%xrt==13
ty%rat==27	;ratios
ty%cpx==30	;complex (unimplemented)
  ty%xbg==15
ty%big==32	;bignum (arbitrary precision integer)
ty%cbg==33	;constant bignum (ie, stack allocated)
;;ty%int	incant when hacking inums
  ty%xni==16
ty%lni==34	;low negative integer (32 bit integer)
ty%hni==35	;high negative integer
  ty%xpi==17
ty%lpi==36	;low positive integer
ty%hpi==37	;high positive integer

;here is the structure of an atom:
;	value cell
;	ptr to property list (=cdr)
;	pname, a string pointer
;	function defn - lambda if expr or addr if subr
;	function evaluator for interpreter
;	address of function address block, or address of function
;Here is an explanation for how the dispatch in compiled code works:
;We want to be able to redefine functions.  Thus we can't do PUSHJ P,FOO.
;Instead we do PUSHJ P,@XXX, where XXX contains the current definition
;of FOO.  If FOO is compiled, this is just the address of FOO, else it is
;the address of a routine in the interpreter to interpret FOO.  In fact
;there is a three-word block, called a "function address block" associated
;with each function that is called from compiled code.  This block is
;constructed by %FUNCTION-ADDRESS-BLOCK.  Its most important field is
;the address of the function.  Calls to a compiled function are indirect
;off this word.  ALIAS makes sure to update it whenever you redefine
;a function.  In order to allow this, the atom contains a pointer to
;the function address block.  If no compiled code calls this function,
;there is no function address block, and the dispatch word in the atom
;contains the actual function address.  We can tell which because the
;address of the function address block is of type TY%LPI and the
;function address is TY%IADR.  The function address block must be in the
;same section as the code, which is why we can't just use a field in the
;atom itself.  Also, the function address block contains a pointer to
;the atom, which is used when an interpreter routine need to know what
;function it is calling.  Calls from compiled code are either
;  PUSHJ P,@function address block, word 1
;  JSP W3,@function address block, word 3
;These allow the interpreter to find the function address block, and
;hence the atom itself.  For a PUSHJ, we look at the top of P.  This gives
;the address of the PUSHJ.  Then we look at the PUSHJ instruction.  Its
;address field is the address of the function address block.  For the
;JSP we do the same with AC 3.  Note that JSP W3 is used wherever you would
;normally expect a JRST, i.e. for tail-recursion.  If it transfers directly
;to a compiled function, W3 is ignored.  If it calls the interpreter, the
;interpreter can use W3 to find the function being called.

at%val==0
at%pro==1
at%pna==2
at%fun==3
at%fev==4
at%dsp==5
at%siz==6	;size of block

;function address block:
fa%adr==0	;the address for indirect pushj's
fa%atm==1	;the atom
fa%adx==2	;the address for indirect JSP's.  This is normally the
		;same as FA%ADR, except that calls to the interpreter
		;have to use a special entry

;note that some of the property list code depends upon at%pro being 1
;the variables declared by DECLFU depend upon the fact that AT%VAL is
;0, but this can be changed by changing DECLFU.

;here is the structure of a string.  This is what is pointed to
; by a string pointer
;object(ty%spc,number of words following)
;asciz string

;AC usage is (unfortunately) known by everybody

p=17		;control stack
q=16		;data stack.
sp=15
n=14		;will be used for number of args passed
free=13		;start of free space

nil=0		;must always contain 0
nil1=1		;must always contain 0 except during jsys's

;The working AC's are separated into those that contain GC'able
;objects and those that don't.  This lets us know which to
;GC when we have to do that.  It also allows interrupt handling,
;since we know what is in each AC.

;AC's w2 to w4 must not contain legal Lisp objects, i.e. things
;that need not be GC'ed.  If they must be saved, they should be
;pushed onto P.  These must be first in order to allow jsys's
;to be called, since clearly the AC's used by jsys's can't in
;general be assumed to contain lisp objects.

;Wn may be assumed to be ACn.  These must include at least AC2,3,
;and 4, since these AC's are used for JSYS's.  

;There is no W1 because W1 is part of NIL.  To emphasize that fact,
;we call this NIL1.  This should remind you to zero it if you
;put anything in it.

w2=2
w3=3
w4=4

;AC's o1 to o6 must contain legal Lisp objects, i.e. things that
;GC can collect.  If they must be saved, they should be pushed
;onto Q

o1=5
o2=6
o3=7
o4=10
o5=11
o6=12		;used as a temp in macros - avoid using it yourself

;to call a routine, load the args into O1 to O6.  They must be legal
;Lisp objects, or the GC will get you.  Don't try to economize by
;passing a bare number - set the type code, please. there are macros to
;go from numbers to objects and visa versa, just so you don't have to
;know the numerical representation.  We will, however, tell you
;that the representation for integers is efficient enough that these
;macros are not expensive.  values are returned in O1.

;In general you should assume that calling a routine garbages all
;the working AC's, i.e. Ox and Wx.  The exceptions are the macros
;for CAR, CDR, RPLACA, RPLACD, and CONS, which touch only those
;AC's that they are defined as touching.

call=pushj p,
ret=popj p,

define makerr (*str)
[object ty%adr,[asciz |str|]] termin

define err(*str)
	move o1,makerr /str/
	jrst error
	termin

define perr(*str)
	move o6,makerr /str/
	jrst perror
	termin


;save/restart - produce pseudo-.EXE file and bootstrap the system from one

;this code is needed because the save and get jsae do not work for extended
;sections.  Thus we write an .EXE file with two parts - a normal .EXE
;file containing only the following bootstrap, and then extra pages
;containing the real program.  the version of Lisp that the user runs is
;actually one of these files, since it is produced by loading a default
;environment and then saving the result.  The bootstrap code should
;be the first code in the core image, as only page 0 from the core image
;is mapped out in the "normal" part of the .EXE file.

;Here is the format of the pseudo-.EXE file:

;page 0 is a normal .EXE directory

;1776,,3
;300000,,1    [file page]
;0	      [process page]
;1775,,3
;3            [# words in entry vector]
;bootst
;1777,,1

;page 1 is a directory for the real program, in the format of an .EXE
;file.  (This allows us to use the same routines to read both)

;1776,,11
;300000,,file page		;for codesec,,0  to codesec,,bpsend-1
;nnn000,,process page		;nnn is repeat count
;  ditto for datsec,,datoff to hipags-1
;  ditto for stthis to free
;  ditto for SP
;1777,,1


;page 2 is a copy of page 0 of the core image - the bootstrap loader
;This is all that the GET jsys will see


;pages 3 to N are the data for the real program


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   SECTION creation code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;common routine for creating all the sections.  See the following
;page for documentation of the program structure.

sects:	movei w2,qsec
	call maksec
	 jrst secfai
	movei w2,bufsec
	call maksec
	 jrst secfai
	movei w2,psec
	call maksec
	 jrst secfai
	movei w2,spsec
	call maksec
	 jrst secfai
	movei w4,datsiz		;loop on data sections
	movei o1,datsec		;first such section
datlop:	move w2,o1
	call maksec
	 jrst secfai		;ran out of sections
	addi o1,1
	sojg w4,datlop
	movei w4,datsiz		;now same for second set of sections
	movei o1,datsc2
datlp2:	move w2,o1
	call maksec
	 jrst secfai
	addi o1,1
	sojg w4,datlp2
	movei w2,codsec		;now the code
	call maksec
	 jrst secfai
	ret

;maksec - create a section.
;  w2 - section number to make.  
; skip return if it works
maksec:
  ;create the section
	setz nil1,
	hrli w2,.fhslf
	move w3,[pm%cnt\pm%rwx\1]
	smap%
	 erjmp cpopj
	aos (p)
cpopj:	ret

secfai:	hrroi nil1,[asciz / Can't create section
/]
	esout
	haltf
	jrst .-1

tmpsts==10
	.vector tmpstk(tmpsts)

exeerr:	hrroi nil1,[asciz / Bad .EXE file
/]
	esout
	haltf
	jrst .-1

badfil:	hrroi nil1,[asciz / Problems reading .EXE file - you must run this program from disk, 
  and must not change the core image before starting it.
/]
	esout
	haltf
	jrst .-1

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;   BOOT
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;This code is all that is loaded into memory when you first run a saved
;core image.  Its responsibility is to load the rest of the file.
;One of the trickier things is to find out what file it is.  We do
;this by doing RMAP, which gives you the JFN that is mapped into page
;0.  That should be the file.  Note that the JSYS manual specifically
;prohibits this code.  However it should work if we are running from
;disk.

;O2 is global to this section, and contains the JFN of the file.

bootst:	reset
	move nil1,[.fhslf,,0]		;see who we are mapped to
	rmap				;nil1 - jfn,,file page
	hlrz o2,nil1			;save in o2
	caige o2,100			;see if valid jfn
	caig o2,0
	jrst badfil
	move p,[-tmpsts,,tmpstk-1]
;create sections
	call sects
;now read the rest of the code from our pseudo-EXE file.  We do
;this in sections.  Each section corresponds to a 2-word entry
;in the directory, and describes a set of contiguous pages.
;We first read the 2-word entry and then pmap in the pages
;that it describes.
  ;get to the directory and validate it.
	hrrz nil1,o2			;get to directory page
	movei w2,1000			;start of page
	sfptr
	 erjmp badfil
	bin				;should be 1776,,n
	hrrz w4,w2			;isolate count
	hlrz w2,w2			;make sure it is kosher
	caie w2,1776
	jrst exeerr			;illegal structure
	subi w4,1			;w4 - number of entries
	lsh w4,-1
  ;pmap in the data, one piece at a time
    ;get data for one chunk from directory
bootlp:	hrrz nil1,o2			;jfn
	bin
	push p,w2			;(p) - 300000,,file page
	bin				;w2 - rpt000,,process page
    ;pmap it in
	pop p,nil1			;jfn,,file page
	hrl nil1,o2
	ldb w3,[.bp 777000000000,w2]	;bits,,count
	addi w3,1			;.EXE file has odd defn of count
	hrli w3,(pm%cnt\pm%rd\pm%ex\pm%cpy)
	hrli w2,.fhslf			;.fhslf,,process page
	pmap
	sojg w4,bootlp			;again if there are more
  ;end loop when get to end of directory
;finally, ddt.  We map the pages that contain ddt from section 0 to
;section 1, so if the user does the DDT command it shows up in
;section 1, which is after all where it is most useful.
	move nil1,[.fhslf,,ddtpag] ;and the upper 1/4 to codsec (for DDT)
	move w2,[.fhslf,,codsec*1000+ddtpag]
	move w3,[pm%cnt\pm%rd\pm%cpy\ddtsiz]
	pmap
;reset so restart gets us to new context
	movei nil1,.fhslf
	move w2,[3,,evec]
	sevec
;and go to permanent Lisp context
	move q,[baseq-1]
	move p,[basep-1]
	xjrstf [0
		codsec,,.+1]
	move w2,[jfcl]
	movem w2,evhook
	move free,freesv'
;At the moment, section zero contains just one page, the bootstrap.
;We would like the whole thing, since it contains DDT symbols (which
;DDT stubbornly refuses to take from section 1.  Also the entry
;vectors, DDTST, and other randomness.  In order to save swap space,
;we want to map this all from the file.  This works because we
;guarantee that sections zero and one are the same.  Note that we
;don't bother to map BPS into section 0
	move nil1,[.fhslf,,1000]		;get ident for section 1
	rmap
	move w2,[.fhslf,,0]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	hrrz w4,bpsend				;first address beyond end
	subi w4,1				;last used
	lsh w4,-9.				;last page
	addi w4,1				;number of pages
	hrr w3,w4
  ;The obvious thing is to just do the pmap we just set up.  Alas,
  ;the destination page is 0.  when you do this in section 1, page 0
  ;is interpreted as page 0 in the current section.  we have to go
  ;back to section 0 in order to get this page number interpreted right.
        xjrstf [0
	        0,,.+1]
	pmap
	xjrstf [0
	        codsec,,.+1]
  ;and finish init
	setzb nil,nil1
	setzb o1,o2
	setzb o3,o4
	call limstk		;set up stack limits
	call ioinit		;set up I/O system
	setzm edfork		;no editor there now
	setzm lnkfrk		;nor LINK
	setzm @[datsec,,.CFILE]	;no open files
	move sp,bootsp		;unbind from here
	move w2,[basesp-1]	;down to here
	call unbin1
	jrst toplev		;start top

;make sure everything needed above is on this page

	.scalar bpsbeg,bpsend,bootsp

	consta

	variab


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  SAVE
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Here is the save code
;the following AC's are global to this whole section.  The rest are temps.
;  O1 - channel object for file
;  W4 - last disk page written

;(save "filename") - save the core image
;o1 - string or atom for file name
xsave:	
;open and set up file
	call xoutpu		;o1 - channel object for file
  ;the only AC that will be needed for booting is FREE.  Note that this
  ;is being saved in section 1, not section 0.
	movem free,freesv	;save free for BOOT
	movem sp,bootsp		;and SP for unbinding after BOOT
	hrrz nil1,ch%jfn(o1)	;xoutpu openned for 7 bits, change to 36
	movei w2,36.
	sfbsz
	 erjmp [setz nil1,
		err /Can't set byte size to 36/]
;write out bootstrap directory and data
	movei w4,1		;pages 0 and 1 are used (for directory)
	call dirhd6		;type 6 header (page directory)
	movei w2,0		;process 0
	movei w3,1		;count 1
	call diren6		;type 6 entry
	call dirtr6		;type 6 trailer
	movei w2,3		;vector length 3
	movei w3,bootst		;vector location
	call dir5		;type 5 (entry vector)
	call dir7		;type 7 (end block)
;write out actual data directory and data
  ;get to directory page
	hrrz nil1,ch%jfn(o1)	;now go to second (kludgo) directory
	movei w2,1000		;page 1
	sfptr
	 erjmp [setz nil1,
		err /Can't set file pointer to page 2/]
  ;header
	call dirhd6		;type 6 header
  ;the code
	movei w2,codsec*1000	;process page
	hrrz w3,bpsend		;number of pages - this is first address above
	subi w3,1		;last addr used
	lsh w3,-9.		;last page used
	addi w3,1		;number of pages
	call diren6		;type 6 entry for code
  ;constant data area.  This is the start of the first free space,
  ;and contains the initial OBLIST and its friends.
	movei w2,datsec*1000+datoff ;process page
	move w3,hipags		;number of pages
	call diren6		;type 6 entry for constant data
  ;the currently active free space.  Only the part with data in
  ;it is saved.
	move w2,stthis		;now copy currently active free space - start
	lsh w2,-9.		;convert to page - first page
	move w3,free		;last addr
	lsh w3,-9.		;convert to page - last page
	sub w3,w2
	addi w3,1		;page count
	call diren6		;type 6 entry for free space
  ;currently active SP
	move w2,[basesp/1000]	;first page of SP
	move w3,sp		;last addr
	lsh w3,-9.		;convert to page - last page
	sub w3,w2
	addi w3,1		;page count
	call diren6		;type 6 entry for SP
	call dirtr6		;type 6 trailer
  ;close things off
	call dir7		;end
	move w2,[444440,,0]
	movem w2,ch%bpt(o1)	;say 36 bit bytes
	addi w4,1		;go to base 1 count
	imuli w4,512.		;convert pages to bytes
	movem w4,ch%lby(o1)	;and say we have this many pages
	call xclose		;close file
	move o1,nil
	ret

;routines for writing .EXE files - w4 is an implict arg to all these
;routines.  It is the last file page that has been written.

;type 6 - the actual data.  The structure of this is
;  1776,,length
;  pairs of data
;To do this, first call DIRHD6 once to leave space for the header
;DIREN6 once for each entry, to make the pairs  (actually if the count
;	is .GT. 1000, one call may make more than one pair)
;DIRTR6 once at the end to go back and fill in the count in the header
	
;dirhd6 - header for directory entry
dirhd6:	hrlzi w2,1776		;make 1776,,length - length filled in later
	hrrz nil1,ch%jfn(o1)	;to output
	bout
	rfptr			;find out where we are
	 jrst poserr
	subi w2,1
	movem w2,dirst6'	;save as start of directory
	ret

poserr:	err /Can't use random access on file/

;diren6 - entry for directory entry - process page in w2, count in w3
;This routine allows counts .GT. 1000, calling DIR6DO several times in
;that case.
diren6:	caig w3,1000		;1000 is the maximum count we can have
	jrst dir6do		;.LE. 1000, OK
	push p,w2		;save for next time
	push p,w3
	movei w3,1000		;do the first 1000 pages
	call dir6do
	pop p,w3
	pop p,w2
	subi w3,1000		;now have 1000 pages fewer to do
	addi w2,1000		;starting 1000 pages later
	jrst diren6		;so try again

;dir6do - this routine does an actual type 6 entry - proc pag in w2, count w3
dir6do:	push p,w2		;-1(p) - process page
	push p,w3		;(p) - count of pages
;first put dir entry to dir area
	hrrz nil1,ch%jfn(o1)
	move w2,w4		;300000,,file page
	addi w2,1		;use first page after last used
	hrli w2,300000
	bout			;put to file
	move w2,(p)		;rpt000,,process page
	subi w2,1		;DEC's rpt count is count-1
	lsh w2,27.		;in bits xxx000,,000000
	hrr w2,-1(p)		;saved process page
	bout			;put to file
;now actual data pages - uses page BUFPAG as a buffer
dir6lp:	sosge (p)		;any more left?
	jrst dir6ex		;no - done
	addi w4,1		;next disk page
	hrl nil1,ch%jfn(o1)	;file jfn,,file page
	hrr nil1,w4
	move w2,[.fhslf,,bufpag]	;to buffer page
	move w3,[pm%rd\pm%wr]	;we want to write it (obviously)
	pmap			;now we have mapping to file
	movei nil1,1000		;next we copy a page to the buffer - 1000 wds
	move w2,-1(p)		;this page
	lsh w2,9.		;but we want address
	move w3,[bufpag*1000]	;to buffer
	xblt nil1,
	aos -1(p)		;advance process page
	jrst dir6lp		;and try again
dir6ex:	adjsp p,-2		;get rid of saved args
	seto nil1,		;and unmap buffer page
	move w2,[.fhslf,,bufpag]
	setz w3,
	pmap
	ret			;and return

;dirtr6 - trailer for directory entry.  Must fill in length part of header
dirtr6:	hrrz nil1,ch%jfn(o1)	;jfn of file
	rfptr			;current pos in w2
	 jrst poserr
	move w3,dirst6		;start of block
	movem w2,dirst6		;save current pos
	sub w2,w3		;subtract start, for length
	hrli w2,1776		;1776,,length
	rout			;put out the header at start pos
	move w2,dirst6		;get back end position
	sfptr			;and go back there
	 jrst poserr
	ret

;dir5 - entry vector - length in w2, address in w3
dir5:	push p,w2
	hrrz nil1,ch%jfn(o1)	;jfn of file
	move w2,[1775,,3]	;entry header
	bout
	pop p,w2		;length
	bout
	move w2,w3
	bout
	ret
	
;dir7 - end - no args
dir7:	hrrz nil1,ch%jfn(o1)	;jfn of file
	move w2,[1777,,1]
	bout
	ret


;startup - sets up memory structure.

;this routine knows about memory structure.
;anyone who wants initialization done should write a routine and
;	put a call to it here.

;memory structure is documented at the beginning of the program.
;anyone changing these declarations should change those comments.

;locals:

;section definitions.
codsec==1		;code
edsec==2		;EMACS subfork
lnksec==3		;LINK subfork
qsec==4			;section for Q stack
 baseq=qsec,,40000	;start of Q pdl, used in GC
 endq=qsec,,740000	;leave a bit of space for debugger in case of PDL over
 endqs=qsec+1,,0	;real end of section
bufsec==5		;I/O buffers
 bufill=bufsec,,0	;illegal page to stop Q stack
 bufst=bufsec,,400000	;first buffer
 bufend=bufsec+1,,0	;end of buffers
psec==6			;section for P stack
 basep=psec,,20		;ERCAL gets confused if this is between ,,0 and ,,17
			;also, until that bug is fixed, the stack can't cross
			;a section boundary.
 endp=psec,,740000
 endps=psec+1,,0
spsec==10		;section for SP stack
 basesp=spsec,,20000
 endsp=spsec,,740000
 endsps=spsec+1,,0
bufpag==10000		;page for use in SAVE command.  Any free page will do

datsiz==11		;maximum number of sections in each data space
	;this number should be odd, in order that both data spaces start
	;in sections of the same parity.  This is important for performance
	;reasons.
datsec==12		;first section in first data space
datoff==400		;page within section where first data space starts
datsc2==datsec+datsiz+1	;first section in second data space
datof2==600		;page within section where secnd data space starts

ddtpag==760		;start of ddt
ddtsiz==20		;number of pages in ddt

evec:	xjrstf [0
		codsec,,rstart]
	xjrstf [0
		codsec,,rstart]
	1,,0

ddtst:	xjrstf [0
		codsec,,770000]

calddt:	skipe @770001
	jrst caldd1
;no DDT yet - get it
	move nil1,[gj%old+gj%sht]  ;look up the file
	hrroi w2,[asciz /sys:uddt.exe/]
	gtjfn
	 jrst [err /Can't find SYS:UDDT.EXE/]
	push p,nil1		;save jfn
	movei nil1,.fhslf
	gevec			;get entry vector, since GET will change it
	move nil1,(p)		;now get back JFN
	movem w2,(p)		;and save entry vector
	hrli nil1,.fhslf
	get
	 erjmp [err /Can't get SYS:UDDT.EXE/]
	movei nil1,.fhslf	;put back entry vector
	pop p,w2
	sevec
	setz nil1,
	move w2,@[116]		;get symbol pointer
	hrrz w3,770001		;get addr of symbol table in DDT, sec. 0
	movem w2,(w3)		;now put symbol pointer in symbol table
caldd1:	call 770000
	jrst retnil

start:	reset
	move p,[-tmpsts,,tmpstk-1]
;Most of the following code is used to get us into our final
;sections.  there is no way to get Midas or Link to load
;code directly into a non-zero section, but we must be there
;or global addressing won't work.  To get into a non-zero
;section, you must
;  1) use SMAP% to create the section
;  2) PMAP code there from an existing place
;  3) use XJRSTF to get there.  XJRSTF is the only instruction
;	that you can use to get from section zero to a non-zero
;	section.
  ;write out ELISP.REL, with symbols in it
	call wrirel
  ;create sections
	call sects		;routine also used by BOOT code
;now we move things into these sections we just created.  Things go
;faster when a page is not mapped, so we first map them copy on
;write, and then do a MOVES on each page to make them private.
;this may be superstition.  You should see whether it seems to help.
;There is some evidence that the tests we used to evaluate this
;strategy were wrong.  If so, turn on PM%WR instead of PM%CPY, and
;omit the code that does MOVES on each page.

;low section - code. This is from 0 to then end of the symbol table.
	hrrz w4,116		;.jbsym - symbol table
	hlre o1,116		;negative length
	movn o1,o1		;positive length
	add w4,o1		;w4 is now first loc after sym tab
	subi w4,1		;need last used
  ;construct entry for list of symbol tables
	push w4,[0]		;end of list
	hrli w4,codsec		;put in section number
	movem w4,symlst		;first entry in list of symbol tables
	push w4,116		;AOBJN word for this table
	hrli w4,codsec		;put in section number
	addi w4,1		;first beyond
	movem w4,bpsbeg		;save as start and end of BPS
	movem w4,bpsend		;
	tlz w4,777777		;get back to local addressing
	subi w4,1		;w4 is now last loc used
	lsh w4,-9.		;w4 is now last page used
	addi w4,1		;w4 is now number of pages used
	movem w4,lopags'	;save for later
	move nil1,[.fhslf,,0]	;pmap lower half of our sec 0 to codsec
	move w2,[.fhslf,,codsec*1000]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	ior w3,w4		;or in count
	pmap
;now high section (oblist) to data.  This is from 400000 to ENDOBL
	movei w4,endobl		;now number of pages in oblist
	subi w4,datoff*1000	;starts here
	subi w4,1		;just like above
	lsh w4,-9.
	addi w4,1
	movem w4,hipags'	;save for later
	move nil1,[.fhslf,,datoff] ;the oblist to datsec
	move w2,[.fhslf,,datsec*1000+datoff]
	move w3,[pm%cnt\pm%rd\pm%cpy]
	ior w3,w4
	pmap
;finally, ddt
	move nil1,[.fhslf,,ddtpag] ;and the upper 1/4 to codsec (for DDT)
	move w2,[.fhslf,,codsec*1000+ddtpag]
	move w3,[pm%cnt\pm%rd\pm%cpy\ddtsiz]
	pmap
  ;reset so restart gets us to new context
	movei nil1,.fhslf
	move w2,[3,,evec]
	sevec
  ;also so DDT gets the right DDT
	movei w2,ddtst
	skipe 770000			;if we have ddt
	movem w2,74			;make jbddt point to extended ddt
	xjrstf [0
		codsec,,.+1]
  ;and go to permanent Lisp context
	move q,[baseq-1]
	move p,[basep-1]
	move sp,[basesp-1]
	move w2,[jfcl]
	movem w2,evhook
  ;now make all the pages private
    ;code
	move w2,[codsec,,20]		;first in code pages
	move w3,lopags			;number of pages
	moves (w2)			;make private
	addi w2,1000			;next page
	sojg w3,.-2			;loop for all pages
   ;data
	move w2,[datsec,,datoff*1000+20] ;same for data
	move w3,hipags
	moves (w2)
	addi w2,1000
	sojg w3,.-2
  ;if ddt is here, start it
	skipn 770000
	jrst noddt
	movei w2,ddtst
	movem w2,74
	hrroi nil1,[asciz /
Type DDTRET$G to return
/]
	psout
	xjrstf [0
		codsec,,770000]
ddtret:	xjrstf [0
		codsec,,noddt]
  ;now do initialization for various pieces of code that need it
noddt:	setzb nil,nil1
	setzb o1,o2
	setzb o3,o4
	call limstk		;set up stack limits
	call ioinit		;set up I/O system
	push q,[datsec,,datoff*1000]
	push q,[datsec,,endobl]
	push q,[datsec+datsiz,,0]
	push q,[datsc2,,datof2*1000]
	push q,[datsc2+datsiz,,0]
	call gcinit
	jrst topst		;start top

;WRIREL - write out ELISP.REL, with all of our symbols in it, for use
;  by the LINK interface.
wrirel:	movsi nil1,(gj%fou+gj%sht) ;new version
	hrroi w2,[asciz /ELISP.REL/]
	gtjfn
	 erjmp wrirer
	movem nil1,n			;save JFN in N
	move w2,[<44_30.>\of%wr]	;open binary
	openf
	 erjmp wrirer
 ;NAME block
	move w2,[6,,1]
	bout
	movei w2,0
	bout
	move w2,[.rsqz 0,ELISP]
	bout
 ;SYMBOL block
	hlre w2,116		;get count, negative
	movn w2,w2		;make positive
	subi w2,2		;leave out the program name
	hrli w2,2		;block type 2
	bout
	move w3,116		;W3 - AOBJN word for symbols
	add w3,[2,,0]		;leave out the program name
	setz w4,		;W4 - counter for every 22 words
  ;main loop - here to output another symbol if there is one left
wrirl:	sojg w4,wrirn		;if W4 non-zero, normal case
  ;W4 exhausted, time for a relocation word
	movei w2,0		;none relocatable
	bout
	movei w4,11		;reinit W4 for 11 symbols (22 words)
  ;normal symbol output
wrirn:	move w2,(w3)		;get symbol
	hlrz o1,w2		;O1 - LH of symbol
	hlrz o2,1(w3)		;O2 - LH of value
	trz o1,740000		;clear flags in symbol
	caie o1,014772		;symbol = G00xxx
	cain o2,(object ty%ccn,<datsec,,0>) ;dummy symbol inside atom
	jrst wrirn1		;leave local
	tlne w2,040000		;already global or PNAME?
	jrst wrirn1		;yes - leave it alone
	tlne w2,100000		;local?
	tlc w2,140000		;yes - make global
wrirn1:	bout			;output it
	aobjp w3,wrire		;go to next
	move w2,(w3)		;get value
	bout			;put it out
	aobjn w3,wrirl
  ;done with symbols
wrire:		
 ;END block
	move w2,[5,,2]
	bout
	movei w2,0
	bout
	bout
	bout
 ;now finished
	closf
	 erjmp .+1
	setz nil1,
	setzb o1,o2
	ret

wrirer:	hrroi nil1,[asciz /Can't open ELISP.REL/]
	esout
	setz nil1,
	setzb o1,o2
	ret

;forward decls - these belong on the page with CAR and CDR
define docar(x,y)
	move x,(y)
	termin

define pushcar(x,y)
	push x,(y)
	termin
	
define docdr(x,y)
	move x,1(y)
	termin

define pushcdr(x,y)
	push x,1(y)
	termin

define doboth(x,y)
	dmove x,(y)
	termin

;;TY%CON
define dorpd(x,y)
	movem y,1(x)
	termin

;;TY%CON
define docons(x,y,z)
	caml free,lastl		;make sure there is space
	 call sgc		;special version of GC that saves AC's
	push free,y		;and set car and cdr
	move x,free		;return next free
	tlo x,(object(ty%con,0)) ;as cons cell
	push free,z
	termin

;;TY%ATM
define bind(x,y)		;bind x to y using z as temp
	jumpe x,illreb		;check for NIL and T
	came x,[%T]
	satom x			;and make sure it is an atom
	jrst illreb
	push sp,x		;save old value
	push sp,at%val(x)
	setval x,y
	termin

;FASBIND is used in fast EVAL, where ALIAS has validated the formals
;when the function was defined.
;;TY%ATM
define fasbind(x,y)
	push sp,x
	push sp,at%val(x)
	setval x,y
	termin

;;TY%ATM
define setval(atom,value)
	movem value,at%val(atom)
	termin

;;TY%INT

inum0==object(ty%lpi,0)

define inum (n)
<n>+inum0 termin

define posnum(ac)
	tlz ac,760000 termin

define negnum(ac)
	tlo ac,760000 termin

define getnum(ac)
	sub ac,[inum0]
	termin

; skip if ac an inum
define skpin (ac)
	camge ac,[object ty%lni,0] termin
; -- not an inum
define skpnin (ac)
	caml ac,[object ty%lni,0] termin



;;TY%INT
; make a bare number into an inum
define maknum(ac)
	add ac,[inum0]
	termin

;;TY%IFL
; make a bare floating point number into an iflon
define makifl(ac)
	ash ac,-4
	tloe ac,240000
	 tlz ac,540000
	termin

define iflon(num)
	<num/20+<240000,,0>> termin

;;TY%STR
define makstr &str&
	object ty%cst,<codsec,,[object ty%spc,.length str
				asciz str]>
	termin

;I/O - TYI and TYO
;knows about representation of TY%CHN, and characters.  This should be the
;only page (except for the GC, to some extent) that knows about
;channels.  The string stuff will probably have to know about char's.
;Anyone else wanting to convert from char objects to char's should use
;the macros GETCHR and MAKCHR.

;locals to this page: 

;variables for terminal I/O:
trmbfs==100.	;size of buffer
	.vector trmbuf(trmbfs)	;terminal input buffer
	.scalar trmcnt		;number of char's available
	.scalar trmpnt		;ILDB pointer to next char
	.scalar trmlka,trmlst	;lookahead for untyi

;macros for people to convert between char objects and characters

;GETCHR(AC) - convert char object in AC to ASCII character
define getchr(ac)
	tlz ac,770000		;clear type code
  termin

;MAKCHR(AC) - convert ASCII char in AC to char object
define makchr(ac)
	tlo ac,(object(ty%lpi,0)) ;and make char
  termin

;MAKDIG(AC) - convert numeric value in AC to ASCII char for the digit
define makdig(ac)
	caile ac,9.
	 addi ac,"A"-"9"-1
	add ac,[inum "0"] ;and make char
  termin

;CHAR(ch) - a character object with this code
define char(ch)
	object(ty%lpi,ch) termin

;Channels have the following form:
;	jfn
;	line length
;	char's left on the line
ch%spc==0	;code for gc - may be ch%666 or ch%666-1 depending upon
		;whether the data in ch%dat is GC'able or not
ch%jfn==1	;these are bare numbers
ch%len==2
ch%pos==3
ch%get==4	;routine for tyi
ch%put==5	;routine for physical put
ch%lka==6	;lookahead character in case we backed up
ch%lst==7	;last char read for untyi
ch%dsp==10	;dispatch for less-used routines
 ch%cps==0		;curpos
 ch%sps==1		;setpos
 ch%clo==2		;close
ch%buf==11	;address of window
ch%pag==12	;file page mapped to window
ch%bpt==13	;byte pointer
 ;two-word byte pointer
ch%bct==15	;byte count
ch%bfs==16	;bytes per window
ch%cby==17	;current byte in file
ch%lby==20	;last byte in file
ch%lts==21	;line number test word
ch%pgs==22	;bytes per page
 ch%obl==22		;alternate defn for string output channels
ch%dat==23	;mode-dependent data
ch%666==23	;last entry

winpgs==4	;size of window in pages

;;TY%ATM
;;TY%CHR
;CHRVAL - octal for char atom
;O1 - char atom or string
chrval:	call getstr
	move w3,o1
	tlz w3,770000		;clear type code
	hrlzi w2,010740		;w2,w3 are extended BP
	ildb w2,w2
	maknum w2
	move o1,w2
	ret

;MODCHR - change read table
;O1 - char to modify; O2 - new value if non-nil
modchr:	gettyp o1
	caie w2,ty%lpi		;better be a low positive integer
	jrst illasc
	move w3,o1
	posnum w3
	caile w3,177
	jrst illasc
	move w2,rdtab(w3)	;get old read table entry
	jumpe o2,ret1nt		;done unless new value
	push p,w3		;save char index
	move o1,o2
	call get1nt		;get integer value to w2
	pop p,w3
	exch w2,rdtab(w3)	;save numerical value, get old
	jrst ret1nt		;return old

;SETCHR - change read table, only read macro part (first 2 bits)
;O1 - char to modify; O2 - new value if non-nil
setchr:	push q,o2
	call chrval		;get integer to o1
	pop q,o2
	ldb w2,[.bp 700000000000,rdtab(o1)] ;get old read table entry
	jumpe o2,ret1nt		;done unless new value
	push p,w2		;save old value
	exch o1,o2		;save char index
	call get1nt		;get integer value to w2
	dpb w2,[.bp 700000000000,rdtab(o2)] ;set new value
	pop p,w2
	jrst ret1nt		;return old

;;TY%CHR
;ASCII - char atom for octal code
mascii:	gettyp o1
	caie w2,ty%lpi		;better be a low pos integer
	jrst illasc
	move w2,o1
	posnum w2
	caile w2,177
	jrst illasc
	move o1,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	ret

illasc:	perr /Arg to ASCII must be integer from 0 to 127./

;;TY%CHN
lineln:	move o2,@[datsec,,.curout] ;output channel
	jumpe o1,getlln		;new value: none, wants to see current
	camge o1,[inum0]	;use 0 for neg numbers
	 move o1,[inum0]
	camg o1,[inum 8]	;is new value valid?
	 camn o1,[inum0]	;special case
	  skipa
	   jrst lenerr		;no
	move w3,o1
	getnum w3		;get internal integer
	movem w3,ch%len(o2)	;new line len
	move w2,ch%jfn(o2)
	caie w2,.priou		;on tty only...
	 ret
	move nil1,w2		;really set linelength
	movei w2,.moslw
	mtopr
	setz nil1,
	ret

getlln:	move w3,ch%len(o2)	;current length
	maknum w3
	move o1,w3		;return it
	ret

lenerr:	perr /LINELENGTH must be > 8 or =< 0/

;;TY%CHN
chrct:	move o1,@[datsec,,.curout] ;output channel
	move w2,ch%len(o1)
	jumpe w2,chrcti		;if length negative, return +INF
	sub w2,ch%pos(o1)
	jrst ret1nt

chrcti:	move o1,[inum 17777777777]	;return highest inum
	ret

;;TY%CHN
chrpos:	move o1,@[datsec,,.curout] ;output channel
	move w2,ch%pos(o1)
	addi w2,1
	jrst ret1nt

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  STRING stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;ISTLEN - internal string length
;O1 - Lisp string object
;returns in W4 the length of the string
;Garbages W2 and W3, preserves all Lisp AC's
istlen:	move w4,(o1)		;length in words
	tlz w4,770000		;minus type code
	subi w4,1		;w4 - full words
	xmovei w3,(o1)		;address before string
	add w3,w4		;w3 - word before last
	imuli w4,5		;w4 - chars due to full words
	move w2,[010740,,0]	;w2/3 - byte pointer to last word
istln2:	ildb nil1,w2
	jumpe nil1,cpopj	;now count chars in that word
	aoja w4,istln2

;GETSTR - Lisp object of unknown type in O1
;If string, OK
;If atom, get pname to O1
;Else error
;Preserves AC's above O1
getstr:	jumpe o1,[move o1,@[datsec,,.nil+at%pna]
		  ret]
	xtype o1
	cain w2,ty%xat
	jrst [move o1,at%pna(o1)
	      ret]
	cain w2,ty%xst
	ret
	perr /Not string or atom/

;NTHCHAR - returns char object
; O1 - string
; O2 - place in string
nthchr:	call getnth		;internal NTHCHR, gets char to w4
	jumpl w4,retnil		;if failed, give NIL
	move o1,@[<w4_30.>\<datsec,,charar>] ;get atom for this char
	ret

;ANTHCHAR - like NTHCHAR, but returns INUM
; O1 - string
; O2 - place in string
anthch:	call getnth		;internal NTHCHR, gets char to w4
	jumpl w4,retnil		;if failed, give NIL
	maknum w4
	move o1,w4
	ret

;TY%STR
;TY%ATM
;TY%SPC
;Internal NTH CHAR - returns char itself in W4
; O1 - string
; O2 - place in string
getnth:	exch o1,o2		;number in o1
	call get1nt		;numerical value to W2
	jumpl w2,getnng		;if negative, it is harder
;here to redirect output to dummy channel that finds Nth char in output
getnps:	push p,sp		;save sp since we rebind curout
	push p,q		;also we will do not-local exit
	move o1,[.dumchn]	;get the dummy channel
	movem p,ch%jfn(o1)	;save for non-local exit
	movei w3,ch%666		;make ch%dat be not checked by GC
	hrrm w3,ch%spc(o1)
	movem w2,ch%dat(o1)	;here is the count of where to stop
	xmovei w3,nthput	;special put routine that stops at N
	movem w3,ch%put(o1)
	setzm w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	move o1,o2		;get thing to print into O1
	call princ		;and print with princ
	seto w4,		;if got here, we failed
	adjsp p,-1
	jrst unbind		;rebind curout

;here non-locally if we find it
nthfnd:	move p,ch%jfn(o2)	;end - stop quickly
	pop p,q			;restore context
	move w4,w2		;move return value where unbind won't kill
	jrst unbind

;here if negative number - subtract abs(n) from length+1
getnng:	push q,o2		;save args
	push p,w2
	move o1,o2		;now find length
	call flatsc		;FLATSIZEC - has to be non-neg INUM [;TY%NUM]
	tlz o1,770000		;so fast conversion
	pop p,w2		;get back length, is negative
	add w2,o1		;subtract abs(n)
	addi w2,1		;+1
	pop q,o2		;got arg back
	jrst getnps		;and process as positive

;EQSTR - compare two strings (or atoms) for equality
eqstr:	call getstr		;get valid string arg in o1
	exch o1,o2
	call getstr		;now in both o1 and o2
	move w4,[cmpse o1,]	;compare for equal
	jrst cmpstr

;IDIRST - currently this is an internal routine
; W2 - directory or user number
; returns string in O1
idirst:	push free,[object(ty%spc,0)] ;now make string - dont know how big
	move nil1,[.bp 376,(free)] ;destination - free space
	dirst
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
	jrst strret		;finish bookkeeping on string

myuser:	gjinf
	move w2,nil1
	jrst idirst

mydir:	gjinf
	jrst idirst

;time since midnight, msec.  (actually seconds at the moment)
dtime:	seto w2,		;use current time
	setz w4,		;default format
	odcnv
	andi w4,777777		;time since midnight
	imuli w4,1000.		;pseudo-msec.
	maknum w4
	move o1,w4		;and return as INUM
	ret

;

;DATE - (MO DO YR-1900)
date:	seto w2,
	setz w4,
	odcnv
	hlrz o2,w2		;year
	subi o2,1900.
	maknum o2		;-1900 as inum
	docons o1,o2,nil	;(YR-1900)
	hlrz o2,w3		;day, 0 based
	addi o2,1
	maknum o2
	docons o3,o2,o1		;(DAY YR-1900)
	hrrz o2,w2		;month, 0 based
	addi o2,1
	maknum o2
	docons o1,o2,o3		;(MO DAY YR-1900)
	ret

;*STCONCAT - string concatenation
concat:	call getstr		;validate the args
	exch o1,o2
	call getstr
	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word of string
	hrlzi nil1,440740	;w1/2 source
	xmovei w2,1(o2)		;first arg
conc1:	ildb o2,nil1
	jumpe o2,conc2		;loop over first string
	setzm 1(w4)		;clear next word, for low order bits
	idpb o2,w3
	jrst conc1
conc2:	hrlzi nil1,440740	;second source
	xmovei w2,1(o1)
conc3:	ildb o2,nil1
	jumpe o2,conc4
	setzm 1(w4)
	idpb o2,w3
	jrst conc3

conc4:	idpb nil,w3		;make ASCIZ
	xmovei w2,1(free)	;start of string
	move free,w4		;update free list
	sub w4,w2		;w3 is length in words
	tlo w4,(object(ty%spc,0)) ;special GC code
	movem w4,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	move o1,w2		;and return it
	setzb o2,nil1		;clear garbage
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret	

;STNTH - Nth char in string
stnth:	call getstr		;validate arg
	move w2,o2
	posnum w2		;number in o2
	hrlzi w3,440740
	xmovei w4,1(o1)
	adjbp w2,w3		;adjust to the nth char
	ldb w2,w2		;get the char
	move o1,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	ret

;STLENGTH - length of string
stlen:	call getstr		;validate arg
	move w2,(o1)		;size in words
	tlz w2,770000		;minus type code
	subi w2,1		;w2 - full words
	xmovei w4,(o1)		;address before string
	add w4,w2		;w4 - word before last
	imuli w2,5		;w2 - chars due to full words
	move w3,[010740,,0]	;w3/4 - byte pointer to last word
stlenl:	ildb nil1,w3		;now count chars in that word
	jumpe nil1,ret1nt	;return as int
	aoja w2,stlenl

;PACKC - takes a list of characters and returns an atom
packc:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word of string
	hrlzi nil1,440740	;w1/2 source
packcl:	jumpe o1,packcx		;done if nil - intern it
	docar o2,o1		;O2 - next char
	docdr o1,o1
	xtype o2
	xct packtb(w2)		;get char into w2
;falls through here if NIL
	movei w2,"N"
packcd:	setzm 1(w4)		;clear next word, for low order bits
	idpb w2,w3
	jrst packcl

packcx:	setz nil1,
	idpb nil,w3
	jrst packx

packtb:	jumpn o2,pckatm		;normal atom (except nil)
	jrst rdlerr		; cons
	jrst pckstr		; string
	jrst rdlerr		; channel
	jrst rdlerr		; vector
	jrst rdlerr		; hash table
	jrst rdlerr		; address
	jrst rdlerr		; array
	jrst rdlerr		; lflon
	jrst rdlerr		; iflon
	jrst rdlerr		; iflon
	jrst rdlerr		; ratio
	jrst rdlerr		; complex
	jrst rdlerr		; bignum
	jrst rdlerr		; neg integer
	jrst pckint		; pos integer

pckstr:	skipa w2,o2

pckatm:	move w2,at%pna(o2)	;put byte ptr to pname in -1(p)
	ldb w2,[.bp 177_29.,1(w2)]
	jrst packcd		;put byte in string

pckint:	move w2,o2
	jrst packcd

;RPLSTR
; O1 - target string
; O2 - N - start with this pos
; O3 - new string - replace with this
rplstr:	push q,o3
	push q,o2
	call mkstr		;make it a string if it isn't
	exch o1,-1(q)
	call mkstr		;also new string
	exch o1,-1(q)		;get back target in O1
	pop q,w2		;get back N in O2
	posnum w2		;number in o2
	subi w2,1		;index by 0
	hrlzi w3,440740
	xmovei w4,1(o1)
	adjbp w2,w3		;W2/W3 is now pointer to Nth
	push p,w2
	push p,w3		;bpt is now -1(p)
	pop q,o3		;new string
	hrlzi w3,440740
	xmovei w4,1(o3)
rplstl:	ildb w2,w3
	jumpe w2,rplstx		;done at null
	idpb w2,-1(p)
	jrst rplstl
rplstx:	adjsp p,-2
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; output
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;This section is organized in layers.
;;;;1) TYO and TYOUT, which think all characters and devices are the same
;;;;2) character-dependent routines that keep track of position on
;;;;     the line and any other bookkeeping
;;;;3) device-dependent routines that actually put out the characters.


;;;;;;;;;;;;;;;LEVEL 1 --  TYO and TYOUT;;;;;;;;;;;;;;;;;


;tyout - prints an asciz string - string in w2
;this is an internal routine only, so it does not return a value
tyout:	push p,[440740,,0]	;make up byte pointer at -1(p)
	push p,w2
tyolp:	ildb w2,-1(p)		;next char
	jumpe w2,tyoend		;done
	makchr w2
	move o1,w2
	call tyo
	jrst tyolp
tyoend:	adjsp p,-2
	ret


;;TY%CHN
;TYO - output char on currently open channel
tyo:	move o2,@[datsec,,.curout] ;output channel
	gettyp o1
	caie w2,ty%lpi		;better be low pos int
	jrst illasc
	move w2,o1
	posnum w2
	caile w2,177
	jrst illasc
	hrrz w3,rdtab(w2)	;see what it is
	xct tyotab(w3)

;;;;;;;;;;;;;;;LEVEL 2 -- character action routines;;;;;;;;;;;;;;;;;

;;READTABLE
tyotab:	jrst tyon	;letters
	jrst tyon	;lower case
	jrst tyon	;(
	jrst tyon	;)
	jrst tyon	;[
	jrst tyon	;]
	jrst tyon	;.
	jrst tyon	;,
	jrst tyon	;'
	jrst tyon	;/
	jrst tyon	;"
	jrst tyosp	;space
	jrst tyoeol	;all end of lines
	jrst tyon	;digits
	jrst tyon	;+ -
	jrst tyon	;esc
	jrst tyon	;comment
	jrst tyon	;null

tyoeol:	setzm ch%pos(o2)	;reinit new line
	jrst tyodo

tyon:	aos w3,ch%pos(o2)	;normal char - is there room?
	skiple ch%len(o2)	;forget the test if length .LT. 0
	camg w3,ch%len(o2)
	jrst tyodo		;there is room - normal
	jrst tyocnt		;there isn't, do continuation

;to continue to next line
tyocnt:	push p,w2
	movei w2,31		;^Y
	move w3,ch%jfn(o2)	;see if terminal
	cain w3,.priou
	 jrst tyocn2		;the monitor will do the crlf
	call @ch%put(o2)
	movei w2,15		;crlf
	call @ch%put(o2)
	movei w2,12
	call @ch%put(o2)
tyocn2:	pop p,w2
	setzm ch%pos(o2)
	aos ch%pos(o2)
	jrst tyodo		;finally do the real char

;space or tab
tyosp:	caie w2,11		;tab?
	jrst tyon		;no - just do it
;tab - note that tabs never get ^Y'ed.  However they may make the
;next character get it.
	move w3,ch%pos(o2)	;w3 is now 0 if at start of line
	trz w3,7
	addi w3,10		;w3 is now next tab stop
	movem w3,ch%pos(o2)
	jrst tyodo		;put out the tab

tyodo:	call @ch%put(o2)	;put it out
	ret

;;;;;;;;;;;;;;;;LEVEL 3 -- device-dependent routines;;;;;;;;;;;;;

;these routines always take an ASCII char in W2.
;o2 is assumed to contain the channel object

;this is the normal put routine, for physical devices
norput:	hrrz nil1,ch%jfn(o2)
	bout
cpopn1:	setz nil1,
	ret

;this is the routine for explode.  ch%jfn is the last CONS in
;the list being built
expput:	move o3,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	move o4,ch%dat(o2)		;old end
	docons o5,o3,nil		;(char)
	dorpd o4,o5			;(old char)
	movem o5,ch%dat(o2)		;save as new end
	ret

;this is the routine for aexplode.  ch%jfn is the last CONS in
;the list being built
aexput:	caige w2,10.			;numbers less then 10
	addi w2,200			;have an extra bit because of MAKNAM
	maknum w2
	move o4,ch%dat(o2)		;old end
	docons o5,w2,nil		;(char)
	dorpd o4,o5			;(old char)
	movem o5,ch%dat(o2)		;save as new end
	ret

;this is the routine for flatsize.  Incr's count
fltput:	aos ch%dat(o2)
	ret

;this is the routine for NTHCHAR.  Stop at nth char
nthput:	sose ch%dat(o2)			;count down
	ret				;not yet
	jrst nthfnd			;found the right char - in W2

;this is the routine for PACK and friends
pckput:	idpb w2,ch%bpt(o2)
	move w2,ch%bpt+1(o2)
	setzm 1(w2)
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  input
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;TYI is in three levels:
;;;;;; 1) TYI and its subroutine is device-independent.  Its only
;;;;;;		intelligence is the ^Y convention.
;;;;;; 2) TYIGET implements UNTYI
;;;;;; 3) device dependent routines do the actual I/O


;;;;;;;;;;;;;;;;;;;;;;;LEVEL 1 -- TYI;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;the main responsibility at this level is to handle ^Y


tyi:	call tyiget		;real read
	hrrz w3,rdtab(w2)	;see if funny char
	caie w3,rd%cmt		;comment and null
	cain w3,rd%nul
	jrst tyifun		;are funny
	makchr w2		;have char, make object
	move o1,w2		;return it
	ret

tyifun:	cain w3,rd%nul		;if null, ignore it
	jrst tyi
tyiflp:	call tyiget		;now skip to end of line
	hrrz w3,rdtab(w2)
	cain w3,rd%esc
	jrst tyi		;esc is end of line
	caie w2,15		;cr is not real end of line
	caie w3,rd%eol
	jrst tyiflp
	jrst tyi		;now get a real char

;;;;;;;;;;;;;;;;;LEVEL 2 -- TYIGET;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;the main responsibility at this level is UNTYI.  Get a char
;and return it in W2.  all other AC's are free.

;;TY%CHN
tyiget:	move o2,@[datsec,,.curin] ;input channel
	skipe w2,ch%lka(o2)	;lookahead?
	jrst tyilka		;yes, use it
	call @ch%get(o2)	;no, real get
	andi w2,177
	movem w2,ch%lst(o2)	;save as last char in case of UNTYI
	ret

;here if found a lookahead char
tyilka:	setzm ch%lka(o2)	;no more lookahead
	movem w2,ch%lst(o2)
	ret

;There was some confusion over TYI in the documentation.  UNTYI is
;the original implementation, based on erroneous documentation.
;XUNTYI is what UCILSP actually implemented.  I am leaving UNTYI
;because internal code uses it.  However XUNTYI is the function that
;the user will get when he calls UNTYI.
;;TY%CHN
xuntyi:	gettyp o1		;check the thing
	caie w2,ty%lpi		;better be low pos int
	jrst illasc
	move w2,o1
	posnum w2
	caile w2,177
	jrst illasc
	move o2,@[datsec,,.curin] ;current input channel
	movem w2,ch%lka(o2)	;use for lookahead
	ret

;;TY%CHN
;untyi - back up pointer
untyi:	move o2,@[datsec,,.curin] ;current input channel
	move w2,ch%lst(o2)	;get last char
	movem w2,ch%lka(o2)	;and use for lookahead
	jrst retnil

;;TY%CHN
;lastc (file) - find last char
lastc:	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	move w2,ch%lst(o1)	;get last char
	move o1,@[<w2_30.>\<datsec,,charar>] ;get atom for this char
	ret	

;;;;;;;;;;;;;;;;;;;LEVEL 3 -- actual I/O routines;;;;;;;;;;;;;;;;;;;
;get a char into W2, preserve O2, which is the channel object.
;  other AC's free

;;TY%CHN
;norget is for everything except terminals
norget:	hrrz nil1,ch%jfn(o2)	;jfn
	bin			;do the input
	 erjmp eoferr		;error - treat as EOF
	setz nil1,
	ret

;This is EOF on input.  Try the following:
; 1 - see if GNJFN finds another file
; 2 - see if there were more files in the original OPENIN
; 3 - generate $EOF$ error
;O2 has the channel object, which must be preserved
eoferr:	move w2,ch%jfn(o2)	;see if we should do EOF processing
	tlnn w2,(gn%cnt)	;continuous mode?
	jrst eofbad		;no - done
	call inextf		;try to advance to next file
	 jrst eofbad		;failed
;open file, given indexable file handle in 1,
;openf bits in 2
	tlz nil1,777777		;have to open with JFN only
	move w2,[070000000000+of%rd]
	openf
	 erjmp opfer2		;error with file in o2
	move w4,w2		;openf bits for opendv
	move o1,o2		;and file in standard place
	call opendv		;do any device setups
	move o2,o1		;now get it back in our wierdo AC
	setz nil1,
	jrst @ch%get(o2)	;and try char on this one
	

;NEXTF
; get JFN on next file in wildcard or list
nextf:	jumpe o1,retnil		;if nil, fails always
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst retnil
	jumpe nil1,retnil	;also if nothing there any more, fails
	hrrz nil1,ch%jfn(o1)	;now see if open
	gtsts
	xmovei w3,inextf	;assume close needed
	tlnn w2,(gs%opn)	;is it open?
	xmovei w3,inext1	;no - use other entry
	setz nil1,
	push q,o1		;save arg
	move o2,o1		;inextf needs arg in O2
	call (w3)		;go to next file
	 jrst nextfe		;error
	pop q,o1		;return arg
	setz nil1,
	ret

nextfe:	adjsp q,-1		;error - return nil
	setzb nil1,o1
	ret

;INEXTF
; internal version of NEXTF.  In order for use for EOF processing,
;   - arg is channel in O2
;   - return +1 is error, +2 is OK
; returns indexable file handle in NIL1, also put into ch%JFN
;INEXT1 is special entry if no close needed
inextf:	
;close file, since GNJFN requires this
	move o1,o2		;file must be in O1 for close
	movsi w2,(co%nrj)	;don't release JFN
	call doclos		;do dev-specific and monitor close
	 jrst .+1
	move o2,o1		;get file back to O2
;now see if GNJFN gives us any more files
;INEXT1 - entry if no close needed
inext1:	move nil1,ch%jfn(o2)	;indexable file handle
	tlz nil1,(gn%cnt)	;this is a bogus bit, clear it
	gnjfn
	 erjmp eofnfl		;nothing there, next file spec please
;yes, we can just reopen and use it
	move nil1,ch%jfn(o2)	;get jfn again
	aos (p)			;worked - good return
	ret			

;here if we have to go to a new file spec
eofnfl:	
;first finish getting rid of old one
	hrrz nil1,ch%jfn(o2)	;jfn
	rljfn			;release it
	 erjmp .+1		;ignore errors
	move nil1,ch%jfn(o2)	;get old JFN
	setzm ch%jfn(o2)	;say no longer open
;now look at new ones
	move o3,ch%dat(o2)	;any more files?
	jumpe o3,cpopj		;no - it is bad
;here if there are more files, open the next one
	docar o1,o3		;get the new file
	docdr o3,o3		;get to next for next time
	movem o3,ch%dat(o2)
	push p,nil1		;save old file handle
	call mflnam		;put name in FILNAM
	move nil1,[gj%old+gj%ifg+gj%flg+gj%sht]  ;and open it, as in xinput
	hrroi w2,filnam
	gtjfn
	 erjmp oper
	pop p,w2		;get old file handle
	tlne w2,(gn%cnt)	;if was continuous before
	tlo nil1,(gn%cnt)	;make it so now
	movem nil1,ch%jfn(o2)	;new jfn
	aos (p)			;OK return
	ret

eofbad:	move w2,@[datsec,,priin]
	movem w2,@[datsec,,.curin]
	move o1,[%$EOF$]
	setz nil1,		;=*= re-entering the LISP world ...
	call uerr

;special read from terminal for DDTIN mode
  ;first see if anything left over in line buffer
ddtget:	sosge trmcnt		;anything left over from line-mode read?
	 jrst ddting		;no - do real DDTIN input
	ildb w2,trmpnt
	jrst trmdon		;and check for odd char's

  ;real input routine for DDTIN
ddting:	setzm trmcnt
	pbin
	move w2,nil1
	move w3,w2		;get copy without high-order bit
	andi w3,177		;ignore high-order bit
	setz nil1,
	camn w3,fixch		;fix char?
	jrst trmfix		;yes - do it
	came w3,rerdch		;reread char or
	cain w3,177		;kill char?
	jrst trmrer		;yes - do that
	ret			;no - done

;;;;;;This is the set of routines for normal terminal input

;special read from terminal
trmget:	sosge trmcnt		;anything there?
	 jrst trmgbf		;no - get a buffer
	ildb w2,trmpnt
;now check for odd char's
trmdon:	camn w2,rerdch		;reread char
	jrst trmrer		;do it
	camn w2,fixch		;fix char
	jrst trmfix		;do it
	ret

;;;;;;Here are the action routines for funny char's

;here for fix char
trmfix:	skipn @[datsec,,.rdtop]	;in read?
	ret			;no - return normal anyway
	setom sawfix'		;say we saw it
	jrst @ch%get(o2)	;and get a real char

;here for reread char
trmrer:	skipn @[datsec,,.rdtop]	;in read?
	ret			;no - return normal anyway
	hrroi nil1,[asciz / XXX
/]
	psout
	setz nil1,
	setzm ch%lka(o2)	;clear lookahead
	setzm ch%lst(o2)
	jrst rdkill		;yes - kill read

	.scalar prmpch

;here if buffer empty
trmgbf:	hrroi nil1,prmpch	;prompt
	psout
	hrroi nil1,trmbuf
	move w2,[rd%top+5*trmbfs]
	hrroi w3,prmpch		;prompt char
	rdtty
	 jrst [	setz nil1,
		err /End of file on primary input/]
	andi w2,777777		;get count
	subi w2,5*trmbfs
	movnm w2,trmcnt
	move nil1,[.bp 376,trmbuf-1] ;reinit byte pointer
	movem nil1,trmpnt
	setzm @[datsec,,outchn+ch%pos]
	setz nil1,
	jrst trmget		;and go read it

;PROMPT
;  O1 - new prompt char
prompt:	move w3,[.bp 774000000000,prmpch] ;current prompt
	jrst setprm

;INITPROMPT
iniprm:	move w3,[.bp 774000000000,inprch] ;toplevel prompt
	jrst setprm

;SETPRM - internal routine to set prompt or initprompt
;  O1 - new char
;  w3 - byte pointer to prompt or initprompt
;returns old value
setprm:	ldb w4,w3		;get old char
	makchr w4
	jumpe o1,setpnl		;see if need to set new one
	gettyp o1
	caie w2,ty%lpi		;better be low pos int
	jrst illasc
	move w2,o1
	posnum w2
	caile w2,177
	jrst illasc
	dpb w2,w3		;set new char
setpnl:	move o1,w4		;return old value
	ret

;TALK - clear output and ^O
talk:	movei nil1,.priou
	rfmod			;get modes in W2
	tlnn w2,(tt%osp)	;are we in ^O?
	jrst talkx		;no
	cfobf			;yes, kill rest of output
	tlz w2,(tt%osp)		;clear ^O
	sfmod
talkx:	setz nil1,
	ret

;TTYECHO - complement echo
ttecho:	movei nil1,.priou
	rfmod			;get modes in W2
	trc w2,tt%eco		;complement echo
	sfmod
	setzb o1,nil1		;assume turning off
	trne w2,tt%eco		;if just turned it on
	move o1,[%T]		;say so
	ret

;TTYPAUSE - set pause on end of page or not
ttpaus:	movei nil1,.priou
	movei w2,.morxo		;look at old status
	mtopr
	exch o1,w3		;old value to return, new to w3
	caie o1,0		;normalize O1 to T/NIL
	move o1,[%T]
	caie w3,0
	movei w3,1		;normalize W3 to 0/1
	movei w2,.moxof		;now set new value
	mtopr
	setz nil1,
	ret

;CLRBFI
; return NIL
clrbfi:	movei nil1,.priin
	cfibf			;yes, kill rest of output
	setzm @[datsec,,inchn+ch%lka]
	setzm @[datsec,,inchn+ch%lst]
	setzm trmcnt		;and clear internal buffer
	setzb nil1,o1
	ret

;READP - is there an input char ready?  Ignores lookahead buffer
;  (as UCI Lisp does)
readp:	skiple trmcnt		;if we have anything in RDTTY buffer
	jrst rett		;then yes
	movei nil1,.priin
	sibe
	skipa o1,[%t]		;not empty, i.e. something there
	move o1,nil		;empty, not
	setz nil1,
	ret

;REREADCH
; O1 - number of char to use for ^Z
;negative numbers are a flag that no ^Z char at all
setrrd:	call get1nt
	exch w2,rerdch
	jrst ret1nt

;EDITCH
; O1 - number of char to use for ^F
;negative numbers are a flag that no ^F char at all
setedc:	call get1nt
	exch w2,fixch
	jrst ret1nt

;ERRCH
; O1 - number of char to use for ^G (ERR ERRORX)
;negative numbers are a flag that no ^G char at all
errch:	call get1nt		;get integer value to w2
	caig w2,33		;esc and lower
	jrst ercok		;are OK as is
	cain w2,177		;so is rubout
	jrst ercrub
	cain w2,40		;and space
	jrst ercsp
	perr /ERRCH must be control char, <esc>, <del>, or <sp>/

ercrub:	skipa w2,[.ticrb]
ercsp:	movei w2,.ticsp
ercok:	hrl w2,w2		;char,,chan
	hrr w2,erchin
	hlrz nil1,erchin	;old association
	trnn nil1,400000	;none
	dti			;cancel it
	move nil1,w2		;new association
	tlnn nil1,400000	;none
	ati			;make it
	setz nil1,
	exch w2,erchin		;now save new, get old
	hlrz w2,w2		;get old char
	caig w2,.tices		;if esc or less
	jrst ret1nt		;just return it
	cain w2,.ticrb		;else map it back
	movei w2,177
	cain w2,.ticsp
	movei w2,40
	jrst ret1nt

;;TY%INT		binary out halfwords
binohw:	hrl o2,o1		;this is a hack to speed up the compiler
	skipa w2,o2
;;TY%CHN
;BINOUT - binary out
	;falls thru
binout:	 call get1nt		;get arg into W2
	move o2,@[datsec,,.curout] ;output channel
	camn o2,@[datsec,,priout] ;instead of .PRIOUT
	move o2,[.binchn]	;use binary channel
	jrst @ch%put(o2)	;now put out the thing

;;TY%CHN - binary in
binin:	move o2,@[datsec,,.curin] ;output channel
	camn o2,@[datsec,,priin] ;instead of .PRIIN
	move o2,[.binchn]	;use binary channel
	call @ch%get(o2)	;now get the char
	jrst ret1nt		;and return as integer

;;TY%CHN
;CURPOS - get current position in random access. Next GET will read this
curpos:	jumpe o1,ret0		;terminal always as 0
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst ret0
	jumpe nil1,retnil	;also if nothing there any more, fails
	move w2,ch%dsp(o1)
	call @ch%cps(w2)
	 jrst retnil		;not open, etc. - NIL
	skipe ch%lka(o1)	;if lookahead
	sos w2			;then logically back one in file
	setz nil1,
	jrst ret1nt

ret0:	move o1,[inum0]
	setz nil1,
	ret

;;TY%CHN
;SETPOS - set current position in random access. Next GET will read this
setpos:	jumpe o1,retnil		;terminal always as 0
	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, fails
	cain nil1,.priou
	jrst retnil
	jumpe nil1,retnil	;also if nothing there any more, fails
	exch o1,o2		;get number
	call get1nt		;into W2
	move w3,ch%dsp(o2)
	call @ch%sps(w3)
	 jrst retnil		;not open, etc. - NIL
	setzm ch%lka(o2)	;clear lookaheads
	setzm ch%lst(o2)
	setz nil1,
	jrst rett		;OK



;put for pmapped I/O
dskput:	aos w3,ch%cby(o2)	;advance current byte
	camle w3,ch%lby(o2)	;beyond end seen so far?
	movem w3,ch%lby(o2)	;yes - update it
	sosge ch%bct(o2)	;room in buffer?
	 call dskadv		;no - next
	idpb w2,ch%bpt(o2)
	 ercal maperr
	ret

;This routine is called when we get an error upon attempting access
; to a page.  It makes assumes that the caller uses the following
; sequence:
;	aos ch%cby(o2)
;	sos ch%bct(o2)
;	idpb/ildb w2,ch%bpt(o2)
;	 ercal maperr
; as it will undo the sideeffects of these operations if necessary.
;    When a hole is found (only possible on read), we just have to set w2
;    to zero after clearing the page.
; But on a real error, we have to back out all the operations shown
;	and abort the caller.

maperr:	
;for tops-20 the most likely thing here is that we tried to read a
;  hole in the file. Tops-20 gives an ill mem read in that case. 
;Also, it may be quota exceeded.
;So the code comes in these pieces:
;  diagnose it - hole in the file?
;  if a hole, then give a zero page
;  else, print an error message and back out of the I/O operation

	sfm w3			;save flags in W4
	tlo w3,020000		;set first part done, as ILDB was interrupted
	move w4,[440700,,w4]	;do an ILDB to clear first part done
	ildb w4,w4		;since ERCAL may leave it set
	push p,w2		;save the char
	movei nil1,400000	;see what error
	geter
	tlz w2,777777		;w2 _ error code
	cain w2,iox11		;if quota error
	jrst mapquo		;special handling
	pop p,w2		;put back stack (don't care about char now)
;here we check to see if the page is perhaps nonexistent in the file
;if so, we treat it as zeros.  
	move nil1,ch%bpt+1(o2)	;addr of core page
	lsh nil1,-11		;convert to page
	hrli nil1,.fhslf	;in our fork
	rpacs
	 erjmp maper3		;treat this as an I/O error
;The case we are looking for is read-only access and an indirect pointer
	tlnn w2,(pa%wt)		;if have write access, not this problem
	tlnn w2,(pa%ind)	;if indirect too, that is it
	jrst maper3		;write access or not indirect: normal error
  ;here if it is a hole.  clear the page
maper1: move w2,nil1		;b _ .fhslf,,core page no.
	seto nil1,		;clear page
	setz w3,		;no counts
	pmap
	 chkquo			;[27]
	 erjmp maper2		;can't clear page
	setzb nil1,w2		;return a zero byte
	ret			;and continue as if ILDB had worked

;here if is a quota error, to retry
mapquo:	hrroi nil1,[asciz / Quota exceeded or disk full for /]
	esout
	movei nil1,.priou
	hrrz w2,ch%jfn(o2)
	push p,w3
	setz w3,
	jfns
	hrroi nil1,[asciz /
[Find some space, then type CONTINUE]
/]
	psout
; Finally we are ready to restore to the user's context and continue,
; if user types CONTINUE
	pop p,w3
	pop p,w2		;restore thing to put out
	pop p,w4		;return address
	subi w4,2		;back to the IDPB
	setz nil1,		;get legal again
	haltf			;let him delete some files
	xjrstf w3		;flags (including first part done) are in W4

;here is the beginning of the true error code.
maper2:	
maper3:
	sos ch%cby(o2)		;move back
	aos ch%bct(o2)
;the following should use ADJBP with -1, but that doesn't work in extended
;addressing (at least in release 4)
	ldb w3,[.bp 77_24.,ch%bpt(o2)] ;byte size
	ldb w2,[.bp 77_30.,ch%bpt(o2)] ;offset - can't be 44, as we have just
					;done ildb
	add w2,w3		;move back a byte
	dpb w2,[.bp 77_30.,ch%bpt(o2)]	;and put it back in byte pointer
	setz nil1,
ioer:	jrst opfer2		;error with file in O2

dskeof:	sos ch%cby(o2)		;yes - don't do the advance
	jrst eoferr		;now see if more files, etc.

;get for pmapped I/O
dskget:	aos w3,ch%cby(o2)	;advance current byte
	camle w3,ch%lby(o2)	;beyond eof?
	 jrst dskeof		;yes - do it
	sosge ch%bct(o2)	;count bytes left in this buffer
	call dskadv		;none - get new buffer
	ildb w2,ch%bpt(o2)	;get character
	 ercal maperr
	move w3,ch%lts(o2)	;line no. test bit if 7 bit mode
	tdnn w3,@ch%bpt+1(o2)	;was it a line no.?
	ret			;no - that's all
;currently we aren't giving the user the line number
;	move w3,@ch%bpt(o2)	;line no. - get it
;	movem w3,...		;save it for user
	aos ch%bpt+1(o2)	;skip it
	movei w3,5		;update currentposition
	addm w3,ch%cby(o2)
	movni w3,5		;note getchb already skipped one char, so
	addb w3,ch%bct(o2)	; we only skip 5
	jumpge w3,dskget	;now get real character
;the context in which dskadv is valid is where we have just done sosge ch%bct,
;and are about to do ildb.  Usually this is right, as in the subtraction of
;5 above, 1 of the 5 is in the new block.   so that is the sosge.  we will
;still have to do an ibp afterwards, though.  If we are further into the
;word than the first char, we now back up, since filadv will leave us at
;the start of the buffer (and its error handling is predicated on the
;assumption that we are working on the first char)
	addi w3,1		;if more than one char into new buffer
	addm w3,ch%cby(o2)	;move back (T is negative)
	call dskadv		;go to new buffer
;this should be IBP, but IBP doesn't work in extended addressing
	ildb w3,ch%bpt(o2)	;pass over first char (tab)
	jrst dskget		;now go back for real char

;pmap I/O - buffer advance and go to new page

;dskadv - get to the next page when reading sequentially.  If
; the getpage succeeds, this gives new byte ptr, count, etc., for
; the new page.  Otherwise you are left exactly where you were before,
; with filcby adjusted, since the caller is assumed to have
; incremented it.
;    W2 must be preserved, since it has the character in it
dskadv:	move w3,ch%pag(o2)	;old page
	addi w3,winpgs		;new page
	call getfpg		;get page routine
	 jrst badadv		;can't get new page
	move w3,ch%bfs(o2)	;bytes in buffer
	subi w3,1		;caller has done sosge
	movem w3,ch%bct(o2)
	move w3,ch%buf(o2)	;pointer to start of buffer
	movem w3,ch%bpt+1(o2)
	movei w3,44
	dpb w3,[.bp 77_30.,ch%bpt(o2)]
	ret

badadv:	sos ch%cby(o2)		;user has done aos on this
	err /I-O error on disk file/

;getfpg - get specified page 
;	w3 - desired page - preserved
;	w2 - preserved
;  returns:  w3 - requested disk page, skip if works, non-skip if not
;    also resets 
;	ch%pag to indicate we are on a new file page
;    the user is assumed to adjust counts, pointers, etc., as he likes

getfpg:	push p,w2
	push p,w3
	hrr nil1,w3		;desired page
	hrl nil1,ch%jfn(o2)	;on this file
	move w2,ch%buf(o2)	;address of buffer
	lsh w2,-9.		;make page no.
	hrli w2,400000		;current process
	move w3,[pm%cnt\pm%rd\pm%wr\pm%pld\winpgs] ;use count, preload
	pmap
	 chkquo			;[27]
	 erjmp badpag
	setz nil1,
	pop p,w3
	pop p,w2
	movem w3,ch%pag(o2)	;only now can we say are on that page
	aos (p)			;skip return - success
	ret

;note that badpag is called with b&c saved on stack
badpag:	pop p,w3		;we don't change filpag, as haven't moved
	pop p,w2
	setz nil1,
	ret			;error return

;pmap I/O - device dependent openning

;Here after a file has been opened on disk.
;W4 - OPENF bits user asked for (if simulating append, may have used others)
;O1 - file, which must be preserved

;The first problem is to see whether we have enough access to the file to
;   PMAP it.  Write-only or append-only files can't be pmapped.
dskopn:	hrrz nil1,ch%jfn(o1)	;let's see whether we can use PMAP'ed I/O
	gtsts			;w2 - file status
	tlne w2,(gs%opn)	;if not open, nothing we can do
	tlnn w2,(gs%rdf)	;also if can't read, pmap is no use
	ret			;not open or no read
	tlnn w2,(gs%rnd)	;better not be opened append-only
	ret			;it is
	trnn w4,of%wr\of%app	;if he wanted write or append
	jrst dskop1		;no - read is enough
	tlnn w2,(gs%wrf)	;we had better be able to write
	ret			;can't - let monitor figure this out
;If here, we know we will be able to PMAP the file
dskop1:	push p,w4		;save open bits for later users
	skipe w2,ch%buf(o1)	;if there is already a buffer
	jrst dskop2		;we use it
	movei w2,winpgs		;get this many pages
	call getbuf		;returns address in W2
dskop2:	movem w2,ch%buf(o1)	;now set up all the fields
	movem w2,ch%bpt+1(o1)
	ldb w2,[.bp 77_30.,(p)] ;get byte size
	cain w2,0		;if not specified
	movei w2,7		;use ascii
	movei w3,36.		;now compute number of bytes per word
	idiv w3,w2		;w3 - number of bytes per word
	lsh w3,9.		;w3 - number of bytes per page
	movem w3,ch%pgs(o1)
	imuli w3,winpgs		;w3 - number of bytes per buffer
	movem w3,ch%bfs(o1)
	setzm ch%lts(o1)	;assume no line number test needed
	cain w2,7		;if 7-bit
	aos ch%lts(o1)		;then turn on the bit
	lsh w2,24.		;move into byte size field in byte ptr
	tlo w2,440040		;and make pointer to start of word, extended
	movem w2,ch%bpt(o1)	;now we have a full byte pointer (2-word)
	movni w2,winpgs		;set set DSKADV gives first page
	movem w2,ch%pag(o1)
	setom ch%bct(o1)	;no space left
	setzm ch%cby(o1)	;and no char's read
	move w2,[codsec,,dskget] ;set up dispatches
	movem w2,ch%get(o1)
	move w2,[codsec,,dskput]
	movem w2,ch%put(o1)
	move w2,[codsec,,dskdsp]
	movem w2,ch%dsp(o1)

;here we have to split according to the sort of open being done
	pop p,w2		;get back openf bits
	trne w2,of%app		;special code to simulate append
	jrst dskapp
	trnn w2,of%rd		;special code if write-only
	jrst dskwrt
;read or update
	trne w2,of%wr		;if only read
	jrst sizefi		;and finally, use size of existing file

  ;read only
	move w2,[codsec,,errio]	;disable writing
	movem w2,ch%put(o1)
	move w2,[codsec,,dskrds] ;use special dispatch because of close
	movem w2,ch%dsp(o1)
	jrst sizefi		;and finally, use size of existing file

;write only
dskwrt:	setzm ch%lby(o1)		;file is now zero length
	ret			;that's it

;append simulation
dskapp:	pushj p,sizefi		;find end of file
	move w2,ch%lby(o1)	;go to end
	move o2,o1		;retint will set O1
	call ret1nt
	exch o1,o2		;file to O1, position to O2
	push q,o1
	call setpos		;now setpos to position
	pop q,o1
	ret

;These are common initializations that must not be done until
;we know the open succeeded

;Find the size of the file, and set up CH%LBY
sizefi:	hrrz nil1,ch%jfn(o1)
	move w2,[2,,.fbbyv]
	movei w3,w2		;put w2 _ byte size, w3 _ bytes in file
	gtfdb			;get from fdb
	 erjmp opfer
	ldb w4,[.bp 77_24.,ch%bpt(o1)]	;w4 _ our byte size
	ldb w2,[.bp 77_24.,w2]	;w2 _ file's byte size
	cain w2,0		;[2] if zero
	movei w2,36.		;[2] use 36 to prevent divide by 0
	camn w2,w4
	jrst sambsz		;if same, use exact calculation
;[44] new algorithm that gets exact sizes if at all possible
;different byte sizes.  First we figure the number of completely filled
;words.  Then if not an even number of words, we handle the last,
;partially filled word separately.  The object is to avoid rounding up
;if possible.
	movei o2,36.
	idiv o2,w2		;o2 - file bytes/wd
	move o3,w3		;o3 - number of full words, o4 - extra fil byt
	idiv o3,o2
	imul o4,w2		;o4 - extra bits in last word
	movei o5,36.		;o5 - our bytes per word
	idiv o5,w4
	imul o5,o3		;o5 - our bytes in full words
	move o6,o5		;o6 - our bytes in full words
	idiv o4,w4		;o4 - extra bytes of our size in last wd
				;o5 - extra bits beyond those bytes
	add o6,o4		;o6 - our bytes due to full words and extra
				;    bytes in last word
	skiple o5		;any bits not yet counted?
	addi o6,1		;yes - say one more byte
	move w3,o6		;c - final result - bytes in file
	setzb o2,o3		;make these things legal
	setzb o4,o5
	setz o6,
;[44] end of new algorithm
sambsz:	movem w3,ch%lby(o1)
	ret

;I/O buffer allocation

;At the moment all of our buffers are the same size, so we use a
;bit mask showing availability of buffers, not pages.  A bit
;turned on indicates something is there, as this is easier to find.

numbfs==64.	;number of buffers possible
winpgs==4
;fremap is initially an array of 64 bits

;GETBUF
;W2 - number of pages to get
;returns address in W2

getbuf:	caie w2,winpgs
	jrst [err /Bad request - GETBUF/]
	seto w2,	;assume nothing there
	skipe fremap+1	;anything in second word?
	movei w2,1	;yes - use it if not in first
	skipe fremap	;anything in first word?
	setz w2,	;yes - use it
	jumpl w2,[err /No space for I-O buffer/]
;w2 is now a word in FREMAP having an entry
	move w3,fremap(w2) ;get the word
	jffo w3,getbf1
	err /Impossible error in GETBUF/
getbf1:	movsi w3,400000	;make up mask
	movn w4,w4
	lsh w3,(w4)
	andcam w3,fremap(w2)
	movn w4,w4
	imuli w2,36.	;number of bits per word
	add w2,w4	;w2 now has a buffer number
	imuli w2,winpgs	;now we have a page number
	lsh w2,9.	;to address offset
	add w2,[bufst]	;and real address in section
	ret		;that's it

;RELBUF
;W2 - address
;W3 - number of pages
relbuf:	caie w3,winpgs	;better be this
	jrst [err /Bad request - RELBUF/]
	sub w2,[bufst]	;get to address offset
	lsh w2,-9.	;to page number
	idivi w2,winpgs	;to buffer number
	idivi w2,36.	;to word and bit
	movsi w4,400000	;mask
	movn w3,w3
	lsh w4,(w3)	;now have bit in right place
	iorm w4,fremap(w2) ;in right word
	ret

;pmap I/O - device-dependent routines

;break - force out the buffer - this is close for read-only
dskbrk:	skipge ch%pag(o1)	;anything there?
	ret			;no - nothing to do
	seto nil1,		;clear the pages
	move w2,ch%buf(o1)	;this core address
	lsh w2,-9.		;convert to page
	hrli w2,400000		;in this process
	move w3,[pm%cnt\winpgs]	;this many
	pmap
	 chkquo
	 erjmp opfer		;error with file in O1
	setz w2,
	exch w2,ch%buf(o1)	;address of buffer
	movei w3,winpgs		;size
	call relbuf		;release the space
	setz nil1,
	ret

;close for read/write modes
dskclo:	call dskbrk		;force the last buffer
	hrli nil1,400000\.fbbyv	;byte size, suppress updating disk copy
	hrr nil1,ch%jfn(o1)
	move w3,ch%bpt(o1)
	hrlzi w2,007700		;mask
	chfdb
	 erjmp .+1		;if not open for output, ignore
	hrli nil1,.fbsiz	;no. of bytes
	hrr nil1,ch%jfn(o1)
	move w3,ch%lby(o1)
	seto w2,		;all bits
	chfdb
	 erjmp .+1
	setz nil1,
	ret

	subttl pmap I/O - random access

;setpos - file is O2, position is W2
;skips if works, error is non-skip

;dskmov - internal routine to move to new place
dskmov:	caige w2,0		;if less than zero
	move w2,ch%lby(o2)	;use end of file
	push p,w2		;save desired byte in W4
	idiv w2,ch%pgs(o2)	;w2 _ pages, w3 _ bytes off in page
	sub w2,ch%pag(o2)	;w2 _ pages from start of buffer
	cail w2,0		;is it in the window
	cail w2,winpgs
	jrst dskmv1		;no - need a new page
dskmv2:	pop p,ch%cby(o2)	;we are now at requested place
  ;compute byte count
	move w2,ch%pag(o2)	;compute bytes left in buffer - bytes to start
	imul w2,ch%pgs(o2)
	sub w2,ch%cby(o2)	;- (current - start of window)
	movn w4,w2		;for later: w4 = current - start of window
	add w2,ch%bfs(o2)	;bytes left in window
	movem w2,ch%bct(o2)
  ;compute byte pointer - this code is because ADJBP doesn't work for 2-word
	move w3,ch%bpt(o2)	;get the byte size from the current pointer
	tlz w3,770040		;00nn00,,0
	tlo w3,440000		;44nn00,,0
	adjbp w4,w3		;w4 - one-word bpt from zero
	tlo w4,000040		;LH is now LH of 2-word
	hllm w4,ch%bpt(o2)
	hrre w4,w4		;address portion only
	add w4,ch%buf(o2)	;add to start of buffer
	movem w4,ch%bpt+1(o2)	;this is second word of 2-word pointer
	aos (p)			;good (skip) return
	ret

dskmv1:	move w3,(p)		;get back target byte
	idiv w3,ch%pgs(o2)	;w3 _ pages
	call getfpg		;get file page
	 jrst .+1		;error
	jrst dskmv2		;it worked
	adjsp p,-1		;fail return
	ret

dskcpo:	move w2,ch%cby(o1)
	aos (p)
	ret

;error handling

;chkquo - special thing designed to be used with ERCAL after a
;jsys that may write to disk.  If quota is exceed, gives a
;message that looks just like the EXEC's, and retries the jsys
;if continued.
quochk:	push p,nil1
	push p,w2
	movei nil1,400000
	geter
	tlz w2,777777		;b _ error code
	caie w2,iox11		;is it quota problem?
	cain w2,pmapx6
	jrst isquot		;yes
;not a quota problem, do the next instruction, including erjmp/cal
;simulation.
	move nil1,-2(p)		;ret addr
	hlrz w2,(nil1)		;next inst
	cain w2,(erjmp)		;is erjmp?
	jrst dojmp
	cain w2,(ercal)		;is ercal?
	jrst docal
retba:	pop p,w2		;no, normal return
	pop p,nil1
	ret

;here are the erjmp/cal simulations
dojmp:	hrrz w2,(nil1)		;address to go to
	hrrm w2,-2(p)		;make us return there
	jrst retba

docal:	hrrz nil1,(nil1)	;address to call
	hll nil1,(p)		;left half should be callers section
	pop p,w2
	exch nil1,(p)
	adjsp p,-1		;we now have goto addr 1(p)
	aos (p)			;return after the next ercal
	jrst @1(p)		;this is pjrst

;here if it is a quota problem
; print a message, and then prepare to retry the instruction
isquot:	hrroi nil1,[asciz / Quota exceeded or disk full
[Find some space, then type CONTINUE]
/]
	esout
; Finally we are ready to restore to the user's context and continue,
; is user types CONTINUE
	pop p,w2
	pop p,nil1
	sos (p)			;make return point to thing before QUOCHK
	sos (p)
	haltf			;let him delete some files
	ret

;disk dispatch

dskdsp:	codsec,,dskcpo		;curpos
	codsec,,dskmov		;setpos
	codsec,,dskclo		;close

;for read-only
dskrds:	codsec,,dskcpo		;curpos
	codsec,,dskmov		;setpos
	codsec,,dskbrk		;close

;here is what the dispatch routines must do:
;	curpos - file in O1, return position in W2.  Wn's are free
;	setpos - file in O2, position in W2 ; skips if it works. Wn's are free
;	close - file in O1.  Wn's are free

;Here are the routines for normal files

norcpo:	hrrz nil1,ch%jfn(o1)
	rfptr
	 erjmp .+2
	aos (p)
	setz nil1,
	ret

norspo:	hrrz nil1,ch%jfn(o2)
	sfptr
	 erjmp .+2
	aos (p)
	setz nil1,
	ret

;And here is the dispatch for them

nordsp:	codsec,,norcpo
	codsec,,norspo
	codsec,,cpopj

;This is for channels not yet open or open on odd streams

errdsp:	codsec,,errio
	codsec,,errio
	codsec,,errio




;;TY%CHN
;;TY%ATM
;special read for readlist
rdlget:	move o3,ch%dat(o2)	;get tail of list
	camn o3,[%dointern]	;see if trying to go beyond end
	jrst [err /READLIST: list ends before end of object/]
	jumpe o3,rdleof		;just at end of list
	docar o4,o3		;current element
	docdr o3,o3		;advance for next time
	movem o3,ch%dat(o2)
	xtype o4		;get type
	xct rdltab(w2)		;and dispatch on type
;falls through here if NIL
	movei w2,"N"
	ret

rdltab:	jumpn o4,rdlatm		;normal atom (except nil)
	jrst rdlerr		; cons
	jrst rdlstr		; string
	jrst rdlerr		; channel
	jrst rdlerr		; vector
	jrst rdlerr		; hash table
	jrst rdlerr		; address
	jrst rdlerr		; array
	jrst rdlerr		; lflon
	jrst rdlerr		; iflon
	jrst rdlerr		; iflon
	jrst rdlerr		; ratio
	jrst rdlerr		; complex
	jrst rdlerr		; bignum
	jrst rdlerr		; neg integer
	jrst rdlint		; pos integer

rdlstr:	skipa w3,o4

rdlatm:	move w3,at%pna(o4)	;put byte ptr to pname in -1(p)
	tlz w3,770000		;clear type code
	hrlzi w2,010740		;w2,w3 are extended BP
	ildb w2,w2		;first byte
	ret

rdlerr:	move o1,o4
	perr /arg to READLIST must be a character/

rdleof:	movei w2," "		;give him a space at the end
	move o3,[%dointern]	;and set special flag
	movem o3,ch%dat(o2)	;to kill him next time
	ret

;rdlint - if integer, we treat it as ascii value
rdlint:	move w2,o4
	posnum w2
	cail w2,0
	caile w2,177+9.		;200 to 211 is kludge for 0-11
	jrst rdlerr
	caige w2,10.		;except if 0-9
	addi w2,"0"		;it is handled as digit
	andi w2,177		;200-211 kludge
	ret

;special routine for PACK
pckget:	ildb w2,ch%bpt(o2)
	jumpe w2,rdleof		;and indicate EOF if end
	ret

;;;;;;;;;;;;;;MISC INPUT-RELATED FUNCTIONS;;;;;;;;;;;;;;;;;;;;


;;TY%INT
readch:	call tyi
	move o1,@[<o1_30.>\<datsec,,charar>] ;get atom for this char	
	ret

;;TY%CHN
;clearin - clear input buffer
clrin:	move o2,@[datsec,,.curin] ;current input chan
	setzm ch%lka(o2)
	setzm ch%lst(o2)
	hrrz nil1,ch%jfn(o2)	;jfn
	cain nil1,.priin	;priin is special
	setzm trmcnt
	jumpe nil1,cpopn1	;if no jfn, forget it
	cfibf
	setz nil1,
	ret

;can't open binary tty output
ttoper:	hrroi nil1,[asciz /Can't open JFN for binary TTY output/]
	esout
	movei nil1,.priou
	movem nil1,@[datsec,,binchn+ch%jfn]
	jrst ioin1

;check stack limit and redo if needed.  If case debugger has released
;the limit.
chstlm:	skipe @[datsec,,.%%STKLIM]	;only do this if not done
	ret
	hrroi nil1,[asciz /
[Reducing stacks to normal size]
/]
	psout
	seto nil1,			;kill the extra pages
	move w2,[.fhslf,,endq_-9.]	;start at top of normal
	move w3,[pm%cnt+<<endqs-endq>_-9.>] ;to end of section
	pmap				;clear them all
;limit stack usage, so we trap PDL overflows in time to call debugger
limstk:	move o1,[%T]
	movem o1,@[datsec,,.%%STKLIM]	;say limit has been done
;put illegal pages in to limit memory usage
	moves @[endp]			;create the page
	move nil1,[.fhslf,,endp/1000]	;end of P
	setz w2,			;no access
	spacs
	moves @[endsp]			;create the page
	move nil1,[.fhslf,,endsp/1000]	;end of SP
	setz w2,			;no access
	spacs
	moves @[endq]			;create the page
	move nil1,[.fhslf,,endq/1000]	;end of Q
	setz w2,			;no access
	spacs
	setz nil1,
	ret	

;EXPSTK - allow access to the whole section, to allow debugging after PDL ovrfl
expstk:	setzm @[datsec,,.%%STKLIM]	;say need to reset them later
;put illegal pages in to limit memory usage
	move nil1,[.fhslf,,endp/1000]	;end of P
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	move nil1,[.fhslf,,endsp/1000]	;end of SP
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	move nil1,[.fhslf,,endq/1000]	;end of Q
	movsi w2,(pa%rd\pa%wt\pa%ex)	;full access
	spacs
	setz nil1,
	jrst (w3)

ioinit:	
;open jfn on TTY in binary mode, put it in BINTTY
	moves @[bufill]			;create the page
	move nil1,[.fhslf,,bufill/1000]	;illegal page in buf sec, to stop Q
	setz w2,			;no access
	spacs
	dmove w2,[-1 ? 777777777400]	;say all I/O buffer pages free
	dmovem w2,fremap
	movsi nil1,(gj%fou\gj%phy\gj%sht)
	hrroi w2,[asciz /TTY:/]
	gtjfn
	 erjmp ttoper
	move w2,[<10_30.>\of%rd\of%wr] ;binary access
	openf
	 erjmp ttoper
	movem nil1,@[datsec,,binchn+ch%jfn]
;initialize I/O state stuff
ioin1:	setzm trmcnt		;force read on first try
	move w2,@[datsec,,priin] ;init current channels
	movem w2,@[datsec,,.curin]
	setzm ch%lka(w2)	;clear lookahead
	setzm ch%lst(w2)
	movei nil1,.priou	;get the tty page width
	movei w2,.morlw
	mtopr
	move w2,@[datsec,,priout]
	movem w3,ch%len(w2)	;set linelength to tty width
	movem w2,@[datsec,,.curout]	;set current out to tty
	setzm @[datsec,,.rdtop]
	movei nil1,.fhslf
;turn on ^C interrupt
	rpcap
	tlo w3,(sc%ctc)		;enable control-C
	epcap
;enable char interrupts
	movei nil1,2
	movem nil1,cnccnt
	setzm crit		;not in critical section
	movei nil1,.fhslf
	move w2,[codsec,,sirarg]
	xsir%
	eir
	movei nil1,.fhslf
	move w2,[770547,,106000] ;channels to enable
	aic
;These are the mandatory channels
	move nil1,["C"-100,,0]	;^C on channel 0
	ati
	 erjmp [hrroi nil1,[asciz /
% Can't trap ^C - Use (EXIT) to reset terminal modes
/]
		psout
		jrst .+1]
	move nil1,erchin	;^G on channel 3 (unless reset)
	tlnn nil1,400000	;if -1 LH, none at all
	ati	
;Now turn on or off the optional interrupts
	move o1,@[datsec,,.debiok] ;turn on or off the optional ones
	call debint		;turn on the optional ones
	setz nil1,
	ret

;DEBUGINT - O1 is T to turn on, NIL to turn off, return old
debint:	move w2,[ati]		;assume turn on
	cain o1,0		;unless off
	move w2,[call dodti]
	move nil1,["D"-100,,1]	;^D on channel 1
	xct w2
	move nil1,["E"-100,,2]	;^E on channel 2
	xct w2
	move nil1,["H"-100,,4]	;^H on channel 4
	xct w2
	move nil1,["B"-100,,5]	;^B on channel 5
	xct w2
	move nil1,["Y"-100,,24.] ;^Y on channel 23
	xct w2
	setz nil1,
	exch o1,@[datsec,,.debiok] ;return old, set new
	ret

dodti:	hlrz nil1,nil1
	dti
	ret

sirarg:	3
	codsec,,levtab
	codsec,,chntab

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Interrupt system
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;We have to disable interrupts during the GC.  The way we will
;handle this is by using routines STCRIT and ENCRIT.  STCRIT
;will just set a flag CRIT.  ENCRIT will clear this flag and
;activate any delayed interrupt.  At the moment we will use
;only level 2.  The routine CHCRIT should be used to check if
;we are in a critical section and if so delay the interrupt.
;Note that only one interrupt at a time is delayed, the most
;recent.

	.vector lev1pc(2),lev2pc(2),lev3pc(2),cnccon(2)
	.scalar crit,cnccnt

;crit-
;  0 if not in critical section
;  -1 if in critical section, but no interrupts yet
;  chan number if in cricial section and an interrupt has happened.


levtab:	codsec,,lev1pc
	codsec,,lev2pc
	codsec,,lev3pc


;;;;;;The following routines must always preserve all AC's, stack, etc,
;;;;;; since they may be called anywhere.  They may however garbage
;;;;;; AC's if they have determined that they are about to abort, etc.

;^C - exit at next good time, unless he gets impatient
cncint:	
;if he has done 6 ^C's without an exit, don't check critical section, just exit
	sosge cnccnt		;if 6 ^C's,
	jrst cncdo		;just do it
;now do normal processing
	push q,[object ty%adr,0]
	call chcrit		;delay if in critical section
cncdo:	push p,nil1
	movei nil1,2		;rearm the count
	movem nil1,cnccnt
	movei nil1,.priin
	cfibf			;otherwise EXEC will see our typeahead
	hrroi nil1,[asciz /^C
/]
	psout
	call warncr
	pop p,nil1	
	haltf
	debrk

cnyint:	push p,nil1
	movei nil1,.priin
	cfibf			;otherwise EXEC will see our typeahead
	hrroi nil1,[asciz /^Y
/]
	psout
	call warncr
	pop p,nil1
	haltf
	debrk

;WARNCR - if in GC, warn the user
warncr:	hrroi nil1,[asciz /%% Beware - you are in the garbage collector.  CONTINUE is OK, but START 
   will result in an unusable core image.
/]
	skipe crit
	psout
	ret

;^D - to top level
cndint:	push q,[object ty%adr,1]
	call chcrit
kill:	movei nil1,7
	pbout
	setz nil1,
	move w2,[codsec,,restac]
	dmovem nil1,lev2pc
	debrk

;^E - (ERR NIL)
cneint:	push q,[object ty%adr,2]
	call chcrit
	move o1,nil
	move w2,[codsec,,uerr]
	movei nil1,7
	pbout
	setz nil1,
	dmovem nil1,lev2pc
	jsp w2,valsp
	debrk

;^G - (ERR 'ERRORX)
cngint:	push q,[object ty%adr,3]
	call chcrit		;delay if in critical section
	move o1,[%ERRORX]
	move w2,[codsec,,uerr]
	movei nil1,7
	pbout
	setz nil1,		;if interrupting the RDTTY, NIL1 is non-zero
	dmovem nil1,lev2pc	;zero flags and new PC
	jsp w2,valsp
	debrk

;^H - break later
cnhint:	push p,w2
	move w2,[jrst latbrk]	;now establish break
	movem w2,evhook
	pop p,w2
	debrk

latbrk:	move w2,[jfcl]
	movem w2,evhook
	err /Break caused by ^H/

;^B - break now
cnbint:	push q,[object ty%adr,5]
	call chcrit		;delay if in critical section
	move o1,makerr /Break caused by ^B/
	move w2,[codsec,,error]
	movei nil1,7
	pbout
	setz nil1,		;if interrupting the RDTTY, NIL1 is non-zero
	dmovem nil1,lev2pc	;zero flags and new PC
	jsp w2,valsp
	debrk

;VALSP - check for SP of odd size or with partial EVAL blip at top, due
;to interrupting an operation on the SP
;  This must be done at interrupt level, before the DEBRK
valsp:	move w3,savesp		;get known valid SP
	xor w3,sp		;compare with current
	trne w3,1		;if different parity
	adjsp sp,-1		;then adjust to valid
	skipe -1(sp)		;if partial EVAL blip
	jrst (w2)		;not - done
	push sp,[%savep]	;finish the blip
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	jrst (w2)	

;start critical section
stcrit:	setom crit		;say in critical section
	ret

;end critical section - this is called as a normal routine, so the AC's
;are free.  But we do have to prevent race conditions.
;Do any deferred interrupts.
encrit:	setz w3,
	exch w3,crit		;no longer critcal, see if anywhere to go
	jumpe w3,[halt .]	;not in critical section???
	jumpl w3,cpopj		;no interrupt happened
;here when we have defered an interrupt.  The channel number will be in
;CRIT, now in W3.
	hrlzi w2,400000		;make bit from bit number
	tlz w3,770000		;this was an object, so clear ty%adr
	movn w3,w3
	lsh w2,(w3)
	movei nil1,.fhslf
	iic
	setz nil1,
	ret

;this is called at interrupt level, so we are protected against
;further interrupts.  Thus we don't have to do anything fancy with
;EXCH, etc.
chcrit:	skipn crit		;in critical section?
	jrst chcrix		;no - exit
;we are in critical section - save the fact that int occured and debreak
	pop q,crit		;arg is interrupt channel
	adjsp p,-1		;forget ret addr
	debrk

chcrix:	adjsp q,-1		;forget arg
	ret

exit:	haltf
	ret

;ILLMEM - interrupt handler for illegal mem reads and writes
illmem:	move nil,@lev2pc+1	;get the bad instruction
	ldb nil,[.bp <740,,0>,nil] ;the AC field
;check for PDL overflow
	cain nil,p
	jrst regpdl		;P pdl
	cain nil,q
	jrst datpdl		;Q pdl
	cain nil,sp
	jrst spcpdl		;SP pdl
;check for data out of range
	move nil,@lev2pc+1	;the bad instruction
	tlz nil,777740		;change into XMOVEI NIL,
	tlo nil,(xmovei nil,)
	xct nil			;now have E.A. of instruction
	camg nil,[datsec+datsiz,,1000] ;see if just above data section 1
	camge nil,[datsec+datsiz-1,,777777]
	jrst .+2
	jrst freovr		;yes - free space overflow
	camg nil,[datsc2+datsiz,,1000] ;see if just above data section 1
	camge nil,[datsc2+datsiz-1,,777777]
	jrst .+2
	jrst freovr		;free space overflow in other space
	camg nil,[codsec+1,,1000] ;see if just above code section
	camge nil,[codsec,,777777]
	jrst .+2
	jrst codovr		;code space overflow
	dmove w2,[0 ? codsec,,grbptr]
	dmovem w2,lev2pc
	debrk
grbptr:	setzb nil,nil1
	move 
	err /Reference to illegal address - probable garbage pointer/

;various error processing routines
;PDL overflows - expand the stacks so we can use the debugger

regpdl:	hrroi nil1,[asciz / The control stack overflowed - probably too much recursion/]
	jrst dopdl

datpdl:	hrroi nil1,[asciz / The data stack overflowed - probably too much recursion/]
	jrst dopdl

spcpdl:	hrroi nil1,[asciz / The special stack overflowed - probably too much recursion/]
	jrst dopdl

dopdl:	esout
	skipn @[datsec,,.%%STKLIM]	;already in bad shape?
	jrst badpdl
	dmove w2,[0 ? codsec,,dopdl1]
	dmovem w2,lev2pc
	debrk
dopdl1:	jsp w3,expstk			;no - expand it
	jsp w2,valsp			;make sure SP is valid
	err /Expanding stacks temporarily to allow the debugger to run/

badpdl:	hrroi nil1,[asciz /
Your stack is already expanded, so we must return you to the top level of LISP
/]
	jrst fatal

freovr:	hrroi nil1,[asciz /You have run out of memory in Lisp free space.  Your program is probably 
too big.  We will return you to the top level of Lisp.  You should save any
data you can, because your core image is probably irretrievably garbaged.
/]
	jrst fatal

codovr:	hrroi nil1,[asciz /You have run out of memory in code space.  If you were not loading compiled
code, it is possible that what you really have is a garbage pointer.
/]
	jrst fatal

fatal:	esout
	setzb nil,nil1
	jrst kill

pdlovr:	dmove w2,[0 ? codsec,,pdlmsg]
	dmovem w2,lev2pc
	debrk
pdlmsg:	setzb nil,nil1
err /Pushdown list overflow.  This should be impossible.  Probably a bug in
the interpreter or compiled code./

sysres:	dmove w2,[0 ? codsec,,syrmsg]
	dmovem w2,lev2pc
	debrk
syrmsg:	hrroi nil1,[asciz /
System resources exhausted.  Probably you have run out of memory.
If so, your core image has probably been irretrievably lost.  
Type "CONTINUE" to try to restart Lisp.
/]
	psout
	haltf	;make him type continue, to avoid infinite loop
	setzb nil,nil1
	jrst restac

maxerr==40
	.vector errmsg(maxerr)	;place to put monitor error msg

illins:	dmove w2,[0 ? codsec,,ilsmsg]
	dmovem w2,lev2pc
	debrk
ilsmsg:	hrroi nil1,errmsg	;put it here
	move w2,[.fhslf,,-1]	;most recent error for this process
	hrlzi w3,-maxerr*5	;this many char's
	erstr
	 jrst illinx
	 jrst illinx
	move o1,[object ty%adr,errmsg] ;print the message returned
	setzb nil,nil1
	jrst error

illinx:	setzb nil,nil1
	err /The operating system has issued an error that we can't figure out/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  I/O channel stuff
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

fnaml==40
	.vector filnam(fnaml)

;;TY%ATM
;one arg - put name as asciz in filnam
mflnam:	jumpe o1,mflnil		;nil is special
	call getstr		;get valid string into o1
mflnm1:	move w2,(o1)		;get length code
	tlz w2,770000		;clear funny bits
	caile w2,fnaml		;if too long
	movei w2,fnaml		;use maximum length
	xmovei w3,1(o1)		;get addr of first data word
	move w4,[codsec,,filnam] ;put it here
	xblt w2,		;do the copy
	ret

mflnil:	err /Null file name/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here are the new file I/O functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;xopenf - this is OPENF.
; o1 - channel, or list of files
; o2 - NIL or list of options

define cntflg			;-1: continuous input
	0(p) termin
define gtjbts			;gtjfn bits
	-1(p) termin
define opfbts			;openf bits
	-2(p) termin
define errflg			;-1: return NIL if error
	-3(p) termin

gn%cnt==gn%dir			;flag for doing continous proceed to next

xopenf:	push p,[0]		;place for bits to go
	push p,[0]
	push p,[0]
	push p,[0]
;check options arg type
	jumpe o2,openfj		;none - do gtjfn
	scons o2
	jrst [move o1,o2
	      perr /OPENF options must be a list/]
;we now have a valid option list in O2
openf1:	docar o3,o2		;o3 - current option
	gettyp o3
	cain w2,ty%lpi		;may be byte size
	jrst opfbsz
	camn o3,[%OLD]
	jrst opfold
	camn o3,[%NEW]
	jrst opfnew
	camn o3,[%NEWVERSION]
	jrst opfnve
	camn o3,[%WILD]
	jrst opfwld
	camn o3,[%CONTINUOUS]
	jrst opfcnt
	camn o3,[%UEROR]	;ERROR
	jrst opferr
	camn o3,[%IN]
	jrst opfin
	camn o3,[%OUT]
	jrst opfout
	camn o3,[%APPEND]
	jrst opfapp
	move o1,o3
	perr /Unknown OPENF option/

openf2:	docdr o2,o2		;next option
	jumpn o2,openf1		;if any
	jrst openfj		;none - now gtjfn

;here are the option processors
opfnew:	skipa w2,[gj%new]
opfold:	movsi w2,(gj%old)
	iorm w2,gtjbts
	jrst openf2

opfnve:	skipa w2,[gj%fou]
opfwld:	movsi w2,(gj%ifg)
	iorm w2,gtjbts
	jrst openf2

opfin:	skipa w2,[of%rd]
opfout:	movei w2,of%wr
	iorm w2,opfbts
	jrst openf2

opfapp:	movei w2,of%app
	iorm w2,opfbts
	jrst openf2

opfcnt:	setom cntflg
	jrst openf2

opferr:	setom errflg
	jrst openf2

opfbsz:	move w2,o3		;move into byte size field
	lsh w2,30.
	iorm w2,opfbts		;and put it in OPENF
	jrst openf2

;now we have the bits set up in the stack - O1 is file list
;Make channel and do GTJFN if needed
;This entry is used by INPUT and OUTPUT
openfj:	xtype o1
	cain w2,ty%xch		;if already a channel
	jrst openfo		;go directly to OPEN
	scons o1		;if list
	jrst [push q,nil	;not - treat it as singleton
	      jrst openf3]
	push q,o1		;save arg list
	docar o1,o1		;get first one for now
openf3:	call mflnam		;put name in FILNAM
	move nil1,gtjbts	;find the gtjfn bits
	tlo nil1,(gj%sht+gj%flg) ;standard bits
	hrroi w2,filnam
	gtjfn
	 erjmp [skipn errflg
		jrst oper
		adjsp q,-1
		adjsp p,-4
		setzb nil1,o1
		ret]
	skipe cntflg		;if asking for continuous
	tlo nil1,(gn%cnt)	;then set that bit
	call makchn		;make a channel with that JFN in it
	pop q,o2		;get back arg list
	docdr o2,o2		;any more?
	jumpe o2,openfo		;no - done
	sos ch%spc(o1)		;yes - put the rest in list
	movem o2,ch%dat(o1)
;Open the file if called for.
; This entry is used by eoferr
openfo:	skipn opfbts		;does he want any open functions?
	jrst openfx		;no - forget it - channel already in O1
	hrrz nil1,ch%jfn(o1)	;get JFN
	gtsts			;see if it is open
	tlnn w2,(gs%opn)	;is it open?
	jrst openff
 ;file is open, we must close it
	movsi w2,(co%nrj)	;don't release JFN!
	call doclos		;dev-specific and monitor close
	 jrst opfer
openff:	hrrz nil1,ch%jfn(o1)	;get back pure jfn
	dvchr			;see what we have
	ldb w4,[.bp 777_18.,w2]	;device type
	hrrz nil1,ch%jfn(o1)	;get back jfn again
	move w2,opfbts		;and openf bits
	tlnn w2,770000		;already have byte size?
	tlo w2,070000		;no - add in 7-bit mode
 ;this is code to let us try simulating append with normal read/write I/O
	cain w4,.dvdsk		;disk?
	trnn w2,of%app		;append?
	jrst openfn		;no or no - just go ahead
	trz w2,of%app		;first try to let us simulate - clear append
	tro w2,of%wr\of%rd	;first try to let us simulate using read/write
	openf
	 erjmp [move w2,opfbts		;oh, well, try again the original way
		tlnn w2,770000		;already have byte size?
		tlo w2,070000		;no - add in 7-bit mode
		hrrz nil1,ch%jfn(o1)	;get back pure jfn
		jrst openfn]
	jrst openfy
 ;end of special append code
openfn:	openf
	 erjmp [skipn errflg
		jrst opfer
		adjsp p,-4
		rljfn
		 erjmp .+1
		setzb nil1,o1
		ret]
;we now have a file open.  Do device depend initialization if needed
openfy:	move w4,opfbts
	call opendv
;done - restore things
openfx:	adjsp p,-4
	setzb nil,nil1
	ret

;OPENDV is a general routine, usable by anyone who opens files and
;wants the right device-specific stuff.  We assume that the channel
;has already been set up except the DSK specific stuf.  W4 contains
;the OPENF bits, including byte size.
opendv:	move w2,[codsec,,norget] ;initialize for random device
	movem w2,ch%get(o1)
	move w2,[codsec,,norput]
	movem w2,ch%put(o1)
	move w2,[codsec,,nordsp]
	movem w2,ch%dsp(o1)
	hrrz nil1,ch%jfn(o1)	;get back pure jfn
	dvchr			;see what we have
	ldb w2,[.bp 777_18.,w2]	;device type
	cain w2,.dvdsk		;disk?
	call dskopn		;yes - set up for PMAP I/O
	setz nil1,
	ret

;RENAME
; o1 - file or channel
; o2 - file name
; o3 - non-NIL to suppress release
;returns file name if it works, NIL if not
rename:	push q,o3		;save args
	push q,o2
	move o2,[object ty%ccn,<datsec,,oldopt>]  ; '(OLD ERROR)
	call xopenf		;get jfn if necessary
	jumpe o1,renerr		;if error, stop
	hrrz nil1,ch%jfn(o1)	;close if still open
	gtsts
	tlnn w2,(gs%opn)	;if open
	jrst renam1
	movsi w2,(co%nrj)	;don't release
	call doclos		;dev-specific and monitor close
	 jrst renerr
renam1:	exch o1,(q)		;save channel, get new name
	call mflnam		;put name in FILNAM
	move nil1,[gj%fou+gj%sht] ;get jfn for new file
	hrroi w2,filnam
	gtjfn
	 erjmp renerr
	move w2,nil1		;2 - new jfn
	move o1,(q)		;old channel
	hrrz nil1,ch%jfn(o1)	;1 - old jfn
	rnamf
	 erjmp renerr
	movem w2,ch%jfn(o1)	;channel now has new JFN
	skipe -1(q)		;allow close?
	jrst renex		;no - done
	move nil1,w2		;yes - release
	rljfn
	 erjmp .+1
	setzm ch%jfn(o1)	;everything is gone now
renex:	adjsp q,-2
	setz nil1,
	ret

renerr:	setzb nil1,o1
	adjsp q,-2
	ret

;DELETE
; o1 - file or channel
; o2 - non-NIL to suppress release
;returns file name if it works, NIL if not
delete:	push q,o2		;save args
	move o2,[object ty%ccn,<datsec,,oldopt>]  ; '(OLD ERROR)
	call xopenf		;get jfn if necessary
	jumpe o1,delerr		;if error, stop
	hrrz nil1,ch%jfn(o1)	;close if still open
	gtsts
	tlnn w2,(gs%opn)	;if open
	jrst delet1
	movsi w2,(co%nrj)	;don't release
	call doclos
	 jrst delerr
delet1:	hrrz nil1,ch%jfn(o1)
	skipe (q)		;keep jfn?
	tlo nil1,(df%nrj)	;yes
	delf
	 erjmp delerr
	skipn (q)		;keep jfn?
	setzm ch%jfn(o1)	;no - none left
	setz nil1,
	adjsp q,-1
	ret

delerr:	setzb nil1,o1
	adjsp q,-1
	ret
	
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here are the old file I/O functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;xinput - this is OPENIN.  It is an FEXPR that takes a list of file names.

xinput:	push p,[0]
	push p,[070000000000+of%rd]
	push p,[gj%old+gj%ifg+gj%flg+gj%sht]	;allow wildcards
	push p,[-1]		;continue to next file
	jrst openfj		;now let openf do it

;;TY%CHN
;makchn - make channel object for real I/O device, jfn in NIL1
makchn:	push free,[object ty%spc,ch%666] ;GC code
	move w2,free		;save addr to return
	push free,nil1		;jfn
	push free,[72.]		;len
	push free,[0]		;pos
	push free,[codsec,,errio] ;get
	push free,[codsec,,errio] ;put
	push free,[0]		;lka
	push free,[0]		;lst
	push free,[codsec,,errdsp] ;normal dispatch table
	movei w3,ch%666-ch%dsp	;number of extra entries needed
	push free,[0]
	sojg w3,.-1
	tlo w2,(object ty%chn,0)
	move o1,w2		;return new channel
	setz nil1,
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

xoutpu:	push p,[0]
	push p,[070000000000+of%rd+of%wr]
	push p,[gj%fou+gj%sht]
	push p,[0]
	jrst openfj		;now let openf do it

;here for error from openf - file in O1
;actually the error message used is from the monitor, so this case
;be used for any error in which there is a file in O1
opfer2:	move o1,o2		;file is on O2
opfer:	hrrz w2,ch%jfn(o1)	;get name for this file
	hrroi nil1,filnam
	setz w3,		;default format
	jfns
;here for error from gtjfn - file name in FILNAM
oper:	hrroi nil1,errmsg	;put it here
	move w2,[.fhslf,,-1]	;most recent error for this process
	hrlzi w3,-maxerr*5	;this many char's
	erstr
	 jrst operx
	 jrst operx
	move o6,[object ty%adr,errmsg] ;print the message returned
	move o1,[object ty%cst,<codsec,,filnam-1>]
	jrst perror

operx:	perr /Error in file operation/

;;TY%CHN
;JFNS 
; O1 - channel or string
; O2 - format bits, as integer
xjfns:	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst stjfns		;if string or atom, special
	skipn w2,ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	trne w2,777700		;and legal range for JFN (i.e. no .PRIIN)
	jrst [perr /JFNS is only legal for files/]
	push free,[object(ty%spc,0)] ;now make string - dont know how big
	exch o1,o2		;get code into O1
	skipn o1		;if nil
	move o1,[object(ty%lpi,0)] ;use default
	call get1nt		;value into W2
	move w3,w2		;this is format
	move nil1,[.bp 376,(free)] ;destination - free space
	hrrz w2,ch%jfn(o2)	;source - this file
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
;now we have to make sure the unused portions of these words are zero
strret:	movei w4,1		;clear this bit
	hrrz w2,nil1		;we used this many words
	hrrm w2,(free)		;note that fact in header
	move o1,free		;remember start as final string
	tlo o1,(object(ty%str,0))
	jumpe w2,xjfns2		;now loop over words
xjfns1:	aoj free,		;incrementing free
	andcam w4,(free)	;and clearing bit
	sojg w2,xjfns1
xjfns2:	seto w3,		;now handle the last word
	setz w2,		;w2,w3 = 0,,0,,-1,,-1
	lsh nil1,-30.		;nil1 is now offset to rightmost bit used
	lshc w2,(nil1)		;give us ones for the rest
	andcam w2,(free)	;and clear those bits in last word
	setz nil1,		;that's it - O1 was set above
	camle free,lastl	;see if need GC
	 call sgc
	ret		

;STJFNS - O1 is a string.  We want to use JFNS to return a certain
; field from the string.  To do this, we get a parse-only JFN on it,
; do the JFNS, and then release the JFN.
stjfns:	call getstr
	movsi nil1,(gj%sht+gj%ofg) ;parse-only jfn
	move w2,[440705,,1]	;POINT 7,1(O1)
	gtjfn
	 erjmp retnil
	push free,[object(ty%spc,0)] ;now make string - dont know how big
	exch o1,o2		;get code into O1
	skipn o1		;if nil
	move o1,[object(ty%lpi,0)] ;use default
	call get1nt		;value into W2
	move w3,w2		;this is format
	move w2,nil1		;jfn in W2
	move nil1,[.bp 376,(free)] ;destination - free space
	jfns
	 erjmp retnil		;if error, give him NIL
	idpb nil,nil1		;advance to the zero
	push p,nil1		;save pointer
	move nil1,w2		;JFN to 1
	rljfn
	 erjmp .+1
	pop p,nil1
	jrst strret	

;(GTFDB chan word#)
xgtfdb:	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn nil1,ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	trne nil1,777700	;and legal range for JFN (i.e. no .PRIIN)
	jrst [perr /GTFDB is only legal for files/]
	hrrz nil1,nil1		;get JFN part only
	move o1,o2		;get integer value
	call get1nt		;into W2
	hrli w2,1		;count in left
	movei w3,o1		;place to put result
	gtfdb
	setz nil1,
	move w2,o1
	jrst ret1nt

;;TY%CHN
ddtin:	move w2,[codsec,,trmget] ;normal terminal input routine
	skipe o1		;but if DDTIN T
	move w2,[codsec,,ddtget] ;special routine
	exch w2,@[datsec,,inchn+ch%get] ;use as read char
	move o1,nil		;return prev
	came w2,[codsec,,trmget]
	move o1,[%T]
	ret

;;TY%CHN
;INCH - return current input 
inch:	move o1,@[datsec,,.curin]
	camn o1,@[datsec,,priin] ;return NIL if primary input
	move o1,nil
	ret

;;TY%CHN
;OUTCH - return current output
outch:	move o1,@[datsec,,.curout]
	camn o1,@[datsec,,priout] ;return NIL if primary output
	move o1,nil
	ret

;;TY%CHN
inc:	jumpe o2,inc1		;no close
	push q,o1		;save arg
	move o1,@[datsec,,.curin]
	call xclose
	pop q,o1		;get back new chan
inc1:	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	exch o1,@[datsec,,.curin]
	camn o1,@[datsec,,priin] ;return NIL if primary input
	move o1,nil
	ret

;;;;;CWTHIN and CWTHOU are for compiled functions:
;;;;;  move o1,channel   ;non-NIL corresponds to T in WITHIN
;;;;;  move o2,flag
;;;;;  call cwthin
;;;;;  jrst ret+1
;;;;;  code inside the within
;;;;;  ret


;;TY%CHN
;WITHIN - For compactness, we use the special coroutine kludge designed
;  for compiled code
within:	setz o3,		;assume the close flag is not given
	docar o2,o1		;look at car
	came o2,[%T]		;if T, then must save for close on exit
	jrst wthin1
	move o3,o2		;it was - say so
	docdr o1,o1		;and skip over the T
wthin1:	pushcdr q,o1		;save forms
	push q,o3		;and flag
	docar o1,o1		;get channel
	call eval
	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
;now that the args are set up, we do a call to CWTHIN, just as would
;be done from compiled code
				;o1 is already the channel
	pop q,o2		;o2 is the flag
	pop q,o3		;o3 is the code to execute
	call cwthin
	 jrst cpopj		;this is done at the end
	 move o1,o3		;here is the thing we do
	 call progn		;a progn
	 ret			;returns to the JRST CPOPJ

;;TY%CHN
;WITHOUT - For compactness, we use the special coroutine kludge designed
;  for compiled code
withou:	setz o3,		;assume the close flag is not given
	docar o2,o1		;look at car
	came o2,[%T]		;if T, then must save for close on exit
	jrst wthou1
	move o3,o2		;it was - say so
	docdr o1,o1		;and skip over the T
wthou1:	pushcdr q,o1		;save forms
	push q,o3		;and flag
	docar o1,o1		;get channel
	call eval
	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary output
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
;now that the args are set up, we do a call to CWTHOU, just as would
;be done from compiled code
				;o1 is already the channel
	pop q,o2		;o2 is the flag
	pop q,o3		;o3 is the code to execute
	call cwthou
	 jrst cpopj		;this is done at the end
	 move o1,o3		;here is the thing we do
	 call progn		;a progn
	 ret			;returns to the JRST CPOPJ


;;;;;CWTHIN and CWTHOU are for compiled functions:
;;;;;  move o1,channel   ;non-NIL corresponds to T in WITHIN
;;;;;  move o2,flag
;;;;;  call cwthin
;;;;;  jrst ret+1
;;;;;  code inside the within
;;;;;  ret

;;TY%CHN
cwthin:	cain o1,nil		;if nil
	move o1,@[datsec,,priin] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
  ;now we want to do (UNWIND-PROTECT --body-- (CLOSE file))
	push p,sp		;save for unbind
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	movem o1,@[datsec,,.curin] ;and reset to whatever he asked for
	jumpe o2,cwthn2		;skip following if not flagged
	push sp,[%CFILES]
	push sp,@[datsec,,.cfiles] ;save file to be closed
	movem o1,@[datsec,,.cfiles]
	push sp,[%UNWIND]	;unwind trap
	push sp,[object ty%adr,<codsec,,cwthic>] ;at this address
cwthn2:	call wtherr		;this does what the user wanted, in an errset
	 skipa			;error return - diagnose it
	jrst cubind		;normal return - restore channel, closing
	came o1,[%$eof$]	;end of file?
	call uerr		;no - just propagate the error
	setz o1,		;yes - return nil
	jrst cubind

;unwind trap for WITHIN - close the file
cwthic:	move o1,@[datsec,,.cfiles] ;get current file to close
	jrst xclose		;and close it

;WTHERR is the ERRSET inside WITHIN
wtherr:	move o1,[%T]		;make this a default errset
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG]	;save F for ERROR
	movem o1,@[datsec,,.ERRFLAG]
	move w2,-4(p)		;get address to go to for user's code
	call 1(w2)
	aos -2(p)		;if we get to here, it is success
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst cubind		;restores old TOPERR


;;TY%CHN
cwthou:	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary input
	xtype o1		;make sure its a channel
	caie w2,ty%xch
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
  ;(UNWIND-PROTECT --body-- (CLOSE file))
	push p,sp		;save for unbind
	push sp,[%CUROU]	;save current channel
	push sp,@[datsec,,.curou]
	movem o1,@[datsec,,.curou] ;and reset to whatever he asked for
	jumpe o2,cwtho2		;skip following if not flagged
	push sp,[%CFILES]
	push sp,@[datsec,,.cfiles] ;save file to be closed
	movem o1,@[datsec,,.cfiles]
	push sp,[%UNWIND]	;unwind trap
	push sp,[object ty%adr,<codsec,,cwthic>] ;at this address
cwtho2:	move w2,-1(p)		;get ret addr
	call 1(w2)		;call one beyond
	jrst cubind		;restore channel, closing files

;;TY%CHN
outc:	jumpe o2,outc1		;no close
	push q,o1		;save new chan
	move o1,@[datsec,,.curout]
	call xclose
	pop q,o1		;get back new chan
outc1:	cain o1,nil		;if nil
	move o1,@[datsec,,priout] ;use primary output
	xtype o1		;make sure its a channel
	caie w2,ty%xch	
	jrst illchn		;not - illegal
	skipn ch%jfn(o1)	;and make sure it has a jfn
	jrst notopn		;not open
	exch o1,@[datsec,,.curout]
	camn o1,@[datsec,,priout] ;return nil if priout
	move o1,nil
	ret

;;TY%CHN
;This function should never give an error, unless it is given an object
;that couldn't be a legal channel.  I.e. it should be legal to close
;channels that are already closed, etc.
xclose:	jumpe o1,cpopn1		;if nil, no-op
	setz o2,		;release JFN
closef:	xtype o1		;make sure legal channel number
	caie w2,ty%xch
	jrst illchn
	hrrz nil1,ch%jfn(o1)	;get jfn
	caie nil1,.priin	;if pri in or pri out, noop
	cain nil1,.priou
	jrst cpopn1
	jumpe nil1,retnil	;also if nothing there any more, already done
	gtsts
	 erjmp closz		;trap all errors
	tlnn w2,(gs%nam)	;something wrong with JFN?
	jrst closz		;yes - forget it all
	tlnn w2,(gs%opn)	;is it open?
	jrst closno		;no - release it instead
	push q,o2		;save flag
	setz w2,		;no funny bits
	skipe o2		;except if requested to keep jfn
	tlo w2,(co%nrj)		;then do so
	call doclos		;call common routine for actual close
	 jrst .+1
	pop q,o2
	skipn o2		;unless kept jfn
closz:	setzb o1,ch%jfn(o1)	;say nothing there now
closx:	setz nil1,
	ret

;here if JFN not open - release it instead
closno:	skipe o2		;if keeping JFN
	jrst closx		;nothing to do
	rljfn
	 erjmp .+1		;ignore errors
	setzb o1,ch%jfn(o1)	;nothing there now
	setz nil1,
	ret

;doclos - routine to close a file.  File in O1, close bits in W2
doclos:	push p,w2		;save bits
	move w2,ch%dsp(o1)	;dispatch
	call @ch%clo(w2)	;dev-specific close
	pop p,nil1		;get back bits
	hrr nil1,ch%jfn(o1)	;and add in JFN
	closf
	 erjmp .+2		;error return
	aos (p)			;normal return
	setz nil1,
	ret


illchn:	perr /Illegal I-O channel/

notopn:	perr /I-O channel not open/

;;TY%STR
;;TY%CHN
;;;;;(INSTRING string) create an input channel open on a string

instrg:	xtype o1
	caie w2,ty%xst
	 jrst isterr
	push free,[object ty%spc,ch%666-1] ;GC code
	move w2,free		;save addr to return
	push free,[-1]		;jfn
	push free,[72.]		;len
	push free,[0]		;pos
	push free,[codsec,,strtyi] ;get
	push free,[codsec,,strtyo] ;put
	push free,[0]		;lka
	push free,[0]		;lst
	push free,[codsec,,strdsp] ;normal dispatch table
	push free,[0]		;buf
	push free,[0]		;pag
	push free,[440740,,0]	;bpt
	push free,[030000,,1]	; bpt wd 2 = 0(2) global
	push free,[0]		;bct
	push free,[0]		;bfs
	push free,[0]		;cby
	move w3,(o1)
	move w4,(o1)
	add w4,o1
	getnum w3
	imuli w3,5
	tlz w4,770000
	move w4,(w4)
	trz w4,1
	  addi w3,1
	  lsh w4,7
	  jumpn w4,.-2
	subi w3,5
	push free,w3		;lby
	push free,[0]		;lts
	push free,[0]		;pgs
	push free,o1		;dat
	tlo w2,(object ty%chn,0)
	move o1,w2		;return new channel
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

isterr:	perr /INSTRING needs a string/

strtyi:	move w3,ch%dat(o2)
	ildb w2,ch%bpt(o2)
	jumpe w2,eofbad
	aos ch%cby(o2)
	ret

strtyo:	move w3,ch%dat(o2)
	ildb w4,ch%bpt(o2)
	jumpe w4,eofbad
	dpb w2,ch%bpt(o2)
	aos ch%cby(o2)
	ret

;	curpos - file in O1, return position in W2.  Wn's are free
;	setpos - file in O2, position in W2 ; skips if it works. Wn's are free
;	close - file in O1.  Wn's are free
strdsp:	codsec,,strcps
	codsec,,strsps
	codsec,,strcls

strcps:	move w2,ch%cby(o1)
	ret

strsps:	cail w2,0
	 camle w2,ch%lby(o2)
	  ret
	move w3,w2
	sub w3,ch%cby(o2)
	adjbp w3,ch%bpt(o2)
	dmovem w3,ch%bpt(o2)
	movem w2,ch%cby(o2)
	aos (p)
	ret

strcls:	setzm ch%jfn(o1)
	setzm ch%dat(o1)
	setzm ch%bpt(o1)
	setzm ch%bpt+1(o1)
	ret

oustrg:	skipn o1
	 move o1,[inum 72.]
	getnum o1
	push free,[object ty%spc,ch%666-2] ;GC code
	move w2,free		;save addr to return
	push free,[-2]		;jfn
	push free,o1		;len
	push free,[0]		;pos
	push free,[codsec,,errio] ;get
	push free,[codsec,,osttyo] ;put
	push free,[0]		;lka
	push free,[0]		;lst
	push free,[codsec,,ostdsp] ; dispatch table
	push free,[0]		;buf
	push free,[0]		;pag
	push free,[440740,,0]	;bpt
	push free,[030000,,1]	; bpt wd 2 = 0(2) global
	push free,[1025.]	;bct
	push free,[1025.]	;bfs
	push free,[0]		;cby
	push free,[0]		;lby
	push free,[0]		;lts
	push free,nil		;obl  --  old buffer list
	push free,nil		;dat
	tlo w2,(object ty%chn,0)
	move o1,w2		;return new channel
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	call ostnbf		;create initial output buffer
	ret

osttyo:	move w3,ch%dat(o2)
	idpb w2,ch%bpt(o2)
	sosle ch%bct(o2)
	 ret
	move o1,o2
	call ostnbf
	dmove w3,[440740,,0 ? 030000,,1]
	dmovem w3,ch%bpt(o2)
	move w3,[1025.]
	movem w3,ch%bct(o2)
	aos ch%pag(o2)
	ret

ostnbf:	push free,[object ty%spc,205.]
	move w2,free
	tlo w2,(<object ty%str>)
	movem w2,ch%dat(o1)
	move w3,ch%obl(o1)
	adjsp free,205.		;the string obj referred to earlier
	push free,w2		;;ty%con  sneaking a cons in here
	move w2,free
	push free,w3
	tlo w2,(<object ty%con>)	;;ty%con  end of cons
	movem w2,ch%obl(o1)
	movei w2,204.		;zero out the string
	move w3,ch%dat(o1)
	aos w4,w3
	aos w4
	setzm (w3)
	xblt w2,
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

;	curpos - file in O1, return position in W2.  Wn's are free
;	setpos - file in O2, position in W2 ; skips if it works. Wn's are free
;	close - file in O1.  Wn's are free
ostdsp:	codsec,,ostcps
	codsec,,ostsps
	codsec,,ostcls

ostcps:	move w2,ch%pag(o1)
	imuli w2,1025.
	addi w2,1025.
	sub w2,ch%bct(o1)
	ret

ostsps:	err /Can't SETPOS an output string/

ostcls:	setzm ch%jfn(o1)
	setzm ch%dat(o1)
	setzm ch%obl(o1)
	setzm ch%bpt(o1)
	setzm ch%bpt+1(o1)
	ret

;;(getstring <channel>) ==> string
ugtstr:	xtype o1
	caie w2,ty%xch
	 jrst stcerr
	move w2,ch%jfn(o1)
	came w2,[-2]
	 jrst stcerr
	skipe ch%pag(o1)
	 jrst gtstcp
	move o2,ch%dat(o1)
	movei w2,1030.
	sub w2,ch%bct(o1)
	idivi w2,5
	tlo w2,(<object ty%spc>)
	movem w2,(o2)
gtstrt:	setzm ch%obl(o1)
	call ostnbf
	dmove w3,[440740,,0 ? 030000,,1]
	dmovem w3,ch%bpt(o1)
	move w3,[1025.]
	movem w3,ch%bct(o1)
	setzm ch%pag(o1)
	setzm ch%pos(o1)
	move o1,o2
	ret

stcerr:	perr /not out string channel/

gtstcp:	move w2,ch%pag(o1)	;number of buffers filled
	imuli w2,205.		;wds per
	movei w3,1030.		;compute # chars in last
	sub w3,ch%bct(o1)
	idivi w3,5		;wds
	add w2,w3		;total new string length
	tlo w2,(<object ty%spc>)
	push free,w2		;strg header
	move o2,free		;will be strg pointer
	tlo o2,(<object ty%str>)
	adjsp free,(w2)
	move w4,free		;pointer for filling in new strg
	sub w4,w3		;back by #wds in last buffer
	addi w4,1
	move w2,w3		;count
	move w3,ch%dat(o1)	;buffer strg ptr
	addi w3,1
	move o3,w4		;save
	xblt w2,
	move o4,ch%obl(o1)	;list of buffers
stcbbl:	docdr o4,o4		;bass ackwards down the list
	jumpe o4,gtstrt
	docar w3,o4		;get a buffer
	addi w3,1
	subi o3,205.		;next block in output strg
	move w4,o3
	movei w2,205.		;count
	xblt w2,
	jrst stcbbl

;;;;;Various restart addresses

;internal restart - here to restart clearing typeahead
restac:	call clrin
	jrst restar

;like RESTAC but leaves .UNWPRO alone
restc1:	call clrin
	jrst restr1

;external restart, i.e. used by START command
rstart:	cis			;clear any interrupts, since this may
				;have been done from interrupt level if
				;he did ^C
	setzm crit		;forget it if we are in crit section
;internal restart - here to restart without clearing typeahead
restar:	move o1,[%TOP]		;say what kind of unwind this is
	movem o1,@[.unwpro]

;like RESTAR but leaves .UNWPRO alone
restr1:	setzb nil1,nil		;here to leave .unwpro alone
	setzb o1,o2		;make sure AC's are valid
	setzb o3,o4
	setzb o5,o6
	seto n,
	move p,savep
	move q,saveq
	move w2,savesp		;get known valid SP
	xor w2,sp		;compare with current
	tlne w2,1		;if different parity
	adjsp sp,-1		;then adjust to valid
	move w2,savesp
	call cubin1		;unbind, closing files passed
	move sp,savesp
	move w2,[jfcl]
	movem w2,evhook
	move o1,nil
	move o2,[%T]
	call inc
	move o1,nil
	move o2,[%T]
	call outc
	setzm @[datsec,,.rdtop]
	setzm @[%BKSAVE]
	move o1,[inum0]
	movem o1,@[%INDENT]
	move o1,[%t]
	movem o1,@[datsec,,.dointern]	;turn on interning
	jrst toplev

;  Arithmetic functions
;;TY%NUM
;;TY%INT

;movflo - loads double float number into w2 and w3 from pointer
define movflo(pnt)
	dmove w2,1(pnt)
	termin

;MINUS:
;we try to handle small integers quickly
minus:	xnmtyp o1		;right type?
	movn o1,o1		;negate it
	xct minust(w2)		;yes if we don't jrst somewhere
	ret

;;TYPES
;table is in reverse order since type code negated above
minust:	jrst minusl		;long floats
	tlc o1,740000		;lo iflons
	tlc o1,740000		;hi iflons
	jrst minusr		;ratios
	jrst notnum		;complex (not implemented)
	jrst minusb		;bignums
	tlc o1,740000		;lo inums
	tlc o1,740000		;hi inums

;;TY%BIG
exnegb:	skipa o2,o1		;entry from absf etc.
minusb:	 movn o2,o1		;put it back, leave o1 free
	getsiz w4,o2		;new num of same size
	call bigmak		;ob in o1, size/2 in w4
	sojn w4,minuxb
	dmovn w2,1(o2)		;only one doublewd
	dmovem w2,1(o1)
	jrst bgtr2w		;check it hasn't become an inum

minuxb:	 move o3,o1		;general bignums
	dmove w2,1(o2)		;first loop until rightmost 1 bit found
	tlz w2,400000		;sign bit not used in low wds
	dmovnm w2,1(o3)		;negate the doubleword
	dadd o2,[2 ? 2]		;bump both pointers
	skipn 1(o3)		;proceed to other loop 
	 jrst minux2		; unless it was zero
	sojg w4,minuxb+1	;loop unless last doubleword
	jfcl 17,.+1		;this one has the real sign bit
	dmovn w2,1(o2)		;negate it
	dmovem w2,1(o3)
	setzb o2,o3		;clear these, now not objects
	jov bmoflo		;in case it was a multiple of -1x2^70
	jrst bgtrim		;in case it was a multiple of +1x2^70

minux2:	dmovn w2,1(o2)		;doublewords beyond rightmost 1 bit
	dsub w2,[0 ? 1]		;merely flip all the bits
	dmovem w2,1(o3)
	dadd o2,[2 ? 2]		;bump the pointers
	sojg w4,minux2		;this *loop* includes the top dw
	setzb o2,o3		;not valid obs
	ret			;the only shrink/expand cases were above

;;WORK
;; convert bignum to long float
cnvb2l:	push q,o1		;save bignum
	call intlen		;how many bits?
	posnum o1		;better be positive!
	cail o1,200		;test for num too big
	 jrst [pop q,o1 ? jrst ovrflo]
	push p,o1		;save that too
	move w2,o1		;how many bits in hi dw?
	idivi w2,70.
	jumpe w3,cbl02		;if 0 bits, that isn't really the high dw
cbl03:	movei w4,62.		;adjust for space taken by exponent
	sub w4,w3		;(this will be the "lsh factor")
	pop q,o1		;bignum again
	getsiz w2,o1		;how many words
	add o1,w2		;point to end
	push p,w2		;save # wds
	dmove w2,-1(o1)		;get hi dw
	ashc w2,(w4)		;who knows which way
	dmovem w2,work+1	;save
	pop p,w2		;# of wds again
	cain w2,2		;skip this next if only a 2-wd bignum
	 jrst cbl01
	dmove w2,-3(o1)		;also include bits from next-highest
	tlz w2,400000		;dw of bignum
	ashc w2,-70.(w4)	; -- in the right place
	dadd w2,work+1
	skipa
cbl01:	 dmove w2,work+1	;get number
	pop p,w4		;this was number of bits
	jfcl 17,.+1
	fsc w2,200(w4)		;put it in exponent
	jov ovrflo		;woops
	dmovem w2,work+1	;put back
	move o1,[object ty%spc,2]	;make an obj out of it
	movem o1,work
	move o1,[object ty%cfl,<codsec,,work>]
	ret

;here if IDIVI claims that there are no bits in the hi dw.  What has
;happened is that things came out even.  Instead of 3 dw's with the
;last having 0 bits, we want to claim that there are 2 dw's with the
;last one full.  Except of course if the number is 0...
cbl02:	jumpe w2,cbl03		;if zero, no adjustment
	movei w3,70.		;a full dw
	soja w2,cbl03		;but one fewer

;; convert bignum to iflon
;; NB: does wierdness: saves w3; returns arg as machine float in o1
cnvb2f:	push p,w3		;this is the other arg in some arith rtns
	call cnvb2l		;the easy way: make a long float
	move o1,work+1		;get significant word
	fmpr o1,[201400,,4]	;round it
	trz o1,17
	pop p,w3		;restore other arg
	ret

;;TY%RAT
minusr:	push q,1(o1)		;save denominator
	move o1,(o1)
	call minus		;negate numerator
	pop q,o2
rltrat:				;rtn a ratio already in lowest terms
	push free,o1		; set up numerator
	move o1,free		; make address into ratio
	tlo o1,(object(ty%rat,0))
	push free,o2		; and denominator
	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	ret

minusl: dmovn w2,1(o1)		;lflon version - get number
	jrst retflo		;return the value



;;TY%FLO
;Lisp object in O1.  Returns real value in W2/W3.
getrea:	skpnum o1
	 jrst notnum
	xtype o1
	xct gtrtab-ty%xfl(w2)
	ret			;already real, done

;GETFLO - special version of GETREA for the arith package.
;Skips or not to show whether value is double precision.  Note that
;a d.p. value is always computed.  This is merely advice to the caller.
;We consider that any conversion from integer or bignum to real is
;to single precision.  Only if the original is double precision do
;we indicate double precision.  The user can ask for double precision
;if he wants it by calling DOUBLE.
;  normal - single precision
;  skip - double precision

;;TY%FLO
;Lisp object in O1.  Returns real value in W2/W3.
getflo:	skpnum o1
	 jrst notnum
	xtype o1
	xct gtrtab-ty%xfl(w2)
	aos (p)			;double - do the skip ret
	ret			;already real, done

;;TYPES
;WARNING - this table is also used by DOUBLE, so be careful
gtrtab:	dmove w2,1(o1)		; long flonum ;;TY%FLO
	jrst gtrifl		; neg iflons
	jrst gtrifl		; pos iflons
	jrst nyirat		; ratios
	jrst notnum		; complex (unimplemented)
	jrst gtrbig		; bignum
	jrst gtrinu		; neg inums
	jrst gtrinu		; pos inums
;;TY%IFL
gtrifl:	move w2,o1		;make double flo from iflon
	lsh w2,4
	setz w3,
	ret

gtrbig:	push q,o1
	call cnvb2l		;convert bignum to long float
	dmove w2,1(o1)
	pop q,o1		;leave something useful in o1
	ret

;;TY%INU
;integer - convert to real.  We can't use FLOAT because that would limit
;us to the range of single precision numbers.  We produce a non-normalized
;real by adding an exponent, then add 0 to normalize it.
gtrinu:	move w3,o1
	getnum w3
	jumpl w3,gtrin1		;if negative, special
	move w2,[<62.+200>_27.]	;and exp in w2
	dfad w2,0		;normalize by adding 0
	ret

gtrin1:	movn w3,w3		;get positive form
	move w2,[<62.+200>_27.] ;and exp in w2
	dfad w2,0		;normalize by adding 0
	dmovn w2,w2		;negate the whole thing
	ret

;;;;; Numerical coercion routines.

;DOUBLE - force to long real
double:	skpnum o1
	 jrst notnum
	push p,[codsec,,retflo]	;if the XCT JRST's, it will return to RETFLO
	xtype o1
	xct gtrtab-ty%xfl(w2)
  ;here if it was already double
	adjsp p,-1		;forget the retflo, already long
	ret			;already real, done

;FLONUM - force to short real
flonum:	call getrea		;get real into W2/W3
retif:	fmpr w2,[201400,,4]	;round it
	makifl w2		;make number into an iflon
	move o1,w2		;and return it
	ret

;FIX - force to integer the easy way ;;WORK
fixf:	skpnnt o1		;if already an integer
	ret			;nothing to do
	call getrea		;get real into W2/W3
;we can handle this the easy way if what is in W2 is precise.  If
;any significant digits are in w3, then we have to do it the hard
;way.  the magic number below is 777,,777777.
	camg w2,[134217727.0]
	camge w2,[-134217727.0]
	jrst truncb		;use bignum code
	jumpl w2,truncn		;negative is wrong
	fix o1,w2
	maknum o1		;always an INUM
	ret

;the spec calls for FLOOR.  FIX produces TRUNC.  Oh, well...
truncn:	fad w2,[134217727.0]	;make it positive so FIX will work
		;note that this is a non-rounding add, for obvious
		;reasons.  We would need one more digit of precision
		;for FADR to work.
	fix o1,w2
	sub o1,[134217727.]	;now get back to right range
	maknum o1
	ret

truncb:	ldb w4,[.bp <777000,,0>,w2] ;get exponent field
	tlz w2,377000		;now clear the exponent (but not sign)
	tlne w2,400000		;if neg
	tlo w2,777000		;propagate sign
	trne w4,400		;if neg
	trc w4,777		;have to complement exponent
	subi w4,200+62.		;-200 to get actual exp, 62 to shift beyond .
	maknum w4		;make arg for lsh
	move o2,w4
	dmovem w2,work+1	;put the actual number in an ersatz bignum
	move o1,[object ty%spc,2]
	movem o1,work
	move o1,[object ty%cbg,<codsec,,work>] ;pointer to bignum
	jrst lshf

;ROUND - force to integer ;;WORK
round:	skpnnt o1		;if already an integer
	ret			;nothing to do
	call getrea		;get real into W2/W3
;we can handle this the easy way if what is in W2 is precise.  If
;any significant digits are in w3, then we have to do it the hard
;way.  the magic number below is 377,,777777.  This is half the
;one above because we need one bit after the decimal point for the
;rounding to work.
	camg w2,[67108863.0]
	camge w2,[-67108863.0]
	jrst roundb		;use bignum code
	fixr o1,w2
	maknum o1		;always an INUM
	ret

roundb:	dfad w2,[0.5 ? 0]	;do the rounding
	ldb w4,[.bp <777000,,0>,w2] ;get exponent field
	tlz w2,377000		;now clear the exponent (but not sign)
	tlne w2,400000		;if neg
	tlo w2,777000		;propagate sign
	trne w4,400		;if neg
	trc w4,777		;have to complement exponent
	subi w4,200+62.		;-200 to get actual exp, 62 to shift beyond .
	maknum w4		;make arg for lsh
	move o2,w4
	dmovem w2,work+1	;put the actual number in an ersatz bignum
	move o1,[object ty%spc,2]
	movem o1,work
	move o1,[object ty%cbg,<codsec,,work>] ;pointer to bignum
	jrst lshf

;;TY%INT
;;TY%BIG
;Lisp object in O1.  Returns integer value in w2
get1nt:	skpnin o1		;;TY%NUM  --inums are last
	 jrst getin1
	caml o1,[object ty%big,0] ;;TY%NUM --bignums are next
	 jrst getin2
gtiner:	perr /Must be an integer/
;small integer
getin1:	move w2,o1
	getnum w2
	ret
;bignum -- we want the 1 bits out of 000000,,000001 ? 377777,,777777
getin2:	dmove w2,1(o1)
	lsh w3,1		;  000000,,000001 ? 777777,,777776
	lshc w2,35.		;  777777,,777777 ? 000000,,000000
	ret

;;TY%INT
;;TY%BIG
ret1nt:	ashc w2,-35.		;make a 2-wd quantity out of it
;return 2wd integer, in w2/3, as lisp object in o1
retint:	dmovem w2,w4		;save it in an odd place
	jfcl 17,.+1
	ashc w2,39.		;see if more than 31 significant bits
	jov retbw4		;there were, so make a bignum
	maknum o1		;"just happens" to be in the right place
	ret

retbw4:	dmove w2,w4		;get it back
retbig:	push free,[object(ty%spc,2)] ;a small (2-wd) bignum
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%big,0))
	move o1,w4		;and return that
	dmovem w2,1(free)
	addi free,2
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

;;TY%BIG
;make a new bignum.  take the size in w4, return size/2 in w4,
; object ptr in o1
bigmak:	tlo w4,(<object(ty%spc,0)>)	;make gc skip wd
	push free,w4		;invalid gc state starts here
	move o1,free		;	 ...
	tlo o1,(object(ty%big,0))	;...
	tlz w4,(<object(ty%spc,0)>)	;...
	add free,w4		;... and ends here
	lsh w4,-1		;leave # of doublewords
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

	.vector work(7)		;temps for representation changes

; Generic arithmetic functions.  These functions handle mixed args
; of types inum, bignum, ratio, iflon, long float.
; The types are given in reverse coercion precedence order, ie, 
; with two args of different types, the one occurring earlier in
; the list will be converted to the type occurring later in the list.
; The main table used (by all functions) is DOPTAB.  The DOPTAB 
; entry corresponding to the xtype of the second argument is 
; executed, with a copy of the 2nd arg in w3.  If the second arg
; is an inum, w3 is converted to a machine integer in place and 
; the next instruction is skipped;  the first argument isn't even 
; looked at.  If the second arg is not an inum, both args are looked
; at, and converted according to the following table; no skip occurs.
;
;   if either arg is     and other is	other is converted; args left in
;	long flonum	any other type		o1, o2 as lisp objects
;	immed flonum	any except long		o1, w3 as machine flonums
;	ratio		any non-flonum		o1, o2 as lisp objects
;	bignum		any integer		o1, o2 as lisp objects
;
; w2 is left with the xtype of the type converted to.  Lflon, ratio,
; and bignum are converted to by placing data in the area WORK and
; a pointer to WORK in the appropriate register.


;;TYPES
;;TY%INT
doptab:	repeat 8,jrst notnum	;atoms, etc
	jsp w4,dopa2l		;long flon
	jsp w4,dopa2f		;iflon
	jsp w4,dopa2f		;iflon
	jsp w4,dopa2r		;ratio
	jrst notnum		;complex
	jsp w4,dopa2b		;bignum
	tloa w3,760000		;neg inum
	tlza w3,760000		;pos inum

; special macro for secondary type tables. leave xtype of o1 in w2,
; dispatching off an xnmtyp table to begin right after the macro.
define a1disp
	skpnum o1
	 jrst notnum
	xtype o1
	xct .+1-ty%xfl(w2)  termin
	
;arg 2 is long flon, convert arg 1 to long flon
dopa2l:	a1disp			;;TYPES
	jrst (w4)		;long flon
	jrst a2la1f		;iflon
	jrst a2la1f		;iflon
	jrst a2la1r		;ratio
	jrst notnum		;complex
	jrst a2la1b		;bignum
	jrst a2l1ni		;neg int
	jrst a2l1pi		;pos int

;;TY%INT
;;TY%FLO
a2l1ni:	tloa o1,760000
a2l1pi:	 tlz o1,760000
	fltr o1,o1
	jrst sto1lf

;;TY%IFL
;;TY%FLO
a2la1f:	lsh o1,4
sto1lf:	movem o1,work+1
	setzm work+2
	move o1,[object ty%spc,2]
	movem o1,work
	move o1,[object ty%cfl,<codsec,,work>]
	movei w2,ty%xfl
	jrst (w4)

; arg 1 is bignum, cnvt to long flon w/ std routine
a2la1b:	push p,w4
	pushj p,cnvb2l
	movei w2,ty%xfl
	popj p,

; 1st arg is a ratio, convert to long flon with std routine
a2la1r:	push p,w4
	pushj p,cnvr2l
	movei w2,ty%xfl
	popj p,

;arg 2 is iflon, cnvt other unless long, when cnvt a2 to long
dopa2f:	lsh w3,4		;arg 2 => machine flonum in w3
	a1disp			;;TYPES
	jrst a2fa1l		;long flon
	jrst a2fa1f		;iflon
	jrst a2fa1f		;iflon
	jrst a2fa1r		;ratio
	jrst notnum		;complex
	jrst a2fa1b		;bignum
	jrst a2f1ni		;neg int
	jrst a2f1pi		;pos int

cnvr2l:
cnvr2f:
nyirat:	err /NYI for RATIOs/

;;TY%IFL
;;TY%FLO
a2fa1l:
sto2fl:	movem w3,work+1		;here with 1-wd flon in w3
	setzm work+2
	move o2,[object ty%spc,2]
	movem o2,work
	move o2,[object ty%cfl,<codsec,,work>]
	jrst (w4)

;;TY%IFL
a2fa1f:	lsh o1,4
	jrst (w4)

; arg 1 is bignum, cnvt to iflon w/ std routine
a2fa1b:	push p,w4
	pushj p,cnvb2f
	movei w2,ty%xif
	popj p,

; 1st arg is a ratio, convert to iflon with std routine
a2fa1r:	push p,w4
	pushj p,cnvr2f
	movei w2,ty%xif
	popj p,

;;TY%INT
;;TY%IFL
a2f1ni:	tloa o1,760000
a2f1pi:	 tlz o1,760000
	fltr o1,o1
	movei w2,ty%xif
	jrst (w4)

;2nd arg a ratio, make it a float if other is or make other a ratio
dopa2r:	a1disp			;;TYPES
	jrst a2ra1l		;a long flon
	jrst a2ra1f		;iflon
	jrst a2ra1f		;iflon
	jrst (w4)		;ratio
	jrst notnum		;complex
	jrst a2ra1i		;bignum
	jrst a2ra1i		;neg int
	jrst a2ra1i		;pos int

a2ra1l:	push p,w4
	exch o1,o2
	pushj p,cnvr2l
	exch o1,o2
	movei w2,ty%xfl
	popj p,

a2ra1f:	push p,w4
	exch o1,o2
	pushj p,cnvr2f
	exch o1,o2
	movei w2,ty%xif
	popj p,

a2ra1i:	movem o1,work
	move o1,[inum 1]
	movem o1,work+1
	move o1,[object ty%crt,<codsec,,work>]
	movei w2,ty%xrt
	jrst (w4)

;2nd arg a bignum, make float or rat if other is or make other a bignum
dopa2b:	a1disp			;;TYPES
	jrst a2ba1l		;a long flon
	jrst a2ba1f		;iflon
	jrst a2ba1f		;iflon
	jrst a2ba1r		;ratio
	jrst notnum		;complex
	jrst (w4)		;bignum
	jrst a2b1ni		;neg int
	jrst a2b1pi		;pos int

a2ba1l:	push p,w4
	exch o1,o2
	pushj p,cnvb2l
	exch o1,o2
	movei w2,ty%xfl
	popj p,

a2ba1f:	push p,w4
	exch o1,o2
	pushj p,cnvb2f
	move w3,o1
	lshc o1,36.+4
	movei w2,ty%xif
	popj p,

a2ba1r:	movem o2,work
	move o2,[inum 1]
	movem o2,work+1
	move o2,[object ty%crt,<codsec,,work>]
	jrst (w4)

;;TY%INT
;;TY%BIG
a2b1ni:	tloa o1,760000		;arg one was a neg inum...
a2b1pi:	 tlz o1,760000		;... or a pos inum...
	movem o1,work+2		;make it into a 2-wd bignum
	ash o1,-35.
	movem o1,work+1
	move o1,[object ty%spc,2]
	movem o1,work
	move o1,[object ty%cbg,<codsec,,work>]
	movei w2,ty%xbg
	jrst (w4)

;;TYPES    arg two was int, but result not right. either oflo or 
; other arg wrong type.  
a2itab:	repeat 8, jrst notnum	;atoms and stuff
	jsp w4,a2ia1l		;long flon
	jsp w4,a2ia1f		;iflon
	jsp w4,a2ia1f		;iflon
	jsp w4,a2ia1r		;ratio
	jrst notnum		;complex
	jsp w4,a2ia1b		;bignum
	tlo o1,760000		;;TY%INT    - inums
	tlz o1,760000		;positive same


a2ia1l:	fltr w3,w3
	jrst sto2fl

;;TY%IFL
a2ia1f:	fltr w3,w3
	lsh o1,4
	jrst (w4)

a2ia1r:	maknum o2		;(!)
	jrst a2ba1r

;;TY%BIG
;-- other arg was a bignum already
a2ia1b:	move w2,w3		;smallest bignum is 2 words
	ashc w2,-35.
	dmovem w2,work+1
	move o2,[object ty%spc,2]
	movem o2,work	;save it in this fixed area
	move o2,[object ty%cbg,<codsec,,work>]
	movei w2,ty%xbg
	jrst (w4)

ovrflo:	err /Floating overflow/

notnm2:	move o1,o2
notnum:	perr /Argument to numerical function is not a number/

plus:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xplus
	add o1,w3		;this is what we came for...
	skpnin o1		;will be neg if oflo
	 ret
	sub o1,w3		;woops
	xtype o1
	xct a2itab(w2)
xplus:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xplflo		;long flons
	jrst xplifl		;iflons
	jrst xplifl		;iflons
	jrst xplrat		;ratios
	jrst notnum		;complex
	jrst xplbig		;bignums
	jrst xplinu		;inums 
	jrst xplinu		;inums

;;TY%FLO
xplflo:	dmove w2,1(o1)
	dfad w2,1(o2)
;return long flon found in w2 and w3
retflo:	push free,[object(ty%spc,2)] ;now make real number object
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%flo,0))
	move o1,w4		;and return that
	push free,w2
	push free,w3
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

;;TY%IFL
xplifl:	fad o1,w3		;do the addition
retifl:	makifl o1		;make into iflon object
	ret

xplrat:	jrst nyirat

;;TY%BIG		add two bignums
xplbig:	move o3,o1		;save o1
	getsiz w3,o1		;find out how big they are
	getsiz w4,o2
	came w4,w3		;same size?
	 jrst xplbds		; no, use general routine
	caie w3,2		;yes: 2 words perchance
	 jrst  xplb2		; no...
	jfcl 17,.+1		;yes, all is very simple (& fast)
	dmove w2,1(o2)
	dadd w2,1(o3)
	jov w2oflo		;see if was more than 2-wd result
	jrst retint

;args same size but >2 wds.  slight simplification.
xplb2:	call bigmak		; answ that size too
	push p,0		;this is the size difference
	jrst xplbx0

xplbds:	camg w3,w4		;which is bigger?
	 jrst .+3
	  exch w3,w4		;put bigger size on w4
	  exch o2,o3		;put bigger ob in o2
	lsh w3,-1		;smaller size ==> #/dw's
	push p,w3
	call bigmak		;result gets size of larger
	sub w4,(p)		;difference in sizes
	exch w4,(p)		;use smaller for count, save diff
xplbx0:	move o4,o1		;result area, use as traveling ptr
	jrst xplbx2		;no carry into right end

;;the structure of the loops is wierd to preserve carry/oflo info.
;;sojx ruins the carry bits (but not overflow).
;;thus jcry's must be done before sojx's, but sojx's must be done
;;to see if an overflow test is warranted.
;;first loop is for adding digits where the numbers coincide;
;;second is to propagate the carry along the "overhang" of the
;;larger number.
xplbx1:	soje w4,xplbx3		;here if carry from previous digit
	dmove w2,[0 ? 1]
	skipa
xplbx2:	 setzb w2,w3		;here if no carry
	jfcl 17,.+1
	dadd w2,1(o2)		;add to carry bit
	dadd w2,1(o3)		;add to other digit
	dmovem w2,1(o4)		;stash
	addi o2,2		;advance pointers
	addi o3,2
	addi o4,2
	jcry1 xplbx1		;was there a carry this time?
	sojg w4,xplbx2		;no, are we out of digits
	skipa w3,[0]		;yes-- but remember there was no carry
xplbx3:	 movei w3,1		;out of digits with a carry, from above
	pop p,w4		;difference count
	jumpe w4,xplbx9		;if #'s same size, that was it!
	move w2,-1(o3)		;else extend sign of short one
	ash w2,-35.
	movem w2,work+3		;at +3 in case an arg occupies +0, 1, & 2!
	movem w2,work+4
	jrst xplbx6		;otherwise save carry status

xplbx4:	soje w4,xplbx9		;here if carry
	skipa w3,[1]
xplbx5:	 setz w3,		;here if no carry
xplbx6:	setz w2,		;here if carry wd in w3 already
	jfcl 17,.+1
	dadd w2,1(o2)		;add carry to digit
	dadd w2,work+3		;and sign from short number
	dmovem w2,1(o4)		;stash
	addi o2,2		;bump pointers
	addi o4,2
	jcry1 xplbx4		;more carry?
	sojg w4,xplbx5		;no--out of digits?
xplbx9:	setzb o2,o3		;yes: clean up
	setz o4,
	jov bmoflo		;see if there was an overflow
	;falls through
;;trim a bignum so that it occupies no more doublewords
;;than necessary to hold it.  in the extreme case, make an
;;inum.  enter w/ bignum in o1, exit with same (or inum in o1)
;;remember that unless we hack o1, we're merely returning the argument.
bgtrim:	getsiz w4,o1		;find the high-order end
	add w4,o1
	soj w4,			;adjust so that w4=o1 when we
bgt01:	soj w4,			; have just one doublewd left
	dmove w2,1(w4)		;get hi-order dw
	camn w4,o1		;was it also the low-order dw?
	 jrst bgtr2w		; yes, special case
	jfcl 17,.+1		;nope: is it 0 or -1?
	ashc w2,70.
	jov [ret]		;no...
	rot w2,1		;move the sign down to the next dw
	dpb w2,[.bp (400000),-1(w4)]
	setzm 1(w4)
	setzm 2(w4)
	sos (o1)
	sos (o1)
	soja w4,bgt01

;;only 2 words left, may be an inum
bgtr2w:	jfcl 17,.+1		;more than 31 significant bits?
	ashc w2,39.
	jov [ret]		;yes, leave it as is
	ash w2,-4		;no, make it an inum
	maknum w2
	move o1,w2
	ret

;;here w/ 2-wd result in o2/3 that overflowed
w2oflo:	call retbig
	;falls through
;;generalized overflow for bignum operations routine
;;come here with left wd of last op in w2, result obj in o1
;;result must have been the last thing consed
bmoflo:	aos (o1)		;extend length counter
	aos (o1)		; :: In an overflow, sign bit
	dmove w3,[0 ? 1]	; is wrong sign but correct magnitude
	skipl w2
	 dmove w3,[-1 ? -2]
	dmovem w3,1(free)	;needs smartening for interrupts
	addi free,2
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

xplinu:	add w3,o1		;not inum but still 1 word
	move w2,w3
	ashc w2,-35.		;but return 2-wd bignum anyway
	jrst retbig

diff:	move w3,o2
	xtype o2		;what's 2nd arg?
	xct doptab(w2)		;above, qv
	 jrst xdiff
	sub o1,w3		;this is what we came for...
	skpnin o1		;will be neg if oflo
	 ret
	add o1,w3		;woops
	xtype o1
	xct a2itab(w2)
xdiff:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xdfflo		;long flons
	jrst xdfifl		;iflons
	jrst xdfifl		;iflons
	jrst xdfrat		;ratios
	jrst notnum		;complex
	jrst xdfbig		;bignums
	jrst xdfinu		;inums
	jrst xdfinu		;inums

;;TY%FLO
xdfflo:	dmove w2,1(o1)
	dfsb w2,1(o2)
	jrst retflo

;;TY%IFL
xdfifl:	fsbr o1,w3		;do the subtraction
	jrst retifl

xdfrat:	jrst nyirat

;;TY%BIG		subtract bignums
xdfbig:	move o3,o1		;save o1
	getsiz w3,o1		;find out how big they are
	getsiz w4,o2
	came w4,w3		;same size?
	 jrst xdfbds		;no, use general routine
	caie w3,2		;yes: 2 words perchance
	 jrst  xdfb2		; no...
	jfcl 17,.+1		;yes, all is very simple (& fast)
	dmove w2,1(o3)		;o3 is the minuend
	dsub w2,1(o2)		;o2 is the subtrahend
	jov w2oflo		;see if was more than 2-wd result
	jrst retint

;args same size but >2 wds.  slight simplification.
xdfb2:	call bigmak		;answ will be the same size
	setz o5,		;this is the which-bigger flag
	push p,0		;this is the size difference
	jrst xdfbx0

xdfbds:	setz o5,		;o5=0 ==> o2 is longer
	camg w3,w4		;which is bigger?
	 jrst .+3
	  exch w3,w4		;put bigger size on w4
	  seto o5,		;can't switch args, use flag
	lsh w3,-1		;smaller size ==> #/dw's
	push p,w3
	call bigmak		;result gets size of larger
	sub w4,(p)		;difference in sizes
	exch w4,(p)		;use smaller for count, save diff
xdfbx0:	move o4,o1		;result area, use as traveling ptr
	jrst xdfbx1+1		;no borrow from right end

;;the structure of the loops is wierd to preserve carry/oflo info.
;;sojx ruins the carry bits (but not overflow).
;;thus jcry's must be done before sojx's, but sojx's must be done
;;to see if an overflow test is warranted.
;;first loop is for adding digits where the numbers coincide;
;;second is to propagate borrowing along the "overhang" or
;;"underhang" of the larger number.

xdfbx1:	 soje w4,xdfbx3		;here if no borrow
	setzb w2,w3
	skipa
xdfbx2:	 dmove w2,[-1 ? -1]	;here if borrow from previous digit
	dadd w2,1(o3)		;add to borrow subtrahend
	jfcl 17,.+1
	dsub w2,1(o2)
	dmovem w2,1(o4)		;stash
	addi o2,2		;advance pointers
	addi o3,2
	addi o4,2
	jcry1 xdfbx1		;was there a borrow this time?
	sojg w4,xdfbx2		;yes, are we out of digits
	skipa w3,[-1]		;yes-- but remember there was borrow
xdfbx3:	 setz w3,		;out of digits with no borrow, from above
	pop p,w4		;difference count
	jumpe w4,xdfbx9		;if #'s same size, that was it!
	skipn o5		;o5=0 ==> o2 is longer 
	 skipa w2,-1(o3)	; the subtrahend (ran out)
	  move w2,-1(o2)	;  the minuend (ran out)
	ash w2,-35.		;propagate the sign thereof
	movem w2,work+3		;at +3 in case an arg was at work+0!
	movem w2,work+4
	jrst xdfbx6		;otherwise save borrow status

xdfbx4:	soje w4,xdfbx9		;here if no borrow
	skipa w3,[0]
xdfbx5:	 seto w3,		;here if borrow
xdfbx6:	move w2,w3		;here if borrow wd in w3 already
	jumpe o5,.+4		;o5=0 ==> o2 is longer
	 dadd w2,1(o3)		;borrow from "overhang"
	 jfcl 17,.+1
	 dsub w2,work+3		;sign of shorty
	jumpn o5,.+4
	 dadd w2,work+3		;sign of shorty
	 jfcl 17,.+1
	 dsub w2,1(o2)		;subtract "underhang" from borrow
	dmovem w2,1(o4)		;stash
	addi o2,2		;bump pointers
	addi o3,2		;one is superfluous, but we don't know which
	addi o4,2
	jcry1 xdfbx4		;more borrow?
	sojg w4,xdfbx5		;no--out of digits?
xdfbx9:	setzb o2,o3		;yes: clean up
	setz o4,o5
	jov bmoflo		;see if there was an overflow
	ret

xdfinu:	sub o1,w3		;both inums but result not
	move w2,o1
	ashc w2,-35.		;rtn smallest (2-wd) bignum
	jrst retbig

times:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xtimes
	xtype o1
	xct a2itab(w2)
xtimes:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xtiflo		;long flons
	jrst xtiifl		;iflons
	jrst xtiifl		;iflons
	jrst xtirat		;ratios
	jrst notnum		;complex
	jrst xtibig		;bignums
	jrst xtiinu		;inums
	jrst xtiinu		;inums

;;TY%FLO
xtiflo:	dmove w2,1(o1)		;double precision mult
	dfmp w2,1(o2)
	jrst retflo

;;TY%IFL
xtiifl:	fmpr o1,w3		;single prec mult
	jrst retifl

xtirat:	jrst nyirat

;;TY%BIG      multiply bignums
xtibig:	move o3,o1		;save o1
	getsiz w3,o1		;find out how big they are
	getsiz w4,o2
	add w4,w3		;size of result
	caie w4,4		;both args 2wds by chance?
	 jrst  xtib2		; no...
	call bigmak
	jfcl 17,.+1		;yes, all is very simple (& fast)
	dmove nil1,1(o2)
	dmul nil1,1(o3)
	dmovem nil1,3(o1)
	dmovem w3,1(o1)
	move w2,nil1		;bmoflo expects this here
	setz nil1,		;and everybody else expects this here
	jov bmoflo		;oflo for the dmul
	jrst bgtrim		;on the other hand...

xtib2:	call bigmak		;alloc core for new number
	getsiz w2,o1		;its size
	sos w2			;less one
	move w3,o1
	aos w4,w3		;copy from first element
	aos w4			;...to second
	setzm (w3)		;fill it with zeroes
	xblt w2,
	push p,o1		;save: new number
	push p,o2		;multiplier
	push p,o3		;multiplicand
	move o1,o2		;clear the sign bits of the internal
	call zisbit		;(ie, nonsignificant) doublewords
	move o1,o3		;of both args
	call zisbit
	getsiz w4,o2		;form doubleword counts for both args
	lsh w4,-1		;for looping purposes
	push p,w4
	getsiz w4,o3
	lsh w4,-1
	push p,w4
	push p,0		;this will hold the carry
	push p,0
	move o2,-5(p)		;multiplier
	move o5,-6(p)		;product
;; the following is a double nested loop in four parts. 
;; essentially it merely loops across the multiplicand inside a loop
;; across the multiplier, multiplying the digits and adding up the results.
;; the inner loop body appears four times in different forms, however,
;; to avoid extraneous testing inside it.  the first incarnation is the
;; main case, for internal digits (doublewords) of both numbers. it does
;; positive carries only.  The other incarnations are for the most-
;; significant digits of one or the other number, which are distinguished
;; by having significant sign bits, and must do signed carries.  the last
;; incarnation is only done once: it handles the MSD's of both numbers,
;; and has to handle overflow as well.
	;falls in
	setz n,			;n is the signed carry between partial prods
	sosg -3(p)		;multiplier size counter
	 jrst xtiml5		;do n-1 times, skip if ctr is 1
xtiml0:	move o1,-4(p)		;multiplicand
	move o3,o5		;product
	move o4,-2(p)		;multiplicand size ctr
	soje o4,xtiml1		;do n-1 times, skip if 1
xtimlp:	dmove nil1,1(o1)	;multiplicand loop
	dmul nil1,1(o2)		;multiplier digit constant through this loop
	dadd w3,1(o3)		;add into partial prod
	tlze w3,400000		;check for carry (& keep PP sign bits clear)
	 aos (p)
	dmovem w3,1(o3)		;9x9=81, that was the 1, this is the 8
	dadd nil1,3(o3)
	dadd nil1,-1(p)		;carry in
	setzm (p)
	tlze nil1,400000	;carry out
	 aos (p)
	dmovem nil1,3(o3)
	addi o1,2		;multiplicand digit
	addi o3,2		;partial product digit
	sojg o4,xtimlp		;counter
xtiml1:	dmove nil1,1(o1)	;last iteration for sign digit 
	dmul nil1,1(o2)		; of multiplicand
	tlz w3,400000		;insignificant sign bit
	dadd w3,1(o3)		;from PP
	tlze w3,400000		;low digit carry
	 aos n
	dmovem w3,1(o3)
	add n,(p)		;carry from above loop (p)
	move w3,n		;n is signed carry from previous this loop
	ashc w3,-35.
	setzb n,(p)		;carry out
	tlze nil1,400000	;this means negative (carry = -1)
	 sos n
	dadd nil1,w3		;add in above carry
	tlze nil1,400000	;this means overflow (carry = 1)
	 aos n
	dmovem nil1,3(o3)	;new PP
	addi o2,2		;now do new multiplier digit
	addi o5,2		;shift range in product
	sose -3(p)		;count multiplier digits
	 jrst xtiml0
xtiml5:	move o1,-4(p)		;last multiplier digit: a whole nother
	move o3,o5		; multiplicand loop
	move o4,-2(p)
	movem n,(p)		;the roles of these are switched
	setz n,
	soje o4,xtiml7		;again only loop n-1 times
xtiml6:	dmove nil1,1(o1)	;multiplicand -- internal digit
	dmul nil1,1(o2)		;multiplier  -- sign digit
	tlz w3,400000		;insigificant sign bit
	dadd w3,1(o3)		;PP
	tlze w3,400000		;low digit carry, plus only
	 aos n
	dmovem w3,1(o3)
	move w3,n		;but hi digit from prev loop might not be
	ashc w3,-35.
	setz n,
	tlze nil1,400000	;- carry out
	 seto n,
	dadd nil1,3(o3)		;PP
	dadd nil1,w3		;carry in
	tlze nil1,400000	;+ carry out
	 aos n
	dmovem nil1,3(o3)
	addi o1,2		;new multiplicand digit
	addi o3,2		;new PP digit
	sojg o4,xtiml6
xtiml7:	jfcl 17,.+1		;both sign digits
	dmove nil1,1(o1)
	dmul nil1,1(o2)		;if this oflows, is -2**70
	jov [setom -1(p) ? jrst xtiml8]	;use explicit oflo flag
	tlz w3,400000		;internal sign bit
	dadd w3,1(o3)
	tlze w3,400000		;low digit, + carry only
	 aos n
	dmovem w3,1(o3)
	add n,(p)		;from two loop bodies above
	move w3,n
	ashc w3,-35.
	jfcl 17,.+1
	dadd nil1,w3		;add in final carries
	dmovem nil1,3(o3)	;store final digit
	jov [setom -1(p) ? jrst xtiml8]	;unless...
xtiml8:	move w4,-1(p)		;oflo flag
	adjsp p,-6		;all our temps
	pop p,o1		;let's not forget the quotient
	setz nil1,		;reconform to Lisp reg. standards
	setzb o2,o3
	setzb o4,o5
	jumpn w4,bmoflo		;ie, if -2**gazillion
	jrst bgtrim		;    if not

;; zero internal sign bits in a bignum
;; only the sign bits in the leading words of the doublewords are zeroed
zisbit:	getsiz w4,o1
	lsh w4,-1
	hrlzi w3,400000
	jrst .+3
zisbi2:	 andcam w3,1(o1)
	 addi o1,2
	sojg w4,zisbi2
	ret

;;TY%INT
xtiinu:	move w2,o1		;two inums: save arg 1
	lsh o1,4		;do in times-16 so overflo
	jfcl 17,.+1		; will check inum bounds
	imul o1,w3		;one wd mult
	jov xtiiov		;too big, use 2 wd
	ash o1,-4		;inum fits, return it
	maknum o1
	ret

xtiiov:	mul w2,w3		;(no poss. of oflo since were inums)
	jrst retbig

quot:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xquot
	xtype o1
	xct a2itab(w2)
xquot:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xquflo		;long flons
	jrst xquifl		;iflons
	jrst xquifl		;iflons
	jrst xqurat		;ratios
	jrst notnum		;complex
	jrst xqubig		;bignums
	jrst xquinu		;inums
	jrst xquinu		;inums

;;TY%FLO
xquflo:	dmove w2,1(o1)		;double precision divide
	dfdv w2,1(o2)
	jrst retflo

;;TY%IFL
xquifl:	fdvr o1,w3		;single prec divide
	jrst retifl

xqurat:	jrst nyirat

;;TY%BIG
xqubig:	getsiz w2,o1		;size of dividend
	getsiz w3,o2		;siza divisa
	caile w2,4		;DDIV can handle <4wd>/<2wd>
	 jrst xqubgb		;else go for mult wd routine
	caile w3,2
	 jrst xqubgb
	dmove w3,1(o1)		;indeed, ddiv requires 4wd/2wd
	cain w2,4		;so we must do the sign-extend
	 jrst [dmove nil1,3(o1) ? jrst .+3]
	  move nil1,w3		;by hand if dividend is only 2wd.
	  ashc nil1,-70.
	jfcl 17,.+1		;overflow occurs if the quotient is 
	ddiv nil1,1(o2)		;bigger than 2 words, so go to 
	jov [skipn 1(o2) ? skipe 2(o2) ? jrst xqubgb ? jrst .+1]
	move w3,w2		;general case code if it happens--
	move w2,nil1		;unless divisor was 0, when we return
	setz nil1,		;some random junk.
	jrst retint

xqubgb:	call divrou		;this routine does the work--qv
	move w4,o2		;length of quotient
	add o2,o1		;o1 is pointer to quotient on the stack
	push p,o2		;this points to the end of it
	setzb nil1,o2		;clean up sensitive registers
	setzb o3,o4
	setz o5,
	call bigmak		;alloc space for the quotient
	pop p,o2		;copy from stack into heap.
	move o3,o1		;remember that the doublewords in
xqucpy:	dmove w2,-2(o2)		;the heap object are in reverse order.
	dmovem w2,1(o3)		;lsd to msd
	addi o3,2		;up the bignum
	subi o2,2		;down the stack
	sojg w4,xqucpy
	pop q,p			;saved p
	tlz p,770000		;(we made it into an object for q)
	setzb o2,o3		;clean up more regs
	skipe n			;see if it was negative
	 call rdnbig		;it was
	jrst bgtrim		;--n't

;; this routine does bignum division, leaving the results on the stack.
;; it expects dividend (as lisp pointer) in o1 and divisor in o2.
;; it leaves:	o1: pointer to quotient		(all as bare addresses
;;		o2: length of quotient		 and numbers, not
;;		o3: pointer to remainder	 lisp objects)
;;		o4: length of remainder
;;	    on p: data for all of the above
;;	    on q: saved p as address object
;;	    in n: 0 if results are positive, -1 if negative
;;(the idea is to avoid negating remainder if only quotient is to be
;; used, and vice versa) (the algorithm requires generating both)
;;	all other registers:  garbage
divrou:	pop p,o5		;our return address
	move w4,p		;make an addr obj
	tlo w4,(inum0)
	push q,w4		;save it
	setz n,			;numpsh sets n to n xor (minusp o1)
	adjsp p,2		;elbow room for wierd spec case (see div2cg)
	call numpsh		; and throws o1's bignum's data on p
	pop p,o4		;and leaves pointer and length on p also
	pop p,o3
	move o1,o2		;do the divisor also
	call numpsh		;numpsh leaves the number in positive form
	move o1,(p)		;(reversing the order of the doublewords)
	push p,o3		;now n is set for the sign of the q and r
	push p,o4		;and both sets of ptr/lens are on p
	caie o1,2		;there follows a simple routine for
	 jrst div2bg		;use when the divisor is only 2 wds long
	move o2,-3(p)		;otherwise jump to div2bg
	lsh o4,-1		;o4 counts doublewords
	dmove w2,-2(o3)		;o3 moves along the dividend
dvrdiv:	dmove w4,(o3)		;third-grade short division w/1-digit divisor
	ddiv w2,(o2)		;o2 points to the divisor
	dmovem w2,-2(o3)	;--of course, digits are base 2^70
	dmove w2,w4		;replace dividend with quotient as we go
	addi o3,2
	 sojg o4,dvrdiv
	dmovem w2,-2(o3)
	dmove o1,-1(p)		;pointer to quotient, which has replaced
	subi o1,2		;dividend
	subi o3,2		;pointer to remainder, right after it
	movei o4,2		;length of remainder
	jrst (o5)		;return to sender, at address unknown

;; takes the bignum whose pointer is in o1, and pushes it (all the data)
;; onto p.  actually pushes the magnitude, ie negates it if negative.
;; also, if negative, xors register n with -1 (for determination of
;; the sign of the result after this is done twice).  clears all the
;; sign bits of the internal (nonsignificant) doublewords in the number.
;; leaves pointer and length on the top of p.
numpsh:	getsiz w4,o1	
	add o1,w4		;find end of number
	sos o1			;(we reverse the doublewds for division)
	move nil1,p
	pop p,w2		;our return address
	push p,0		;a 0 digit on the front ameliorates
	push p,0		;many of the algorithms
	adjsp p,(w4)		;w4 is the length
	addi nil1,2		;nil1 points to our new space
	push p,nil1		;push it
	push p,w4		; the length
	push p,w2		; rtn addr
	lsh w4,-1		;count doublewds
	skipge (o1)		;if <0, negate it
	 jrst dvrneg
dvr1:	dmove w2,(o1)		;get dw from object
	tlz w2,400000		;make sure sign bits are 0
	tlz w3,400000
	dmovem w2,(nil1)	;put on stack
	addi nil1,2		;bump pointer
	subi o1,2		;decr obj ptr
	sojg w4,dvr1		;until done
	ret

;;negate a number which was negative
dvrneg:	trc n,1
dvrn1g:	setcm w2,(o1)		;get dw from object
	tlz w2,400000		;make sure sign bit is 0
	setcm w3,1(o1)
	tlz w3,400000
	dmovem w2,(nil1)	;put on stack
	addi nil1,2		;bump pointer
	subi o1,2		;decr obj ptr
	sojg w4,dvrn1g		;until done
	sos nil1		;that was a one's complement..
dvrn2g:	aosl (nil1)		;add one to it
	 ret			;stops when carry does
	setzm (nil1)
	soja nil1,dvrn2g

;; this is the main division routine. enter at your own risk.
;; there are lots of hidden assumptions about what digits must
;; be zero or less than other digits, and when overflow can happen.
;; this is a "guessing" algorithm, ie it attempts to find the right
;; next digit of the quotient by dividing the top two remaining
;; digits of the dividend by the top digit of the divisor.  this
;; guess is correct in all but 3 out of 2^70 cases, providing we
;; normalize the dividend (ie, shift it left until the high-order
;; bit in the top digit is a 1). We do this, so we must also shift
;; the result back.  If the guess was wrong, it was too high by
;; 1 or 2.  We must add back the divisor (having subtracted it as
;; multiplied by too high a number) and modify the quotient digit.
;; For a mathematical analysis of all these shenanigans, see Knuth
;; (volume II, Seminumerical Algorithms / the classical algorithms)
;; registers:	o1:	
div2bg:	dmove o1,-3(p)		;find the leftmost bit of the dividend
	skipe -1(o1)
	 jrst div2cg
	dmove w2,(o1)		;here's the leftmost word
	move w4,o1		;another ptr to leftmost wd
	jumpn w2,.+4		;leftmost wd is 0, prepare to 
	  aos o1		;shift number 1 wd as well as n bits
	  sos o2		;ptr moves up, length down
	  move w2,w3
	jffo w2,.+1		;find leftmost bit
	sos o3,w3		;bits to shift (not including sign bit)
	push p,w4		;this will be 1 if a wordshift, else 0
	subm o1,(p)
	call ashbig		;shift it
	skipe (p)		;zero last word if a wordshift
	 setzm 1(w4)
div2dg:	dmove o1,-2(p)		;now shift the divisor the same amount
	dadd o1,[-2 ? 2]	;give it 2 extra words since it may
	dmovem o1,-2(p)		;have more bits in the high digit
	move w4,o1		;than the dividend
	add o1,(p)		;same word-shift flag
	call ashbig		;same everything
	skipe (p)
	 setzm 1(w4)
	push p,o3		;# of bits shifted
	push p,-3(p)		;dividend/quotient pointer
	move w2,-5(p)		;length of divisor/remainder (in wds)
	lsh w2,-1		;now in doubleword digits
	push p,w2
	move w3,-4(p)		;length of dividend
	lsh w3,-1		;in digits
	sub w3,w2		;makes length of quotient
	push p,w3
	push p,o5		;rtn addr
;;P at this point:
;; 0(p) = rtn addr
;; -1(p) = # of digits in quotient
;; -2(p) = # of digits in divisor (and remainder)
;; -3(p) = points to beginning of quotient (to move)
;; -4(p) = # of bits numbers are shifted (mod 35)
;; -5(p) = # of wds numbers are shifted (0 or 1)
;; -6(p) = # of wds in dividend
;; -7(p) = pointer to dividend
;; -10(p) = # of wds in divisor
;; -11(p) = pointer to divisor

	sos -2(p)		;# digits in divisor--1st done separately
	move o4,-3(p)		;quotient
divdvl:	move o3,-11(p)		;divisor
	move o5,o4		;dividend
	dmove nil1,(o5)		;divide top two digits in dividend
	dmove w3,2(o5)
	ddiv nil1,(o3)		;by top digit in divisor
	skipn nil1		;skip the loop if this gives 0
	 jumpe w2,divcrj
	dmovem nil1,(o4)	;else move the quotient to the quotient
	dmovem w3,2(o5)		;and the remainder back to the dividend
	addi o3,2		;divisor
	addi o5,2		;dividend
	move o6,-2(p)		;# of divisor digits for subtract loop
divsbl:	dmove nil1,(o3)		;multiply the divisor
	dmul nil1,(o4)		;by the quotient
	dmove o1,2(o5)		;and subtract it from the dividend
	dsub o1,w3
	tlze o1,400000		;check for borrow
	 dadd nil1,[0 ? 1]
	dmovem o1,2(o5)		;replace over dividend
	dmove o1,(o5)		;subtract the other digit from the
	dsub o1,nil1		; multiply
	tlze o1,400000		;check for borrow
	 jrst divbkn		; this means more involved finagling
	dmovem o1,(o5)		;else put that one back too
divbrj:	addi o3,2		;	There once was a student at Trinity
	addi o5,2		;	Who solved the square root of infinity.
	sojg o6,divsbl		; <==	  While counting the digits,
divcrj:	addi o4,2		;	  He was siezed by the figits;
	aos -3(p)		;	Dropped science, and took up divinity.
	aos -3(p)		;at divcrj we bump and count quotient digits
	sose -1(p)		;and redo the inner divisor-digit loop
	 jrst divdvl		;for each one.
	dmove o1,-7(p)		;pointer to dividend, now quotient
	add o1,o2		;length thereof, giving end ==> remainder
	move o2,-10(p)		;length of divisor/remainder
	movn o3,-4(p)		;bit shift offset
	sos w4,o1		;remainder pointer
	sub w4,-5(p)		;word shift 0/1
	sub o2,-5(p)		;this loop shifts the remainder back
	soje o2,divrh1		;the same amount the divisor & dividend
divrsh:	dmove w2,-1(w4)		;were shifted forth.  the quotient is
	ashc w2,(o3)		;of course already correct (since
	movem w3,(o1)		;a*2^n / b*2^n = a/b).  this loop has
	dsub w4,[1 ? 1]		;to go in the opposite direction from
	sojg o2,divrsh		;the other shift loop
divrh1:	move w2,(w4)		;last word, shift in 0's
	ash w2,(o3)
	movem w2,(o1)
	skipe -5(p)		;clear hi-order wd if a word shift
	 setzm (w4)
	dmove o1,-7(p)		;ptr, length of dividend/quotient
	sub o2,-10(p)		;len(dividend)-len(divisor)=len(quotient)
	move o3,-3(p)		;quotient ptr moved off end now -> remainder
	move o4,-10(p)		;length of divisor/remainder
	setzb o5,o6		;clean up junk
	ret			;whew finally at last

;; shift o2 words from (o1) left o3 bits and put them at (w4)
ashbig:	 soje o2,ashb1g		;only 1 wd?
	dmove w2,(o1)		;main loop--dmove to get bits to shift in
	ashc w2,(o3)
	movem w2,(w4)
	dadd w4,[1 ? 1]		;bump both pointers
	sojg o2,ashbig+1
ashb1g:	move w2,(o1)		;last word, shift in 0's
	ash w2,(o3)
	movem w2,(w4)
	ret

;; this code will probably never be fired in anger.  it handles the
;; special case where the divisor was an even power of -2^70, which
;; numpsh overflows into the buffer 0 digit (so we have to make a
;; new 0 digit).  We know in advance that there is only one 1-bit
;; in the whole number, so we fake the results of ashbig.
div2cg:	movei o3,34.
	move w2,[200000,,0]
	movni o1,2
	addb o1,-3(p)
	movem w2,(o1)
	setzm 1(o1)
	setzm -1(o1)
	setzm -2(o1)
	push p,1
	jrst div2dg

;; here when we borrow out of the current digit in the mult/subtract loop
divbkn:	dmovem o1,(o5)		;continue to borrow backwards
	move w4,o5
divbk1:	subi w4,2		;unless we hit the beginning of the divisor
	camn w4,o4
	 jrst divbk2
	dmove o1,(w4)
	dsub o1,[0 ? 1]
	tlze o1,400000
	 jrst .+3
	  dmovem o1,(w4)
	  jrst divbrj
	dmovem o1,(w4)
	jrst divbk1

;; here when we've borrowed all the way out of the dividend--the guess
;; was too high.  decrement the quotient and add the divisor back in
;; --but only to the point we first began to borrow from; and then
;; continue the original mult/sub loop with the new, lower guess
divbk2:	dmove o1,(o4)
	dsub o1,[0 ? 1]
	dmovem o1,(o4)
	move w3,-11(p)
	hrlzi w2,400000
	iorm w2,2(w4)
divbk3:	addi w4,2
	dmove o1,(w4)
	dadd o1,(w3)
	tlze o1,400000
	 jrst divbk5
	dmovem o1,(w4)
divbk4:	addi w3,2
	camg w4,o5
	 jrst divbk3
	jrst divbrj

;; in theory, we could mult/sub all the way down the dividend,
;; borrow all the way back up, add-back the divisor all the way
;; down again, and come here--to carry all the way back up!
;; in practice, of course, it almost never happens.
divbk5:	 move w2,w4
	dmovem o1,(w2)
	subi w2,2
	dmove o1,(w2)
	dadd o1,[0 ? 1]
	tlze o1,400000
	 jrst divbk5+1
	dmovem o1,(w2)
	jrst divbk4
;; ** end of bignum divide routine **

;;TY%INT
;; after that, the inum divide routine is awfully anticlimactic:
xquinu:	idiv o1,w3
	setz o2,		;squelch the remainder
	maknum o1
	ret

;;TY%RAT
;; this is an embryonic version of the ratio forming routine
rat:	xnmtyp o1		;check each number for integrity
	caige w2,ty%xbg-ty%xfl
	 jrst ratwtn
	xnmtyp o2
	caige w2,ty%xbg-ty%xfl
	 jrst ratwtn
	jrst rltrat		;;MORE  must take lowest terms first

ratwtn:	err /Only integer ratios allowed./

eqp:	camn o1,o2
	 jrst rett
	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xeqp
	xtype o1
	xct a2itab(w2)
xeqp:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xeqflo		;long flons
	jrst xeqifl		;iflons
	jrst xeqifl		;iflons
	jrst xeqrat		;ratios
	jrst notnum		;complex
	jrst xeqbig		;bignums
	jrst retnil		;inums 
	jrst retnil		;inums

xeqflo:	dmove w2,1(o1)
	dfsb w2,1(o2)
	 jumpn w2,retnil
	jrst rett

;;TY%IFL
xeqifl:	came o1,w3
	 jrst retnil
	jrst rett

xeqrat:	jrst nyirat

xeqbig:	getsiz w2,o1
	getsiz w3,o2
	came w2,w3
	 jrst retnil
	move w4,w3
	lsh w4,-1
	add w2,o1
	add w3,o2
	dmove o1,-1(w2)
	came o1,-1(w3)
	 jrst xeqrnl
	move o1,(w3)
	tlz o1,400000
	tlz o2,400000
	came o2,o1
	 jrst xeqrnl
	soje w4,xeqrtt
	hrlzi o3,400000
xeqmlp:	subi w2,2
	subi w3,2
	andcam o3,-1(w2)
	andcam o3,-1(w3)
	dmove o1,-1(w2)
	dsub o1,-1(w3)
	jumpn o1,xeqrnl
	jumpn o2,xeqrnl
	sojg w4,xeqmlp
xeqrtt:	setzb o2,o3
	jrst rett

xeqrnl:	setzb o2,o3
	jrst retnil

;iniint - initialize arg values into w2 and w3, assuming they are integers
iniint:	gettyp o2
	cain w2,ty%lpi
	jrst iniin3
	caie w2,ty%big
	jrst notin2
	move w3,1(o2)
iniin1:	gettyp o1
	cain w2,ty%lpi
	jrst iniin4
	caie w2,ty%big
	jrst notint
	move w2,1(o1)
iniin2:	ret

iniin3:	move w3,o2
	getnum w3
	jrst iniin1

iniin4:	move w2,o1
	getnum w2
	jrst iniin2

notin2:	move o1,o2
notint:	perr /Argument to an integer function not an integer/

rem:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xrem
	xtype o1
	xct a2itab(w2)
xrem:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xrmflo		;long flons
	jrst xrmifl		;iflons
	jrst xrmifl		;iflons
	jrst xrmrat		;ratios
	jrst notnum		;complex
	jrst xrmbig		;bignums
	jrst xrminu		;inums
	jrst xrminu		;inums

;;TY%FLO
xrmflo:	dmove w2,1(o1)		;double precision divide
	dfdv w2,1(o2)
	jrst retflo

;;TY%IFL
xrmifl:	fdvr o1,w3		;single prec divide
	jrst retifl

xrmrat:	jrst nyirat

xrmbig:	getsiz w2,o1
	getsiz w3,o2
	caile w2,4
	 jrst xrmbgb
	caile w3,2
	 jrst xrmbgb
	dmove w3,1(o1)
	cain w2,4
	 jrst [dmove nil1,3(o1) ? jrst .+3]
	  move nil1,w3
	  ashc nil1,-70.
	jfcl 17,.+1
	ddiv nil1,1(o2)
	jov [skipn 1(o2) ? skipe 2(o2) ? jrst xrmbgb ? jrst .+1]
	move w2,w3
	move w3,w4
	setz nil1,
	jrst retint

xrmbgb:	call divrou
	move w4,o4
	add o3,o4
	push p,o3
	setzb nil1,o2
	setzb o3,o4
	setz o5,
	call bigmak
	pop p,o2
	move o3,o1
xrmcpy:	dmove w2,-2(o2)
	dmovem w2,1(o3)
	addi o3,2
	subi o2,2
	sojg w4,xrmcpy
	pop q,p
	tlz p,770000
	setzb o2,o3
	skipe n
	 call rdnbig
	jrst bgtrim

;;TY%INT
xrminu:	idiv o1,w3		;bogus ucilisp truncating int divide
	move o1,o2		;get the remainder
	setz o2			;kill old copy
	maknum o1
	ret

;divide - (quotient . remainder)
;as far as I know, nobody ever uses this
divid:	push q,o1		;save dividend
	push q,o2		;divisor
	call rem
	pop q,o2
	exch o1,(q)
	call quot
	pop q,o2
	jrst cons
	
;GCD
gcd:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xgcd
	xtype o1
	xct a2itab(w2)
xgcd:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xgcdno		;long flons
	jrst xgcdno		;iflons
	jrst xgcdno		;iflons
	jrst xgcdno		;ratios
	jrst notnum		;complex
	jrst xgdbig		;bignums
	jrst xgdinu		;inums
	jrst xgdinu		;inums

xgcdno:	err /Can't take GCD of non-integers/

xgdbig:	camn o1,[object ty%cbg,<codsec,,work>]
	 jrst [move o1,work+2 ? maknum(o1) ? jrst .+1]
	camn o2,[object ty%cbg,<codsec,,work>]
	 jrst [move o2,work+2 ? maknum(o2) ? jrst .+1]
	push q,o1
	push q,o2
	call lessp
	jumpe o1,.+4
	 dmove o1,-1(q)
	 exch o1,o2
	 dmovem o1,-1(q)
	dmove o1,-1(q)
	pop q,-1(q)
xgdbgl:	call rem		;Euclid's algorithm (the hard way)
	pop q,o2
	exch o1,o2
	camn o2,[inum0]
	 jrst absf
	push q,o2
	jrst xgdbgl

;;TY%INT
xgdinu:	movm w2,w3		;GCD ignores sign
	movms o1
	jumpe w2,xgdret		;if either 0 return the other
	jumpe o1,ret1nt
	setz o2,		;binary GCD: find common power of 2
xgdip2:	trnn w2,1
	 trne o1,1
	  jrst xgdime
	lsh o1,-1		;shift both numbers right until 
	lsh w2,-1		; one of them is odd
	aoja o2,xgdip2

xgdime:	tlne w2,1		;make w2 the even one
	 exch w2,o1
xgdilp:	movn w3,w2		;shift right until odd
	eqv w3,w2
	jffo w3,.+2
	 skipa			;(already odd)
	  lsh w2,-35.(w4)
	camge w2,o1		;make w2 the larger one
	 exch w2,o1
	sub w2,o1		;--the difference
	jumpn w2,xgdilp		;continue until 0
	lsh o1,(o2)		;restore power of 2
	setz o2,
xgdret:	tlo o1,(inum0)
	ret

sieve:
	.byte 9
	1. ? 11. ? 13. ? 17. ? 19. ? 23. ? 29. ? 31. ? 37. ? 41. ? 43.
	47. ? 53. ? 59. ? 61. ? 67. ? 71. ? 73. ? 79. ? 83. ? 89. ? 97.
	101. ? 103. ? 107. ? 109. ? 113. ? 121. ? 127. ? 131. ? 137.
	139. ? 143. ? 149. ? 151. ? 157. ? 163. ? 167. ? 169. ? 173.
	179. ? 181. ? 187. ? 191. ? 193. ? 197. ? 199. ? 209.
	.byte
sivsiz:	48.
sivptr:	441100,,sieve

prime:	move w2,o1		;find the next prime >=arg
	getnum w2
	call iprime
	jrst ret1nt

iprime:	idivi w2,210.
	imuli w2,210.
	push p,w2
	dmove w4,sivsiz
iprim1:	ildb w2,o1
	camge w2,w3
	 sojg w4,iprim1
	sos w4
	push p,w4
	push p,o1
	add w2,-2(p)
	call iprimp
	jumpn o1,iprim4
iprim2:	dmove w3,-1(p)
	sojle w3,iprim5
iprim3:	ildb w2,w4
	add w2,-2(p)
	dmovem w3,-1(p)
	call iprimp
	jumpe o1,iprim2
iprim4:	dmove w3,-1(p)
	ldb w2,w4
	add w2,-2(p)
	adjsp p,-3
	ret

iprim5:	dmove w3,sivsiz
	move w2,-2(p)
	addi w2,210.
	movem w2,-2(p)
	jrst iprim3

primep:	move w2,o1
	getnum w2
	caie w2,2		;2 is prime
	 cain w2,3		;3 is prime
	  jrst rett
	caie w2,5		;5 is prime
	 cain w2,7		;7 is prime
	  jrst rett
	caig w2,10.		;other numbers <= 10 are not
	 jrst retnil
	move w4,w2
	idivi w4,2		;divisible by 2?
	 jumpe o1,[ret]		; yes, not prime
	move w4,w2
	idivi w4,3		;by 3?
	 jumpe o1,[ret]
	move w4,w2
	idivi w4,5		;by 5?
	 jumpe o1,[ret]
	move w4,w2
	idivi w4,7		;by 7?
	 jumpe o1,[ret]
	caige w2,121.		;other numbers less than 11^2 are prime
	 jrst rett		;after this, the number is as if chosen
				;from the sieve table
iprimp:	adjsp p,5
; -4(p) -- the number in question
; -3(p) -- inner loop count (ranges over the sieve table)
; -2(p) -- byte pointer into sieve table
; -1(p) -- base, for which sieve table contains offsets
;   (p) -- the estimated square root
	movem w2,-4(p)
	jffo w2,.+1		;estimate square root of the #
	move w4,w2		;take a number with half as many bits
	subi w3,36.
	ash w3,-1
	lsh w4,(w3)
	idiv w2,w4		;divide the original # by it
	addi w2,1
	add w2,w4		;and take the average of it and the quotient
	lsh w2,-1
	addi w2,1		;rounding up at every turn so we are sure
	movem w2,(p)		;the estimate is >= the actual root
	dmove w2,sivsiz
	sos w2			;don't try to divide by 1
	ibp w3
	dmovem w2,-3(p)
	setzm -1(p)
pploop:	ildb w2,w3
	add w2,-1(p)
	caml w2,(p)
	 jrst [adjsp p,-5 ? jrst rett]
	move w4,-4(p)
	idiv w4,w2
	jumpe o1,[adjsp p,-5 ? ret]
	sosle -3(p)
	 jrst pploop
	dmove w2,sivsiz
	dmovem w2,-3(p)
	move w2,-1(p)
	addi w2,210.
	movem w2,-1(p)
	jrst pploop

;BOOLE - LSUBR, 1st arg is code, rest are combined
;o3 - arg count
;nil1 - boole code (first arg)
;w3 - place for building up result
boole:	getnum o1
	cain o1,3
	 jrst bool3
	move w4,q		;w4 - addr of last arg
	sub w4,o1		;w4 - below first arg
	addi w4,2		;2nd arg
	push p,w4
	subi o1,2
	jumpl o1,[perr /BOOLE needs at least 2 args/]
	push p,o1		;move count
	move o1,-1(w4)		;boole code
	move nil1,o1
	getnum nil1
	cail nil1,0
	 caile nil1,17
	  jrst [perr /BOOLE - function must be 0 to 15/]
	lsh nil1,29.		;put into bits 074000,,0
	ior nil1,[setz o1,w3]
	push p,nil1
	xor nil1,[<setz o1,w3>#<setz w2,1(o2)>]
	push p,nil1
	xor nil1,[<setz w2,1(o2)>#<setz w3,2(o2)>]
	push p,nil1
	move o1,(w4)		;first arg
boolel:	aos -4(p)		;incr pointer
	sosge -3(p)		;and decr count
	 jrst boolex		;no - done
	move o2,@-4(p)		;yes - get it
	call xboole
	jrst boolel		;now see if more

boolex:	setz nil1,		;clear up NIL1
	adjsp p,-5
	ret

;; do boole of numbers in o1 and o2, returning result in o1
xboole:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst boowho
	xtype o1
	xct a2itab(w2)
boowho:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst booerr		;long flons
	jrst booerr		;iflons
	jrst booerr		;iflons
	jrst booerr		;ratios
	jrst notnum		;complex
	jrst boobig		;bignums
	jrst booinu		;inums 
	jrst booinu		;inums

booerr:	err /BOOLE only takes integers/

;;TY%BIG		booleate bignums
boobig:	move o3,o1		;save o1
	getsiz w3,o1		;find out how big they are
	getsiz w4,o2
	came w4,w3		;same size?
	 jrst boobds		;no, use general routine
	caie w3,2		;yes: 2 words perchance
	 jrst  boob2		; no...
	dmove w2,1(o3)		;yes, all is very simple (& fast)
	xct -2(p)		;setxx w2,1(o2)
	xct -1(p)		;setxx w3,2(o2)
	jrst retint

;args same size but >2 wds.  slight simplification.
boob2:	call bigmak		;answ will be the same size
	setz o5,		;this is the which-bigger flag
	push p,0		;this is the size difference
	jrst boobx0

boobds:	setz o5,		;o5=0 ==> o2 is longer
	camg w3,w4		;which is bigger?
	 jrst .+3
	  exch w3,w4		;put bigger size on w4
	  seto o5,		;can't switch args, use flag
	lsh w3,-1		;smaller size ==> #/dw's
	push p,w3
	call bigmak		;result gets size of larger
	sub w4,(p)		;difference in sizes
	exch w4,(p)		;use smaller for count, save diff
boobx0:	move o4,o1		;result area, use as traveling ptr
;;	jrst boobx2             falls thru

;;the structure of the loops is wierd because it was copied from subtract.
;;first loop is for booleing digits where the numbers coincide;
;;second is to propagate borrowing along the "overhang" or
;;"underhang" of the larger number.

boobx2:	dmove w2,1(o3)
	xct -3(p)		;setxx w2,1(o2) (extra junk on p)
	xct -2(p)		;setxx w3,2(o2)
	dmovem w2,1(o4)		;stash
	addi o2,2		;advance pointers
	addi o3,2
	addi o4,2
	sojg w4,boobx2		; are we out of digits
boobx3:	pop p,w4		;difference count
	jumpe w4,boobx9		;if #'s same size, that was it!
	skipn o5		;o5=0 ==> o2 is longer 
	 skipa w2,-1(o3)
	  move w2,-1(o2)
	ash w2,-35.		;propagate the sign of the shorter
	movem w2,work+3		;at +3 in case an arg was at work+0!
	movem w2,work+4
boobx6:	jumpe o5,.+2		;o5=0 ==> o2 is longer
	 xmovei o2,work+2
	jumpn o5,.+2
	 xmovei o3,work+2
	dmove w2,1(o3)
	xct -2(p)		;setxx w2,1(o2)
	xct -1(p)		;setxx w3,2(o2)
	dmovem w2,1(o4)		;stash
	addi o2,2		;bump pointers
	addi o3,2		;one is superfluous, but we don't know which
	addi o4,2
	sojg w4,boobx6		;out of digits?
boobx9:	setzb o2,o3		;yes: clean up
	setz o4,o5
	ret

booinu:	xct -3(p)		;setxx o1,w3
	move w2,o1
	ashc w2,-35.
	jrst retint

bool3:	dmove o2,-1(q)
	move o1,-2(q)
	; fall thru

;*BOOLE
;o1 - which function
;o2 - arg 1
;o3 - arg 2
	;fall in
sboole:	move nil1,o1
	getnum nil1
	cail nil1,0
	 caile nil1,17
	  jrst [perr /BOOLE - function must be 0 to 15/]
	lsh nil1,29.		;put into bits 074000,,0
	ior nil1,[setz o1,w3]
	push p,nil1
	xor nil1,[<setz o1,w3>#<setz w2,1(o2)>]
	push p,nil1
	xor nil1,[<setz w2,1(o2)>#<setz w3,2(o2)>]
	push p,nil1
	dmove o1,o2
	call xboole
	setz nil1,
	adjsp p,-3
	ret

;lsh
;;WORK - warning: TRUNC replies on the fact that WORK is not used when a
;bignum is passed.
lshf:	move w4,o2		;2nd arg: # of bits to lsh first arg
	skpin o2
lsherr:	 jrst [err /Improper value in arg to LSH/]
	getnum w4
inlsh:	a1disp			;;TYPES
	jrst lshflo		;a long flon
	jrst lshifl		;iflon
	jrst lshifl		;iflon
	jrst lshrat		;ratio
	jrst notnum		;complex
	jrst lshbig		;bignum
	jrst lshint		;neg int
	jrst lshint		;pos int

;;TY%FLO			floating numbers are scaled
lshflo:	dmove w2,1(o1)
	jfcl 17,.+1
	fsc w2,(w4)
	jov ovrflo
	jrst retflo

;;TY%IFL
lshifl:	lsh o1,4
	jfcl 17,.+1
	fsc o1,(w4)
	jov ovrflo
	jrst retifl

lshrat:	push q,1(o1)
	move o1,(o1)
	call inlsh
	pop q,o2
	jrst rat

;;WORK
lshint:	getnum o1		;
	move w2,o1
	ashc w2,-35.
	dmovem w2,work+1
	cail w4,70.
	 jrst lshiov
	camg w4,[-70.]
	 movni w4,70.
	jfcl 17,.+1
	ashc w2,(w4)
	jov lshiov
	jrst retint

lshiov:	move o1,[object ty%spc,2]
	movem o1,work	;save it in this fixed area
	move o1,[object ty%cbg,<codsec,,work>]
	;jrst lshbig

;;TY%BIG
lshbig:	skipge w2,w4		; separate left and right lsh's
	 jrst lshbng
	jumpe w2,[ret]		;... and none at all
	idivi w2,70.		;# of bits => # of doublewds, bits
	skipe w3		;even dw boundary?
	 aosa w2		;no, bump #dws to cover extra piece
	  movei w3,70.		;call it a 70-bit shift
	getsiz w4,o1		;how big is the number?
	lsh w4,-1		;gives # of dws
	add w4,w2		;original size + amount to lsh = new size
	lsh w4,1		;in wds again
	move o2,o1		;save obj ptr while making new no.
	push p,w2		;save # of dws
	push p,w3		;save # of bits
	call bigmak		;ptr in o1, size/2 in w4
	getsiz w2,o1		;its size
	sos w2			;less one
	move w3,o1
	aos w4,w3		;copy from first element
	aos w4			;...to second
	setzm (w3)		;fill it with zeroes
	xblt w2,
	move o3,o1		;copy to move
	move o4,(p)		;# bits to shift
	subi o4,70.		;--backward
	move o5,(p)		;--forward (see algorithm below)
	move w2,-1(p)		;# dws to shift
	sos w2			;fencepost fudge factor
	lsh w2,1		;use as # of wds
	add o3,w2		;word-shifting by offsetting pointers
	getsiz w4,o2		;of original
	lsh w4,-1		;dws
	dmove w2,1(o2)		;low order dw
	ashc w2,(o5)		;shift left
	dmovem w2,1(o3)		;plunk into place
	soje w4,eolblp		;see if also the high-order dw...
lshbgl:	dadd o2,[2 ? 2]		;main loop: bump both pointers
	dmove w2,1(o2)		;get input dw whose low order bits will fall
	ashc w2,(o5)		;in this output dword, and shift it left
	dmovem w2,1(o3)		;save; then get dw just below, whose high
	dmove w2,-1(o2)		;order bits will fall in the output dw
	tlz w2,400000		;--clear the sign bit--
	ashc w2,(o4)		;shift it *right*
	dadd w2,1(o3)		;put the two together (there's no "dior" inst)
	dmovem w2,1(o3)		;place in output dw
	sojg w4,lshbgl		;loop
eolblp:	dmove w2,1(o2)		;high order dw:
	ashc w2,(o4)		;the right shift part only,
	dmovem w2,3(o3)		; without clearing the sign bit
	setzb o2,o3		;clean up
	setzb o4,o5
	adjsp p,-2
	jrst bgtrim		;and return the number

;this is for right shifts: various things are different
lshbng:	idivi w2,70.		;# of bits => # of doublewds, bits
	getsiz w4,o1		;how big is the number?
	lsh w4,-1		;gives # of dws
	add w4,w2		;original size + amount to lsh = new size
	lsh w4,1		;in wds again
	jumple w4,ret0		;if we're shifting it out of existance
	cain w4,2		;if a single doubleword
	 jrst lshb22		; use special case routine
	move o2,o1		;save obj ptr while making new no.
	push p,w2		;save # of dws
	push p,w3		;save # of bits
	call bigmak		;ptr in o1, size/2 in w4
	move o3,o1		;copy to move
	move o4,(p)		;# bits to shift
	addi o4,70.		;--backward
	move o5,(p)		;--forward (see algorithm below)
	getsiz w4,o3		;size of new no.
	lsh w4,-1		;in dws
	sos w4			;lose one in the process
	move w2,-1(p)		;# dws to shift
	lsh w2,1		;use as # of wds
	sub o2,w2		;word-shifting by offsetting pointers
lshbnl:	dmove w2,1(o2)		;get input dw whose high order bits will fall
	tlz w2,400000		;--clear the sign bit--
	ashc w2,(o5)		;in this output dword, and shift it right
	dmovem w2,1(o3)		;save; then get dw just above, whose low
	dmove w2,3(o2)		;order bits will fall in the output dw
	ashc w2,(o4)		;shift it left
	dadd w2,1(o3)		;put the two together (there's no "dior" inst)
	dmovem w2,1(o3)		;place in output dw
	dadd o2,[2 ? 2]		;bump both pointers
	sojg w4,lshbnl		;loop
eolbnl:	dmove w2,1(o2)		;high order dw:
	ashc w2,(o5)		;the right shift part only,
	dmovem w2,1(o3)		; without clearing the sign bit
	setzb o2,o3		;clean up
	setzb o4,o5
	adjsp p,-2
	jrst bgtrim		;and return the number

lshb22:	getsiz w4,o1		;for cases when only the high-order dw
	add o1,w4		;of arg is used
	move w4,w3		;right shift of 2-wd bignum
	dmove w2,-1(o1)
	ashc w2,(w4)
	jrst retint

intlen:	camge o1,[object ty%big,0]
	 jrst [err /Not an integer/]
	skpin o1
	 jrst ilbig
	getnum o1
	movm w4,o1
	jffo w4,.+1
	skipe w4
	 movei w4,36.
	subm w4,o1
	maknum o1
	ret

ilbig:	getsiz w4,o1
	add o1,w4
	dmove w2,-1(o1)
	skipge w2
	 dmovn w2,w2
	jumpn w2,.+3
	 subi w4,1
	 move w2,w3
	imuli w4,35.
	jffo w2,.+1
	subi w3,1
	sub w4,w3
	maknum w4
	move o1,w4
	ret

;numberp
;;TYPES
nump:	skpnum o1
	 jrst retnil
	jrst rett

;inump
inump:	skpin o1
	 jrst retnil
	jrst rett

;numtype
numtyp:	xnmtyp o1
	xct nmtytb(w2)
	ret

;;TYPES
nmtytb:	move o1,[%DOUBLE]	; long flon
	move o1,[%FLONUM]	; - iflon
	move o1,[%FLONUM]	; + iflon
	move o1,[%RATIO]
	jrst notnum
	move o1,[%BIGNUM]
	move o1,[%INUM]		; integer
	move o1,[%INUM]		; integer

;zerop
zerop:	camn o1,[inum0] ;first check for most common
	 jrst rett		;it is
	skpnin o1		;else if inum not 0
	 jrst retnil
	xnmtyp o1		;then try the rest
	xct zeropt(w2)

;;TYPES
zeropt:	jrst zeropr		; real
	jrst retnil		; neg iflon
	jrst zpifl		; pos iflon
	jrst zprat		;ratio
	jrst notnum		;complex
	jrst retnil		; bignum -- 0 is an inum
	jrst syserr		;already tested for
	jrst syserr		;already tested for

syserr:	err /Impossible error/

zpifl:	camn o1,[object ty%lpf,0]
	 jrst rett
	jrst retnil

;;TY%FLO
zeropr:	skipn 1(o1)
	 skipe 2(o1)
	  jrst retnil
	jrst rett

;;TY%RAT
zprat:	docar o1,o1		;a ratio is zero only if
	jrst zerop		;the numerator is

;SUB1
;we try to handle small integers quickly
sub1:	sos o1
	skpnin o1		;if underflow or not an inum
	 ret			;that's usually it...
	aos o1			;..we jumped the gun
	xnmtyp o1		;what kind of number
	xct sub1t(w2)

;;TYPES
sub1t:	jrst s1lflo		;long flon
	jrst s1iflo		;neg iflon
	jrst s1iflo		;pos iflon
	jrst sb1rat		;ratio
	jrst notnum		;complex (not implemented)
	jrst sb1big		;bignum
	jrst s1uflo		;arg was smallest inum, rtn a bignum
	jrst syserr		;(pos inums)
	
;;TY%FLO
s1lflo:	movflo o1		;can't overflow
	dfsb w2,[1.0 ? 0]
	jrst retflo

;;TY%IFL
s1iflo:	lsh o1,4		;save type bits
	fsbri o1,(1.0)		;can't overflow
	jrst retifl

;;TY%INT
;;TY%BIG
; inum underflow, only one possible value
s1uflo:	dmove w2,[-1 ? -020000000001]
	jrst retbig

;;TY%RAT
sb1rat:	dmove o1,(o1)		;(a/b)-1 = (a-b)/b
	push q,o2		;furthermore, lowest terms are preserved
	call diff
	pop q,o2
	jrst rltrat

sb1big:	move o2,[inum 1]	;note the incredibly sophistocated
	jrst diff		;way this is done...

;ADD1
;we try to handle small integers quickly
add1:	aojl o1,a1oflo		;overflo of inum makes word negative
	skpnin o1	;was it an inum after all?
	 ret			;...yes
	sos o1			;no--undo our overeager incrementation
	xnmtyp o1		;what kind of number
	xct add1t(w2)

;;TYPES
add1t:	jrst a1lflo		;long flon
	jrst a1iflo		;neg iflon
	jrst a1iflo		;pos iflon
	jrst ad1rat		;ratio
	jrst notnum		;complex (not implemented)
	jrst ad1big		;bignum
	jrst syserr		;inums should have been gotten above
	jrst syserr		;(pos inums)

;;TY%INT
;;TY%BIG
; inum overflow. there's only one possible value...
a1oflo:	dmove w2,[0 ? 020000,,0]
	jrst retbig

;;TY%FLO
a1lflo:	movflo o1
	dfad w2,[1.0 ? 0]	;can't overflow
	jrst retflo

;;TY%IFL
a1iflo:	lsh o1,4		;move the type bits out of harm's way
	fadri o1,(1.0)		;can't overflow
	jrst retifl

;;TY%RAT
ad1rat:	dmove o1,(o1)		;(a/b)+1 = (a+b)/b
	push q,o2		;furthermore, lowest terms are preserved
	call plus
	pop q,o2
	jrst rltrat

ad1big:	move o2,[inum 1]	;note the incredibly sophistocated
	jrst plus		;way this is done...

;minusp
minusp:	xnmtyp o1
	xct minupt(w2)		;skip if negative
	 tdza o1,o1		;nil
	  move o1,[%T]		;T
	ret

;;TYPES
minupt:	skipl 1(o1)		; long flon  ;;TY%FLO
	skipa			;minus iflons
	jfcl			;plus flons
	jrst [docar o1,o1 ? jrst minusp]  ;ratio ;;TY%RAT
	jrst notnum		; complex (not implemented)
	jrst mnpbig		; bignum
	skipa			; neg inums
	jfcl			; pos inums

;;TY%BIG
mnpbig:	getsiz w4,o1		;find the other end
	add w4,o1		; --with the significant sign bit
	skipl -1(w4)		;is it negative
	 jrst retnil		; no
	jrst rett		;yes
;abs
absf:	xnmtyp o1
	xct absft(w2)
	jrst notnum

;;TYPES
absft:	jrst absflo		;long flons
	jrst absifl		;neg iflons
	ret			;pos iflons
	jrst absrat		;ratios
	jrst notnum		;complex
	jrst absbig		;bignum
	jrst absinu		;neg inum
	ret			;pos inum

;;TY%INT
absinu:	tlo o1,760000
	movns o1
	camn o1,[020000,,0]
	 jrst a1oflo
	tlo o1,(inum0)
	ret

;;TY%FLO
absflo:	dmovn w2,1(o1)
	jumpge w2,retbig
	ret

;;TY%IFL
absifl:	lsh o1,4		;save type bits
	movns o1		;we know it's negative
	jrst retifl

;;TY%RAT
absrat:	push q,1(o1)		;save the denominator
	move o1,(o1)		;abs the numerator
	call absf
	pop q,o2
	jrst rltrat		;still in lowest terms

absbig:	getsiz w4,o1		;find the other end
	add w4,o1		; --with the significant sign bit
	skipl -1(w4)		;is it negative
	 ret			; no, return it
	jrst exnegb		;yes, negate it

repeat 0,[  ;we are now using a version elsewhere, completely
	;rewritten
;FIX
fixf:	xnmtyp o1
	xct fixft(w2)
	jrst notnum

;;TYPES
fixft:	jrst fixlfl		; long flon
	jrst fixifl		; neg iflon
	jrst fixifl		; pos iflon
	jrst fixrat		; fix ratio
	jrst notnum		; complex - not implemented
	ret			; bignum
	ret			; neg inum
	ret			; pos inum

fixlfl:	dmove w2,1(o1)		;value to w2,w3
	skipge w2		;treat negative separately
	 jrst fixfn
	ldb w4,[.bp <377_27.>,w2]	;get exponent
	tlz w2,377000		;and clear it
	ashc w2,-200-27.-35.(w4)	;right justify in w2/3
	jrst retint

fixfn:	ldb w4,[.bp <377_27.>,w2]	;get exponent
	movn w4,w4
	tlo w2,377000		;and clear it
	ashc w2,177-27.-35.(w4)	;right justify in w2/3
	jrst retint

fixifl:	lsh o1,4		;;MORE  -- make these produce bignums on 
	fix o1,o1		; overflo
	maknum o1
	ret

fixrat:	dmove o1,(o1)		;divide numerator by denominator (!)
	jrst quot
] ;repeat 0

;greaterp
greatp:	exch o1,o2
	;jrst lessp
;lessp
lessp:	skpnin o1
	 skpin o2
	  jrst lessp1
	camge o1,o2
	 jrst rett
	jrst retnil

lessp1:	move w3,o2
	xtype o2		;what's second arg?
	xct doptab(w2)		;above, qv
	 jrst xlessp
	xtype o1
	xct a2itab(w2)
xlessp:	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xlpflo		;long flons
	jrst xlpifl		;iflons
	jrst xlpifl		;iflons
	jrst xlprat		;ratios
	jrst notnum		;complex
	jrst xlpbig		;bignums
	jrst xlpifl		;inums (can't get here, but if we could,
	jrst xlpifl		;inums  the same instrs would work.)

;;TY%FLO
xlpflo:	dmove w2,1(o1)
	dfsb w2,1(o2)
	 jumpl w2,rett
	jrst retnil

;;TY%IFL
xlpifl:	camge o1,w3
	 jrst rett
	jrst retnil


xlprat:	jrst nyirat

xlpbig:	getsiz w2,o1
	getsiz w3,o2
	came w2,w3
	 jrst xlpdfs
	move w4,w3
	lsh w4,-1
	add w2,o1
	add w3,o2
	dmove o1,-1(w2)
	camge o1,-1(w3)
	 jrst xlprtt
	came o1,-1(w3)
	 jrst xlprnl
	move o1,(w3)
	tlz o1,400000
	tlz o2,400000
	camge o2,o1
	 jrst xlprtt
	came o2,o1
	 jrst xlprnl
	soje w4,xlprnl
	hrlzi o3,400000
xlpmlp:	subi w2,2
	subi w3,2
	andcam o3,-1(w2)
	andcam o3,-1(w3)
	dmove o1,-1(w2)
	dsub o1,-1(w3)
	jumpl o1,xlprtt
	jumpg o1,xlprnl
	jumpg o2,xlprnl
	sojg w4,xlpmlp
xlprnl:	setzb o2,o3
	jrst retnil

xlprtt:	setzb o2,o3
	jrst rett

xlpdfs:	move w4,w2
	sub w4,w3
	add w2,o1
	add w3,o2
	move w2,-1(w2)
	skipl w3,-1(w3)
	 jumpl w2,rett
	skipl w2
	 jumpl w3,retnil
	xor w4,w2
	jumpl w4,rett
	jrst retnil

;;TYPES
;TY%ATM
;TY%STR
;LEXTB - type dispatch for LEXORDER
;W3 - where to go if number
;O1 - object we are looking at
;string pointer left in O1

lextb:	call lexatm		;atom
	call lexcon		;cons
	jfcl			;string
	jrst lexill		; channel
	jrst lexill		; hash table
	jrst lexill		; vector
	jrst lexill		; addr
	repeat 8,jrst (w3)		; numbers

lexill:	perr /Argument to LEXORDER must be number, string, or atom/

lexatm:	skipn o1
	move o1,[%NIL]
	move O1,at%pna(o1)	;atom
	ret

lexcon:	docar o1,o1
	sos (p)
	sos (p)		;try again
	ret

;TY%STR
;TY%SPC
;lexorder - compare either numbers or strings
;TRUE IF A IS ALPHAMERICALLY LESS THAT OR EQUAL TO B
;**	FIXED TO HANDLE LISTS BY FINDING LEFT-MOST ATOM

lexord:	xmovei w3,lex2		;where to go if number
	xtype o1		;check first arg
	xct lextb(w2)
	exch o1,o2
	xmovei w3,retnil	;if first non-num, second num, NIL
	xtype o1
	xct lextb(w2)
	move w4,[cmpsle o1,]
;o2 - 1st arg, string; o1 - second arg, string; w4, cmpxx instruction
cmpstr:	xmovei o6,1(o1)		;address only, second arg
	xmovei o3,1(o2)		;address only, first arg
	move o4,(o1)		;size, second arg
	tlz o4,770000
	move o1,(o2)		;size, second arg
	tlz o1,770000
	move o2,[444340,,0]	;35-bit byte, extended format
	move o5,o2		;for both
	xct w4			;compare
	skipa o1,nil		;failed - nil
	move o1,[%t]		;succeeded - T
	setzb o2,o3		;clear garbage
	setzb o4,o5
	setz o6,
	ret

lex2:	exch o1,o2		;now analyze second
	xmovei w3,lex3		;both numbers, continue
	xtype o1
	xct lextb(w2)
	jrst rett		;1st=num, 2nd not, defined as true

;now both known to be numbers, but order is reversed.  Correct test
;is .LE., so we do .GE., in form .NOT. .LT.
lex3:	call diff
	call minusp
	jrst not

;;TY%NUM		cnvt any number to a 1 wd float in w2
ob21wf:	skpnum o1
	 jrst retnil		;do nothing if not a number
	nmtypx o1
	xct o1wtab(w2)
	 skipa w2,o1
	  fltr w2,o1
	move o1,[inum0]
	ret

;;TYPES
o1wtab:	move o1,1(o1)		; long flon
	lsh o1,4		; neg iflon
	lsh o1,4		; pos iflon
	jrst retnil		; fix ratio - nyi
	jrst retnil		; complex - not implemented
	skipa o1,2(o1)		; bignum
	tloa o1,760000		; neg inum
	tlza o1,760000		; pos inum

;meter
;accounting meter stuff
umeter:	skpin o1
	 jrst notint		;better be an integer
	move nil1,o1
	getnum nil1
	meter%
	setz nil1,
	ashc w2,-12.		;right justify
	jrst retint		;return as integer

;time
;runtime for process
runtim:	movei nil1,.fhslf
	runtm			;runtime to nil1 in msec
	move w2,nil1		;need it in W2 for ret1nt
	setz nil1,
	jrst ret1nt

;startclock, stopclock
;(startclock msec tabsiz) sets the clock to fire every msec milliseconds
; and notate the running function in a table of size tabsiz,
; which is returned by stopclock when it is called to stop the clock.
; the table is a vector: 
; <total # of interrupts>, <# in GC>, <# "otherwise">, 
;  tabsiz function names, tabsiz numbers of calls per function
stclk:	getnum o1		;msec btween ticks
	getnum o2		;slots in counting array
	movem o1,clkinc
	movem o2,clkfns
	move o1,o2		;actual vector is 2*tabsiz+4 long
	setz o2,
	addi o1,2
	lsh o1,1
	maknum o1
	call makvec		;vector ptr in o1
	movem o1,@[datsec,,clktab]
	dmove o2,[inum0 ? inum0]	;initialize total, gc, and "other" #'s
	dmovem o2,(o1)
	movem o2,2(o1)
	move nil1,[.fhslf,,.timel]	;interrupt this process in AC2 msec
	move w2,clkinc
	movei w3,25.		;make sure this corresponds with CHNTAB
	timer
	 jrst [setz nil1, ? setzb o1,o2 ? setzm clkinc
		err /invalid args to STARTCLOCK/]
	setz nil1,
	setzb o1,o2
	ret

;;TY%ATM	-- in particular, the structure of the fn addr blocks
	.vector clksav(4)	;for saving regs at interrupt level
clkint:	skipn clkinc
	 debrk
	dmovem nil1,clksav
	dmovem w3,clksav+2
	skipe crit
	 jrst clkgc
	move nil1,p
clkilp:	camg nil1,[basep]
	 jrst clknof
	pop nil1,w2
	hlrz w3,w2
	caie w3,codsec
	 jrst clkilp
	hlrz w3,-1(w2)
	caie w3,(<pushj p,@0>)
	 jrst clkilp
	hrrz w3,-1(w2)
	hrli w3,ty%lpi_12.+codsec	;now points to dispatch block
	move w4,1(w3)		;points back to the atom
	tlne w4,767700		;;TY%ATM
	 jrst clkilp
	came w3,at%dsp(w4)	;should also point to dispatch block
	 jrst clkilp
;if we get this far, we have something remarkably similar to an atom
;with function address block.  count it.
	move nil1,@[datsec,,clktab]
	aos (nil1)		;incr total # of calls
	addi nil1,3
	move w2,clkfns
clksek:	camn w4,(nil1)
	 jrst clkfnd
	skipn (nil1)
	 jrst clkemp
	aoj nil1,
	sojg w2,clksek
	move nil1,@[datsec,,clktab]	;out of room
	aos 2(nil1)		;# of "other" calls
	jrst clkout

clkfnd:	add nil1,clkfns
	aos (nil1)
	jrst clkout

clknof:	move nil1,@[datsec,,clktab]	;couldn't determine a function
	aos (nil1)		;incr total # of calls
	aos 2(nil1)		;# of "other" calls
	jrst clkout

clkgc:	move nil1,@[datsec,,clktab]	;in the garbage collector
	aos (nil1)		;incr total # of calls
	aos 1(nil1)		;# of gc calls
	jrst clkout

clkemp:	movem w4,(nil1)		;empty slot found
	add nil1,clkfns		;put function name
	move w2,[inum 1]	;put 1 for # of calls
	movem w2,(nil1)
clkout:	move nil1,[.fhslf,,.timel]	;interrupt this process in AC2 msec
	move w2,clkinc
	movei w3,25.		;make sure this corresponds with CHNTAB
	timer
	 jfcl
	dmove nil1,clksav
	dmove w3,clksav+2
	debrk

stpclk:	setzm clkinc
	move o1,@[datsec,,clktab]	;return the table
	setzm @[datsec,,clktab]
	ret

	; CAR, CDR, CONS and of course the garbage collector
	; code in this section knows about the format of cons cells
	; (a cons cell is two consecutive words containing values)
	; the garbage collector knows a little bit about everything,
	; so always check it when any format is changed.
;this page contains all routines that depend upon the format of a
;cons cell.  for the use of other pages, we define macros for
;car, cdr, rplaca, and rplacd.

;;TY%CON
CAR:	scons o1		;make sure it is cons cell
	jumpn o1,notcns		;if not, error unless it's nil
	move o1,(o1)		; car of a cell is the first word
	ret

;optimized form of CAR, called directly from eval
evcar:	docdr o1,o1
	docar o1,o1		;now have the arg
	call eval		;have to eval it
	scons o1
	jumpn o1,notcns
	move o1,(o1)
	adjsp p,-2
	adjsp sp,-4
	ret


notcns:	perr /Attempt to CAR or CDR something that is not a CONS cell/


;;TY%CON
CDR:	scons o1		;make sure it is a cons cell
	jumpn o1,notcns		;if not, error unless it's nil
	move o1,1(o1)		; cdr of a cell is the second word
	ret

;optimized form of CDR, called directly from eval
evcdr:	docdr o1,o1
	docar o1,o1		;now have the arg
	call eval		;have to eval it
	scons o1
	jumpn o1,notcns
	move o1,1(o1)
	adjsp p,-2
	adjsp sp,-4
	ret

;;TY%CON
rplaca:	chcons o1		;better be a cons cell
	movem o2,(o1)
	ret

;;TY%CON
define dorpa(x,y)
	movem y,(x)
	termin

;;TY%CON
rplacd:	chcons o1		;better be a cons cell
	movem o2,1(o1)		;put it in cdr
	ret

;;SASSOC - assoc that calls a funct when it fails
sassoc:	skipa w2,[sassf]

;;ASSOC - assoc that returns nil when it fails
assoc:	movei w2,retnil

;;IASSOC - search a list of pairs looking for one with a given CAR
;o2 - list, o1 - target, w2 - place to go if you lose
;O6 is assumed to be preserved 
iassoc:	
  ;loop until list runs out
assocl:	jumpe o2,(w2)		;if list empty, return nil
	docar o4,o2		;o1 _ caar of list
	docar o5,o4
	camn o5,o1		;if EQ target
	jrst assocf		;found it, yes
	docdr o2,o2		;no, advance down list
	jrst assocl
assocf:	move o1,o4		;return car
	ret

;here if SASSOC fails
sassf:	move o1,o3
	move o2,nil
	jrst apply

retnl1:	adjsp q,-1
retnil: setzb o1,nil1
	ret

rett1:	adjsp q,-1
rett:	move o1,[%t]
	ret

;EQ - fast compare
eq:	camn o1,o2
	jrst rett
	jrst retnil

;eveq - direct call version
eveq:	docdr o1,o1		;two args
	pushcdr q,o1		;save cdr args
	docar o1,o1		;first
	call eval
	exch o1,(q)		;save first res; rest cdr
	docar o1,o1
	call eval		;second
	pop q,o2		;first
	camn o1,o2		;same?
	jrst evrett		;yes
evretn:	move o1,nil		;no
	adjsp p,-2
	adjsp sp,-4
	ret

;MEMBERT - like member, but uses EQUALT instead of EQUAL
memeql:	push q,o1
	push q,o2
	jrst memeq2

memeq1:	move o1,(q)
	docdr o2,o1
	movem o2,(q)
memeq2:	xtype o2
	caie w2,ty%xcn
	 jrst [adjsp q,-2 ? jrst retnil]
	docar o2,o2
	move o1,-1(q)
	call equalt
	jumpe o1,memeq1
	move o1,(q)
	adjsp q,-2
	ret

; EQL - compare two objects for equalt if numbers, else eq
eql:	camn o1,o2
	jrst rett		;if EQ then true
	xtypea w2,o1		;must be of same type
	xtypea w3,o2		;(xtype allows FOOs to be equalt
	camn w2,w3		; to constant FOOs)
eqln:	 caige w2,ty%xfl	;must be EQ if not numbers
	  jrst retnil		; enter eqln from inside equalt
	xct .+1-ty%xfl(w2)	;;TYPES
	jrst xeqflo		;long flons
	jrst xeqifl		;iflons
	jrst xeqifl		;iflons
	jrst xeqrat		;ratios
	jrst notnum		;complex
	jrst xeqbig		;bignums
	jrst retnil		;inums 
	jrst retnil		;inums

;;TY%INT
;;TY%FLO
;EQUALT - compare two objects to see if they are identical in structure
;o1 and o2 are the objects
equalt:
  ;if the two objects are EQ, then they are EQUALT
	camn o1,o2
	jrst rett		;if EQ then true
	xtypea w2,o1		;must be of same type
	xtypea w3,o2		;(xtype allows FOOs to be equalt
	came w2,w3		; to constant FOOs)
	 jrst retnil
  ;otherwise we recursively check CAR and CDR of each to see
  ; if they match.
	scons o1		;here only if types match
	 jrst eqln
  ;recursively compare CAR's and CDR's
	pushcdr q,o1		;else save cdr's for later
	pushcdr q,o2
	docar o1,o1		;compare car's
	docar o2,o2
	call equalt		;recursively
	jumpe o1,eqlfai		;if failed, prune stack and fail
	pop q,o2
	pop q,o1
	jrst equalt		;else loop to compare cdr's
eqlfai:	adjsp q,-2
	move o1,nil
	ret

;;TY%INT
;;TY%FLO
;EQUAL - compare two objects to see if they are similar
;o1 and o2 are the objects
equal:
  ;if the two objects are EQ, then they are EQUAL
	camn o1,o2
	jrst rett		;if EQ then true
  ;otherwise we recursively check CAR and CDR of each to see
  ; if they match.  If they aren't both cons cells, then this
  ; is nonsense, and they fail
	scons o1		;else only thing else would be real
	jrst eqncon
	scons o2
	jrst retnil
  ;recursively compare CAR's and CDR's
	pushcdr q,o1		;else save cdr's for later
	pushcdr q,o2
	docar o1,o1		;compare car's
	docar o2,o2
	call equal		;recursively
	jumpe o1,eqfai		;if failed, prune stack and fail
	pop q,o2
	pop q,o1
	jrst equal		;else loop to compare cdr's
eqfai:	adjsp q,-2
	move o1,nil
	ret

;;TYPES
;here if first is not cons - if they are numbers, compare them
eqncon:	skpnum o1
	 jrst retnil
	skpnum o2
	 jrst retnil
;they are numbers
	jrst eqp

;;TY%ATM
;SXHASH -- rtn a number dependent on the equalness of an object
sxhash:	xtype o1
	xct sxhtab(w2)
	ret
;;TYPES
sxhtab:	jrst sxatom		; atom
	jrst sxcons		; cons
	jrst sxstrg		; string
	jrst sxchan		; channel
	jrst sxhh		; hash table
	jrst sxvect		; vector
	jrst sxaddr		; address
	jrst sxarry		; array
	jrst sxlflo		; long flonum
	tlc o1,(<object ty%lpi#ty%lnf>)		; neg iflons
	tlc o1,(<object ty%lpi#ty%lpf>)		; pos iflons
	jrst sxcons		; ratios
	jrst sxcons		; complex (unimplemented)
	jrst sxbig		; bignum
	tlc o1,(<object ty%lpi#ty%lni>)		; neg inums
	ret			; pos inums

;;TY%INT    ---   all of the below

;;TY%ATM
sxatom:	jumpe o1,[move o1,[inum 1] ? ret]	;(sxhash ()) = 1
	move w2,at%pna(o1)	;otherwise take bits from the first
	dmove w3,(w2)		;two words (and the length) of the 
	imuli w4,111		;pname
sxat1:	camle w3,[object ty%spc,1]
	 add w4,2(w2)
	lsh w4,-4
	add w4,w3
	tlo w4,(inum0)
	move o1,w4
	ret

;;TY%CON
sxcons:	push q,1(o1)		;for a cons cell:
	move o1,(o1)		;take the sxhash of the car
	call sxhash
	imuli o1,8009.		;times a prime number
	push p,o1
	pop q,o1		;plus the sxhash of the cdr
	call sxhash
	add o1,(p)
	adjsp p,-1
	movms o1		;..chucking any extra bits that might
	tlo o1,(inum0)		; happen to have been generated.
	ret

;;TY%STR
sxstrg:	move w2,o1
	dmove w3,(w2)
	imuli w4,101
	jrst sxat1

; channel
sxchan:
; hash table
sxhh:
; vector
sxvect:
; array
sxarry:	err /SXNYI/

; address	(NIL is faked off into an address for hash tables)
sxaddr:	tlo o1,(inum0)
	ret

;;TY%FLO
sxlflo:	;same code  --  hash the first three words of the object
;;TY%BIG
sxbig:	move w2,(o1)
	add w2,1(o1)
	add w2,2(o2)
	imul w2,10101
	ashc w2,23.
	movms w2
	tlo w2,(inum0)
	move o1,w2
	ret

; Hash Tables:  a hash table is essentially a two-level vector,
; of which the top is a record-like structure:
ht%siz==0	; the number of slots in the table (an inum)
ht%rxf==1	; rehash expansion factor, an iflon
ht%lf==2	; load factor, the fraction of a table which may be filled 
ht%rht==3	; rehash trigger, ht%lf (an iflon) as an inum
ht%nsu==4	; number of slots in use (an inum)
ht%ptr==5	; points to the vector which is the actual table
ht%get==6	; address of the routine to do GETHASH for this table
ht%put==7	; address of the routine to do PUTHASH for this table
; the actual table is a separate vector for ease of rehashing.  It contains
; two words per "slot", one for key and one for value.  Whenever ht%nsu
; exceeds ht%rht, the table is rehashed, with a size of ht%rxf * ht%siz
; (rounded up to the next prime).
;    For EQ hash tables, the table must be rehashed after every garbage
; collection.  To avoid rehashing if the table is not being used, it
; is rehashed at the next get or put instead of during GC.  GC merely
; changes the get and put routine addresses to grehsh and prehsh, which
; rehash, reset the addresses, and proceed to the normal get or put.

;; (make-hash-table size rehash-size load-factor)
; all args are optional.
mhasht:	skipn o1		;size given?
	 move o1,[inum 64.]	;no, use 64
	camge o1,[inum 10.]	;bigger than 10?
	 move o1,[inum 10.]	;no, use 10
	skipn o2		;rehash size given?
	 move o2,[iflon 1.6]	;no, use 1.6
	skipn o3		;load factor given?
	 move o3,[iflon 0.4]	;no, use .4
	push free,[inum 10]	;now create the top-level vector (length 8)
	push free,o1		;ht%siz (later we primeify this)
	push free,o2		;ht%rxf (arg 2...)
	push free,o3		;ht%lf  (arg 3)
	call prime		;o1 --> o1
	movem o1,-2(free)	;--> ht%siz
	move w2,o1
	move w3,(free)
	call mpyixf		;ht%siz * ht%lf (gives inum)
	push free,w2		;--> ht%rht
	push free,[inum0]	;ht%nsu
	push free,nil		;ht%ptr
	push free,[object ty%iadr,<codsec,,eqghsh>]	;ht%get
	push free,[object ty%iadr,<codsec,,eqphsh>]	;ht%put
	move w2,free		;create hash table pointer
	subi w2,7		; (which we'll return)
	tlo w2,(<object ty%eht>)	;the type code
	push q,w2		;stash it temporarily
	lshc w4,6		;multiply the size by two
	lsh o1,1		;(it's an inum)
	lshc w4,-6
	call makvec		;make the actual table part
	exch o1,(q)		;get the header pointer again
	pop q,5(o1)		;insert table ptr into ht%ptr
	ret

; multiply inum (w2) by iflon (w3) returning inum in w2
mpyixf:	getnum w2
	fltr w2,w2
	lsh w3,4
	fmpr w2,w3
	fixr w2,w2
	maknum w2
	ret

; divide inum (w2) by iflon (w3) returning inum in w2
divibf:	getnum w2
	fltr w2,w2
	lsh w3,4
	fdvr w2,w3
	fixr w2,w2
	maknum w2
	ret

;; (make-eql-hash-table ...) -- calls make-hash-table, and replaces
;; the dispatch addresses with eql-using ones
;;  eql is a variant of eq, so we must still rehash at GC
m1ht:	call mhasht
	dmove w2,[object ty%iadr,<codsec,,elghsh>	;ht%get
		  object ty%iadr,<codsec,,elphsh>]	;ht%put
	dmovem w2,ht%get(o1)
	ret

;; (make-equal-hash-table ...) -- calls make-hash-table, replaces
;; the dispatch addresses with equal-using ones, and changes the type.
;; equal hash uses sxhash codes, so no need to rehash at GC
m2ht:	call mhasht
	dmove w2,[object ty%iadr,<codsec,,lghsh>	;ht%get
		  object ty%iadr,<codsec,,lphsh>]	;ht%put
	dmovem w2,ht%get(o1)
	tlc o1,(<object ty%eht>#<object ty%oht>)
	ret

; The following functions are generic over kind of hash table.
; they are done by dispatch off the specific routine addresses
; stored in the hash table header.

; (gethash key table default)
; default is optional, default default is nil. default is returned 
; if key not found
gethsh:	xtype o2		;make sure it's a hash table
	cain w2,ty%xht
	 jrst @ht%get(o2)	;dispatch to whatever gethash routine
	err /GETHASH: not hash table/

; (puthash key value table)
puthsh:	xtype o3		;make sure it's a hash table
	cain w2,ty%xht
	 jrst @ht%put(o3)	;dispatch to whatever puthash routine
	err /PUTHASH: not hash table/

; (remhash key table)
remhsh:	xtype o2		;make sure it's a hash table
	caie w2,ty%xht
	 jrst [err /REMHASH: not hash table/]
	move w2,ht%get(o2)
	jrst -1(w2)	;dispatch to whatever remhash routine

;; These are the routine the garbage collector sets the get/put
; entries in the header to for eq hash tables.  They perform a
; rehash on the table before doing the indicated function.
	jrst rrehsh		;must be at grehsh-1
grehsh:	push q,o1		;save args
	push q,o2
	push q,o3
	move o1,o2		;restore normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,eqghsh>
		  object ty%iadr,<codsec,,eqphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash
	pop q,o3		;restore args
	pop q,o2
	pop q,o1
	jrst eqghsh		;proceed to get

; rehash for puthash
prehsh:	push q,o1		;save args
	push q,o2
	push q,o3
	move o1,o3		;reset normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,eqghsh>
		  object ty%iadr,<codsec,,eqphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash the table
	pop q,o3		;restore args
	pop q,o2
	pop q,o1
	jrst eqphsh		;proceed to put

; rehash for remhash -- comes from jrst at grehsh-1
rrehsh:	push q,o1		;save args
	push q,o2
	move o1,o2		;restore normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,eqghsh>
		  object ty%iadr,<codsec,,eqphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash
	pop q,o2		;restore args
	pop q,o1
	jrst eqghsh		;proceed to remhash

; gethash routine for eq hash tables
; eq hash function is simply the whole raw object word value mod
; the table size.

;table organization is simply an array of length 2p (p a prime)
;which has for each key at k, the value at k+p

	jrst eqrhsh		;must be at eqghsh-1
eqghsh:	move w2,ht%siz(o2)	;table size
	getnum w2
	skipn w3,o1		;key
	 jrst [move o1,[object ty%adr] ? jrst .-1]	;substitute if nil
	idiv w3,w2		;get remainder   key/size
	move w3,ht%ptr(o2)	;table address
	add w3,w4		;plus remainder
	came o1,(w3)		;= key sought?
	 jrst egh2		; no
	add w3,w2		;yes, add table size to find value
	move o1,(w3)		;which get
	ret			;and return

; for secondary probing we keep adding the remainder and reducing
; mod the table size.  since t.s. is prime, this will cycle thru
; all entries randomly and be 0 last.

;registers:  w2=table size; w3=successive secondary hash indices;
;	     w4=original hash index; o1=key; o2=table; o3=default rtn val;
;	     o4=indirect word pointing to the base of the table
;		and indexed off w3

egh2:	skipn (w3)		;key in table /= arg key
	 jrst eghnf		;slot empty => not in table
	move o4,ht%ptr(o2)	;else secondary hash
	tlc o4,(<object ty%vec>#<object w3>)	;make indirect wd
	skipn w3,w4		;original remainder
	 movei w4,1		;if it was 0
eghlop:	add w3,w4		;add remainder
	caml w3,w2		;reduce mod t.s.
	 sub w3,w2
	camn o1,@o4		;a hit?
	 jrst eghfnd		; yes
	skipe @o4		;empty?
	 jumpn w3,eghlop	;no
	setz o4,		;yes empty, return default (o4 wasn't an obj)
eghnf:	move o1,o3
	ret

eghfnd:	add w3,w2		;yes found key, now get value
	move o1,@o4		;and return it
	setz o4,		;kill nasty invalid object
	ret

;; puthash for eq hash tables.  o1=key, o2=value, o3= table
eqphsh:	move w2,ht%siz(o3)
	getnum w2
	skipn w3,o1		;nil
	 jrst [move o1,[object ty%adr] ? jrst .-1]
	idiv w3,w2		;hash
	move w3,ht%ptr(o3)
	add w3,w4		;lookup
	came o1,(w3)		;match
	 skipn (w3)		;different key
	  jrst ephrpl		;empty (different from get)
	   jrst eph2
	movem o1,(w3)		;new key: ass whole new entry
	add w3,w2
	movem o2,(w3)		;stash value
ephcnt:	move o1,o2		;return value
	aos w2,ht%nsu(o3)	;increment 
	camg w2,ht%rht(o3)
	 ret
	push q,o2
	move o1,o3
	call rehash
	pop q,o1
	ret

;key already there; merely replace the value
ephrpl:	add w3,w2
	movem o2,(w3)		;stash value
	ret

; the look algorithm is of course exactly the same--we even use the same
;registers:  w2=table size; w3=successive secondary hash indices;
;	     w4=original hash index; o1=key; o2=value; o3=table;
;	     o4=indirect word pointing to the base of the table
;		and indexed off w3

eph2:	move o4,ht%ptr(o3)
	tlc o4,(<object ty%vec>#<object w3>)
	skipn w3,w4
	 movei w4,1
ephlop:	add w3,w4
	caml w3,w2
	 sub w3,w2
	skipn @o4
	 jrst ephemp
	camn o1,@o4
	 jrst ephfnd
	jumpn w3,ephlop
	err /hash tab wedged/

; found empty slot
ephemp:	movem o1,@o4		;deposit the key
	add w3,w2
	movem o2,@o4		;and the value
	setz o4,
	jrst ephcnt		;and go count the new slot

; found old slot with that key
ephfnd:	add w3,w2		;need only the value
	movem o2,@o4
	setz o4,
	ret			;no need to count

;remhash for eq hash tables  o1=key, o2=table
; return T if found/removed, NIL if not found
; deletion is done by replacing the key in the table with a
;  special code.  We can't merely remove it since that might
; break secondary hash chains.  The deleted markers will go away
; next time the table is rehashed.
eqrhsh:	move w2,ht%siz(o2)
	getnum w2
	skipn w3,o1		;nil
	 jrst [move o1,[object ty%adr] ? jrst .-1]
	idiv w3,w2		;hash
	move w3,ht%ptr(o2)
	add w3,w4		;lookup
	came o1,(w3)		;match
	 jrst erh2
	move o1,[object ty%adr,86.]	;insert "deleted" code
	movem o1,(w3)
	add w3,w2
	setzm (w3)		;clear value so it can be GC'ed
	move o1,[%t]		;return T
	ret

; same secondary hash as everybody else...
erh2:	skipn (w3)
	 jrst erhnf		;empty, return nil
	move o4,ht%ptr(o2)
	tlc o4,(<object ty%vec>#<object w3>)
	skipn w3,w4
	 movei w4,1
erhlop:	add w3,w4
	caml w3,w2
	 sub w3,w2
	camn o1,@o4
	 jrst erhfnd
	skipe @o4
	 jumpn w3,erhlop
	setz o4,
erhnf:	setz o1,		;return nil
	ret

erhfnd:	move o1,[object ty%adr,86.]	;found, insert "deleted" code
	movem o1,@o4
	add w3,w2
	setzb o4,@o4		;clear value so it can be GC'ed
	move o1,[%t]		;return T
	ret

;; rehash a table, either for size expansion or because the EQ hash
; keys (based on addresses) are invalid after a GC.
; accepts table in o1
rehash:	move w2,ht%nsu(o1)	;no need to rehash if 0 entries
	camn w2,[inum0]
	 ret
	push q,o1		;save
	push q,ht%put(o1)	;the puthash routine for later use
	move w4,ht%ptr(o1)	;pointer to the old table vector
	tlz w4,(<object 77>)	;make an indirect indexed off w2 ptr
	tlo w4,(<object w2>)
	move w3,ht%siz(o1)	;size of the old
	getnum w3		;as bare no. in w3
	movn w2,w3		;negative in w2, counts up to 0
	add w4,w3		;bump by table size to match negative counter
	push p,w4		;save everything
	push p,w2
	push p,w3

; the next little sequence is to compute the new table size.  If we are
; doing an expansion, it's just the expansion factor times the current size:
;  ht%siz * ht%rxf.   If this is a GC-triggered rehash, we take the max of 
; the current size and the size an expansion would have given had the table 
; been small enough that the existing fitems would have caused an expansion:
;  ht%rxf * ht%nsu / ht%lf.  We find out which case we have by seeing if the
; table is full to the trigger level.  (Actually the formulae would give the
; same result, but here it is faster to check than to do the work every time.
	move w2,ht%nsu(o1)	;slots used
	camge w2,ht%rht(o1)	;>= trigger level?
	 skipa w3,ht%lf(o1)	;no, do nsu/lf
	  skipa w2,ht%siz(o1)	;yes, use current size
	   call divibf		;(only for nsu/lf case)
	move w3,ht%rxf(o1)	;multiply whatever that was by rxf
	call mpyixf
	camge w2,ht%siz(o1)	;but never shrink the table.
	 move w2,ht%siz(o1)
	move o1,w2
	call prime		;round up to nearest prime #
	move o2,-1(q)
	movem o1,ht%siz(o2)	;--> new size
	move w2,o1
	move w3,ht%lf(o2)	;use it to compute new trigger level
	call mpyixf
	movem w2,ht%rht(o2)
	move w2,[inum0]		;the new table is empty so far...
	movem w2,ht%nsu(o2)
	lshc w4,6		;double the prime number for the new
	lsh o1,1		; vector size.
	lshc w4,-6
	call makvec
	movem o1,ht%ptr(o2)	;and save the new pointer.

;; this is similar to the maphash loop: we go through the table
;  getting key/value pairs, only instead of calling a function, we
;  merely insert them into the new table.  The control data is 
;  simpler than maphash since we know there can't be a GC inside
;  the loop.
rehl1:	move w4,-2(p)
	dmove w2,-1(p)
rehl2:	skipn o1,@w4
	 aojl w2,rehl2
	jumpge w2,eoreh
	camn o1,[object ty%adr,86.]
	 jrst rehl2+1		; a "deleted" marker, re-enter search loop
	camn o1,[object ty%adr,nil]
	 move o1,nil
	add w4,w3
	move o2,@w4
	aos w2
	movem w2,-1(p)
	move o3,-1(q)
	call @(q)
	skipge -1(p)
	 jrst rehl1
eoreh:	adjsp p,-3
	adjsp q,-2
	ret


;; These are the routine the garbage collector sets the get/put
; entries in the header to for eql hash tables.

;; ***** these routines (lgreh in particular) MUST LIE BETWEEN
;;       eqghsh and elghsh in that order for the garbage
;;       collector to be able to distinguish eq and eql hash tables.
;;	 Consult routine CPYEHT.

	jrst lrreh		;must be at lgreh-1
lgreh:	push q,o1		;save args
	push q,o2
	push q,o3
	move o1,o2		;restore normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,elghsh>
		  object ty%iadr,<codsec,,elphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash
	pop q,o3		;restore args
	pop q,o2
	pop q,o1
	jrst elghsh		;proceed to get

; rehash for puthash
lpreh:	push q,o1		;save args
	push q,o2
	push q,o3
	move o1,o3		;reset normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,elghsh>
		  object ty%iadr,<codsec,,elphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash the table
	pop q,o3		;restore args
	pop q,o2
	pop q,o1
	jrst elphsh		;proceed to put

; rehash for remhash -- comes from jrst at lgreh-1
lrreh:	push q,o1		;save args
	push q,o2
	move o1,o2		;restore normal get/put addrs
	dmove w2,[object ty%iadr,<codsec,,elghsh>
		  object ty%iadr,<codsec,,elphsh>]
	dmovem w2,ht%get(o1)
	call rehash		;rehash
	pop q,o2		;restore args
	pop q,o1
	jrst elghsh		;proceed to remhash

; hash routines for eql hash tables
; we simply use eq hash routines for everything except numbers,
;  and equal hash routines for numbers

	jrst elrhsh		;must be at elghsh-1
elghsh:	xtype o1		;what type object is the key?
	xct eqlhtb(w2)
	 jrst eqghsh		;if not number, use eq hash
	jrst lghsh		;if number, use equal hash

elphsh:	xtype o1		;what type object is the key?
	xct eqlhtb(w2)
	 jrst eqphsh		;if not number, use eq hash
	jrst lphsh		;if number, use equal hash

elrhsh:	xtype o1		;what type object is the key?
	xct eqlhtb(w2)
	 jrst eqrhsh		;if not number, use eq hash
	jrst lrhsh		;if number, use equal hash

;;TYPES		(note immediate numbers are equal only if eq)
eqlhtb:	jfcl			; atom
	jfcl			; cons
	jfcl			; string
	jfcl			; channel
	jfcl			; hash table
	jfcl			; vector
	jfcl			; address
	jfcl			; array
	skipa			; long flonum
	jfcl			; neg iflons
	jfcl			; pos iflons
	skipa			; ratios
	skipa			; complex (unimplemented)
	skipa			; bignum
	jfcl			; neg inums
	jfcl			; pos inums

;; gethash for equal hash tables
; ("equal" here means Common Lisp equal, ie, equalt.)
lghsh:	jumpe o1,[move o1,[object ty%adr] ? jrst .+1]	;substitute if nil
	push q,o3		;default value
	push q,o2		;table
	push q,o1		;key
	call sxhash		;obtain hash value for key
	move o2,-1(q)
	move w2,ht%siz(o2)	;table size
	getnum w2
	move w3,o1
	idiv w3,w2
	move w3,ht%ptr(o2)	;table address
	push p,w3
	add w3,w4		;plus remainder
	push p,w2		;size
	push p,w3		;position
	push p,w4		;hash function value
	move o1,(q)
	skipn o2,(w3)
	 jrst lghnf
	call equalt		;match?
	move w3,-1(p)
	jumpe o1,lgh2		; no
	add w3,-2(p)		;yes, add table size to find value
	move o1,(w3)		;which get
	adjsp q,-3
	adjsp p,-4
	ret			;and return

; for secondary probing we keep adding the remainder and reducing
; mod the table size.  since t.s. is prime, this will cycle thru
; all entries randomly and be 0 last.

; stacks: q: -2=default, -1=table, 0=key
;	  p: -3=table base, -2=size, -1=posn, 0=hash fn val
lgh2:	skipn (w3)		;key in table /= arg key
	 jrst lghnf		;slot empty => not in table
	skipn w3,(p)		;original remainder
	 aos (p)		;if it was 0
	movem w3,-1(p)
lghlop:	add w3,(p)		;add remainder
	caml w3,-2(p)		;reduce mod t.s.
	 sub w3,-2(p)
	movem w3,-1(p)		;save for looping
	add w3,-3(p)		;add in base address
	move o1,(q)
	skipn o2,(w3)
	 jrst lghnf		;woops, an empty slot
	call equalt		;a match?
	jumpn o1,lghfnd		; yes
	skipe w3,-1(p)		;should never be necessary, since=>table full
	 jrst lghlop		;no
lghnf:	move o1,-2(q)
	adjsp q,-3
	adjsp p,-4
	ret

lghfnd:	move w3,-1(p)		;get posn as computed
	add w3,-2(p)		;add table size to get value
	add w3,-3(p)		;and base addr
	move o1,(w3)		;and return it
	adjsp q,-3
	adjsp p,-4
	ret



;; puthash for equal hash tables.  o1=key, o2=value, o3= table
lphsh:	jumpe o1,[move o1,[object ty%adr] ? jrst .+1]	;substitute if nil
	push q,o3		;table
	push q,o2		;value
	push q,o1		;key
	call sxhash		;obtain hash value for key
	move o2,-2(q)
	move w2,ht%siz(o2)	;table size
	getnum w2
	move w3,o1
	idiv w3,w2
	move w3,ht%ptr(o2)	;table address
	push p,w3
	add w3,w4		;plus remainder
	push p,w2		;size
	push p,w4		;h(key), to match loop below
	push p,w4		;hash function value
	move o1,(q)
	skipn o2,(w3)
	 jrst lphemp
	call equalt		;match?
	move w3,-1(p)
	jumpe o1,lph2		; no
;key already there; merely replace the value
lphrpl:	move o1,-1(q)		;value
	move w3,-1(p)
	add w3,-3(p)		;key posn
	add w3,-2(p)		;value posn
	movem o1,(w3)		;stash value
	adjsp q,-3
	adjsp p,-4
	ret

; slot empty, fill it in
lphemp:	dmove o1,-1(q)		;value, key
	move w3,-1(p)
	add w3,-3(p)		;key posn
	movem o2,(w3)		;new key: ass whole new entry
	add w3,-2(p)
	movem o1,(w3)		;stash value
	move o3,-2(q)
	adjsp q,-3
	adjsp p,-4
	aos w2,ht%nsu(o3)	;increment # of entries
	camg w2,ht%rht(o3)	;if higher than trigger,
	 ret
	push q,o1		;rehash
	move o1,o3
	call rehash
	pop q,o1
	ret			;and return

; secondary hash search
; stacks: q: -2=table, -1=value, 0=key
;	  p: -3=table base, -2=size, -1=posn, 0=hash fn val
lph2:	skipn w3,(p)		;original remainder
	 aos (p)		;if it was 0
lphlop:	add w3,(p)		;add remainder
	caml w3,-2(p)		;reduce mod t.s.
	 sub w3,-2(p)
	movem w3,-1(p)		;save for looping
	add w3,-3(p)		;add in base address
	move o1,(q)
	skipn o2,(w3)
	 jrst lphemp		;aha, an empty slot
	call equalt		;a match?
	jumpn o1,lphrpl		; yes
	skipe w3,-1(p)		;should never be necessary, since=>table full
	 jrst lphlop		;no
	err /hash tab wedged/


;remhash for equal hash tables  o1=key, o2=table
; return T if found/removed, NIL if not found
; deletion is done by replacing the key in the table with a
;  special code.  We can't merely remove it since that might
; break secondary hash chains.  The deleted markers will go away
; next time the table is rehashed.
lrhsh:	jumpe o1,[move o1,[object ty%adr] ? jrst .+1]	;substitute if nil
	push q,o2		;table
	push q,o1		;key
	call sxhash		;obtain hash value for key
	move o2,-1(q)
	move w2,ht%siz(o2)	;table size
	getnum w2
	move w3,o1
	idiv w3,w2
	move w3,ht%ptr(o2)	;table address
	push p,w3
	add w3,w4		;plus remainder
	push p,w2		;size
	push p,w4		;hf val, to be posn
	push p,w4		;hash function value
	move o1,(q)
	skipn o2,(w3)
	 jrst lrhnf
	call equalt		;match?
	move w3,-1(p)
	add w3,-2(p)		;recompute position on the side
	jumpe o1,lgh2		; no
	move o1,[object ty%adr,86.]	;insert "deleted" code
	movem o1,(w3)
	add w3,-2(p)		; add table size to find value
	setzm (w3)		;clear value so it can be GC'ed
lrhfnd:	skipa o1,[%t]		;return T
lrhnf:	 setz o1,		;return NIL
	adjsp q,-2
	adjsp p,-4
	ret			;and return

; for secondary probing we keep adding the remainder and reducing
; mod the table size.  since t.s. is prime, this will cycle thru
; all entries randomly and be 0 last.

; stacks: q: -1=table, 0=key
;	  p: -3=table base, -2=size, -1=posn, 0=hash fn val
lrh2:	skipn w3,(p)		;original remainder
	 aos (p)		;if it was 0
lrhlop:	add w3,(p)		;add remainder
	caml w3,-2(p)		;reduce mod t.s.
	 sub w3,-2(p)
	movem w3,-1(p)		;save for looping
	add w3,-3(p)		;add in base address
	move o1,(q)
	skipn o2,(w3)
	 jrst lrhnf		;woops, an empty slot
	call equalt		;a match?
	jumpn o1,lrhfnd		; yes
	skipe w3,-1(p)		;should never be necessary, since=>table full
	 jrst lrhlop		;no
	jrst lrhnf


;; (MAPHASH <function> <hashtable>)   <Function> is a fn of 2 args.
;; it will be called on each key,value pair in <hashtable>.  
maphsh:	push q,o1
	push q,o2
	move w3,ht%siz(o2)
	getnum w3
	movn w2,w3
	push p,w2
	push p,w3

mphl1:	move w4,(q)
	move w4,ht%ptr(w4)
	tlz w4,(<object 77>)
	tlo w4,(<object w2>)
	dmove w2,-1(p)
	add w4,w3
mphl2:	skipn o1,@w4
	 aojl w2,mphl2
	jumpge w2,eomph
	camn o1,[object ty%adr,86.]
	 jrst mphl2+1		; a deleted marker, re-enter search loop
	camn o1,[object ty%adr,nil]
	 move o1,nil
	add w4,w3
	move o2,@w4
	aos w2
	movem w2,-1(p)
	movei n,2
	move w4,-1(q)
	call iapply
	skipge -1(p)
	 jrst mphl1
eomph:	adjsp p,-2
	adjsp q,-2
	setz o1,
	ret

clrhsh:	xtype o1
	caie w2,ty%xht
	 jrst [err /CLRHASH: not hash table/]
	move w2,ht%siz(o1)
	getnum w2
	lsh w2,1
	subi w2,1
	move w3,ht%ptr(o1)
	move w4,w3
	aos w4
	setzm (w3)
	xblt w2,
	move w2,[inum0]
	movem w2,ht%nsu(o1)
	ret

;*** end of hash table functions

;;TY%ATM
;PLIST - return property list of atom
plist:	satom o1		;better be an atom
	jrst [perr /PLIST argument must be an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o1,at%pro(o1)	;the property list
	ret

;;TY%ATM
;RPLACPLIST - set property list of atom
rplacp:	satom o1		;better be an atom
	jrst [perr /PLIST argument must be an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	movem o2,at%pro(o1)	;the property list
	ret

;;TY%ATM
;GET - look up property on atom's property list
;o1 - the atom, o2 - the property
;O6 is assumed to be preserved 
xget:	satom o1
	jrst retnil		;if not atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o1,at%pro(o1)	;the property list
	jumpe o1,retnil		;if nothing left, we failed
xgetl:	docar o3,o1
	camn o3,o2		;is CAR what we want?
	jrst xgets		;yes - success
	docdr o1,o1		;no - double cdr
	docdr o1,o1
	jumpn o1,xgetl
	jrst retnil		;nothing left, failed
  ;if we find it, what we found is a pair.  The CDR is the value part.
xgets:	docdr o1,o1		;get the value
	docar o1,o1
	ret

;;TY%ATM
;GETL - look up properties on atom's property list
;o1 - the atom, o2 - list of properties
getl:	satom o1
	jrst retnil		;if not atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	jumpe o2,retnil		;if nothing to look for, will fail
	move o1,at%pro(o1)	;the property list
	jumpe o1,retnil		;if nothing left, we failed
;o3 - current property from plist
;o4 - copy of list of properties
;o5 - current property from list of properties

;while not end of property list do
getlo1:	docar o3,o1
	move o4,o2
;while not end of list of properties do
getli1:	docar o5,o4
	camn o5,o3		;is this one of the properties?
	ret			;yes - success - tail is already in o1
	jumpe o4,getlo2		;no - go to next prop in list of prop's
	docdr o4,o4
	jrst getli1
;end while
getlo2:	
	docdr o1,o1		;nothing matches here, try next
	docdr o1,o1
	jumpn o1,getlo1		;if something left, try it
	jrst retnil		;nothing left, failed
;end while

;;TY%ATM
;putprop - atom, value, prop
;o1 - atom, o2 - value, o3 - prop
putp:	satom o1
	jrst [perr /Attempt to PUTPROP something that is not an atom/]
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
	move o4,at%pro(o1)	;o4 - property list tail
  ;now we search the plist to see if the prop is there already
putpl:	jumpe o4,putpno		;if run out, not there
	docar o5,o4		;o5 _ car of list
	camn o5,o3		;if EQ target
	jrst putpys		;found it, yes
	docdr o4,o4		;no, advance down list
	docdr o4,o4
	jumpn o4,putpl
;not found - add it at beginning
putpno:	move o4,at%pro(o1)	;old property list
	docons o5,o2,o4		;(value --orig--)
	docons o4,o3,o5		;(prop value --orig--)
	movem o4,at%pro(o1)	;new property list
	move o1,o2		;return the value
	ret
;found - just change the value
putpys:	docdr o4,o4
	dorpa o4,o2
	move o1,o2		;return the value
	ret	

;;TY%ATM
;remprop - atom, prop
;o1 - atom, o2 - prop
remp:	satom o1
	jrst retnil		;if not an atom, return NIL
	jumpe o1,[move o1,[%nil] ;if NIL, use shadow atom
		  jrst .+1]
  ;cdr of the atom header is really a pointer to the plist
  ;we use this as a kludge to regard the atom header itself as
  ;the previous cell in the property list
  ;now we search the plist to see if the prop is there already
	;o1 - previous cell in plist
	;o3 - this cell
rempl:	docdr o3,o1		;get next cell
	jumpe o3,retnil		;if none, failed
	docar o4,o3		;o4 - the prop
	camn o4,o2		;if the same, we have it
	jrst rempys
	docdr o1,o3		;else advance
	jrst rempl
rempys:	docdr o3,o3		;get cdr to our cell
	docdr o3,o3
	dorpd o1,o3		;put it after previous
	jrst rett		;and return true

;APPEND - append N lists, copying all but last - LSUBR
;o2 - will be final result
;o3 - tail of list being copied
;o4 - new copy, end
;o5,o6 - work
uapp:	tdnn o1,[377777777]	;any args?
	jrst retnil		;no - NIL
	move w4,q		;w4 - addr of last arg
	sub w4,o1		;w4 - below first arg
	tlz w4,770000	
	docons o4,nil,nil	;dummy start
	movem o4,o2		;save start of copy
  ;more lists to copy?
uappp1:	tdnn o1,[377777776]	;still more than one arg?
	jrst uappex		;no - stick on last one unchanged
  ;start of copying one more list
	move o3,1(w4)		;o3 - current list being copied
	scons o3
	jrst uapppx		;while tail not atom do
  ;copy one cell in the list
uapplp:	docar o6,o3		;o6 _ next list element
	docons o5,o6,nil	;o5 _ copy of it
	dorpd o4,o5		;link into list
	move o4,o5		;new is now old
	docdr o3,o3
	sncons o3
	jrst uapplp
  ;now done with one list
uapppx:	subi o1,1		;decr count
	aoja w4,uappp1		;go to next

  ;here when only one list left, the last
uappex:	move o3,1(w4)		;o3 - current list being copied
	dorpd o4,o3		;link onto end of old
	docdr o1,o2		;and return start of copy
	ret

;*APPEND - list1, list2
;o1 - list1, o2 - list2
;o3 - list1 tail
;o4 - new copy, end
;o5 - cell being constructed
app:	move o3,o1		;init tail
	docons o4,nil,nil	;dummy start
	movem o4,o1		;save start of copy
	scons o3
	jrst appex		;while tail not atom do
applp:	docar o6,o3		;o1 _ next list element
	docons o5,o6,nil	;o4 _ copy of it
	dorpd o4,o5		;link into list
	move o4,o5		;new is now old
	docdr o3,o3
	sncons o3
	jrst applp
appex:	dorpd o4,o2		;link onto copy
	docdr o1,o1		;return start of copy, its cdr
	ret

;NCONC - append N lists, destructively; LSUBR
;o2 - thing we will return
;o3 - current list we are working on
;o4 - next list
unconc:	move o2,nil		;default return
	move w4,q		;w4 - addr of last arg
	ldb w3,[.bp 377777777,o1]
	sub w4,w3		;w4 - below first arg
  ;find the first list
nconl1:	jumpe w3,ret2		;any args?
	move o2,1(w4)		;get current arg
	aoj w4,1		;get to next arg
	scons o2		;is it a list?
	 soja w3,nconl1		;no - skip it
	move o3,o2		;O3 is now the first non-nil list
  ;now find next list
nconl2:	soje w3,ret2		;no more? - done
	move o4,1(w4)		;get current arg
  ;O4 is now next list - now tack it on to current one
nconl3:	docdr o5,o3		;find end of current list
	scons o5		;atom is end
	 jrst nconx3		;at end
	move o3,o5		;not yet
	jrst nconl3
  ;now at end of current list
nconx3:	dorpd o3,o4		;put next list onto end of current
	aoja w4,nconl2		;get to next arg

ret2:	move o1,o2
	ret

;Here is an *NCONC, 2 args only
;NCONC - append a second list to a first destructively
;o1 - first list, o2 - second list
nconc:	scons o1
	jrst inconf		;first is atom (probably nil)
  ;go to end of first
	move o4,o1		;o4 - tail of first
inconl:	docdr o3,o4		;o3 - cdr
	scons o3
	jrst incone		;atom, probably nil - ready to append
	move o4,o3		;not, try again
	jrst inconl
  ;once at end, rplacd the new list onto it
incone:	dorpd o4,o2		;do the rplacd
	ret

inconf:	move o1,o2		;null first - return sec
	ret

;LENGTH - list in o1
length:	setz w2,
lenlp:	scons o1
	jrst lenx
	docdr o1,o1
	aoja w2,lenlp
lenx:	maknum w2
	move o1,w2		;return length
	ret

;FNTH - nth, but no error checking
;TY%INT - we assume no list can be long enough to require a FIXNUM to
;  describe it. This seems valid, since each element is 2 words.
fnth:	move w2,o2		;strip type bits
	tlz w2,770000
fnthl:	caig w2,1
	ret
	docdr o1,o1
	soja w2,fnthl

;TY%CON
XCONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o2		; set up car
	push free,o1		; and cdr
	xmovei o1,-1(free)	; make address into cons cell
	tlo o1,(object(ty%con,0))
	ret

;TY%CON
NCONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o1		; set up car
	move o1,free		; make address into cons cell
	tlo o1,(object(ty%con,0))
	push free,nil		; and cdr
	ret

;TY%CON
CONS:	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o1		; set up car
	move o1,free		; make address into cons cell
	tlo o1,(object(ty%con,0))
	push free,o2		; and cdr
	ret

;optimized version of CONS that is called directly be eval
evcons:	docdr o1,o1		;two args
	pushcdr q,o1		;save cdr args
	docar o1,o1
	call eval		;eval first
	exch o1,(q)		;save first result, get cdr
	docar o1,o1
	call eval		;eval second
	pop q,o2		;o2 - first; o1 - second
	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,o2		; set up car
	move o3,free		; make address into cons cell
	tlo o3,(object(ty%con,0))
	push free,o1		; and cdr
	move o1,o3		; get thing to return
	adjsp p,-2
	adjsp sp,-4
	ret


;SGC - version of GC that saves all AC's
sgc:	push p,w2
	push p,w3
	push p,w4
	push q,o1
	push q,o2
	push q,o3
	push q,o4
	push q,o5
	push q,o6
	call gc
	pop q,o6
	pop q,o5
	pop q,o4
	pop q,o3
	pop q,o2
	pop q,o1
	pop p,w4
	pop p,w3
	pop p,w2
	sos (p)
	sos (p)
	ret

; the garbage collector.  its init routine is called gcinit and
; takes these args:
;   - the beginning of constant data space, which is really at the
;	start of the first of the two data spaces
;   - the first word beyond the constant data space, which is the
;	beginning of the usable part of the first data space
;   - the start of the second data space
;   - the first word beyond the second data space
	; garbage collector variables:
	;free - last used location in data space
	;lastl - last legal location in this data space - 1.  Trigger a GC if
	;   someone tries to go beyond this.
	;stthis - start of this data space
	;enthis - end of this data space
	;stthat - start of other data space
	;enthat - end of other data space
	;stcnst - start of constant space
	;encnst - end of constant space

	.scalar lastl,stthis,enthis,stthat,enthat,stcnst,encnst

freesz==200000	;amount of free space at end of GC

gcinit:	
;init the variables describing the spaces
	pop q,enthat		;end of second data space
	pop q,stthat		;start of second data space
	pop q,enthis		;end of first data space
	pop q,w2		;end of constant area
	movem w2,stthis
	movem w2,encnst		;end of constant area
	pop q,stcnst		;start of constant area
;set up memory allocation variables for initial space
	move free,stthis	;start at beginning of space
	subi free,1		;prepare for push
	move w2,free		;allow allocation of FREESZ words before GC
	addi w2,freesz
	movem w2,lastl		;lastl gives upper limit
	ret

;This is used for explicit user calls.
ugc:	call gc
	move o1,nil
	ret

	.scalar gcstrt,gcstrc,gctimt,gccont

;This is always used when you run out of space
gc:	movei nil1,.fhslf
	runtm
	movem nil1,gcstrt	;time starting GC
	move w2,free
	sub w2,stthis
	movem w2,gcstrc		;starting free space
	skipn @[datsec,,.gcgag]	;if output
	jrst gc1		;none
	hrroi nil1,[asciz /
[GC, /]
	psout
	move w2,free
	sub w2,stthis
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl			;<
	hrroi nil1,[asciz / ==> /]
	psout
gc1:	setz nil1,
	call igc		; call internal gc
	skipn @[datsec,,.gcgag]	;if output
	jrst gc2		;none
	move w2,free
	sub w2,stthis		;free space after
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl
	hrroi nil1,[asciz /, in /]
	psout
	movei nil1,.fhslf
	runtm
	sub nil1,gcstrt		;how much time?
	move w2,nil1
	movei nil1,.priou
	movei w3,10.
	nout
	 jfcl
	hrroi nil1,[asciz / msec.]
/]
	psout
	setzm w2,@[datsec,,outchn+ch%pos]
gc2:	movei nil1,.fhslf
	runtm
	sub nil1,gcstrt
	addm nil1,gctimt
	move w2,free
	sub w2,stthis		;new free space
	sub w2,gcstrc		;minus start
	movn w2,w2		;make positive - this is garbage gotten
	addm w2,gccont		;add to cumulative
	setzb nil,nil1
	ret

;GCGAG - set GCGAG flag and return prev
xgcgag:	exch o1,@[datsec,,.gcgag]
	ret

;GCTIME - total time spent in GC so far
gctime:	move w2,gctimt
	jrst ret1nt

;SPEAK - amount of CONS'ing so far
speak:	move w2,free		;amount in this pass
	sub w2,stthis
	add w2,gccont		;plus cumulative from past
	jrst ret1nt

;UTIME - uptime
uptime:	time
	move w2,nil1
	setz nil1,
	jrst ret1nt

;This is a copying GC, modelled after the Lisp Machine GC, as
;described in Henry Baker's thesis.  There are two data spaces, old and new.
;A GC copies everything that is in use from old to new, and makes new the
;current one.  The main operation is translating objects.  If the object
;is absolute, e.g. an INUM, this is a no-op.  Only pointers into the old
;space are translated.  They are translated by finding the equivalent object
;in the new space, and using its pointer.  There are two cases:
;  - we have already moved the object.  In this case the first entry of
;	the old space copy is a pointer to the copy in new space.  These
;	pointers have the sign bit on, for easy detection.
;  - we have not moved the object.  In this case, we copy it to the end of
;	new space, and use the pointer to the beginning of this copy.
;At any given time, we have a pointer into new space.  Everything before
;this pointer has been translated.   Everything after it has not.  We also
;have to translate the stack and the constant area.  Indeed it is translating
;these areas that first puts something into new space to translate.

mark==400000,,0		;bit that says this has already been translated

;Because there are four different areas to translate, we have a separate
;routine to do the translation.
;  gctran:
;	w3 - first address to be translated.  W2 is updated, and is the
;		pointer mentioned above.  I.e. everything before W2 has
;		been translated
;	w4 - last address to be translated.
;	o5 - lower end of old space
;	o6 - upper end of old space

;The code within gctran avoids the use of the stacks, in order to avoid
;performance problems because of addressing conflicts between the stack
;and the areas being GC'ed.

gctran:	move o1,(w3)		;o1 - thing to be translated
	gettyp o1		;see what we have
	xct trntab(w2)		;translate depending upon type
	camge w3,w4		;see if done
	aoja w3,gctran		;no - next
	ret

;GCTRAX - special version of the above for doing new space.  Ends when
;we reach the free pointer
gctrax:	move o1,(w3)		;o1 - thing to be translated
	gettyp o1		;see what we have
	xct trntab(w2)		;translate depending upon type
	camge w3,free		;see if done
	aoja w3,gctrax		;no - next
	ret

;;TYPES
trntab:	jsp w2,cpyatm		; atom
	jfcl			;  constant atom
	jsp w2,cpycon		; cons
	jfcl			;  constant cons
	jsp w2,cpystr		; string
	jfcl			;  constant string
	jsp w2,cpychn		; channel
	jfcl			;  constant channel
	jsp w2,cpyeht		; eq hash table
	jsp w2,cpyoht		; other hash table
	jsp w2,cpyvec		; vector
	jsp w2,cpygrb		; undefined
	jfcl			; address
	jsp w2,cpyspc		; special (block)
	jsp w2,cpyary		; array
	jfcl			; constant array
	jsp w2,cpyrea		; long flonum
	jfcl			; constant flonum
	repeat 4, jfcl		; iflons & jrst and jfcl in evhook
	jfcl			; jsp in atom block, constant ratios
	jsp w2,cpyrat		; ratios
	jsp w2,cpygrb		; complex (unimplemented)
	jsp w2,cpygrb		; undefined
	jsp w2,cpybig		; bignum
	jfcl			; constant bignums
	repeat 4, jfcl		; inums

;here to translate a CONS cell - normally we copy it and use addr of new copy
;Make lists contiguous
cpycon:	caml o1,lbcon		;make sure valid pointer
	camle o1,ubcon
	jrst cpycgt		;test for garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havcon		;yes - use it
	
	dmove o2,(o1)		;copy it - CDR will be in O3 for code below
	dmovem o2,1(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%con,0))
	movem o2,(w3)		;put it in place to be translated
cpycnl:	tlc o2,(mark\object(ty%con,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,2		;advance free list
	smcons o3		;skip if CDR movable CONS (i.e. not constant)
	jrst (w2)		;not - return
;Now we loop on the CDR, in order to make lists be contiguous.  
;W3 - use FREE, since that is what we are translating
	move o1,o3
	caml o1,lbcon		;make sure valid pointer
	camle o1,ubcon
	jrst cpycgt		;test for garbage
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst (w2)		;yes - no CDR coding is needed.
	
	dmove o2,(o1)		;copy it
	dmovem o2,1(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%con,0))
	movem o2,(free)		;put it in place to be translated
	jrst cpycnl

havcon:	tlc o2,(mark\object(ty%con,0)) ;turn into a real cons pointer
	movem o2,(w3)		;put in place to be translated
	jrst (w2)

;CPYCONS garbage test
;Normally pointers should be into the old space.  I.e. the design is
;such that we never try to translate things twice.  However
;because of our "CDR-coding", it is possible that a pointer will
;be a pointer to the next word.  We check for that case explicitly.
cpycgt:	xmovei o2,-1(o1)	;strip type bits and subtract 1
	came o2,w3		;so is it pointing to next word?
	jrst cpygrb		;no - it is real garbage
	jrst (w2)		;yes - it is fake garbage - return

;here to translate an ATOM - at the moment just like cons cell
cpyatm:	caml o1,lbatm		;make sure valid pointer
	camle o1,ubatm
	jrst cpygrb		;garbage pointer (NB - nil also goes here)
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havatm		;yes - use it
	movei o2,at%siz		;length of atom block
	move o3,o1		;source
	xmovei o4,1(free)	;dest
	xblt o2,
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%atm,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%atm,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,at%siz	;advance free list
	jrst (w2)

havatm:	tlc o2,(mark\object(ty%atm,0))
	movem o2,(w3)
	jrst (w2)

;here to copy string
cpystr:	caml o1,lbstr		;make sure valid pointer
	camle o1,ubstr
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havstr		;yes - use it
	move o3,(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,(o1)		;source
	xmovei o5,1(free)	;destination
	move o2,o5		;destination will be final result also
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%str,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%str,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	jrst (w2)

havstr:	tlc o2,(mark\object(ty%str,0))
	movem o2,(w3)
	jrst (w2)

;here to translate a CHANNEL - at the moment just like cons cell
cpychn:	caml o1,lbchn		;make sure valid pointer
	camle o1,ubchn
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havchn		;yes - use it
	movei o2,ch%666+1	;length of channel block
	move o3,o1		;source
	xmovei o4,1(free)	;dest
	xblt o2,
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%chn,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%chn,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,ch%666+1	;advance free list
	jrst (w2)

havchn:	tlc o2,(mark\object(ty%chn,0))
	movem o2,(w3)
	jrst (w2)

;here to translate a REAL
cpyrea:	caml o1,lbrea		;make sure valid pointer
	camle o1,ubrea
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havrea		;yes - use it
	dmove o2,(o1)		;copy it
	dmovem o2,1(free)
	move o2,2(o1)		;3 cells
	movem o2,3(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%flo,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%flo,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,3		;advance free list
	jrst (w2)

havrea:	tlc o2,(mark\object(ty%flo,0))
	movem o2,(w3)
	jrst (w2)

;copy a ratio: just like a cons cell but no "cdr coding"
cpyrat:	caml o1,lbcon		;make sure valid pointer
	camle o1,ubcon
	jrst cpycgt		;test for garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havrat		;yes - use it
	
	dmove o2,(o1)		;copy it
	dmovem o2,1(free)
	xmovei o2,1(free)	;make address into CONS pointer
	tlo o2,(object(ty%rat,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%rat,0)) ;make a pointer to put into old copy
	movem o2,(o1)		;and put it there
	addi free,2		;advance free list
	jrst (w2)		;return

havrat:	tlc o2,(mark\object(ty%rat,0)) ;turn into a real cons pointer
	movem o2,(w3)		;put in place to be translated
	jrst (w2)

;here to translate a BIGNUM
cpybig:	caml o1,lbbig		;make sure valid pointer
	camle o1,ubbig
	jrst cpygrb		;garbage pointer
	skipge o2,(o1)		;do we already have a translation in old copy?
	jrst havbig		;yes - use it
	move o2,(o1)		;size - this is the special size field
	tlz o2,770000		;clear type bits
	addi o2,1		;size is that +1 if you count this size field
	xmovei o3,(o1)		;source
	xmovei o4,1(free)	;dest
	move o5,o4		;save start addr in O5
	add free,o2		;advance free list
	xblt o2,
	tlo o5,(object(ty%big,0))
	movem o5,(w3)		;put it in place to be translated
	tlc o5,(mark\object(ty%big,0)) ;make a pointer to put into old copy
	movem o5,(o1)		;and put it there
	jrst (w2)

havbig:	tlc o2,(mark\object(ty%big,0))
	movem o2,(w3)
	jrst (w2)

;copy eq hash table -- we set the get and put routine pointers
;    to special routines that rehash the table next time a
;    get or put is attempted.
cpyeht:	caml o1,lbeht		;make sure valid pointer
	camle o1,ubeht
	 jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst haveht		;yes - use it
	dmove o3,[object ty%iadr,<codsec,,lgreh>
		  object ty%iadr,<codsec,,lpreh>]
	caml o3,ht%get(o1)	;is it EQ or EQL?
	 dmove o3,[object ty%iadr,<codsec,,grehsh>
		   object ty%iadr,<codsec,,prehsh>]
	dmovem o3,ht%get(o1)
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%eht,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%eht,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

haveht:	tlc o2,(mark\object(ty%eht,0))
	movem o2,(w3)
	jrst (w2)

;copy other hash tables--just like vectors
cpyoht:	caml o1,lboht		;make sure valid pointer
	camle o1,uboht
	 jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst havoht		;yes - use it
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%oht,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%oht,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

havoht:	tlc o2,(mark\object(ty%oht,0))
	movem o2,(w3)
	jrst (w2)


;here to copy vector
cpyvec:	caml o1,lbvec		;make sure valid pointer
	camle o1,ubvec
	jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst havvec		;yes - use it
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%vec,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%vec,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

havvec:	tlc o2,(mark\object(ty%vec,0))
	movem o2,(w3)
	jrst (w2)


;here to copy vector
cpyary:	caml o1,lbary		;make sure valid pointer
	camle o1,ubary
	jrst cpygrb		;garbage pointer
	skipge o2,-1(o1)	;do we already have a translation in old copy?
	jrst havary		;yes - use it
	move o3,-1(o1)		;number of words to copy
	tlz o3,770000		;make pure number
	addi o3,1		;and include the header
	xmovei o4,-1(o1)	;source
	xmovei o5,1(free)	;destination
	xmovei o2,2(free)	;destination+1 will be final result 
	add free,o3		;update free counter now
	xblt o3,		;do the copy
	tlo o2,(object(ty%ary,0))
	movem o2,(w3)		;put it in place to be translated
	tlc o2,(mark\object(ty%ary,0)) ;make a pointer to put into old copy
	movem o2,-1(o1)		;and put it there
	jrst (w2)

havary:	tlc o2,(mark\object(ty%ary,0))
	movem o2,(w3)
	jrst (w2)

;here if given a garbage pointer or NIL
cpygrb:	jumpe o1,(w2)		;return if nil
	hrroi nil1,[asciz /Bad pointer detected by GC.  Type CONTINUE to proceed.
/]
	psout
	setz nil1,
	haltf
	setzm (w3)		;get rid of it
	jrst (w2)

;here for special thing that GC should ignore. o1 is code,,length
cpyspc:	tlz o1,770000		;make pure number
	add w3,o1		;skip that many words
	jrst (w2)

;the following variables contain lower and upper bounds for pointers
;of each type. this is just stthis and free from before the GC,
;with the appropriate type code filled in

.scalar lbcon,ubcon,lbatm,ubatm,lbstr,ubstr,lbchn,ubchn,lbrea,ubrea,lbbig,ubbig
.scalar lbvec,ubvec,lbary,ubary,lbeht,ubeht,lboht,uboht

igc:	call stcrit			;GC is critical section
  ;initialize for copying scan
  ;bounds for areas
     ;cons
	move w3,[object ty%con,0]
	add w3,stthis
	movem w3,lbcon
	move w3,[object ty%con,0]
	add w3,free
	movem w3,ubcon
     ;atom
	move w3,[object ty%atm,0]
	add w3,stthis
	movem w3,lbatm
	move w3,[object ty%atm,0]
	add w3,free
	movem w3,ubatm
     ;string
	move w3,[object ty%str,0]
	add w3,stthis
	movem w3,lbstr
	move w3,[object ty%str,0]
	add w3,free
	movem w3,ubstr
     ;channel
	move w3,[object ty%chn,0]
	add w3,stthis
	movem w3,lbchn
	move w3,[object ty%chn,0]
	add w3,free
	movem w3,ubchn
     ;real
	move w3,[object ty%flo,0]
	add w3,stthis
	movem w3,lbrea
	move w3,[object ty%flo,0]
	add w3,free
	movem w3,ubrea
     ;bignum
	move w3,[object ty%big,0]
	add w3,stthis
	movem w3,lbbig
	move w3,[object ty%big,0]
	add w3,free
	movem w3,ubbig
     ;vector
	move w3,[object ty%vec,1]
	add w3,stthis
	movem w3,lbvec
	move w3,[object ty%vec,1]
	add w3,free
	movem w3,ubvec
     ;eq hash table
	move w3,[object ty%eht,1]
	add w3,stthis
	movem w3,lbeht
	move w3,[object ty%eht,1]
	add w3,free
	movem w3,ubeht
     ;other hash table
	move w3,[object ty%oht,1]
	add w3,stthis
	movem w3,lboht
	move w3,[object ty%oht,1]
	add w3,free
	movem w3,uboht
     ;array
	move w3,[object ty%ary,1]
	add w3,stthis
	movem w3,lbary
	move w3,[object ty%ary,1]
	add w3,free
	movem w3,ubary
	
	move free,stthat	;start copy in other area
	subi free,1		;because designed for PUSH

  ;now scan the areas that are to be translated
;;;	it appears unnecessary to translate the constant addr blocks
;;;	xmovei w3,stadrs	;translate areas with address blocks
;;;	xmovei w4,enadrs
;;;	subi w4,1
;;;	call gctran
	move w3,bpsbeg		;translate BPS
	move w4,bpsend
	subi w4,1
	call gctran
	move w3,[baseq]		;translate data stack
	move w4,q
	call gctran
	move w3,[basesp]	;translate special PDL
	move w4,sp
	call gctran
	move w3,stcnst		;translate constant area
	move w4,encnst
	subi w4,1
	call gctran
	move w3,stthat		;now do the new space
	call gctrax

  ;now reverse areas
	move w2,stthis
	exch w2,stthat
	movem w2,stthis
	move w2,enthis
	exch w2,enthat
	movem w2,enthis
  ;clear q above the point actually used.  This is necessary since
  ;compiled code sometimes does ADJSP Q,+N.  The effect is that
  ;there may be data on Q that was not put there explicitly.  If a
  ;GC should happen before real data was put in, we could be in trouble
  ;if there were any pointers left over from a previous GC cycle.  To
  ;be safe, we must purge all old items from the Q section.  Other
  ;sections need not be cleared, since data is put in SP space and
  ;and free space only by PUSH or by adjusting FREE to beyond data
  ;actually used.
	move w2,q			;.Q + 1 is first to be cleared
	tro w2,777			;end of page is last
	sub w2,q			;here is number of words
	jumpe w2,igcldn			;forget it if none
	setzm 1(q)			;clear first
	caig w2,1			;done if only one
	jrst igcldn
	xmovei w3,1(q)			;source is .Q + 1
	xmovei w4,2(q)			;dest is one more
	xblt w2,			;clear them all
;now we have cleared remaining part of current page - kill higher pages
igcldn:	move w2,q
	tro w2,777
	addi w2,1			;first word of next page
	lsh w2,-9.			;w2 - page number of next page
	movei w3,endq_-9.		;page number beyond section
	skipn @[datsec,,.%%STKLIM]	;expanded stack?
	movei w3,endqs_-9.		;yes - then to end of section
	sub w3,w2			;w3 - number of pages to clear
	jumpe w3,igpmdn			;done if none
	seto nil1,			;AC1 - unmap
	hrli w2,.fhslf			;AC2 - self,,first page
	tlo w3,(pm%cnt)			;AC3 - count
	pmap				;clear them all
  ;and set up trigger for next GC
igpmdn:	move w3,free			;but now compute used/2
	sub w3,stthis			;  w3 _ used
	fltr w3,w3			;to floating point
	skipe o1,@[datsec,,.GCTRIG]	;now multiply by trigger
	 call ob21wf		;cnvt to number
	jumpe o1,igpmd1
igpmd0:	fmpr w2,w3			;now have real free space
	fixr w2,w2			;convert back to integer
	caige w2,freesz			;give him at least this much
igpmd1:	movei w2,freesz			;no - use this
	add w2,free			;     + free
	move w3,enthis			;but not too big - end of this area
	subi w3,4000			;give a bit of extra space since
					;we can allocate beyond LASTL
	camle w2,w3			;if new LASTL is too big
	move w2,w3			;then use upper bound instead
	movem w2,lastl
	setzb nil,nil1
	setzb o1,o2			;clear these AC's so have valid data
	setzb o3,o4
	setzb o5,o6
	call encrit			;no longer in critical section
	ret

;GCLEFT - amount of space left before the next GC
gcleft:	move w2,lastl
	sub w2,free
	jrst ret1nt

;VECTOR and ARRAY

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	VECTOR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;makvec
makvec:	gettyp o1
	caie w2,ty%lpi			;better be low pos int
	 jrst makver			;(low means <2^30)
	push free,o1			;start with size
	move w2,o1			;w2 - size as number
	posnum w2
	xmovei o1,1(free)		;save start as returned vector
	tlc o1,(object(ty%vec,0))
	xmovei w3,1(free)		;w3 - start of data
	add free,w2
	jumpe w2,makv1			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,makv1			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
makv1:	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret				;object already in o1

makver:	perr /Size of vector must be non-negative integer/

;(GETVEC vector index)
getvec:	caml o2,[inum0]		;better be in bounds
	caml o2,-1(o1)
	jrst bounds
	xmovei w2,(o1)			;addr of vector
	add w2,o2
	move o1,(w2)
	ret

;(SETVEC vector index value)
setvec:	caml o2,[inum0]	;better be in bounds
	caml o2,-1(o1)
	jrst bounds
	xmovei w2,(o1)			;addr of vector
	add w2,o2
	movem o3,(w2)
	move o1,o3
	ret

;(VECTORBLT num fromvec frmindex tovec toindex)  ; JoSH
vecblt:	caml o3,[inum0]
	 camge o5,[inum0]
	  jrst bounds
	move w2,o1		; # of items
	tlz w2,770000		; TY%INT
	xmovei w3,(o2)		; set up from addr
	add w3,o3
	xmovei w4,(o4)		; to addr
	add w4,o5
	add o3,w2		; range check
	add o5,w2
	camg o3,-1(o2)		; (no explicit check for num<0 since
	 camle o5,-1(o4)	;  the tlz will leave a huge pos. no.)
	  jrst bounds
	xblt w2,
	jrst retnil

bounds:	move o1,o2
bound1:	perr /Vector subscript out of bounds/

;Entry for ARRAY subscript calculators.  Entries are made from
;BNDERR to BNDERR+4, depending upon which AC is involved
bnderr:	move o2,o1		;o1
	move o3,o2		;o2
	move o4,o3		;o3
	move o5,o4		;o4
	move o1,o5		;o5
	maknum o1
	setzb o2,o3
	setzb o4,o5
	jrst bound1

;VECTORLENGTH
veclen:	move o1,-1(o1)
	ret

;VECTORP
vecp:	gettyp o1
	caie w2,ty%vec
	jrst retnil
	jrst rett

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	ARRAY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;makary
makary:	gettyp o1
	tlnn o1,4000
	caie w2,ty%lpi			;better be integer
	jrst makver
	move w2,o1			;size as ty%spc
	tlc w2,(<object(ty%lpi,0)>#<object(ty%spc,0)>)
	push free,w2			;start with size
	tlz w2,770000			;now bare number
	xmovei o1,1(free)		;save start as returned vector
	tlc o1,(object(ty%ary,0))
	xmovei w3,1(free)		;w3 - start of data
	add free,w2
	jumpe w2,makv1			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,makv1			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
maka1:	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret				;object already in o1

;makcary
makcar:	gettyp o1
	tlnn o1,4000
	caie w2,ty%lpi			;better be integer
	jrst makver
	move w2,o1			;size as ty%spc
	tlc w2,(<object(ty%lpi,0)>#<object(ty%spc,0)>)
	aos w3,bpsend			;get address to use
	movem w2,-1(w3)			;header is at -1
	tlz w2,770000			;now bare number
	addm w2,bpsend			;update end
	move o1,w3			;make up pointer for start
	tlc o1,(object(ty%car,0))
	jumpe w2,cpopj			;nothing more if size 0
	setzm (w3)			;clear first word
	subi w2,1			;need to clear this many more
	jumpe w2,cpopj			;no more to do
	xmovei w4,1(w3)			;copy from start to start+1
	xblt w2,
	ret				;object already in o1

;(GETIARRAY vector index)
getiar:	move w2,-1(o1)
	tlc w2,(<object(ty%spc,0)>#<object(ty%lpi,0)>)
	caml o2,[inum0]	;better be in bounds
	caml o2,w2
	jrst bounds
	xmovei w2,(o1)			;addr of vector
	add w2,o2
	move w2,(w2)
	jrst ret1nt			;and return as integer

;(GETBARRAY vector index byte-size)
getbar:	exch o1,o2
	call get1nt		;index to w2
	jumpl w2,bound1
	movei w3,36.		;calculate bytes per word
	idivi w3,(o3)		;w3 - bytes per word
	idiv w2,w3		;w2 - words, w3 - bytes
	exch w2,w3		;w2 - bytes, w3 - words
	xmovei w4,(o2)		;in this word
	add w4,w3		;relocate by word offset
	movsi w3,440040		;first half of byte ptr - to high order byte
	dpb o3,[.bp 7700000000,w3] ;take byte size from arg
	ildb o1,w3		;increment so we do LDB not ILDB
	jumpe w2,.+3		;now increment by byte offset
	ildb o1,w3		;must use ILDB because IBP doesn't work
	sojg w2,.-1
  ;w3,w4 is now the byte pointer
	xmovei w2,(o2)		;base address
	sub w2,w4		;here is word offset
	movn w2,w2
	tlo w2,(object(ty%spc,0)) ;set type bits for comparability
	caml w2,-1(o2)		;better be less than upper bound
	jrst bound1
	ldb w2,w3
	jrst ret1nt

;(GETRARRAY vector index)
getrar:	move w2,o2			;index
	lsh w2,1			;* 2
	tlc w2,(<object(ty%spc,0)>#<<object(ty%lpi,0)>_1>) ;convert to SPC
	addi w2,1
	caml w2,[object ty%spc,1]	;better be in bounds
	caml w2,-1(o1)
	jrst bounds
	tlz w2,770000			;clear type code
	add w2,o1			;and add base of vector
	dmove w2,-1(w2)
	jrst retflo			;and return as real

;(SETIARRAY vector index value)
setiar:	move w2,-1(o1)
	tlc w2,(<object(ty%spc,0)>#<object(ty%lpi,0)>)
	caml o2,[inum0]	;better be in bounds
	caml o2,w2
	jrst bounds
	xmovei w4,(o1)			;addr of vector
	add w4,o2
	move o1,o3			;get new value
	call get1nt
	movem w2,(w4)
	ret

;(SETBARRAY vector index byte-size value)
setbar:	exch o1,o2
	call get1nt		;index to w2
	jumpl w2,bound1
	movei w3,36.		;calculate bytes per word
	idivi w3,(o3)		;w3 - bytes per word
	idiv w2,w3		;w2 - words, w3 - bytes
	exch w2,w3		;w2 - bytes, w3 - words
	xmovei w4,(o2)		;in this word
	add w4,w3		;relocate by word offset
	movsi w3,440040		;first half of byte ptr - to high order byte
	dpb o3,[.bp 7700000000,w3] ;take byte size from arg
	ildb o1,w3		;increment so we do LDB not ILDB
	jumpe w2,.+3		;now increment by byte offset
	ildb o1,w3		;must use ILDB because IBP doesn't work
	sojg w2,.-1
  ;w3,w4 is now the byte pointer
	xmovei w2,(o2)		;base address
	sub w2,w4		;here is word offset
	movn w2,w2
	tlo w2,(object(ty%spc,0)) ;set type bits for comparability
	caml w2,-1(o2)		;better be less than upper bound
	jrst bound1
	move o1,o4		;get new value
	push p,w3
	call get1nt		;into w2
	pop p,w3
	dpb w2,w3
	ret

;;TY%FLO
;(SETRARRAY vector index value)
setrar:	move w4,o2			;index
	lsh w4,1			;* 2
	tlc w4,(<object(ty%spc,0)>#<<object(ty%lpi,0)>_1>) ;convert to SPC
	addi w4,1
	caml w4,[object ty%spc,1]	;better be in bounds
	caml w4,-1(o1)
	jrst bounds
	tlz w4,770000			;clear type code
	add w4,o1			;and add base of vector
	move o1,o3			;get new value
	call getrea
	dmovem w2,-1(w4)		;put it in
	ret

;read and print.
;This page contains all the code that depends upon the representation
;of atoms and strings.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;	print
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

princ:	push q,o1		; save return value
	gettyp o1
	xct prtab(w2)

;;TYPES
prtab:	jrst pratom		; atom
	jrst pratom		;  constant atom
	jrst prlist		; cons
	jrst prlist		;  constant cons
	jrst prstr		; string
	jrst prstr		;  constant string
	jrst prchn		; channel
	jrst prcch		;  constant channel
	jrst prhash		; eq hash table
	jrst prhash		; other hash tab
	jrst prvec		; vector
	jrst prerr		; undefined
	jrst pradr		; address
	jrst prspc		; special
	jrst prary		; array
	jrst prcar		; constant array
	jrst prrea		; real
	jrst prerr		; undefined
	jrst prifl		; neg iflon
	jrst prifl		; neg iflon
	jrst prifl		; pos iflon
	jrst prifl		; pos iflon
	jrst prerr		; undefined
	jrst prrat		; ratio
	jrst prerr		; complex (unimplemented)
	jrst prerr		; undefined
	jrst prbig		; bignum
	jrst prerr		; undefined
	jrst prnint		; neg integer
	jrst prnint		; neg integer
	jrst prpint		; pos integer
	jrst prpint		; pos integer

;;TY%STR
;print a string
prstr:	move w2,o1		;string to print
	jrst prstr1

;;TY%STR
;;TY%ATM
;print an atom
pratom:	jumpe o1,prnil		;nil is special
	move w2,at%pna(o1)	;put byte ptr to pname in -1(p)
	caml w2,[object ty%str,0]	;see if really IADR
	 camle w2,[object ty%cst,7777777777]
	  jrst priadr
prstr1:	tlz w2,770000		;clear type code
	push p,[010740,,0]	;W2 is addr of TY%SPC - data in next wd
	push p,w2
pratlp:	ildb w2,-1(p)		;get next byte to print
	jumpe w2,praten
	makchr w2		;make it a char
	move o1,w2
 ;printing
	call tyo
	jrst pratlp

praten:	adjsp p,-2
	pop q,o1		;return saved value
	ret

;print a list
;This routine supplies the ( ) around a list, calling PRINC recursively
; to print the items inside
prlist:	push q,o1		;copy orig value so we can work with it
  ;left parent
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prlslp:	move o1,(q)		;get car of list
	docar o1,o1
	call princ
	move o1,(q)
	docdr o1,o1		;now cdr to next elt
	movem o1,(q)
  ;now go to next.  There are several cases
  ; NIL - stop with right parent
  ; cons cell - go on
  ; other thing - use a final dot
	skipn o1		;if nil
	jrst prlsen		;then done
	scons o1		;continue if cdr is cons cell
	jrst prlsdt		;not, do . )
	move o1,[char " " ]	;space before next elt
	call tyo
	jrst prlslp

;here if ends with . X rparent
prlsdt:	movei w2,[asciz / . /]
	call tyout
	move o1,(q)
	call princ		;now print the last thing
prlsen:	adjsp q,-1		;and forget it
	move o1,[char 51]	;rparent
	call tyo
	pop q,o1		;return original arg
	ret	

;print a vector
;This routine supplies the #( ) around a vector, calling PRINC recursively
; to print the items inside
prvec:	push q,[inum0] ;and count
  ;left parent
	move o1,[char 43]	;#
	call tyo
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prvecl:	move o1,-1(q)		;get object
	move o2,(q)		;and count
	caml o2,-1(o1)		;if something is still left
	jrst prvc1x		;no, done
	posnum o2		;compute index
	add o2,o1		;now get address of element
	move o1,(o2)		;and element itself
	call princ
	aos o2,(q)		;to next count
	move o1,-1(q)		;object
	caml o2,-1(o1)		;if something still left
	jrst prvc1x		;no, done
	move o1,[char 40]	;space
	call tyo
	jrst prvecl

;print an I/O channel
prchn:	movei w2,[asciz /CHN#/]
;common code to print funny pointers
prfun:	call tyout
	move w3,(q)		;print addr
	tlz w3,770000		;clear type code
	setz w2,
	movei n,8.		;in octal
	call ibaset
	call prnmps
	pop q,o1
	ret

;print an undefined object
prerr:	movei w2,[asciz /???#/]
	jrst prfun

;print a constant I/O channel
prcch:	movei w2,[asciz /CCH#/]
	jrst prfun

;print an address
pradr:	movei w2,[asciz /ADR#/]
	jrst prfun		;common code

;print an indirectable address
priadr:	movei w2,[asciz /IADR#/]
	jrst prfun		;common code

;print a special object
prspc:	movei w2,[asciz /SPC#/]
	jrst prfun

;print an array
prary:	movei w2,[asciz /ARY#/]
	jrst prfun

;print a constant array
prcar:	movei w2,[asciz /CAR#/]
	jrst prfun

;;TY%RAT
prrat:	move o1,(q)
	push q,1(o1)		;print a ratio:
	move o1,(o1)		;print the numerator
	call princ
	move o1,[char "/"]	;print a slash
	call tyo
	pop q,o1		;print the denominator
	call princ
	pop q,o1		;return the ratio
	ret

prin1:	push q,o1		;save value for return
	gettyp (q)
	xct pr1tab(w2)

;;TYPES
pr1tab:	jrst prat1		; atom
	jrst prat1		;  constant atom
	jrst prls1		; cons
	jrst prls1		;  constant cons
	jrst prst1		; string
	jrst prst1		;  constant string
	jrst prchn		; channel
	jrst prcch		;  constant channel
	jrst prhash		; eq hash table
	jrst prhash		; other hash tab
	jrst prvc1		; vector
	jrst prerr		; undefined
	jrst pradr		; address
	jrst prspc		; special
	jrst prary		; array
	jrst prcar		; constant array
	jrst prrea		; real
	jrst prerr		; undefined
	jrst prifl		; neg iflon
	jrst prifl		; neg iflon
	jrst prifl		; pos iflon
	jrst prifl		; pos iflon
	jrst prerr		; undefined
	jrst prrat		; ratio
	jrst prerr		; complex (unimplemented)
	jrst prerr		; undefined
	jrst prbig		; bignum
	jrst prerr		; undefined
	jrst prnint		; neg integer
	jrst prnint		; neg integer
	jrst prpint		; pos integer
	jrst prpint		; pos integer

noprt:	pop q,o1		;return original value
	ret

;;TY%STR
;print a string
prst1:	move o1,[char 42]	;quote
	call tyo
	move w2,(q)		;string to print
	push q,(q)		;prstr1 expects the arg to be on stack also
	call prstr1
	move o1,[char 42]	;close quote
	call tyo
	pop q,o1		;return thing that was printed
	ret

;;TY%STR
;;TY%ATM
;print an atom
prat1:	jumpe o1,prnil		;nil is special
	move w2,at%pna(o1)	;put byte ptr to pname in -1(p)
	caml w2,[object ty%str,0]	;see if really IADR
	 camle w2,[object ty%cst,7777777777]
	  jrst priadr
	tlz w2,770000		;clear type code
	push p,[010740,,0]	;W2 is addr of TY%SPC - data in next wd
	push p,w2
;first thing
	ildb w2,-1(p)
	jumpe w2,praten		;null atom???
	skipl w3,rdtab(w2)	;see if needs slash
	xct pratb2(w3)		;prat6 or prat2
;falls to here if read macro
prat2:	push p,w2		;save the thing
	move o1,@[datsec,,.%SLASH]
	call tyo		;do the slash
	pop p,w2
prat6:	makchr w2		;make it a char
	move o1,w2
	call tyo		;print it
;things other than first
prat5:	ildb w2,-1(p)		;get next byte to print
	jumpe w2,praten
	hrrz w3,rdtab(w2)	;see if needs slash
	xct prattb(w3)		;prat3 or prat4
prat3:	push p,w2
	move o1,@[datsec,,.%SLASH]	;do the slash
	call tyo
	pop p,w2
prat4:	makchr w2		;make it a char
	move o1,w2
 ;printing
	call tyo
	jrst prat5

;;READTABLE
pratb2:	jrst prat6	;letters
	jrst prat6	;lower case
	jrst prat2	;(
	jrst prat2	;)
	jrst prat2	;[
	jrst prat2	;]
	jrst prat2	;.
	jrst prat2	;,
	jrst prat2	;'
	jrst prat2	;/
	jrst prat2	;"
	jrst prat2	;space
	jrst prat2	;all end of lines
	jrst prat2	;digits
	jrst prat7	;+ -
	jrst prat2	;esc
	jrst prat2	;comment
	jrst prat2	;null

;special kludge for signs
prat7:	push p,w2	;save actual sign
	dmove w3,-2(p)	;get byte pointer
	ildb w2,w3	;peek at next char
	hrrz w3,rdtab(w2) ;see what it is
	pop p,w2	;get back sign
	caie w3,rd%dig	;if next is digit
	jrst prat6	;not - no quote needed
	jrst prat2	;is - this would look like a number

;;READTABLE
prattb:	jrst prat4	;letters
	jrst prat4	;lower case
	jrst prat3	;(
	jrst prat3	;)
	jrst prat3	;[
	jrst prat3	;]
	jrst prat3	;.
	jrst prat3	;,
	jrst prat3	;'
	jrst prat3	;/
	jrst prat3	;"
	jrst prat3	;space
	jrst prat3	;all end of lines
	jrst prat4	;digits
	jrst prat4	;+ -
	jrst prat4	;esc
	jrst prat3	;comment
	jrst prat3	;null


;print a list
;This routine supplies the ( ) around a list, calling PRIN1 recursively
; to print the items inside
prls1:	push q,(q)		;save original thing, for return value
  ;left parent
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prls1l:	move o1,(q)		;get car of list
	docar o1,o1
	call prin1
	move o1,(q)		;now cdr to next element
	docdr o1,o1
	movem o1,(q)
  ;now go to next.  There are several cases
  ; NIL - stop with right parent
  ; cons cell - go on
  ; other thing - use a final dot
	skipn o1		;if nil
	jrst prls1e		;then done
	scons o1		;continue if cdr is cons cell
	jrst prls1d		;not, do . )
	move o1,[char " " ]	;space before next elt
	call tyo
	jrst prls1l

;here if ends with . X rparent
prls1d:	movei w2,[asciz / . /]
	call tyout
	move o1,(q)
	call prin1		;now print the last thing
prls1e:	adjsp q,-1		;and forget it
	move o1,[char 51]	;rparent
	call tyo
	pop q,o1		;and return the arg
	ret	

;print a hash table
; a temporary hack -- print its guts
prhash:	push q,[inum0] ;and count
  ;left parent
	move o1,[char 43]	;#
	call tyo
	move o1,[char "H"]
	call tyo
	move o1,[char 50]	;lparent
	call tyo
	jrst prvc1l

;print a vector
;This routine supplies the #( ) around a vector, calling PRIN1 recursively
; to print the items inside
prvc1:	push q,[inum0] ;and count
  ;left parent
	move o1,[char 43]	;#
	call tyo
	move o1,[char 50]	;lparent
	call tyo
  ;now the list of things inside
prvc1l:	move o1,-1(q)		;get object
	move o2,(q)		;and count
	caml o2,-1(o1)		;if something is still left
	jrst prvc1x		;no, done
	posnum o2		;compute index
	add o2,o1		;now get address of element
	move o1,(o2)		;and element itself
	call prin1
	aos o2,(q)		;to next count
	move o1,-1(q)		;object
	caml o2,-1(o1)		;if something still left
	jrst prvc1x		;no, done
	move o1,[char 40]	;space
	call tyo
	jrst prvc1l

prvc1x:	move o1,[char 51]	;rparent
	call tyo
	adjsp q,-1		;get rid of count
	pop q,o1		;and return the arg
	ret	

prnil:	movei w2,[asciz /NIL/]
	call tyout
	pop q,o1		;and return the arg
	ret

;;this routine is called at the beginning of number i/o to 
; set register n to the appropriate line of bastab (below).
basset:	move n,@[datsec,,.BASE] ; output base
	getnum n
ibaset:	movms n			;for input base, after defaulting
	cail n,2
	 caile n,16.
	  movei n,10.
	subi n,2
	imuli n,5
	add n,[codsec,,bastab]
	ret

;; table of constants for reading/printing in various bases
;; 2 words are used for the base, for use by dmul etc.
;; exp is the highest power of base that can be crammed into
;; two words.  bignums are read and printed in batches of exp digits.
;;	    base	base^exp	 		  exp
bastab:	0 ? 2.	?	400000,,0 ? 0			? 70.
	0 ? 3.	?	325423420677 ? 340306071161	? 54 
	0 ? 4.	?	400000,,0 ? 0			? 35.
	0 ? 5.	?	311745447150 ? 43164733651	? 36 
	0 ? 6.	?	335736203577 ? 273000000000	? 33 
	0 ? 7.	?	51425624134 ? 312645112101	? 30 
	0 ? 8.	?	200000,,0 ? 0			? 23.
	0 ? 9.	?	325423420677 ? 340306071161	? 26 
	0 ? 10.	?	330656,,232670 ? 273650,,0	? 21.
	0 ? 11.	?	221702201600 ? 111105213761	? 24 
	0 ? 12.	?	105215317330 ? 0		? 23 
	0 ? 13.	?	30305035631 ? 337332367351	? 22 
	0 ? 14.	?	134441045406 ? 202661000000	? 22 
	0 ? 15.	?	25272461637 ? 124147374417	? 21 
	0 ? 16.	?	100000,,0 ? 0			? 17.


;;TY%BIG
prbig:	call basset		;point to right base info
	move o1,(q)		;here's the bignum to print
	getsiz w2,o1		;how big is it?
	caie w2,2		;if 2 wds, use small num print routine
	 jrst prbigx		; if bigger, special bignum routine
	dmove w2,1(o1)		;--for small (2-wd) case:
	jumpge w2,prnum1	;its all set if positive
	move o1,[char "-"]	;else print minus sign
	call tyo
	move o1,(q)
	dmovn w2,1(o1)		;and then print the magnitude
	jrst prnum1

prbigx:	push p,q		;number is >2 wds: use some stack space
	getsiz w4,o1		;p: saved q, number (msw first)
	add o1,w4		;find end of number
	sos o1			;(we reverse the doublewds for division)
	skipge (o1)		;if <0, print "-" and negate it
	 jrst pbxneg		; returns to pbxnrt
	aos o2,p		;o2 = saved p
	adjsp p,1(w4)
	setzb w2,w3		;we add a 0 doublewd at the beginning
	move nil1,o2		; for simplicity in division
	lsh w4,-1		;count doublewds
pbx1:	dmovem w2,(nil1)	;put on stack
	addi nil1,2		;bump pointer
	dmove w2,(o1)		;get dw from object
	tlz w2,400000		;make sure sign bits are 0
	tlz w3,400000
	subi o1,2		;decr obj ptr
	sojg w4,pbx1		;until done
	dmovem w2,(nil1)
pbxnrt:	move nil1,o2		;now to divide: nil1 moves along # again
	setzb w2,w3		;0,x first time along
pbxdiv:	dmove w4,(nil1)		;third-grade short division w/1-digit divisor
	skipl 2(n)		;divide by base^exp -- if negative, means
	 ddiv w2,2(n)		;base 2 or 4, and base^exp = 2^70
	dmovem w2,(nil1)	;--of course, digits are base 2^70
	dmove w2,w4		;replace dividend with quotient as we go
	addi nil1,2		;--as all we are interested in ultimately
	camg nil1,p		;  is the successive remainders
	 jrst pbxdiv
	move nil1,4(n)		;got a remainder.  divide it by base
pbx21:	dmove w4,w2		; exp times (see bastab)
	setzb w2,w3		;(good old 4-wd dividend)
	ddiv w2,(n)		;base (2 wds)
	makdig o1		;makes an inum for ascii code
	push q,o1		;stack digits on q
	sojg nil1,pbx21		;--exp times...
	skipa nil1,o2		;the # is rapidly shrinking, 
pbx0:	 addi nil1,2		;find where it begins
	caml nil1,p		;--if it doesn't begin, we're done
	 jrst pbx30
	dmove w2,(nil1)		;is this dw = 0?
	skipn w2
	 jumpe w3,pbx0		;yes, look some more
	setzb w2,w3		;no, dividend starts here
	jrst pbxdiv

pbx30:	sos p,o2		;done dividing! reset p, nil, etc.
	setz nil1,o2
pbx31:	pop q,o1		;oh, yeah, and type out the digits
	camn o1,[char "0"]	;--ignoring leading 0's
	 jrst pbx31
	camge q,(p)		;all 0's?
	 jrst [push q,o1 ? move o1,[char "0"] ? jrst .+1]
	skipa			;(1st time have non-0 digit we found above)
pbx32:	 pop q,o1		;get a digit
	call tyo		;type it
	came q,(p)		;is that all?
	 jrst pbx32		;nope
	adjsp p,-1		;q already = this, just discard
	pop q,o1		;return object printed
	ret

;;negate a number which was negative
pbxneg:	push p,o1		;not an obj just now
	push p,w4
	move o1,[char "-"]
	call tyo
	pop p,w4
	pop p,o1
	aos o2,p		;o2 = saved p
	adjsp p,1(w4)
	setzb w2,w3		;we add a 0 doublewd at the beginning
	move nil1,o2
	lsh w4,-1
pbxn1g:	dmovem w2,(nil1)	;put on stack
	addi nil1,2		;bump pointer
	setcm w2,(o1)		;get dw from object
	tlz w2,400000		;make sure sign bit is 0
	setcm w3,1(o1)
	tlz w3,400000
	subi o1,2		;decr obj ptr
	sojg w4,pbxn1g		;until done
	dmovem w2,(nil1)	;that was a one's complement..
	aos nil1		;point to next wd
pbxn2g:	aosl (nil1)		;add one to it
	 jrst pbxnrt		;stops when carry does
	setzm (nil1)
	soja nil1,pbxn2g

;;TY%INT
;;WORK	2	holds base for number output
prnint:	move o1,[char "-"]	;print sign
	call tyo
	move w2,(q)		;move sign stuff to here when we
	negnum w2		;flush the -base foolishness
	movms w2
	jrst prnum0
prpint:	move w2,(q)		;get the number, leaving it as ret val
	posnum w2		;numerical form
prnum0:	ashc w2,-35.		;flushed -base cruft
prnum1:	call basset
	call prnmps		;print it
	skipe @[datsec,,.NOPOINT] ;see if need point
	jrst prnmrt		;no
	move w4,1(n)
	setz w2,		;assume no point available
	cain w4,10.		;decimal
	move w2,[char "."]	;here is the point
	cain w4,8.		;octal
	move w2,[char "Q"]	;and octal point
	jumpe w2,prnmrt		;if didn' find one, return
	move o1,w2
	call tyo		;print it
prnmrt:	pop q,o1		;return arg
	ret

;; floating printers follow.  they do not use BASE, as floating #s
;; are always read and printed base 10. (decimal).
prrup:	dfmp w2,[10.0
		 0]
	sos (p)
	jrst prr1

prrdwn:	dfdv w2,[10.0
		 0]
	aos (p)
	jrst prr2

	.scalar numdig

;print an iflon. 
prifl:	movei w2,6		;digits of precision for iflon
	movem w2,numdig
	move w2,o1		;put it in w2/3
	lsh w2,4
	setz w3,
	jrst prreax

;;TY%FLO
;-1(p) - negative flag
;(p) - exponent
prrea:	movei w2,18.
	movem w2,numdig
	move o1,(q)
	dmove w2,1(o1)
prreax:	push p,[0]		;this is count of delayed zeros
	push p,[0]		;assume positive
	cail w2,0		;if negative
	jrst prr0		;not
  ;if negative, we want the positive form
	setom (p)		;set flag
	dmovn w2,w2		;and negate
prr0:	push p,[1]		;this will be exponent
	skipn w3		;check for zero
	tdne w2,[000777777777]
	jrst .+2		;not zero
	jrst prrz		;zero - don't try to adjust to above 1.0
prr1:	camge w2,[1.0]		;it must be at least 1.0
	jrst prrup
prr2:	caml w2,[10.0]		;but smaller than 10.0
	jrst prrdwn
;now scaled from 1.0 to 10.0
	move w4,numdig
	cain w4,6.
	 dfad w2,[0.000005 ? 0] ;round at last digit
	cain w4,18.
	 dfad w2,[107560736521	;round at last digit
	 	  221552226422]
	caml w2,[10.0]		;in case this pushes us over
	jrst prrdwn
prrz:	ldb w4,[.bp 377_27.,w2]	;get binary exponent
	subi w4,200		;scale it
	tlz w2,377000		;clear exponent
	ashc w2,(w4)		;shift mantissa into .GT. 0 part
  ;-5(p) - delayed zeros
  ;-4(p) - negative
  ;-3(p) - exp
  ;-2(p),-1(p) - number being printed
  ;(p) - number of digits left to print
	push p,w2
	push p,w3
	push p,numdig
	move o1,[char "-"]
	skipe -4(p)			;if negative
	call tyo			;print the sign
	move w2,-3(p)			;look at precision
	camg w2,numdig			;if too big
	caige w2,0			;or too small
	jrst prre			;use e format

;this is for printing in F format
	move o1,[char "0"]		;use leading zero if exp = 0
	skipg -3(p)
	call tyo
	aos -3(p)
;loop for printing the digits
prrf3:	move o1,[char "."]		;need decimal pt?
	sosn -3(p)			;no
	call tyo			;yes
	sosge (p)			;run out of digits?
	jrst prrf4			;end of print
	dmove nil1,-2(p)		;get number into 1-2
	ldb w4,[.bp 377_27.,nil1]	;get integer part
	push p,w4			;save it for printing
	tlz nil1,377000			;clear it
	dmul nil1,[0
		   10.]			;now shift on dec digit
	dmovem w3,-3(p)			;and put it back for next
	move nil1,nil
	pop p,w4			;get back digit to print
  ;basically we now print w4 - but want to omit trailing zeros after dec. pt.
	skipge -3(p)			;can we delay zeros?
	jumpe w4,prrf5			;yes, if zero, delay it
	skipe -5(p)			;any delayed zero?
	call prrdel			;yes - do them
	add w4,[char "0"]		;convert to char
	move o1,w4			;and print it
	call tyo
	jrst prrf3

;here to delay a zero
prrf5:	aos -5(p)			;just add zero to total
	jrst prrf3

;here to print delayed zeros
prrdel:	push p,w4		;save thing we want to print
prrd1:	move o1,[char "0"]
	call tyo
	sosle -7(p)		;any more?
	jrst prrd1		;yes - do them
	pop p,w4		;get back real char
	ret
	
prrf4:	move o1,[char "d"]		;need decimal pt?
	move w4,numdig
	cain w4,18.			;long real?
	call tyo			;yes - print D
	adjsp p,-6		;kill saved junk
	pop q,o1		;return the arg
	ret

;Here for E format
prre:	dmove nil1,-2(p)		;get number into 1-2
	ldb w4,[.bp 377_27.,nil1]	;get integer part
	push p,w4			;save it for printing
	tlz nil1,377000			;clear it
	dmul nil1,[0
		   10.]			;now shift on dec digit
	dmovem w3,-3(p)			;and put it back for next
	move nil1,nil
	pop p,w4			;get back digit to print
	add w4,[char "0"]		;convert to char
	move o1,w4			;and print it
	call tyo
	sos (p)			;count the digit
	move o1,[char "."]	;print decimal point
	call tyo
;loop for printing the digits
prr3:	sosge (p)			;run out of digits?
	jrst prr4			;end of print
	dmove nil1,-2(p)		;get number into 1-2
	ldb w4,[.bp 377_27.,nil1]	;get integer part
	push p,w4			;save it for printing
	tlz nil1,377000			;clear it
	dmul nil1,[0
		   10.]			;now shift on dec digit
	dmovem w3,-3(p)			;and put it back for next
	move nil1,nil
	pop p,w4			;get back digit to print
	jumpe w4,prr5			;if zero, delay it
	skipe -5(p)			;any delayed zeros?
	call prrdel			;yes - do them
	add w4,[char "0"]		;convert to char
	move o1,w4			;and print it
	call tyo
	jrst prr3

;here to delay a zero
prr5:	aos -5(p)			;just add zero to total
	jrst prr3
	
prr4:	move w2,numdig		;print the exp
	move o1,[char "e"]	;1.23e45 for iflons
	cain w2,18.
	 move o1,[char "d"]	;1.23d45 for lflons
	call tyo
	sos w2,-3(p)		;exp !!note this hacks its value!!
	maknum w2
	push p,sp		;[RAF 4/26/82] no point after exp
	push sp,[%NOPOINT]
	push sp,@[datsec,,.NOPOINT+at%val]
	move o1,[%t]
	movem o1,@[datsec,,.NOPOINT+at%val]
	move o1,w2		;number part
	call prin1
	pop p,w2
	call unbin1		;[RAF 4/26/82] end
	adjsp p,-6		;kill saved junk
	pop q,o1		;return the arg
	ret

;;WORK
;recursive printer, number in w2.  Will print 36-bit numbers in positive form
prnmps:	dmove w4,w2		;move w2 to w2,w3 as double word
	setzb w2,w3		;now standard recursive printer
	ddiv w2,(n)		;base
	push p,o1		;save digit, retrieve base
	skipn w2		;but someone else has to print rest
	 skipe w3
	  call prnmps		;(unless zero, of course)
	pop p,w3
	makdig w3		;make char
	move o1,w3
	call tyo
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;other random print things
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
terpri:	push q,o1
	movei w2,[asciz /
/]
	call tyout
	pop q,o1
	ret

;lines0 - terpri if not at start of line
lines0:	move o2,@[datsec,,.curout]
	skipg ch%pos(o2)	;beyond start?
	ret			;at beginning, nothing to do
	jrst terpri

;lines(n) - N blank lines
lines:	move w2,o1
	getnum w2
	push p,w2		;(p) - number of lines to do
	call lines0		;to start of line
linesl:	sosge (p)		;now that many terpri's
	jrst cpopj1
	call terpri
	jrst linesl

cpopj1:	adjsp p,-1
	ret

print:	push q,o1		;save arg
	call terpri
	move o1,(q)		;get back arg
	call prin1
	move o1,[char 40]
	call tyo
	pop q,o1		;return arg
	ret


;;;;;Now the fun begins: explode and explodec, which work like prin1 and
;;;;;princ, but output to a list.  they generate a channel object pointing
;;;;;to the list they are building, and set up to use EXPPUT for writing
;;;;;char's.  Note that this program creates a dummy (NIL.NIL).  We need
;;;;;this dummy so that EXPPUT will have something to RPLACD to the first
;;;;;time around.

;common routine to do the explode/c.  the TYO routine and then then print
;routine is pushed on the stack
;;TY%CHN
explo:	push p,sp		;save sp since we rebind curout
	push q,o1		;save arg
	move o1,[.dumchn]	;get the dummy channel
	setzm ch%dat(o1)	;clear in order to prevent chaos if GC done at
				;the CONS below.  CH%DAT must be valid
	movei w2,ch%666-1	;make ch%dat be checked by GC
	hrrm w2,ch%spc(o1)
	move w2,-3(p)		;use special output routine that adds to list
	movem w2,ch%put(o1)
	setzm w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	docons o2,nil,nil	;and put new dummy cell into data
	movem o2,ch%dat(o1)	;to append to
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	pop q,o1		;get back thing to print
	push q,o2		;save start of list we are building
	move w2,-2(p)		;the print routine
	call (w2)
	pop q,o1		;start of list we built
	docdr o1,o1		;car was a dummy
	jrst unbind		;rebind curout

;The actual explode and explodec
explod:	push p,[codsec,,expput]	;this for TYO
	push p,[codsec,,prin1]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

exploc:	push p,[codsec,,expput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

;And AEXPLODE and AEXPLODEC
aexplo:	push p,[codsec,,aexput]	;this for TYO
	push p,[codsec,,prin1]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

aexplc:	push p,[codsec,,aexput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	adjsp p,-2
	ret

;PACK
pack:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word
	dmovem w3,@[datsec,,dumchn+ch%bpt]
	push p,[codsec,,pckput]	;this for TYO
	push p,[codsec,,pckprn]	;this for PRINT
	call explo		;common explosion code
	idpb nil,@[datsec,,dumchn+ch%bpt]
	subi free,2		;undo CONS in explo
	adjsp p,-2
	move w4,@[datsec,,dumchn+ch%bpt+1] ;get updated FREE
;now unless number, intern
;W4 has updated FREE
packx:	push p,w4
	hrlzi w3,440740		;w3/4 byte pointer
	xmovei w4,2(free)
	ildb w2,w3
	move w2,rdtab(w2)	;see what it is
	cain w2,rd%sgn		;if sign, must check next
	jrst [	ildb w2,w3
		move w2,rdtab(w2)
		jrst .+1]
	cain w2,rd%per		;if dot, must check next
	jrst [	ildb w2,w3
		move w2,rdtab(w2)
		jrst .+1]
	caie w2,rd%dig		;if digit, it is a number
	jrst [	pop p,w4
		jrst xintern]	;not - intern as atom
	pop p,w4		;junk
;here for a number - we simulate readlist
	move o1,[.dumchn]
	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	dmovem w3,@[datsec,,dumchn+ch%bpt]
	push p,sp		;save sp since we rebind curin
	move w2,[codsec,,pckget] ;use special input routine that read fr free
	movem w2,@[datsec,,dumchn+ch%get]
	move o3,[%curin]	;rebind current input to this channel
	push sp,[%curin]
	push sp,at%val(o3)
	setval o3,o1
	call read		;result will be in o1
	jrst unbind		;rebind curin
	

;subroutine for PACK.
;This just does PRINC on everything in the list O1
pckprn:	push q,o1
	jumpe o1,pckprx
pckprl:	doboth o1,o1
	movem o2,(q)		;save CDR for next
	call princ
	move o1,(q)
	jumpn o1,pckprl
pckprx:	pop q,o1
	ret

;PACK*
packs:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word
	dmovem w3,@[datsec,,dumchn+ch%bpt]
	move w2,o1		;number of args
	posnum w2		;convert to bare integer
	move w3,q		;last arg
	sub w3,w2		;first arg - 1
	push p,w3		;save current Q for PKSPRN
	push p,[codsec,,pckput]	;this for TYO
	push p,[codsec,,pksprn]	;this for PRINT
	call explo		;common explosion code
	idpb nil,@[datsec,,dumchn+ch%bpt]
	subi free,2		;undo cons
	adjsp p,-3
	move w4,@[datsec,,dumchn+ch%bpt+1] ;get updated FREE
	jrst packx		;intern or make number

;subroutine for PACK*.  This is the LSUBR form
pksprn:	push q,o1
pksprl:	camg o1,[inum0]		;more args? - this requires o1 .ge. 0
	 jrst pksprx		;no - exit
	aos w4,-5(p)		;get copy of Q
	move o1,(w4)		;get next arg
	call princ		;print it
	sos o1,(q)		;now one fewer args
	jrst pksprl	
pksprx:	adjsp q,-1
	ret

;MKATOM
mkatom:	snatom o1
	ret			;already atom
;we could handle strings specially, but we prefer to use this code
;at the moment.  It takes more CPU time but saves consing up a
;new atom in case it already exists.  By using XINTERN we avoid
;CONS for existing atoms.
	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word
	dmovem w3,@[datsec,,dumchn+ch%bpt]
	push p,[codsec,,pckput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	idpb nil,@[datsec,,dumchn+ch%bpt]
	subi free,2		;undo cons
	adjsp p,-2
	move w4,@[datsec,,dumchn+ch%bpt+1] ;get updated FREE
	jrst xintern		;make atom

;MKSTRING
mkstr:	jumpe o1,[move o1,@[datsec,,.nil+at%pna]
		  ret]		;NIL - return its pnam
	xtype o1
	cain w2,ty%xat
	jrst [move o1,at%pna(o1) ;atom - its pname
	      ret]
	cain w2,ty%xst
	ret			;already string
	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	setzm (w4)		;clear first word
	dmovem w3,@[datsec,,dumchn+ch%bpt]
	push p,[codsec,,pckput]	;this for TYO
	push p,[codsec,,princ]	;this for PRINT
	call explo		;common explosion code
	idpb nil,@[datsec,,dumchn+ch%bpt]
	subi free,2		;undo cons
	adjsp p,-2
	move w4,@[datsec,,dumchn+ch%bpt+1] ;get updated FREE
	xmovei w2,1(free)	;start of string
	sub w4,w2		;w3 is length in words
	tlo w4,(object(ty%spc,0)) ;special GC code
	movem w4,(w2)		;as header
	xmovei o1,1(free)	;start of string
	tlo o1,(<object ty%str,0>) ;make string pointer
	move free,@[datsec,,dumchn+ch%bpt+1] ;update free
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

;common routine to do the flatsize/c. the print routine is pushed on the stack
;;TY%CHN
flsize:	push p,sp		;save sp since we rebind curout
	push q,o1		;save arg
	move o1,[.DUMCHN]	;get the dummy channel
	movei w2,ch%666		;ch%dat not GC'ed
	hrrm w2,ch%spc(o1)
	move w2,[codsec,,fltput] ;use special output routine that counts
	movem w2,ch%put(o1)
	setzm w3,ch%len(o1)
	setzm w3,ch%pos(o1)
	setzm ch%dat(o1)	;zero count
	move o3,[%curout] ;rebind current output to this channel
	push sp,o3		;save old value
	push sp,at%val(o3)
	setval o3,o1		;new value
	exch o1,(q)		;get back thing to print, save chan
	move w2,-2(p)		;the print routine
	call (w2)
	pop q,o1
	move w2,ch%dat(o1)	;get count
	maknum w2		;make into lisp number
	move o1,w2
	jrst unbind		;rebind curout

;The actual explode and explodec
flats:	push p,[codsec,,prin1]	;use this routine
	call flsize		;common explosion code
	adjsp p,-1
	ret

flatsc:	push p,[codsec,,princ]
	call flsize
	adjsp p,-1
	ret

;readlist
readls:	push p,sp		;save sp since we rebind curin
	push q,o1		;save arg
	call makchn		;returns a new channel object in o1
	sos ch%spc(o1)		;make ch%dat be checked by GC
	move w2,[codsec,,rdlget] ;use special input routine that read fr list
	movem w2,ch%get(o1)
	pop q,ch%dat(o1)	;put in list to read
	move o3,[%curin]	;rebind current input to this channel
	push sp,[%curin]
	push sp,at%val(o3)
	setval o3,o1
	move w2,-2(p)		;the read routine
	call read		;result will be in o1
	jrst unbind		;rebind curin

;maknam: special version of readlist that doesn't intern
maknam:	push p,sp
	move o3,[%dointern]	;set ..intern to false
	fasbind o3,nil
	call readls
	jrst unbind


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  read
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;Here is the read table.  Each character is given a read class,
;which is then used by the dispatch tables.  This is just a way to
;make the tables smaller, since we only need the tables to be as
;long as the number of read classes, rather than 128 long.

;;READTABLE - anyone that has a table based on this should have a
;   comment saying ;;READTABLE
rd%let==0	;letters
rd%lc==1	;lower case
rd%lp==2	;(
rd%rp==3	;)
rd%lb==4	;[
rd%rb==5	;]
rd%per==6	;.
rd%com==7	;,
rd%quo==10	;'
rd%sl==11	;/
rd%sq==12	;"
rd%sp==13	;space
rd%eol==14	;all end of lines
rd%dig==15	;digits
rd%sgn==16	;+ -
rd%esc==17	;escape - end of line and super-close
;the following types will never get through TYI, and thus need not be
;in the read tables
rd%cmt==20	;comment
rd%nul==21	;null

rd%drm==400000,,0	;flag for read macro, of either kind
rd%dsm==200000,,0	;flag for splice macro - rd%drm also set
rd%dim==100000,,0	;flag for infix macro - rd%drm also set

;The actual table is elsewhere, to keep the code pure

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; READ
;;   This is complicated by the kill character, which is rubout in
;;   DDTIN mode.  In order to abort any reading, we must save the
;;   context at the start of read.  Then when the kill char is seen
;;   anywhere within READ, we restore the context and try again.
;;   Also, note that read macros can call READ recursively.  In this
;;   case, we want to kill up to the topmost call to READ.  Hence
;;   things are saved only initially.  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;Note that a top-level entrance binds RDTOP, whereas recursive
;;;;;entrances rebind it to itself.  This is to make it easy to tell
;;;;;when you have a final exit, because then restoring the old binding
;;;;;will give you NIL.

;;RDEXIT - normal exit from read.  All subroutines of READ should exit
;;  through this
rdexit:	pop sp,@[datsec,,.rdtop];saved value of RDTOP
	adjsp sp,-1		;RDTOP itself
	skipe @[datsec,,.rdtop]	;if this is final exit
	ret			;not - just exit now
	adjsp p,-3		;undo saved q and sp
	skipn sawfix		;asked for edit?
	ret			;no - done now
	move w4,[%FIXFN]
	jrst calatm		;yes - call his fixer

;;RDENT - standard entrance code to READ.
;Note that CRDCTX and RDEXIT depend upon this pushing 3 things on P
define rdenter
	skipe w2,@[datsec,,.rdtop];if first call to read
	jrst .+7		;not, go on
;toplevel call to READ
	setzm sawfix		;init for ^F
	push p,[codsec,,.-3]	;save context on .RDTOP
	push p,q
	push p,sp
	move w2,p
	tlo w2,(object(ty%adr,0))
;all calls to read
	move o2,[object ty%adr,<datsec,,.rdtop>]
	fasbind o2,w2
	termin

;READCONTEXT allows the user to write code that will be executed in
;read context, i.e. if ^Z or ^F is typed, the right thing will happen.

;;;;;READCONTEXT for compiled functions
;;;;;  call crdctx
;;;;;  jrst ret+1
;;;;;  code inside the readcontext
;;;;;  ret

crdctx:	rdenter
	move w2,-3(p)		;return address
	call 1(w2)		;call inner code
	jrst rdexit		;and exit canonically

;interpreted READCONTEXT - FSUBR
rdcntx:	push q,o1		;save in case of recylcing
	rdenter
	move o1,(q)		;get back O1
	call progn		;eval things to do
	adjsp q,-1
	jrst rdexit		;and exit canonically


;;;;;;end of READ context routines.  Here is the code itself
;;;;;;

;RDNAM - like read, but no interning
rdnam:	push p,sp
	move o3,[%dointern]	;set ..intern to false
	fasbind o3,nil
	call read
	jrst unbind

;;RDKILL - called by DDTIN I/O routine to kill a read
rdkill:	move w3,@[datsec,,.rdtop] ;retry read - old p
	tlz w3,770000
	move p,w3
	pop p,w2		;saved sp
	pop p,q			;saved q
	move o1,[%READ]		;say who caused the unwind
	movem o1,@[.unwpro]
	jrst cubin1		;place to go to is now top of P

;;READ - normal read entrance
read:	rdenter			;establish stack context
;loop for skipping leading spaces, etc
read1:	call tyi
read2:	skipl w2,rdtab(o1)
	xct readxt(w2)  	;to READ if should skip, to READY if not
	jrst rdmac

;readx - version of read for internal use - doesn't do tyi
readx:	rdenter
	jrst read2

;this table handles the first char encountered by READ
;;READTABLE
readxt:	jrst rdat	;letters
	jrst rdatlc	;lower case
	jrst rdlist	;(
	jrst read1	;)
	jrst rdsuls	;[ - super list
	jrst read1	;]
	jrst rdindt	;. - may be a float number
	jrst illcom	;,
	jrst rdquot	;'
	jrst rdsl1	;/
	jrst rdstr	;"
	jrst read1	;space
	jrst read1	;all end of lines
	jrst rdnum	;digits
	jrst rdneg	;+ -
	jrst read1	;esc

;here after initial slash - use next char
rdsl1:	call tyi
	hrrz w2,rdtab(o1)
	jrst rdat

;here if lower case - see if we raise it
rdatlc:	skipn @[datsec,,.raise]	;*raise?
	jrst rdat		;no - leave it
	subi o1,40		;raise is on, convert
	;jrst rdat

;;TY%ATM
;;TY%STR
;Here if nothing special - it is an atom
  ;no spec char - first char of atom - set up byte pointer
  ;free + 1 is the string descriptor - can't do it until the end
  ;free + 2 and following is the string, asciz
  ;byte pointer will be -1(p)
  ;o1 is the current char
rdat:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	push p,w3
	push p,w4		;byte ptr is now -1(p)
	setzm (w4)		;make sure low order bit is clear
	idpb o1,-1(p)		;put down 1st char
  ;other char's of atom
rdatlp:	call tyi
	hrrz w2,rdtab(o1)	;see what it is
	xct rdattb(w2)		;stop loop when char that can't be in atom

;;READTABLE
rdattb:	jrst rdatnc	;letters
	jrst rdatnl	;lower case
	jrst rdatsp	;(
	jrst rdatsp	;)
	jrst rdatsp	;[
	jrst rdatsp	;]
	jrst rdatsp	;.
	jrst rdatsp	;,
	jrst rdatsp	;'
	jrst rdsl2	;/
	jrst rdatsp	;"
	jrst rdatsp	;space
	jrst rdatsp	;all end of lines
	jrst rdatnc	;digits
	jrst rdatnc	;+ -
	jrst rdatsp	;esc

;here after initial slash - use next char
rdsl2:	call tyi
	hrrz w2,rdtab(o1)
	jrst rdatnc

;here if lower case - see if we raise it
rdatnl:	skipn @[datsec,,.raise]	;if raise
	jrst rdatnc		;no - leave it
	subi o1,40		;raise is on, and terminal, convert
	;jrst rdatnc

  ;go on to next char in atom
rdatnc:	idpb o1,-1(p)		;put the char in the string
	move w2,(p)		;clear next word
	setzm 1(w2)		;to make sure low order bit is off
	jrst rdatlp

;here when we come to char that can't be in an atom - stop
;this is the main place where we construct atoms
;at%val==0
;at%pro==1
;at%pna==2
;at%fun==3
;at%fev==4

;note that the loop clears the next word ahead of us.  thus we
;have an asciz string without explicitly needing to put a null
;there.

rdatsp:	call untyi		;put back break char
	idpb nil,-1(p)		;make ASCIZ
	skipe @[datsec,,.dointern] ;if interning on
	jrst iinter		;special INTERN will creat atom if needed
	xmovei w2,1(free)	;start of string
	move w3,(p)		;end of string
	move free,w3		;update free list
	sub w3,w2		;w3 is length in words
	tlo w3,(object(ty%spc,0)) ;special GC code
	movem w3,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
	adjsp p,-2		;get rid of byte ptr on stack
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	jrst rdexit

;;TY%STR
;here for string - very much like atom
rdstr:	hrlzi w3,440740		;w3/4 is byte ptr
	xmovei w4,2(free)
	push p,w3
	push p,w4		;byte ptr is now -1(p)
	setzm (w4)		;clear first word of string
  ;characters in string
rdstlp:	call tyi
	hrrz w2,rdtab(o1)	;see what it is
	xct rdsttb(w2)		;stop loop when "

;;READTABLE
rdsttb:	jrst rdstnc	;letters
	jrst rdstnc	;lower case
	jrst rdstnc	;(
	jrst rdstnc	;)
	jrst rdstnc	;[
	jrst rdstnc	;]
	jrst rdstnc	;.
	jrst rdstnc	;,
	jrst rdstnc	;'
	jrst rdstnc	;/
	jrst rdsten	;"
	jrst rdstnc	;space
	jrst rdstnc	;all end of lines
	jrst rdstnc	;digits
	jrst rdstnc	;+ -
	jrst rdstnc	;esc

  ;go on to next char in string
rdstnc:	idpb o1,-1(p)		;put the char in the string
	move w2,(p)		;clear next word
	setzm 1(w2)
	jrst rdstlp

rdsten:	idpb nil,-1(p)		;make ASCIZ
	xmovei w2,1(free)	;start of string
	move w3,(p)		;end of string
	move free,w3		;update free list
	sub w3,w2		;w3 is length in words
	tlo w3,(object(ty%spc,0)) ;special GC code
	movem w3,(w2)		;as header
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	move o1,w2		;and return it
	adjsp p,-2		;get rid of byte ptr on stack
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	jrst rdexit

;here when see an open paren - paren has been read, nothing on stack
;we are going to build up a list structure. Start with (NIL), so as
;to have something to NCONC new char's onto.
;  The super-paren kludge assumes that this section of code will
;  always be exited from rdlsen or rdlsun, or by an error

rdsuls:	;read superlist.  This sets a flag so ] matches
	skipa w2,[-1]		;super list flag
rdlist:	setz w2,
	push p,w2		;save flag
	docons o2,nil,nil
	push q,o2		;save list being built on stack
	push q,(q)		;start, end
rdlslp:	call tyi
	skipl w2,rdtab(o1)	;see what we have
	xct rdlstb(w2)
	tlnn w2,(rd%dsm\rd%dim)	;read macro - is it really splice or infix?
	jrst rdls		;read macro - will be handled by READ
	jrst rdsmac		;yes - read splice macro

;;READTABLE
rdlstb:	jrst rdls	;letters
	jrst rdls	;lower case
	jrst rdls	;(
	jrst rdlsen	;)
	jrst rdls	;[
	jrst rdlsun	;]
	jrst rddot	;.
	jrst rdlslp	;,
	jrst rdls	;'
	jrst rdls	;/
	jrst rdls	;"
	jrst rdlslp	;space
	jrst rdlslp	;all end of lines
	jrst rdls	;digits
	jrst rdls	;+ -
	jrst rdlssn	;esc - supersuper close

  ;beginning of some object, call READX to process
rdls:	call readx		;o1 - new
	docons o2,o1,nil	;o2 - (new)
	pop q,o3		;o3 - old end
	dorpd o3,o2		;o2_ (...end new)
	push q,o2		;now start, new end
	jrst rdlslp

  ;splice or infix macro
rdsmac:	tlne w2,(rd%dim)	;infix?
	jrst rdimac		;yes - do it
  ;splice macro
	call mascii		;o1 - char atom
	move o2,[%splicemacro]	;look up read macro defn
	move o6,o1		;save for error msg
	call xget		;o1 - lambda form
	jumpe o1,nrdmac		;no read macro defn
	move o2,nil		;no args
	call apply		;interpret the lambda
	call coplis		;copy top level (??why??)
	pop q,o3		;o3 - old end
	dorpd o3,o1		;splice new to it
rdsmc1:	docdr o2,o3		;now go to end of list
	scons o2
	jrst rdsmc2
	move o3,o2
	jrst rdsmc1	
rdsmc2:	push q,o3		;we now have end of list
	jrst rdlslp		;now go read next item

  ;infix macro
rdimac:	call mascii		;o1 - char atom
	move o2,[%infixmacro]	;look up read macro defn
	move o6,o1		;save for error msg
	call xget		;o1 - lambda form
	jumpe o1,nrdmac		;no read macro defn
	move w4,o1		;the form for IAPPLY goes in W4
	xmovei o1,-1(q)
	tlo o1,(<object ty%ccn,0>) ;
   ;the arg to the infix macro is a TCONC pointer.  The top 2 words on
   ;Q are in the right form.  To regard them as a CONS cell, we just need
   ;to make up a type-coded pointer to them.  The type should be constant
   ;cons, since we wouldn't want the GC to try to move them.
	movei n,1		;one arg
	call iapply		;interpret the lambda
	jrst rdlslp		;now go read next item

xread:	rdenter
  ;this is a modified version of READ - it is changed to not allow
  ;close parens and friends
  ;loop for skipping leading spaces, etc
xread1:	call tyi
	skipl w2,rdtab(o1)
	xct xreadt(w2)  	;to READ if should skip, to READY if not
	jrst rdmac

;this table handles the first char encountered by READ after a dot
;;READTABLE
xreadt:	jrst rdat	;letters
	jrst rdatlc	;lower case
	jrst rdlist	;(
	jrst illdot	;)
	jrst rdsuls	;[ - super list
	jrst illdot	;]
	jrst rdindt	;.
	jrst illcom	;,
	jrst rdquot	;'
	jrst rdsl1	;/
	jrst rdstr	;"
	jrst xread1	;space
	jrst xread1	;all end of lines
	jrst rdnum	;digits
	jrst rdneg	;+ -
	jrst illdot	;esc

	
;here if we found a dot or decimal pt. - note that we are in rdlist
rddot:	call tyi		;o1 - peek at next
	hrrz w2,rdtab(o1)	;what is it?
	cain w2,rd%dig		;a digit?
	jrst rddot1		;yes - read a real number
	call untyi		;no - unread it and treat this as dot
;It is a dot. Better have closing item.
	call xread		;o1 - new
	pop q,o2		;o2 - old end
	dorpd o2,o1		;stick new onto end
	push q,o1
rddtlp:	call tyi		;now skip until find close paren
  ;blanks are OK
	skipl w2,rdtab(o1)	;see what we have
	xct rddttb(w2)		;blank space or end of list
	jrst illdot		;read macro illegal here

;here when the dot is a period in a real number.  We go to RDLS, just
;as we do to read any other "normal" token showing up in RDLSTB.  However
;we have to restore the dot to o1, since we just scanned ahead.
rddot1:	call untyi		;unread it and treat as decimal pt.
	move o1,[char "."]
	jrst rdls

;;READTABLE
rddttb:	jrst illdot	;letters
	jrst illdot	;lower case
	jrst illdot	;(
	jrst rdlsen	;)
	jrst illdot	;[
	jrst rdlsun	;]
	jrst illdot	;.
	jrst illdot	;,
	jrst illdot	;'
	jrst illdot	;/
	jrst illdot	;"
	jrst rddtlp	;space
	jrst rddtlp	;all end of lines
	jrst illdot	;digits
	jrst illdot	;+ -
	jrst rdlssn	;esc - supersuperend

;here when have read close paren. stack is START, END
  ;special entry for ] - matches [
  ;note that (p) is a flag, non-zero if this was opened by a [
  ;special entry for ESC is never matched
rdlsun:	skipe (p)		;was this opened by [?
	jrst rdlsen		;yes - everything is matched - normal
rdlssn:	call untyi		;no - save the ] for next level above	
rdlsen:	pop q,o1		;forget end
	pop q,o1		;get start
	docdr o1,o1		;our list is the cdr
	adjsp p,-1		;throw away super paren flag	
	jrst rdexit

;here for read macro
;o1 - contains char object
rdmac:	move w2,rdtab(o1)	;get flags
	tlne w2,(rd%dsm\rd%dim)	;make sure not splice or infix
	jrst [perr /Splice or infix macro must occur inside list/]
	call mascii		;o1 - char atom
	move o2,[%readmacro]	;look up read macro defn
	move o6,o1		;save for err msg
	call xget		;o1 - lambda form
	jumpe o1,nrdmac		;no read macro defn
	move o2,nil		;no args
	call apply		;interpret the lambda
	jrst rdexit		;value is returned in o1

nrdmac:	move o1,o6
	perr /Missing readmacro definition/

;here for quote
rdquot:	call read
	docons o2,o1,nil	;(thing)
	move o3,[%quote]
	docons o1,o3,o2		;(quote thing)
	jrst rdexit


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  This section is for reading numbers
;;  The first set of routines does not do any decoding, but is used in
;;    various cases where we don't know whether we have a number of not.
;;  Then there is the main number reader
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;Routines for checking whether we have a number or not.  These either
;;;;;exit to somewhere else or go somewhere into RDNUM.

;;;;;initial dot

;here for initial dot.  Either a decimal pt or illegal
rdindt:	call tyi		;peek at next
	hrrz w2,rdtab(o1)	;see what it is
	caie w2,rd%dig		;if not digit
	jrst illdot		;illegal dot
	call rdind1		;go process starting with initial dot
	jrst rdexit

;;;;;sign

;;TY%INT
;;TY%FLO
;here for a - or + initially
rdneg:	push q,o1		;save sign for later
	call tyi		;see if next is decimal pt or digit
	hrrz w2,rdtab(o1)
	caie w2,rd%per
	cain w2,rd%dig
	jrst .+2
	jrst rdnng		;not a number
	call rdnum0		;now decode the number after it
	pop q,o2		;get back the sign
	camn o2,[char "+"]	;if negative
	jrst rdexit		;not - done
	xnmtyp o1		;see what we have
	xct rdntab(w2)
	jrst rdexit
	
;;TYPES
rdntab:	call rdnrea		;flonum
	jfcl			;negative iflons (can't happen)
	call rdnifl		;pos iflons
	call rnnrat		;ratio
	jfcl			;complex
	call rdnbig		;negate bignum
	jfcl			;neg inum (can't happen)
	call rdninu		;pos inum

;the reason we don't just use MINUS is that we want to negate in place,
;rather than cons'ing a new number cell
rdninu:	hrlzi w2,(<object(ty%lpi,0)>_1)
	subm w2,o1		;negate inum
	ret

rdnifl:	lsh o1,4		;negate iflon
	movns o1		;generally simple
	lsh o1,-4
	tlon o1,(<object ty%lnf,0>)	;(generally hits the sign bit)
	 hrlzi o1,(<object ty%lpf,0>)	;(unless someone types -0.0)
	ret

rnnrat:	push q,o1		;ratio: negate numerator
	move o1,(o1)		;get it
	xnmtyp o1		;same as above
	xct rdntab(w2)
	exch o1,(q)		;put it back in the fraction
	pop q,(o1)
	ret

;negate real
rdnrea:	dmove w2,1(o1)		;negate it in place
	dmovnm w2,1(o1)
	ret

;;TY%BIG
rdnbig:	getsiz w4,o1		;negate a bignum in place
	lsh w4,-1		;how many doublewords?
	sojle w4,rdnrea		;just one--easy
	move o2,o1		;use as moving pointer
rdnb2:	jfcl 17,.+1		;only works for #'s>0 
	dmovn w2,1(o2)		;and only on a KL
	jcry [addi o2,2 ? soja w4,rdnb2] ;this loop for low-order 0's
	jrst .+3
rdnb3:	 dmovn w2,1(o2)		;the rest for words left of the 
	 dsub w2,[0 ? 1]	; rightmost 1 bit
	dmovem w2,1(o2)		;..joined in progress
	addi o2,2		;bump address
	sojge w4,rdnb3		;count doublewords
	setz o2,		;not a valid object now
	ret

rdnng:	call untyi		;undo the lookahead
	pop q,o1		;get back saved sign
	jrst rdat		;and treat it as atom

;;;;;; This is the main number reader
;;TY%INT
;;TY%FLO
;;TY%BIG

;special entry if have already seen a dot - have digit now
rdind1:	push p,q
	push p,[0]
	push p,[0]
	push p,[char "."]
	jrst rdnl1e

;here for a digit
;RDNUM0 is a common routine called here and by the negative number
;handler.  RDNUM0 and all its subroutines return by simple RET.
;RDNUM is jrst'ed to by READ, so it must exit via RDEXIT
rdnum:	call rdnum0
	jrst rdexit

;this is the real work of rdnum
rdnum0:	push p,q		;save q, since we will hack on it
	push p,[0]		;clear working areas
	push p,[0]
	push p,[nil]
	jrst rdnl1e	
;loop one - pushes the char's on the stack
  ;-3(p) - saved q
  ;-2(p) - number of digits seen
  ;-1(p) - number of digits after point
  ;(p) - point character
rdnml1:	call tyi
rdnl1e:	hrrz w2,rdtab(o1)	;see what thing this is?
	camn o1,[char "."]	;decimal pt?
	 jrst rdnmpt		;yes - process it
	cain w2,rd%dig		;digit?
	jrst rdnmdg		;yes - stack it
	came o1,[char "q"]	;octal point?
	camn o1,[char "Q"]
	jrst rdnmoc		;yes - process octal
	camn o1,[char "/"]	;slash in a ratio, don't change to %SLASH
	 jrst rdnrat		;ratio?
	jrst rdnmtr		;no - done with first loop

;digit
rdnmdg:	push q,o1		;stack next char
	aos -2(p)		;and count it
	aos -1(p)
	jrst rdnml1	
;decimal pt
rdnmpt:	setzm -1(p)		;get good count after pt
	movem o1,(p)		;save point
	jrst rdnml1
;octal pt
rdnmoc:	setzm -1(p)		;get good count after pt
	move o1,[char "Q"]	;normalize the point
	movem o1,(p)		;and save it
	hrrz w2,rdtab(o1)	;stop now, as don't allow 123Q45
	jrst rdnmt1		;exit from loop and don't recognize E
;ratio
rdnrat:	adjsp p,1		;oonch everything on the stack up one
	dmove w2,-2(p)		;to put in the new return addr
	dmovem w2,-1(p)
	dmove w2,-4(p)
	dmovem w2,-3(p)
	xmovei w2,[push q,o1	;take the number we read
		   call tyi
		   call rdnum0	;read another one
		   pop q,o2
		   exch o1,o2
		   jrst rat]	;make them into a ratio
	movem w2,-4(p)		;slimy hack
	;;fall through	 	 finish reading the first one first
;now we have the terminator - see if this is a real number
rdnmtr:	skipn (p)		;if no point seen
	setzm -1(p)		;then no digits after point
	came o1,[char "D"]	;double prec w/exp?
	 camn o1,[char "d"]
	  jrst rdoub
	came o1,[char "E"]	;if terminator is exponent
	camn o1,[char "e"]
	jrst rdexp		;then real with exp
	skipe -1(p)		;else if something after point
	jrst rdreal		;normal real
;here if known not to be a real
	came o1,[char "/"]	;don't put back a slash (ratio /, not %SLASH)
	 call untyi		;put back terminator
rdnmt1:

;-2(p) - saved q
;-1(p) - number of digits
;(p) - base
;w2,w3 - number being built
;w4 - new digit

	pop p,o2		;point
	adjsp p,-1		;throw away digits after point
	move n,@[datsec,,.IBASE] ;compute base
	posnum n		;internal value - this is the default
	jumpe o2,rdnmnb		;if no point given, that is it
	movei n,10.		;if point, we have decimal
	came o2,[char "q"]
	 camn o2,[char "Q"]	;except if Q
	  movei n,8.		;then octal
rdnmnb:	call ibaset		;set up ibase table pointer
	push p,0
	push p,0		;placeholders
;nil1 is pointer to q
;now we go up the stack decoding the number
	xmovei nil1,1(q)	;last digit
	sub nil1,-2(p)		;first digit
	move w2,-2(p)		;# of digits
	camle w2,4(n)		;comp w/ #/digits in a doubleword
	 jrst rdnmbg
	setzb w2,w3		;simple special case routine for tiny numbers
	setzb w4,o1		; less than 1000000000000000000000 or so
rdnml2:	sosge -2(p)		;any digits left to scan?
	 jrst rdnmx2		;no - done
	dmul w2,(n)		;multiply old value by base
	dmove w2,w4		;get low-order part of quadruple result
	setz w4,
	move o1,(nil1)		;get the digit
	sub o1,[char "0"]	;convert to value
	dadd w2,w4		;add in new digit
	aoja nil1,rdnml2	;go back for more digits

rdnmx2:	adjsp p,-3		;kill old p things
	pop p,q			;put back q
	move nil1,nil		;and nil1
	jrst retint		;return INUM or small BIGNUM

;;-2(p) -- (also w2) # of digits
;; -1(p) & (p) -- base
;; read a bignum bigger than 2 words.  this routine consists of
;; two double loops:  the first makes 2-wd numbers out of each
;; 21-digit segment of the number; the second puts the segments
;; together in binary form.  The "odd segment" referred to is
;; that formed from the leading (n mod 21) digits.
rdnmbg:	idiv w2,4(n)		;how many chunks to do this # in
	move o4,p		;beginning of space for it 
	move o5,w2		;# of exp-digit segments
	move o3,w3		;# of digits in odd segment
	lsh o5,1		;use 2 wds per segment
	adjsp p,6(o5)		;get space
	lsh o5,-1
	dmovem o4,-3(p)		;-3(p) is old p; -2(p) is # of segs
	setzb w2,w3		;for following loop
	dmovem w2,-1(o4)	;not actually used
rdnmb2:	sojl o3,rdnmb3		;this loop reads an exp-or-less-digit #
	dmul w2,(n)		; into a doublewd as the simple case above
	dmove w2,w4		;get low-order part of quadruple result
	setz w4,
	move o1,(nil1)		;get the digit
	sub o1,[char "0"]	;convert to value
	dadd w2,w4		;add in new digit
	aoja nil1,rdnmb2	;go back for more digits

rdnmb3:	dmovem w2,1(o4)		;successive dw's are stashed in space on p
	addi o4,2		;--the pointer thereinto
	move o3,4(n)		;counter for next segment
	setzb w2,w3		;each one is a separate number
	sojge o5,rdnmb2		;maybe do more segments
	sos o1,-3(p)		;point to the 00 in 00 seg seg seg ...
	addi o1,2		;point to first seg
	move o2,o1		;save to reinitialize o1
	move o3,-2(p)		;# of segs
rdnmb5:	dmove nil1,(o1)		;same number-forming algorithm as above--
	dmul nil1,2(n)		;base^exp
	dadd w3,2(o1)		;--but now the digits are two wds long
	tlze w3,400000		;propagate carry
	 dadd nil1,[0 ? 1]	;note how we cleverly use the space
	dmovem nil1,(o1)	;occupied by the segments to put the
	dmovem w3,2(o1)		;number as it grows
	subi o1,2		;loop back to do next digit of multiplication
	came o1,-3(p)
	 jrst rdnmb5
	addi o2,2		;loop back to do multiplication for next
	move o1,o2		; digit of number
	sojg o3,rdnmb5
	aos w4,-2(p)		;# of segments again, +1 to count odd one
	lsh w4,1		;two wds apiece
	tlo o2,(<object ty%adr,0>)	;so gc doesn't kick
	setzb o3,o4		;contained non-objects
	setz o5,		;--me too
	call bigmak		;form the object
	move o3,o1		;moving ptr-save o1 to return
rdnmb6:	dmove w2,(o2)		;move the words from the stack to the object
	dmovem w2,1(o3)		;reversing the order of doublewords
	subi o2,2
	addi o3,2
	sojg w4,rdnmb6
	setzb o3,nil1		;non-obj
	move p,-3(p)		;throw away the stack space
	adjsp p,-2
	pop p,q			;put back q
	jrst bgtrim		;return INUM or small BIGNUM

;rdint - read integer, results in w3
rdint:	call tyi
	hrrz w2,rdtab(o1)
	call rdsgn		;get a sign - returns on Q
	call rdpint		;get a pos. integer - returns in w3
	pop q,o2		;sign - nil if pos, non-nil if neg
	skipe o2
	movn w3,w3
	ret

;rdsgn - get nil if + or no sign, non-nil if -
rdsgn:	push q,[nil]		;assume no sign
	caie w2,rd%sgn
	ret			;right - none
	move o2,[%t]
	came o1,[char "+"]	;there is one, if negative
	movem o2,(q)		;return T
	call tyi
	hrrz w2,rdtab(o1)	;and get next char
	ret

;rdpint - get positive integer
rdpint:	push p,[0]		;number we are building
rdpinl:	caie w2,rd%dig		;more digits?
	jrst rdpinx		;no - return the 0
	move w3,(p)		;get old number
	imuli w3,10.		;shift by one digit
	move w2,o1		;and add in new one
	sub w2,[char "0"]
	add w3,w2
	movem w3,(p)		;put it back in stack
	call tyi
	hrrz w2,rdtab(o1)	;and advance a char
	jrst rdpinl

rdpinx:	pop p,w3		;return in w3
	ret

;;TY%FLO
;;TY%IFL
;real number readers:

;here if we saw a D exponent
rdoub:	setom (p)		;indicate double precision
	call rdint		;read exp, returns in w3
	movn w3,w3		;subtract from digits after decimal
	addm w3,-1(p)
	jrst rdrl1

;here if we saw E - go scan an exponent
rdexp:	call rdint		;read exp, returns in w3
	movn w3,w3		;subtract from digits after decimal
	addm w3,-1(p)

  ;-5(p) - saved q
  ;-4(p) - number of digits seen
  ;-3(p) - number of digits after point
  ;-2(p) - is it double prec
  ;-1(p),(p) - next char

rdreal:	setzm (p)		;clear double precision flag
rdrl1:	call untyi		;get rid of break char
	setzb w2,w3		;build up number in w2,w3
	push p,[0]		;clear new digit
	push p,[0]
	xmovei w4,1(q)		;last digit
	sub w4,-4(p)		;first digit
	jov .+1			;clear overflow
rdrl2:	sosge -4(p)		;any digits left to scan?
	jrst rdrx1		;no - done
	move nil1,(w4)		;get the digit
	sub nil1,[char "0"]	;convert to value
	fltr nil1,nil1		;float it
	movem nil1,-1(p)	;and put it in right place
	dfmp w2,[10.0 ? 0]	;multiply old value by base
	dfad w2,-1(p)		;and add in new digit
	aoja w4,rdrl2		;go back for more digits

rdrup:	dfmp w2,[10.0
		 0]
	aos -3(p)
	jrst rdrx2

rdrdwn:	dfdv w2,[10.0
		 0]
	sos -3(p)
	jrst rdrx2

;we now have number in w2,w3
;while the number is still in positive integer format,
; test it for fitting in immediate precision
rdrx1:	caml w2,[227777,,777760] ;bigger than biggest iflon?
	 setom -2(p)		;yes, use double precision
rdrx2:	skiple -3(p)		;digits after decimal pt?
	jrst rdrdwn		;yes - scale it down
	skipge -3(p)		;scale the other way?
	jrst rdrup
	jov toobig
	move nil1,nil		;clean up NIL
	skipe -2(p)		;double precision?
	 jrst rdrxd
	adjsp p,-5		;kill off junk
	pop p,q			;put back old q
	fmpr w2,[201400,,4]	;round it
	makifl w2		;make number into an iflon
	move o1,w2		;and return it
	ret

toobig:	err /Floating exponent overflow/

rdrxd:	adjsp p,-5		;kill off junk
	pop p,q			;put back old q
	push free,[object(ty%spc,2)] ;now make real number object
	move w4,free		;make pointer be right type
	tlo w4,(object(ty%flo,0))
	move o1,w4		;and return that
	push free,w2
	push free,w3
	camle free,lastl	;see if need GC
	 call sgc
	ret			;that's all

;;TY%ATM
;;TY%STR
;intern works by doing EQUAL on PNAMEs of all atoms on the OBLIST
;until one is found that matches
intern:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new atom
	satom o1
	jrst [perr /Attempt to INTERN something that is not an atom/]
	move w2,at%pna(o1)	;addr of pname
	move w2,1(w2)		;first word of pname
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o2,@[<w3_30.>\<datsec,,obarr>] ;oblist
intrlp:
  ;o2 is oblist tail
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
	jumpe o2,intrno		;nothing in tail - add new entry to oblist
  ;first find the pname of the new atom into w2
	move w2,at%pna(o1)	;addr of pname
  ;now find the pname of the oblist atom into w3
	docar o3,o2		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst intrnx		;different, ignore
	aoj w2,
	aoj w3,
intrcp:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst intrnx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst intrys		;yes - we found it!
	aoja w3,intrcp		;no - loop
  ;didn't find one, try next thing on oblist
intrnx:	docdr o2,o2
	jrst intrlp

;yes - found it on oblist
;in this case we just want to return the atom on the oblist
;note that NIL is special
intrys:	docar o1,o2		;the atom we found
	adjsp p,-1		;kill hash
	camn o1,[%nil]		;if NIL, use 0
	movei o1,nil	
	ret

;no - ran out of oblist - add to it -- atom, pname
intrno:	pop p,w3		;hash
	move o2,@[<w3_30.>\<datsec,,obarr>] ;old bucket
	docons o3,o1,o2		;make new cell on oblist
	movem o3,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	ret			;returns new atom

;IINTER is an entry to XINTER for READ.  It is JRST'ed to from RDATSP,
;and thus is in that stack context.  Thus it must kill some temps on the
;stack and return via RDEXIT.
iinter:	pop p,w4		;get 2nd word of byte ptr
	adjsp p,-1		;kill first word
	call xinter
	jrst rdexit	

;;TY%ATM
;;TY%STR
;XINTER is a special version of INTERN designed to be called from READ.
;It finds the new string at the start of free space.  If the atom is
;already there, no extra free space is used.  If it has to create a
;new atom, the atom structure must be made here.
;	move w4,second word of byte pointer on which IDPB 0 was just done
;	call xinter
;	  returns atom in o1
;assumes string was started at FREE, and FREE was not updated.

xinter:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new pname
	xmovei w2,1(free)	;start of string
	push p,w4		;save new FREE for later
	sub w4,w2		;w3 is length in words
	tlo w4,(object(ty%spc,0)) ;special GC code
	movem w4,(w2)		;as header
	move w2,2(free)		;start of string
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o2,@[<w3_30.>\<datsec,,obarr>] ;oblist
iintrl:
  ;o2 is oblist tail
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
	jumpe o2,iintrn		;nothing in tail - add new entry to oblist
  ;first find the pname of the new atom into w2
	xmovei w2,1(free)	;addr of length code
  ;now find the pname of the oblist atom into w3
	docar o3,o2		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst iintrx		;different, ignore
	aoj w2,
	aoj w3,
iintrc:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst iintrx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst iintry		;yes - we found it!
	aoja w3,iintrc		;no - loop
  ;didn't find one, try next thing on oblist
iintrx:	docdr o2,o2
	jrst iintrl

;yes - found it on oblist
;in this case we just want to return the atom on the oblist
;note that NIL is special
iintry:	docar o1,o2		;the atom we found
	adjsp p,-2		;kill hash and saved free on stack
	camn o1,[%nil]		;if NIL, use 0
	movei o1,nil	
	ret

;no - ran out of oblist - add to it -- atom, pname
iintrn:	
  ;first create the new atom, put it in O1
	xmovei w2,1(free)	;start of string (actually length code)
	pop p,w3		;hash
	pop p,free		;update free list
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
  ;Now do the actual INTERN
	move o2,@[<w3_30.>\<datsec,,obarr>] ;old bucket
	docons o3,o1,o2		;make new cell on oblist
	movem o3,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret

remob:	push q,o1		;save list of things to remob
remobl:	move o2,(q)		;get list back
	jumpe o2,remobx		;done if nothing more
	docar o1,o2		;we want to do CAR
	docdr o2,o2		;cdr for next time
	movem o2,(q)
	call remob1		;kill this one
	jrst remobl
remobx:	adjsp q,-1
	ret

;;TY%ATM
;;TY%STR
;remob1 works by doing EQUAL on PNAMEs of all atoms on the OBLIST
;until one is found that matches
remob1:	
  ;now for each item on the oblist bucket we get its name and compare with
  ;the new atom
	satom o1
	jrst [perr /Attempt to REMOB something that is not an atom/]
	move w2,at%pna(o1)	;addr of pname
	move w2,1(w2)		;first word of pname
	lsh w2,-1		;do hash
	idivi w2,nbuck		;remained is hash - w3
	lsh w3,1		;multiply by two since it is a list
	push p,w3		;save hash for exit
	move o5,@[<w3_30.>\<datsec,,obarr>] ;bucket
	move o2,[object(ty%adr,o4)] ;start with this psuedo-atom
remolp:
  ;o2 is bucket tail, always one back from current to allow rplacd
  ;w2 is start of pname in new atom
  ;w3 is start of pname in oblist atom
  ;w4 is working ac
  ;O4, O5 are a pseudo-atom whose CDR (O5) points to start of list
  ;first find the pname of the new atom into w2
	move w2,at%pna(o1)	;addr of pname
  ;now find the pname of the oblist atom into w3
	docdr o3,o2		;get to current tail
	jumpe o3,remoex		;nothing in tail - done
	docar o3,o3		;car of oblist tail
	move w3,at%pna(o3)	;addr of pname
  ;now compare them.  Note that the first time through this loop
  ;  we are comparing the GC special code, which is the length.
  ;  So we only proceed with the data if the length is the same.
  ;  This means we only have to check one of them for end, since
  ;  they end at the same place.  Also, they are ASCIZ, with
  ;  all low-order bytes cleared.  So we can check bits 376 for
  ;  zero to see if we are at the end.
	move w4,(w2)		;compare lengths in words
	came w4,(w3)
	jrst remonx		;different, ignore
	aoj w2,
	aoj w3,
remocp:	move w4,(w2)		;compare data
	came w4,(w3)
	jrst remonx		;different, ignore
	aoj w2,
	trnn w4,376		;end of string?
	jrst remoys		;yes - we found it!
	aoja w3,remocp		;no - loop
  ;didn't find one, try next thing on oblist
remonx:	docdr o2,o2
	jrst remolp

;yes - found it on oblist
;in this case we remove it.  The atom is question is (CADR O2)
;note that NIL is special
remoys:	docdr o1,o2		;get next after one to remove
	docdr o1,o1
	camn o2,[object ty%adr,o4] ;at start of list?
	jrst remost		;yes - special
	dorpd o2,o1
remoex:	move o1,nil		;return nil
	adjsp p,-1		;remove saved index
	ret

;at start of bucket
remost:	pop p,w3		;hash
	movem o1,@[<w3_30.>\<datsec,,obarr>] ;update bucket
	move o1,nil
	ret			;returns new atom

;;ty%atm
;;ty%str
gensym:	
;first update GNUM to be the next ascii number
	move w2,[.bp 376,gnum]
	movei w3,4
	movei
gensy1:	ldb w4,w2		;get last digit
	aos w4			;add one
	caile w4,"9"		;if in range
	jrst gensy3		;not
	dpb w4,w2		;yes - just put it back
;now we have an up to date name in GNUM
gensy2:	push free,[object ty%spc,2] ;string of two words
	move w2,free		;save pointer to this
	push free,gnum		;first is GNUM
	push free,[0]		;zero word for ASCIZ
	tlo w2,(object(ty%str,0)) ;make w2 string ptr from addr of start 
	push free,[%.unbound]	;at%val - unbound
	move o1,free		;save addr of first for atom ptr
	push free,nil		;at%pro - no prop's yet
	push free,w2		;at%pna - new pname
	push free,nil		;at%fun - no ftn defn
	push free,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	push free,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	tlz o1,770000		;make it atom
ifn ty%atm,[printx this code depends upon ty%atm being 0]
	camle free,lastl	;see if went beyond end of space
	 call sgc		;yes
	ret			;return it uninterned

;here when a digit overflows
gensy3:	movei w4,"0"		;use 0 and carry
	dpb w4,w2
	add w2,[70000,,0]	;to prev digit
	sojg w3,gensy1
	jrst gensy2		;ran out of digits - wraparound

;;ty%atm
;;ty%str
;CSYM - set up GNUM
csym:	docar o1,o1		;this is fsubr - get the arg
	push q,o1
	call getstr
	move w2,1(o1)		;get first word
	movem w2,gnum		;use that
	pop q,o1
	ret

illdot:	err /Dot context error/

illcom:	err /Comma must separate elements of a list/
	
;main read-eval-print
;This page contains all code that depends upon the fact that
;this is a shallow binding implementation.  

topst:	movem p,savep'
	movem q,saveq'
	movem sp,savesp'
	move o1,[object ty%ccn,<datsec,,initfi>]
	call xinput
	move o2,nil		;no closing
	call inc
;here to restart top level command processing
toplev:	move w2,inprch		;reinit prompt
	movem w2,prmpch
	move o2,nil		;no args
	skipn o2,@[datsec,,initf] ;any init fun?
	jrst toplop		;no - do ours
	docons o1,o2,nil	;yes - make up (fn)
	call eval		;and eval it
	;if it returns, fall into normal loop
toplop:	move o1,@[datsec,,.curin] ;do talk if input is from terminal
	camn o1,@[datsec,,priin]
	call talk
	call chstlm		;reset stack limits if needed
	move o1,[inum 1]
	call lines
	call read
	call eval
	push q,o1
	call lines0
	pop q,o1
	movei n,1
	move w4,[%%PRINFNTOP]
	call iapply
	jrst toplop

;INITFN - to set initf used above
initfn:	exch o1,@[datsec,,initf]
	ret

;;TY%ATM
define getval(dest,atom)
	move dest,at%val(atom)
	termin


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  apply
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;The basic function is EVAL.  McCarthy defines EVAL in terms of APPLY.
;The problem with that definition is that it requires one to CONS up a
;list of args to pass to APPLY, and we don't want to do those CONS's.
;So we do not have EVAL call APPLY. Actually it turns out that our APPLY
;uses the main low-level routine from Slow EVAL.

;uapply is what the user gets when he types (APPLY).  It has an optional
;stack or a-list as third
uapply:	movei w4,apply		;call eval
	jrst incont		;in context specified by user

;;;;;;;;;;;;;;;;here is the real APPLY


apply:	
applc1:	xtype o1
	xct appltb(w2)

;;TYPES
appltb:	jrst applds		;atom - see what it is
	jrst applex		;cons - treat as EXPR
	repeat 16, jrst udf1	; everything else


;main dispatch for atomic CAR
;if an atom, see if ftn def.  If not, eval it
applds:	jumpe o1,udf1		;NIL is special, as at%fun(nil) is AC3
	skipe o3,at%fun(o1)	;see if ftn defn
	jrst appds2		;yes - use it
appds1:	getval o3,o1		;o1 - ftn defn
	came o3,[%.UNBOUND]
	camn o3,o1		;prevent loops
	jrst udf1
	move o1,o3
	jrst applc1		;now see if the value is useful

;if find a ftn defn, dispatch on its type
appds2:	docar o4,o3		;car of defn is type code
	camn o4,[%expr]
	jrst apple1
	came o4,[%lsubr]	;lsubr and subr are bound the same
	camn o4,[%subr]
	jrst apple2		;bind as EXPR
	camn o4,[%fexpr]
	jrst applf1
	camn o4,[%fsubr]
	jrst applf2		;bind as FEXPR
	camn o4,[%macro]
	jrst applm1		;bind as MACRO
	camn o4,[%msubr]
	jrst applm2
	jrst appds1		;not a function type, ignore it

;;;;the following code is modelled after EVSEXP, EVSFEX, and EVSMAC.
;;;;They set up the stack the same way.  These 3 routines are called
;;;;  from APPLTB directly [only applex] - has a form in it, in O1
;;;;  from APPDS2 - has (EXPR LAMBDA, etc., which requires CDR to
;;;;     get to the form.  This is in O3
;;;;O2 is the arg list
;;;;EVFORM wants the function to be in O3

;EXPR
;  apple1 - form in O3, needs CDR
;  apple2 - form in O3, doesn't need CDR
;  applex - form in O1
apple2:	skipa o1,o3
apple1:	docdr o1,o3
applex:	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[0]		;count of args will go here
	jumpe o2,appexx		;no more args
appexl:	pushcar q,o2		;push the first
	aos (p)
	docdr o2,o2		;go to next
	jumpn o2,appexl
appexx:	push q,nil		;dummy extra arg saying not FEXPR
	move o3,o1		;get CAR (functional form)
	jrst evform		;now handle the form

;FEXPR
;  APPLF1 - form in O3, needs CDR
;  APPLF2 - form in O3, doesn't need CDR
applf2:	skipa
applf1:	docdr o3,o3
	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[2]		;we have either 1 or 2 as he prefers
	push q,o2		;one arg - cdr form
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	push q,w2		;second arg - non-NIL, so this flags as FEXPR
	jrst evform		;now handle the form

;MACRO
;  APPLM1 - form in O3, needs CDR
;  APPLM2 - form in O3, doesn't need CDR
;The problem is that we have to call EVFORM and then get control back.
;To do so, we have to hack the stack to produce:
;  saved q
;  saved sp
;  addr here where we want control back
;  ret addr
applm2:	skipa
applm1:	docdr o3,o3
	docons o4,o1,o2		;make up pseudo-form
	push q,o4		;one extra arg for finmac
	push p,[codsec,,evsmrt]
	push p,sp
	push p,q
	push q,nil		;dummy
	push p,[1]
	push q,o4		;one arg - whole form
	push q,nil		;dummy extra arg saying not FEXPR
	jrst evform		;now handle the form and return here

wnoa:	err /Too many arguments supplied/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  eval
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;ueval is what the user gets when he types (EVAL).  It has an optional
;stack or a-list as second arg
ueval:	movei w4,eval		;call eval
	move o3,o2		;incont wants context in o3
	jrst incont		;in context specified by user

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; EVAL comes in two versions.  Fast eval is based on a dispatch
;; directly to specialized code.  Some code is specialized for
;; the particular function, others for specific types, e.g. EXPR.
;;   Slow EVAL uses the full algorithm.  It is used for other cases,
;; and can handle such things as LABEL, FUNARG, etc.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast EVAL.  This stage is optimized by use of the AT%FEV
;; word.  This contains the address of an evaluator for use if
;; that function is called.  This saves us decoding the kind of
;; thing the function is, and lets us go straight to specialized code
;; to invoke it.  Functions that are non-straightforward have
;; evaluators that point to slow EVAL.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

eval:	xtype o1
	xct evaltb(w2)		;handle depending upon type

;;TYPES
evaltb:	jrst evalat		;atom
	jrst evalcn		;cons
	repeat 16, ret		;everything else

;EVALAT - here for an atom
evalat:	getval o2,o1
	camn o2,[%.UNBOUND]
	jrst evalub
	move o1,o2
	ret

;unbound error - here we establish an EVAL BLIP, as at EVALCN, so the
;debugger can process the error.  See the section below on stack hacking
;for what this means
evalub:	push p,sp
	push p,q		;save q for RETFROM
	push sp,nil		;eval blip
	push sp,o1		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	perr /Unbound atom/

;here if form is an expression
evalcn:	
;For the break package, we put some information on the SP.  See the
;section below on stack hacking for what this means.
;Note that all of the special-purpose evaluators end with
;adjsp p,-2 ? adjsp sp,-4.  If you change the code below, you must
;change these.  Try searching for ADJSP SP,-4.
	push p,sp		;save old sp for unbind
	push p,q		;save q for RETFROM
	push sp,nil
	push sp,o1		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
;now we xct a location.  this is used to do single stepping, or anything
;else requiring a hook into the EVAL process
	xct evhook
;now see what we have
	docar o3,o1		;o3 - car of form


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the heart of fast EVAL.  There are actually 3 main cases:
;;    - atom has a function definition that can be done by the fast
;;	  routines.  Then there is a direct dispatch to the routine.
;;    - atom has a function definition that cannot be done by the
;;        fast routines, probably because it has LABEL or FUNARG.
;;	  Then slow eval is called for the function type.  This is
;;	  still done by direct dispatch.
;;    - atom has no function definition, but does have a variable.
;;	  It is evaluated and control returns here to EVAL1 to check again.
;;    - not at atom.  This is done by the slow eval routine for EXPR.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

eval1:	xtype o3
	xct eval1t(w2)

.scalar evhook

;;TYPES
eval1t:	jrst evdisp		;atom - dispatch on evaluator
	jrst evsexp		;cons - must use slow expr eval
	repeat 16, jrst udf	;everything else

udf:	move o1,o3
udf1:	perr /Undefined function/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Here is the main dispatch.  One of the following will happen:
;;    - Directly to routine in fast eval
;;    - To evaluator for its function type in slow eval
;;    - undefined, in which case we can still try for a variable value.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;main dispatch for atomic CAR
evdisp:	jumpe o3,udf		;NIL is special, as at%fun(nil) is AC3
	move w2,at%fev(o3)	;get evaluator for that atom
	jrst (w2)		;go there

;here if undefined function, try value
evund:	getval o2,o3		;o3 - ftn defn of car(form)
	came o2,[%.UNBOUND]
	camn o2,o3		;prevent loops
	jrst udf
	move o3,o2
	jrst eval1		;now see if the value is useful
	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Experts for fast EVAL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;A form starting with an atom is by far the most common case.  Thus we
;have optimized for it.  Each atom has an "evaluator".  This is 
;basically the place to go when we see a form beginning with that
;atom.  Atoms are initialized having evaluators that point to evund,
;for undefined functions.  Others may point to general evaluators such
;as that for EXPR, SUBR, etc.  But common special cases are handled
; directly:
;  SUBR's with 0, 1, and 2 args have special tailored evaluators
;  the most common functions and forms, CAR, CDR, CONS, COND,...
;    all have evaluators going directly to code associated with the
;    functions.  This is a bit hairy, but it gains about a factor of
;    2 in execution speed.  Note that these evaluators all end as
;    follows:
;       adjsp p,-2	;pops off the saved sp and q
;	adjsp sp,-4	;pops off the eval blip
;The adjsp sp,-4 is done instead of JRST UNBIND.  this works if no one
;has bound anything during the process of EVAL.  This is surely OK for
;SUBR's and FSUBR's, since EVAL doesn't do any binding for them.  However
;it may not work if FUNARG or LABEL have been used, which do in fact bind.
;However these forms use stage two.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast EXPR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;we have specialists for exprs with 0, 1, and 2 args
evexp0:	move o3,at%fun(o3)	;(expr lambda nil
	docdr o3,o3		;(lambda nil
	docdr o1,o1		;make sure he didn't give any args
	jumpn o1,wnoa
	docdr o3,o3		;(nil exprs...
	pushcdr q,o3		;(exprs
	jrst evexl

evexp1:	move o3,at%fun(o3)	;(expr lambda (x)
	docdr o3,o3		;(lambda (x)
	docdr o3,o3		;((x) exprs...
	pushcdr q,o3		;(exprs ...
	docar o3,o3		;(x)
	pushcar q,o3		;x
	docdr o2,o1		;arg list
	docar o1,o2		;first arg
	docdr o2,o2		;make sure he didn't give too many args
	jumpn o2,wnoa
	call eval
	pop q,o2		;formal
	fasbind o2,o1
	jrst evexl

evexp2:	move o2,at%fun(o3)	;(expr lambda (x y)
	docdr o2,o2		;(lambda (x y)
	docdr o2,o2		;((x y) exprs...
	pushcdr q,o2		;(exprs ...
	docar o2,o2		;o2 - (x y)
	docdr o3,o2		;(y)
	pushcar q,o3		;STACK - y
	pushcar q,o2		;STACK - x
	docdr o3,o1		;arg list
	docar o1,o3		;o1 - first arg
	docdr o3,o3		;cdr arg list
	pushcar q,o3		;STACK - second arg
	docdr o3,o3		;if more args, error
	jumpn o3,wnoa
	call eval		;eval first arg
	exch o1,(q)		;get second arg, save first
	call eval
	move o2,-2(q)		;second formal
	fasbind o2,o1		;bind second
	dmove o1,-1(q)		;get first arg and value
	fasbind o1,o2
	adjsp q,-3
	jrst evexl
	

;here to eval expr.  o3 has ftn lambda form.  This is the optimized entry
evexpr:
	move o3,at%fun(o3)
	docdr o4,o3		;skip EXPR
	docdr o4,o4
	docar o2,o4		;o2 - formals
evexpp:	docdr o1,o1		;o1 - actuals
	pushcdr q,o4		;save tail, pointing to things to do
	call evbind		;eval and bind args -- expr
	setz o1,		;nil if no expr found
evexl:	move o2,(q)		;get back expr's
	jumpe o2,evexx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evexl		;now try for next
evexx:	adjsp q,-1		;forget the expr
	adjsp p,-1		;forget saved q
	jrst unbind

;;;;;;EVBIND - routine used to evaluate and bind args in fast EXPR

;evbind(actuals,formals)
;o1 - actuals, o2 - formals
;return with new bindings added, evaluation having been done
evbind:	jumpe o2,evbin1		;exit if no more formals
	push q,o2		;save formals
	push q,o1		;save actuals
	docar o1,o1		;first actual
	call eval		;eval it
	exch o1,(q)		;get back actual list, save result
	move o2,-1(q)		;get back formal list
	docar o3,o2		;get this formal
	movem o3,-1(q)		;and put it in stack
	docdr o1,o1		;now cdr both lists
	docdr o2,o2
	call evbind		;handle cdr's first
	pop q,o1		;get back this actual
	pop q,o2		;get back this formal
	fasbind o2,o1		;bind formal to actual
	ret

;here when nothing to do
evbin1:	jumpn o1,wnoa		;if there are actuals, error
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast LEXPR
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;here to eval lexpr.  o3 has ftn lambda form.  This is the optimized entry
evlexp:	move o3,at%fun(o3)
	docdr o3,o3		;skip the EXPR
	docdr o4,o3
	pushcar q,o4		;formal - this is an atom
	docdr o1,o1		;o1 - actuals
	pushcdr q,o4		;tail of things to do
	push p,[0]		;place to count args
	call evonst		;eval and put on stack
;we bind these on the stack.  But since there are a variable number,
;we need something to tell us where they start.  The pseudo-variable
;LXVARS will do that.
	push sp,[%lxvars]	;save old value
	push sp,@[datsec,,.lxvars]
	move w2,[object ty%adr,0] ;and put ADR object for Q into it
	ior w2,q
	sub w2,(p)		;we want Q at the start of the args
	movem w2,@[datsec,,.lxvars]
;we now have the expression list and formal on the stack
;below the args.  Fortunately, W2 is now pointing to that place.
	pop w2,o2		;list of things to do
	pop w2,o1		;formal
	move w2,(p)		;count of args
	maknum w2		;legit lisp number
	bind o1,w2		;find the formal to the count
	push sp,[%lxnum]	;also save number for validity checking
	push sp,@[datsec,,.lxnum]
	movem w2,@[datsec,,.lxnum]
	push q,o2		;and push the list of things
	setz o1,		;nil if no expr found
evlxl:	move o2,(q)		;get back expr's
	jumpe o2,evlxx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evlxl		;now try for next
evlxx:	move w2,@[datsec,,.lxvars] ;get back the q
	tlz w2,770000		;turn into pure address
	move q,w2		;and restore it
	adjsp q,-2		;forget the two saved things
	adjsp p,-2		;forget saved q
	jrst unbind

;;;;;;EVONST - routine used by Fast Lexpr (and many others)


;evonst(actuals)
;o1 - actuals
;return with new bindings on stack
evonst:	jumpe o1,evonsx		;stop when no more args
	push q,o1		;save actuals
	docar o1,o1		;first actual
	call eval		;eval it
	aos -1(p)		;count args
	exch o1,(q)		;get back actual list, save result
	docdr o1,o1		;now cdr arg list
	jumpn o1,evonst		;and try again if more
evonsx:	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast MACRO's.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;here to eval macro - o3 (MACRO lambda ...
evmacr:	move o3,at%fun(o3)
	docdr o3,o3		;get the expr
	docdr o3,o3
	docar o2,o3		;o2 - formal list
	jumpe o2,wnoa		;make sure there is at least one formal
	docar o4,o2		;o4 - first formal
	fasbind o4,o1		;bind to form
	push q,o1		;save form
	docdr o3,o3		;o3 - tail pointing to first expr to do
	push q,o3		;save tail
	setz o1,		;nil if no expr found
evmal:	move o2,(q)		;get back expr's
	jumpe o2,evmax		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst evmal		;now try for next
evmax:	adjsp q,-1		;forget the expr
;This is the entry point from MSUBR code
domacr:	adjsp p,-1		;forget saved Q
	pop p,w2		;now do special unbind that returns
	call unbin1
;now we make the MACROEXPANSION thing
;we have to take the old cell that was his form and smash it, since
;we don't know who points to it.
finmac:	skipn @[datsec,,.mexp]	;expand macros?
	jrst nomexp		;no
	pop q,o2		;o2 - original form
	docdr o3,o2		;o3 - old cdr
	docar o4,o2		;o4 - old car
	docons o5,o4,o3		;o5 - copy of that cell
	docons o4,o5,nil	;o4 - (-old cell-)
	docons o3,o1,o4		;o3 - (exp old-cell)
	move o4,[%mexp]
	dorpa o2,o4
	dorpd o2,o3		;o1 - (mexpan  exp old-cell)
	move o1,o2
	jrst eval		;now eval the result

nomexp:	adjsp q,-1		;prune stack
	jrst eval		;now eval the result

;here to do (mexpansion)
mexp:	docar o1,o1		;get expansion
	jrst eval		;eval it


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast FEXPR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval fexpr. - o3 (FEXPR lambda...
evfexp:	move o3,at%fun(o3)
	docdr o3,o3		;get the expr
	docdr o3,o3
	docar o2,o3		;o2 - formal list
	jumpe o2,wnoa		;make sure there is at least one formal
	docar o4,o2		;o4 - first formal
	docdr o1,o1		;o1 - cdr form
	fasbind o4,o1		;bind to cdr form
	docdr o2,o2		;another formal?
	jumpe o2,evfe1		;no- that's it
  ;here if we have a second formal - it gets a SPDL pointer
	move w2,sp		;top of stack
	sub w2,[basesp+1]	;convert to offset from start
    ;note - the canonical code for above is basesp-1.  However we have
    ;just added a binding which we don't want counted.  So by using
    ;a base 2 too big we get the right result.
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	docar o2,o2		;o2 - second formal
	bind o2,w2		;bind it to spdl pointer
evfe1:	pushcdr q,o3		;save tail of form - list of things to do
	setz o1,		;return nil if nothing to do
	jrst evexl

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Fast SUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;special evaluators for common cases.  Note that these exit by doing
;adjsp P instead of popping.  This is because no bindings other than
;the eval blip can possibly have been done, so we just get rid of
;the blip. We know that because evaluators are always called directly
;from the beginning of EVAL.

evsub2:	move o2,at%fun(o3)
	docdr o2,o2
	pushcar p,o2		;stack the addr to go to
	docdr o2,o1		;arglist
	docar o1,o2		;o1 - first arg
	docdr o2,o2		;cdr arg list
	pushcar q,o2		;STACK - second arg
	docdr o2,o2		;make sure no extra args
	jumpn o2,wnoa
	call eval		;do first arg
	exch o1,(q)
	call eval		;do second arg
	move o2,o1		;move to second place
	pop q,o1		;and this to first
	pop p,w2
	call (w2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

evsub1:	move o2,at%fun(o3)
	docdr o2,o2
	pushcar p,o2		;stack the addr to go to
	docdr o2,o1		;one arg only
	docar o1,o2
	docdr o2,o2		;make sure no extra args
	jumpn o2,wnoa
	call eval
	pop p,w2
	call (w2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

evsub0:	move o2,at%fun(o3)
	docdr o1,o1		;make sure no args
	jumpn o1,wnoa
	docdr o2,o2
	docar o2,o2		;the addr is (cadr form)
	call (o2)
	adjsp p,-2
	adjsp sp,-4
	ret			;for a later patch

;;;;;;;;;;;FAST SUBR - general form

;here to eval subr.  Have  o3 - (SUBR addr, #args)
evsubr:	move o3,at%fun(o3)
	docdr o1,o1		;actuals
	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	docar w2,o3		;#args
	posnum w2
  ;o1 - actuals, w2 - # args, w3 - addr
	call evstac		;value
	adjsp p,-1		;forget saved Q
	jrst unbind

;;;;;;;;;;EVSTACK - subroutine for stage 1 subrs

;evstack(actuals, addr)
;o1 - actuals, w2 - # args, w3 - addr
evstac:	jumpe w2,(w3)		;if no args, just call the thing
	push p,w3		;save the routine to call
	push p,w2		;need two copies of # args
	push p,w2
;evaluate args and put them on stack
evsta1:	push q,o1		;save list of args for next arg
	docar o1,o1		;o1 - current arg
	call eval		;eval it
	exch o1,(q)		;put value on stack and get back actual list
	docdr o1,o1		;next arg
	sosle (p)		;any more formals?
	jrst evsta1		;yes - eval next
;pop the args from the stack to the AC's
	jumpn o1,wnoa		;if any more actuals, too many
	move w2,-1(p)		;new copy of count - (p) is now zero
evsta2:	pop q,o1-1(w2)		;now pop the args to the last AC needed
	sojg w2,evsta2		;and do so for all formals
;now go do the thing
	adjsp p,-2		;get rid of saved copies of # args
	pop p,w2		;address to go to
	jrst (w2)		;do it

;;;;;;;;;;;FAST LSUBR - general form

;here to eval lsubr.  Have  o3 - (SUBR addr)
evlsub:	move o3,at%fun(o3)
	docdr o1,o1		;actuals
	docdr o3,o3
	docar w3,o3		;addr
  ;o1 - actuals, w3 - addr
	push p,[inum0] ;# args
	push p,w3		;save ftn addr temporarily
	jumpe o1,evls2		;done if no more args
evls1:	pushcdr q,o1		;save CDR actuals for later
	aos -1(p)
	docar o1,o1		;get current one
	call eval		;EVAL it
	exch o1,(q)		;save this on Q and get back CDR
	jumpn o1,evls1
evls2:	pop p,w3		;get back ftn addr
	pop p,o1		;number of args is the one argument
	call (w3)		;call the ftn
	pop p,q			;get back Q from the EVAL blip
	jrst unbind

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast MSUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval msubr.  Have o3 as (MSUBR addr), O1 as form
evmsub:	push q,o1		;save original form for MACROEXP...
	move o3,at%fun(o3)
	docdr o3,o3
	docar o4,o3		;car of fsubr prop is the ftn addr
	call (o4)
	jrst domacr		;let common code handle the rest

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Fast FSUBR's
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval fsubr.  Have o3 is (FSUBR addr 2nd-arg?)
evfsub:	move o3,at%fun(o3)
evalfs:	docdr o1,o1		;need to pass cdr form
	docdr o3,o3
	docar o4,o3		;car of fsubr prop is the ftn addr
	docdr o3,o3		;second arg?
	jumpe o3,evfs1		;no, forget the context pointer stuff
  ;put the spdl pointer in the second arg, if requested
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	move o2,w2		;put it in argument 2
  ;now call and go
evfs1:	call (o4)
	adjsp p,-1		;forget saved Q
	jrst unbind



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Slow EVAL.  First we evaluate arguments if necessary.  Then
;; we process things such as LABEL, FUNARG, and LAMBDA.  Processing
;; LAMBDA executes the funtion.  Entry is always at one of
;;   EVSEXP - slow expr
;;   EVSFEX - slow fexpr
;;   EVSMAC - slow macro
;; At entry, the form in in o1 and CAR in o3
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evsexp:	push q,o3		;save O3
	push p,[0]		;count of args will go here
	docdr o1,o1
	call evonst		;puts args on stack
	push q,nil		;flag as not FEXPR binding
	move w2,-1(p)		;get Q back
	move o3,1(w2)		;get CAR (functional form) from Q+2
	jrst evform		;now handle the form

evsfex:	push q,nil		;dummy
	push p,[2]		;we have either 1 or 2 as he prefers
	pushcdr q,o1		;one arg - cdr form
	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	push q,w2		;second arg - not NIL, so flagged as FEXPR
	jrst evform		;now handle the form

;before this, P is
;  saved q
;  saved sp
;  ret addr
;The problem is that we have to call EVFORM and then get control back.
;To do so, we have to hack the stack to produce:
;  saved q
;  saved sp
;  addr here where we want control back
;  ret addr
evsmac:	push q,o1		;one extra arg for finmac
	push p,q		;move stack up one as shown above
	move w2,[codsec,,evsmrt] ;desired continuation addr
	exch w2,-2(p)
	movem w2,-1(p)
	push q,nil		;dummy
	push p,[1]
	push q,o1		;one arg - whole form
	push q,nil		;flag not FEXPR binding
	jrst evform		;now handle the form and return here
;when we get here, we are in the right context for finmac, i.e. just
;saved exp on q and ret addr on p.
evsmrt:	jrst finmac		;execute it and make the MACROEXPANSION

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Now we are have bindings done.  We need to interpret the form, which
;; is probably a lambda
;;     o3 - the current version of the CAR of the form (i.e. the ftn)
;;     (p) - the number of args
;;   -1(p) - saved Q, for exiting
;;   -2(p) - saved sp
;;   -3(p) - ret addr
;;   on Q - the args themselves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evform:	xtype o3
	xct eval2t(w2)

;;TYPES
eval2t:	jrst evfora		;atom - eval it
	jrst evforc		;cons - try it
	repeat 16,jrst udf	;everything else --error

;atom found during slow eval.  Let't hope it has a ftn defn.
evfora:	jumpe o3,udf		;if NIL, done for
	skipe o2,at%fun(o3)	;else first try ftn defn
	jrst evfun
	getval o2,o3		;If no ftn defn, try the value instead
	camn o2,[%.UNBOUND]
	camn o2,o3		;prevent loops
	jrst udf
	move o3,o2
	jrst evform		;now see if the value is useful

evfun:	move o3,o2
	scons o3
	jrst evform
	docar o4,o3
	came o4,[%EXPR]
	camn o4,[%FEXPR]
	docdr o3,o2
	camn o4,[%MACRO]
	docdr o3,o2
	jrst evform

;cons found during slow eval.  If it is LAMBDA, LABEL, or FUNARG,
;we do them.  Else, just eval the thing.
evforc:	docar o4,o3		;should be (lambda, (subr, ...
	camn o4,[%LAMBDA]
	jrst evforl
	camn o4,[%LABEL]
	jrst evforb
	camn o4,[%FUNARG]
	jrst evforn
	camn o4,[%SUBR]
	jrst evfors		;yes - do subr
	camn o4,[%FSUBR]	;can this ever be valid?
	jrst evforf
	camn o4,[%LSUBR]
	jrst evfrls
	camn o4,[%MSUBR]	;or this?
	jrst evfrma

;not special form, just eval it again
	move o1,o3		;and eval car
	call eval
	move o3,o1
	jrst evform		;now see if we are any better off

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Now we come to the experts on different form types.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  LAMBDA, including wacky LEXPR lambda's.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval expr the hard way.  We must check for LEXPR
evforl:	docdr o3,o3
	docar o2,o3		;o2 - formals
	scons o2		;list?
	jumpn o2,ev2l		;no - lexpr (NIL is not a cons, but is a list)
;normal expr, have to bind the variables
	jumpe o2,ev2ex		;no variables, forget it
	move w2,-1(p)		;get back Q, first var is this +2
ev2el:	docar o1,o2		;get the first formal
	move o4,nil		;default if no args left
	sosl (p)		;if args left
	move o4,2(w2)		;get first arg
	bind o1,o4		;bind it
	docdr o2,o2		;next formal
	addi w2,1
	jumpn o2,ev2el
ev2ex:	skipe (q)		;check args if not fexpr
	jrst .+3		;if fexpr, extra arg is OK
	skiple (p)		;better not be any actuals left
	jrst wnoa
;now execute the code.  It is cdr(o3)
	setz o1,		;nil if no expr found
	pushcdr q,o3
ev2exl:	move o2,(q)		;get back expr's
	jumpe o2,ev2exx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst ev2exl		;now try for next
ev2exx:	move q,-1(p)		;restore saved Q
	adjsp p,-2		;forget number of args, saved Q
	jrst unbind

;;;;;;;;;;;Formal is an atom.  This is presumably LEXPR.
ev2l:	skipge (p)
	jrst [err /Atomic argument list illegal for FEXPR/]
;we bind these on the stack.  But since there are a variable number,
;we need something to tell us how many there are.  The pseudo-variable
;LXVARS will do that.
	push sp,[%lxvars]	;save old value
	push sp,@[datsec,,.lxvars]
	move w2,[object ty%adr,1] ;and put ADR object for Q into it
	add w2,-1(p)		;first var is this +2
	movem w2,@[datsec,,.lxvars]
	move w2,(p)		;count of args
	maknum w2		;legit lisp number
	bind o2,w2		;bind the formal to the count
	push sp,[%lxnum]	;also save number for validity checking
	push sp,@[datsec,,.lxnum]
	movem w2,@[datsec,,.lxnum]
	pushcdr q,o3		;and push the list of things
	setz o1,		;nil if no expr found
ev2ll:	move o2,(q)		;get back expr's
	jumpe o2,ev2lx		;if none, done
	docar o1,o2		;get first one
	docdr o2,o2		;and advance to next
	movem o2,(q)
	call eval
	jrst ev2ll		;now try for next
ev2lx:	move q,-1(p)		;restore saved Q
	adjsp p,-2		;forget number of args, saved Q
	jrst unbind


;;;;;;;;;;;;;;;;;ROUTINES USED BY ALL LEXPR's

;now the kludges for dealing with args within the lexpr
;ARG N - get that argument
lxarg:	skipn w3,@[datsec,,.lxvars] ;make sure we are in an lexpr
	jrst [perr /ARG called when not in LEXPR/]
	caml o1,[inum0] ;make sure his arg # is legit
	camle o1,@[datsec,,.lxnum] ;number of args
	jrst [perr /ARG called with invalid arg number/]
	move w2,o1		;get bare number version of his arg
	posnum w2
	add w2,w3		;index into the stack of args
	move o1,(w2)		;and get what he wanted
	ret

;SETARG N VALUE - set that argument
lxsarg:	skipn w3,@[datsec,,.lxvars] ;make sure we are in an lexpr
	jrst [perr /SETARG called when not in LEXPR/]
	caml o1,[inum0] ;make sure his arg # is legit
	camle o1,@[datsec,,.lxnum] ;number of args
	jrst [perr /SETARG called with invalid arg number/]
	move w2,o1		;get bare number version of his arg
	posnum w2
	add w2,w3		;index into the stack of args
	movem o2,(w2)		;and put down what he wanted
	move o1,o2		;and return it
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  LABEL
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval label - o3 (LABEL FOO lambda-exp)
evforb:	docdr o3,o3		;get the var to be bound
	docar o2,o3		;o2 - var
	docdr o3,o3		;and the thing to be bound to
	docar o3,o3		;o3 - exp
	bind o2,o3		;bind it
	jrst evform		;and go process what we have

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FUNARG - stage 2 only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;here to eval funarg - o3 (FUNARG fn . bcp)
evforn:	docdr o3,o3
	docdr o1,o3		;o1 - bcp
	gettyp o1		;see what it is
	cain w2,ty%lpi		;a stack pointer
	jrst evfnst		;yes, play with stack first
;here if it is an alist
evfnal:	docar o4,o1		;first pair
	docar o5,o4		;variable
	xtype o5		;make sure it is
	caie w2,ty%xat
	jrst [move o1,o5
	      perr /Attempt to use something other than an atom as a variable/]
	docdr o4,o4		;value
	bind o5,o4		;bindit
	docdr o1,o1		;next pair
	jumpn o1,evfnal		;if any
	docar o3,o3		;get the function part
	jrst evform		;done - go process it, forcing unbinding

;here if it is a stack pointer
evfnst:	pushcar q,o3		;save his ftn
	call upstak		;go to place he wants
	pop q,o3		;get back ftn
	jrst evform		;go process it, forcing unbinding

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SUBR
;;   o3 - the current version of the CAR of the form (i.e. the ftn)
;;   (p) - the number of args
;; -1(p) - saved Q, for exiting
;;  on Q - the args themselves
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

evfors:	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	docar w2,o3		;#args
	posnum w2
  ;w2 - # formals, w3 - addr
	movei w4,o1-1		;first AC to use
	jumpe w2,ev2sx		;no variables, forget it
	move nil1,-1(p)		;get back Q, first var is this +2
ev2sl:	move o6,nil		;default if no args left
	sosl (p)		;if args left
	move o6,2(nil1)		;get first arg
	push w4,o6		;put it in AC
	addi nil1,1
	sojg w2,ev2sl
ev2sx:	setz nil1,
	skipe (q)		;if bound as FEXPR, skip test
	jrst .+3
	skiple (p)		;better not be any actuals left
	jrst wnoa
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind

;;;;EVFRLS - LSUBR. This has to merge with the normal calling convention
;;;; which is
;;;;   push q,arg1
;;;;   push q,arg2
;;;;     ...
;;;;   move o1,[inum #args]
;;;;   call ftn
;;;;   adjsp q,-#args

evfrls:	docdr o3,o3
	docar w3,o3		;addr
  ;w3 - addr
	skipn (q)		;if (Q) is NIL, it is a dummy
	adjsp q,-1		;so forget it  [if non-NIL, this was bound
				; as an FEXPR, in which case there is big 
				; trouble somewhere]
	pop p,o1		;number of args
	tlo o1,(object(ty%lpi,0)) ;make it legit
	call (w3)		;call the routine
	pop p,q
	jrst unbind

;;EVFRMA - MSUBR.  An MSUBR is treated like a SUBR with one arg

evfrma:	docdr o3,o3
	docar w3,o3		;addr
  ;w3 - addr
	move w2,-1(p)		;get back Q, first var is this +2
	move o1,nil		;default if no args left
	sosl (p)		;if args left
	move o1,2(w2)		;get first arg
	skipe (q)		;if bound as FEXPR, skip test
	jrst .+3
	skiple (p)		;better not be any actuals left
	jrst wnoa
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind

;;;FSUBR - one or two args, we have to manufacture the second

evforf:	docdr o3,o3
	docar w3,o3		;addr
	docdr o3,o3
	move w4,(p)		;how many args?
  ;w3 - addr, w4 - # args
	move w2,-1(p)		;get back Q, first var is this +2
	move o1,nil		;default if no arg
	sosl (p)		;if arg left,
	move o1,2(w2)		;get arg
	jumpe o3,evff1		;forget this if they don't want 2nd arg
	move o2,nil		;default if no arg
	sosl (p)		;if arg left
	move o2,3(w2)		;get arg
evff1:	skipe (q)		;if bound as fexpr
	jrst .+3		;don't care if passed extra arg
	skiple (p)		;if args left
	jrst wnoa		;we are in trouble
	call (w3)		;call the routine
	move q,-1(p)		;get back initial Q
	adjsp p,-2		;skip saved Q, number of args
	jrst unbind


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Various version of LIST, some for compiler only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;TY%INT
;LIST - LSUBR
dolist:	movei o2,nil		;start at end of list - NIL
	move w4,q		;can't pop the real Q, so get copy to POP
dols1:	camg o1,[inum0]		;more args? - this requires o1 .ge. 0
	 jrst dols2		;no - exit
	pop w4,o3		;yes - get next
	docons o4,o3,o2		;and make new list elt
	move o2,o4
	soja o1,dols1
dols2:	move o1,o2		;value being built up is in O2
	ret

;;TY%CON
;LIST1 - 5, for compiler
list1==ncons
list5:	push free,o5
	push free,nil
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list4:	move o6,nil
	push free,o4
	push free,o6
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list3:	move o6,nil
	push free,o3
	push free,o6
	xmovei o6,-1(free)
	tloa o6,(object(ty%con,0))
list2:	move o6,nil
	push free,o2
	push free,o6
	xmovei o6,-1(free)
	tlo o6,(object(ty%con,0))
	push free,o1
	push free,o6
	xmovei o1,-1(free)
	tlo o1,(object(ty%con,0))
	caml free,lastl		;make sure there is space
	 call sgc		;special version of GC that saves AC's
	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Routines to support compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function calling from compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;These functions are special, because JSP enters them at
; starting address - 1.  CMFNST and CMFNEN mark the boundaries
; of these functions.

cmfnst=.

;Typical function call:
;	move o1,arg1
;	move o2,arg2
;	movei n,2	;two args
;	call @codadr
;
;At CODADR:
;   object ty%iadr,<1,,address>
;   atom pointer
;

;CALEXP - for functions known to have EXPR values.  Note that ALIAS
;has already validated the formals.
	hrr w3,-1(w3)		;section,,address from indirect JSP
	move o6,fa%atm-fa%adx(w3) ;the atom that was called
	jrst .+4		;now continue	
calexp:	move o6,(p)		;addr of PUSHJ + 1
	hrr o6,-1(o6)		;section,,address for the indirect PUSHJ
	move o6,fa%atm(o6)	;the atom that was called
	push p,sp		;save sp for unbind
	move o6,at%fun(o6)	;ftn defn
	docdr o6,o6		;(lambda ...
	docdr o6,o6		;((args)...
	pushcdr q,o6		;save (forms ...) for later
	docar o6,o6		;(args ...)
	move w3,[xwd -5-1,o1-1]	;first actual
	jumpe o6,calex2		;if no formals, forget this
calex1:	aobjp w3,[err /Compiled code has called EXPR with more than 5 arguments/]
	pushcar sp,o6		;save old arg
	push sp,@(o6)		;at%val save old value
	move o1,(w3)		;get actual
	movem o1,@(o6)		;at%val set new value
	docdr o6,o6
	jumpn o6,calex1
calex2:	pop q,o1
	call progn		;now eval forms as progn
	jrst unbind

;CALFEX - for functions known to have FEXPR values.  Note that ALIAS
;has already validated the formals.
	hrr w3,-1(w3)		;section,,address from indirect JSP
	move o6,fa%atm-fa%adx(w3) ;the atom that was called
	jrst .+4		;now continue	
calfex:	move o6,(p)		;addr of PUSHJ + 1
	hrr o6,-1(o6)		;section,,address for the indirect PUSHJ
	move o6,fa%atm(o6)	;the atom that was called
	push p,sp		;save sp for unbind
	move o6,at%fun(o6)	;ftn defn
	docdr o6,o6		;(lambda ...
	docdr o6,o6		;((args)...
	docar o3,o6		;(args ...)
	jumpe o3,calfe2		;if no formals, forget this
	pushcar sp,o3		;save old arg
	push sp,@(o3)		;at%val docar save old value
	movem o1,@(o3)		;at%val docar set new value
	docdr o3,o3
	jumpe o3,calfe2		;if no more formals, forget this
	move w2,sp		;top of stack
	sub w2,[basesp+1]	;convert to offset from start
    ;note - the canonical code for above is basesp-1.  However we have
    ;just added a binding which we don't want counted.  So by using
    ;a base 2 too big we get the right result.
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2		;spdl pointer now in w2
	pushcar sp,o3		;save old arg
	push sp,@(o3)		;at%val docar  save old value
	movem w2,@(o3)		;at%val docar  set new value
calfe2:	docdr o1,o6		;get list of things to do
	call progn		;now eval forms as progn
	jrst unbind

;CALLEX - LEXPR called from compiled code.
;we need to build
;  p:  # args
;	q
;	sp
;	ret addr
;  q:  nil
;	argn
;	...
;	arg2
;	arg1
;	junk

	hrr w3,-1(w3)		;section,,address from indirect JSP
	move o6,fa%atm-fa%adx(w3) ;the atom that was called
	jrst .+4		;now continue	
callex:	move o6,(p)		;addr of PUSHJ + 1
	hrr o6,-1(o6)		;section,,address for the indirect PUSHJ
	move o6,fa%atm(o6)	;the atom that was called
	move w4,o1
	tlz w4,770000		;get bare number for # args
	push p,sp
	move w2,q		;now compute Q at bottom of args
	sub w2,w4
	subi w2,1		;this is JUNK shown above
	push p,w2		;Q
	push p,w4		;# args
	push q,nil		;extra NIL at top for slow eval
	move o6,at%fun(o6)	;ftn defn
	docdr o3,o6		;(lambda...
	docdr o3,o3		;((args) ...
	docar o2,o3		;o2 - arg
	jrst ev2l		;now let slow eval do it

;CALUND is last resort, for functions we don't know anything about.
;There can't be a function definition, or we wouldn't have been
;called.  So the only hope is that it eval's to something.  All
;we handle here is that it eval's to a variable.  We call APPLY
;otherwise.

	hrr w3,-1(w3)		;section,,address from indirect JSP
	move o6,fa%atm-fa%adx(w3) ;the atom that was called
	jrst .+4		;now continue	
calund:	  move o6,(p)		;addr of PUSHJ + 1
	  hrr o6,-1(o6)		;section,,address for the indirect PUSHJ
	  move o6,fa%atm(o6)	;the atom that was called
	move w4,at%val(o6)	;does it have a value?
	came w4,o6		;error if loop (e.g. nil or unbound var)
	 satom w4		; or not atom
	  jrst calun0		; error or apply
;here if we find a ftn defn that is an atom - just call it
;w4 - the atom we are to call.  We set up w3/w4 to look like an address block
;  it is faster to do that, since we can see that the right info is in the
;  right ac's already, than to use the existing address block if there is one
	;fall in
calatm:	move w3,at%dsp(w4)	;find dispatch
	tlze w3,760000		;;TYPES - TY%IADR ==> actual address
	 move w3,(w3)		; TY%LPI ==> addr of fn address block
	pushj p,@w3		;w3/w4 now look like an address block
	ret

; IAPPLY, the internal apply routine
; put the args in the regs, the # of args in N, and the function
; (an atom with a fn defn, a lambda expression, or an atom with a
;  function for a value) in w4, and call here.
iapply:	snatom w4
	 jrst calatm
	move o6,w4
	;fall thru
;here if we can't figure out what is going on - let APPLY do it
;the compiler is supposed to have loaded N in such cases
calun0:	jumpl n,calunx		;compiler hasn't told us number of args
	push q,o6		;save atom
	movei w2,o1-1(n)	;location of last arg
	setz o6,		;build up arg list in O6
calun1:	caige w2,o1		;any args left?
	jrst calun2
;here we cons (w2) onto arg list on O6
	caml free,lastl		; make sure we have space 
	 call sgc		; garbage collect if no new cells
	push free,(w2)		; set up car
	push free,o6		; and cdr
	xmovei o6,-1(free)	; make address into cons cell
	tlo o6,(object(ty%con,0))
	soja w2,calun1	

calun2:	seto n,			;invalidate N
	move o2,o6		;arg list to o2
	pop q,o1		;thing to call to o1
	jrst apply		;and let APPLY do its thing

;This is used in case of total failure.  At the moment it is
;used when the compiler didn't set N, in which case we can't use N.
calunx:	push p,q		;save q for RETFROM
	push sp,nil		;eval blip
	push sp,o6		;put expression on SP for debugging
	push sp,[%savep]	;and saved p
	push sp,[object(ty%adr,0)]
	iorm p,(sp)
	move o1,o6
	perr /Called undefined function from compiled code/

cmfnen=.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Support functions for compiled code
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;LEXENT - %LEXPR-ENTRY
;sets up N for magic access to args
lexent:	move w3,q		;have to compute Q at base of args
	sub w3,o1		;O1 is a Lisp int, so have to remove types
	tlc w3,(<<100-ty%lpi>_30.>#<o1_30.>) ;and also add the AC ref.
	push p,w3		;save it for the user to reference
	call (w2)		;now do his code
	adjsp p,-1		;clean up stack
	ret			;and return

;set up O2 to be a stack pointer as needed to call an FSUBR
setfsp:	move o2,sp		;top of stack
	sub o2,[basesp-1]	;convert to offset from start
	lsh o2,-1		;divide by two - two words per "cell"
	maknum o2		;spdl pointer now in w2
	ret

;lb1-lb5 are for lambda binding.
;  jsp w2,lb3
;  setam o1,@[object ty%atm,foo]
;  setam o2,@[object ty%atm,bar]
;  setam o4,@[object ty%atm,baz]
;LB3 is supposed to save the old bindings of the atoms on
;SP, and then return.  The SETAM's (which are equivalent to MOVEM's)
;will then put in the new bindings.  This code depends critically
;upon having SETAM's instead of MOVEM's.  SETAM has the highorder
;bit on, which means that when you use it in an index register you
;get local addressing.

lb5:	move w3,4(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb4:	move w3,3(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb3:	move w3,2(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb2:	move w3,1(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
lb1:	move w3,0(w2)		;w3 - setam o1,address of atom pointer
	push sp,(w3)		;push the atom pointer itself
	push sp,@(sp)		;and its value
	jrst (w2)

;now ub1 to ub5 unbind 1 to 5 things from the SP stack
ub5:	pop sp,@-1(sp)
	adjsp sp,-1
ub4:	pop sp,@-1(sp)
	adjsp sp,-1
ub3:	pop sp,@-1(sp)
	adjsp sp,-1
ub2:	pop sp,@-1(sp)
	adjsp sp,-1
ub1:	pop sp,@-1(sp)
	adjsp sp,-1
	ret

udflab:	perr /GO to undefined label in compiled code/

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; functions to support LAP
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;TY%INT - this entire section uses GETNUM and MAKNUM to handle
; numbers that can be addresses.  This works because the we don't
; allow addresses above 29 bits.  In principle we should use more
; complete code that allows full-size numbers.

define ldint(dest,source)
	move dest,source
	posnum dest
	termin	

;o1 - address
;o2 - opcode
;o3 - reg
;o4 - rest of instruction
;  build instruction (in w3) and put in address
dinst:	ldint w3,o4		;rightmost part
	ldint w4,o3		;reg field
	dpb w4,[.bp 17_23.,w3] ;to reg field in instruction
	ldint w4,o2		;opcode
	dpb w4,[.bp 777_27.,w3] ;to code place
	ldint w4,o1		;place to put it
	movem w3,(w4)		;do so
	ret

;o1 - address to put it
;o2 - atom whose value to refer to
;  put pointer to value cell in address
dvalr:	;addi o2,at%val
	;pjrst dobj

;o1 - address to put it
;o2 - lisp object
;  put lisp object in address
dobj:	ldint w4,o1		;get absolute address
	movem o2,(w4)		;put lisp object there
	ret

;o1 - address to put it
;o2 - number
dconst:	ldint w4,o1		;w3 - address
	move o1,o2
	call get1nt		;w2 - value
	movem w2,(w4)
	ret

;o1 - is this a constant atom?
catmp:	gettyp o1
	caie w2,ty%cat
	jrst retnil
	jrst rett

;o1 - size of GC'ed area
;o2 - size of non-GC'ed area
; allocate BPS
albps:	ldint w3,o1		;amount of GC'ed space
	ldint w4,o2		;amount of non-GC'ed space
	move o1,bpsend		;next BPS to alloc
	maknum o1		;make legit number
	move w2,bpsend		;old start of BPS
	add w2,w3		;get to start of non-GC'ed
	jumpe w4,albps1		;forget this if no non-GC'ed
	move w3,w4		;make SPC pointer
	tlo w3,(object(ty%spc,0))
	movem w3,(w2)		;and put at start of non-GC'ed
	add w2,w4		;now advance BPS beyond it all
	addi w2,1		;include the SPC pointer
albps1:	movem w2,bpsend
	ret

;%FUNCTION-ADDRESS-BLOCK
;o1 - ftn
;allocate an address block in BPS if there isn't one already, and
; put the dispatch address there
fadrbl:	move o2,at%dsp(o1)	;already have one?
	gettyp o2		;what do we have?
	cain w2,ty%lpi		;already have an address block
	jrst fadrbx		;yes that's what we want
;Allocate a new address block and return it
	move o3,bpsend		;this is the address we will want
	move w3,o3
	addi w3,3
	movem w3,bpsend		;update because used 3 loc's
	movem o2,fa%adr(o3)	;put address in block
	caml o2,[object ty%iadr,<codsec,,cmfnst>] ;see if in special range
	caml o2,[object ty%iadr,<codsec,,cmfnen>]
	jrst .+2
	subi o2,3		;yes - alternate entry is -3
	movem o2,fa%adx(o3)	;put in alternate entry
	movem o1,fa%atm(o3)	;put in the atom
	maknum o3		;now turn address of block into legal number
	movem o3,at%dsp(o1)
	move o1,o3
	ret			;and return it

fadrbx:	move o1,o2
	ret

;o1 - ftn (an atom)
;o2 - address
;o3 - SUBR, FSUBR, ...
;o4 - number of args
sftne:	tlc o2,(object ty%lpi#ty%adr,0) ;turn integer into address
	move o5,nil		;assume NIL cdr
	camn o3,[%MSUBR]	;if MSUBR, that's always the case
	jrst sftne1
	camn o3,[%FSUBR]
	jrst sftne2		;FSUBR's are special
;otherwise, presumably SUBR, accept number of args as given
sftne0:	docons o5,o4,nil	;(n)
sftne1:	docons o4,o2,o5		;(addr n)
	docons o2,o3,o4		;(tag addr n)
	jrst alias		;now do it

;here if FSUBR
sftne2:	came o4,[inum 1] ;if one arg
	jrst sftne0		;not one - pass number
	jrst sftne1		;is one - the is defaulted, no number arg

;=*=    =====================================================
;=*=	      support function for loading .FLAP files
;=*=    =====================================================
;=*=  the format of the file is as follows:
;=*=	in ascii, the following:
;=*= SIZE: #of-linkwds #of-codewds
;=*= CONSTANTS: #of-constants <constant forms>
;=*= VARIABLES: #of-variables <variable names>
;=*= FUNCTIONS: #of-functions <function names>
;=*= BINARY:
;=*=	==================================================
;=*=  the LISP function FLAP reads up to here, closes the file,
;=*=  re-opens it in 36-bit mode, sets the input pointer back to
;=*=  this point,  and calls %bflap.  It has allocated the space,
;=*=  filled in the constants, variables, and function pointers;
;=*=  re-opened the file in 36-bit mode and repositioned the
;=*=  pointer to here.  
;=*=	==================================================
;=*=	then binary, ie 36-bit words:
;=*=   666   this as the value of a word as a synchronizer
;=*=   #of-codewords   as a binary value this time
;=*= the code for the functions. the left half of each word is absolute.
;=*= the right half is cnnnnn octal, where c is a code:
;=*= c = 0 or 7  the right half is absolute, leave untouched
     ;=*=     1  rh becomes the nnnnn'th constant
     ;=*=     2  rh is nnnnn'th variable
     ;=*=     3  rh is nnnnn'th function
     ;=*=     4  rh is nnnnn'th internal entry
     ;=*=     5  rh is addr of this word - nnnnn
     ;=*=     6  rh is addr of this word + nnnnn
;=*=   minus #of words of above to be translated (rest are absolute)
;=*=   #of-fns-defined
;=*= a word for each fn definition:  byte (4)what (15)which (17)where
;=*=     what - what kind of entry point, 0-5 = expr of that many args,
;=*=			8 = fexpr, 9 = lexpr, 10 = macro
;=*=     which - index into the function table (above) for this fn
;=*=     where - entry point as offset past beginning of code

;=*= args are: curpos, constants, variables, functions, code
;=*= each is a lisp number giving the beginning address of
;=*= that area, except FUNCTIONS, which is a vector of atoms. Constants
;    and variables are filled in.

;;TY%CHN		-- we grab the current jfn
%bflap:	posnum o1
	push p,o1
	move o1,@[datsec,,.curin]
	push p,ch%jfn(o1)	;=*= a jfn--
	irp x,,[o2,o3,o5]	;=*= --and 3 orgs
	posnum x
	push p,x
	setz x,
	termin
	push q,o4		;this one is a vector, so save on Q
	sos -1(p) ? sos -2(p) 	;=*= fencepost factor
	
	hrrz nil1,-3(p)		;=*= find our starting point
	move w2,-4(p)		
	sfptr
	 erjmp .+1
%bfl01:	bin
	caie w2,666		;=*= the end-of-text/beginning-of-binary flag
	 jrst %bfl01
	bin			;=*= next wd is codesize count
	movn w3,w2		;=*= SIN params: -byte count
	move w2,(p)		;=*= byte pointer
	hrli w2,444400		;=*= full word!
	sin
	bin			;=*= get -# of wds to translate
	hrls w2
	hrr w2,(p)		;=*= w2= aobjn code pointer
%bfl05:	ldb w3,[.bp 700000,(w2)]	;=*= reloc code
	ldb w4,[.bp 077777,(w2)]	;=*= reloc parameter
	xct    [skipa	 	;=*= 0 = absolute
		add w4,-2(p)	;=*= 1 = constant
		add w4,-1(p)	;=*= 2 = variable
		jrst [add w4,(q)	; 3 = function; vector of ftn addrs
		      move w4,-1(w4)	;now have the addr we need
		      move w3,(w2)	;function call - get the actual call
		      tlzn w3,010000 	;is it JRST? (if so, clear the bit)
		      jrst .+1		;no - we have the RH
;JRST's are funny, because a JRST to a function is a JRST hack.  If the
;function turns out not to be defined, we have to have some way of knowing
;what was being called.  Hence we use a special entry in the function address
;block.  It is identical in most cases, but for the interpreter entries, it
;gives special entrypoints that know they were called with  JSP.
		      tlo w3,(jsp w3,@0) ;yes - make it a JSP W3,
		      hrri w3,2(w4)	;with special address
		      movem w3,(w2)	;put it back in the code
		      jrst .+2]		;and forget the HRRM
		move w4,%bfltv(w4) ;=*= 4 = internal entry
		jrst [movns w4	;=*= 5 = backwards ref
		      addi w4,(w2) ? jrst .+1]
		addi w4,(w2)	;=*= 6 = forward ref
		skipa](w3)	;=*= 7 = absolute
	 hrrm w4,(w2)
	aobjn w2,%bfl05

	bin			;=*= next is number of fns defined
	move n,w2		;=*= save for countdown
	jumpe n,%bfl20		;anything there?

%bfl07:	hrrz nil1,-3(p)		;=*= jfn
	bin			;=*= next wd 
	setz nil1,		;=*= leave gronked as briefly as possible
	ldb w4,[.bp 74^12,w2]	;=*= type
	caile w4,7		;=*= is it a subr?
	 jrst %bfl10
	move o2,w4		;=*= yes, this is # of args
	maknum o2		;=*= we make (SUBR addr #args)
	docons o2,o2,nil
	skipa
%bfl10:	 setz o2,		;=*= otherwise (type addr)
	ldb o3,[.bp 377777,w2]	;=*= entry point
	add o3,(p)		;=*= code org
	tlo o3,(object ty%adr,0)
	docons o3,o3,o2		;=*= cons the address constant
	move o2,%bflta(w4)
	docons o2,o2,o3		;=*= this completes the fundef form
	move o1,%bflev(w4)	;=*= the form evaller for EVAL
;=*= find the atom--this has to be after the conses (above)
;=*= so that the atom will hold still while we hack on it.
	ldb w3,[.bp 377774^5,w2]	;=*= which function
	add w3,(q)		;=*= now have
	move w3,1(w3)		;=*= address of 2-word block
	ldb w4,[.bp 377777,w2]	;=*= entry point
	add w4,(p)		;=*= code org
	tlo w4,(object ty%iadr,0)	;=*= make it an internal address
;;TY%ATM		internal form hacked on here
	movem w4,fa%adr(w3)	;set up calling address
	movem w4,fa%adx(w3)	;put in alternate entry
	move w4,-1(w3)		;now get the atom
	movem o1,at%fev(w4)	;=*= plug in funtype entry
	movem o2,at%fun(w4)	;=*= plug in fundef form
	movem w3,at%dsp(w4)	;and the address block itself
	sojg n,%bfl07
%bfl20:	hrrz nil1,-3(p)		;jfn
	rfptr
	 erjmp [err /Can't find file position in FLAP/]
	setzb nil1,o1
	adjsp p,-5		;=*= 4 orgs and a jfn
	adjsp q,-1
	jrst ret1nt
				;=*= function type atom table:
%bflta:	repeat 6, %SUBR
	0 ? 0
	%FSUBR ? %LSUBR ? %MSUBR
				;=*= eval routine entry table:
%bflev:	irp x,,[evsub0,evsub1,evsub2,evsubr,evsubr,evsubr,0,0
		evfsub,evlsub,evmsub]
	object(ty%adr,x(codsec)) ? termin
				;=*= internal entry point table:
%bfltv:	0
	bnderr
	cerrse			;=*= %errset
	free
	getbar
	get1nt
	lb1			;=*= %lambdabind 1 through 5
	lb2
	lb3
	lb4
	lb5
	lexent			;=*= %lexpr-entry
	ret1nt
	retflo
	setfsp			;=*= %set-bcp
	setbar
	ub1			;=*= %unbind 1 through 5
	ub2
	ub3
	ub4
	ub5
	udflab			;=*= %undeflabel
	cwthin			;=*= %within
	cwthou			;=*= %without
	crdctx			;%readcontext
	atomp			;atom
	litat			;litatom
	cons			;cons
	xcons			;xcons
	ncons			;ncons
	cunwpr			;%unwind-protect


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; end of apply and eval - some other stuff that depends upon
;; the representations of values and bindings
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;SET - ident to set, new value
; first look to see if we know where to put it
;o1 - atom, o2 - new value
set: 	skipe o1		;don't let him bind t or nil
	camn o1,[%T]
	jrst illrb1
	satom o1
	jrst illvar		;must be an atom
	setval o1,o2
	move o1,o2		;return new value
	ret

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the code for hacking on the stack, for use by BREAK
;; and friends
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;The stack contains pairs of the following sorts:
;  saved values of variables when they are rebound:
;	value
;	atom
;  saved values of internal variables when they are rebound.  (These
;  internal variables are declared by DECLFU after the OBLIST.)
;	value
;	variable's addr - this is TY%ADR
;  EVAL BLIP - shows every expression that EVAL has seen
;	expression
;	blip giving saved value of P (with Q pushed onto P at that point)

;going up the stack is simple:  look at each pair.  If the bottom one
;is NIL, ignore it, else use it as an address and move the top one into it.


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  These are UNBIND and INCONT, the stack experts for EVAL and APPLY
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;UNBIND unwinds the SP stack.  Since this contains saved values of all
;variables that have been changed, this returns us to an old variable-
;binding context.  The context to return to is passed on P (or in W2, if
;you call UNBIND1).  We must check for EVAL blips, which are the one
;thing this do not have saved values.  The type code for an EVAL blip
;is an isolated bit, so we can just check that bit.

;Note that UNBIND and CUNBIND are designed so that we can ^C out and
;restart the core image, and the restart code will continue the unbind
;without losing anything.  For this reason, SP is not popped until the
;value has been assigned, and the file closing is handled carefully also.

unbind:	pop p,w2		;saved sp
	jrst unbin1

unbinl:	adjsp sp,-2
unbin1:	camg sp,w2
	ret
	dmove o2,-1(sp)
	jumpe o2,unbinl		;ignore eval blips
	setval o2,o3		;restore binding
	jrst unbinl

;CUBIND and CUBIN1 are special versions that activate traps.  These
;  entries are used for normal non-local exits.  The user should be
;  careful to set UNWIND-PROTECT to indicate the cause if there is
;  any chance that the exit could trigger an UNWIND-PROTECT.
cubind:	pop p,w2		;saved sp
	jrst cubin1

cubinl:	adjsp sp,-2
cubin1:	camg sp,w2
	ret
	dmove o2,-1(sp)		;uninterruptible, so this code is reentrant
	jumpe o2,cubinl		;ignore eval blips
	setval o2,o3		;restore binding
	came o2,[%UNWIND]	;unwind-trap?
	jrst cubinl
	push p,w2		;save target
	pushj p,(o3)		;address of trap routine
	pop p,w2
	jrst cubinl


;INCONT - does eval or apply in a certain context
;o1 & o2 are not changed.  They are presumably the args to *EVAL or
; *APPLY.
;o3 is the stack pointer or A-list
;w4 is the function to call.
incont:	jumpe o3,(w4)		;if no funny arg, forget it
	gettyp o3		;see what it is
	cain w2,ty%lpi		;a stack pointer
	jrst incns		;play with stack first

;;;;;;this code is done if the user passes an ALIST
;;;;the code under repeat 0 is designed to rplacd the new values
;;;;into the A-list.  this has been removed as it was an unauthorized
;;;;change to the semantics of Lisp.

;here for an a-list (we hope)
	push p,sp		;establish backup point for unbind
repeat 0,[push q,o3]		;save original list
;loop over alist binding
incn1:	docar o4,o3		;first pair
	docar o5,o4		;variable
	xtype o5		;make sure it is
	caie w2,ty%xat
	jrst [move o1,o5
	      perr /Attempt to use something other than an atom as a variable/]
	docdr o4,o4		;value
	bind o5,o4		;bindit
	docdr o3,o3		;next pair
	jumpn o3,incn1		;if any
;do the eval or apply
	call (w4)		;now eval in that context
repeat 1,[jrst unbind]

repeat 0,[
	move w2,(p)		;w2 - original sp
	pop q,o4		;o4 - original alist
;loop over alist unbinding
	jumpe o4,incn3		;end of alist?
incn2:	move o2,1(w2)		;no - o2 - variable
	move o3,2(w2)		;o3 - old value
	docar o5,o4		;o5 - pair
;;TY%ATM
	exch o3,at%val(o2)	;o3 now has new value, old restored in v. cell
	dorpd o5,o3		;put new value in alist
	docdr o4,o4		;o4 - cdr the alist
	addi w2,2		;and to next place in stack also
	jumpn o4,incn2		;any more to do?
incn3:	pop p,sp		;now restore SP
	ret			;that's it
]  ;repeat 0

;;;;;;here if he supplied a stack index
incns:	push p,sp		;save current sp for unbind
	push q,o1		;save args
	push q,o2
	push p,w4
	move o1,o3		;and move stack index to arg position
	call upstak		;common routine to go to stack context
	pop q,o2
	pop q,o1
	pop p,w4
	call (w4)		;now do what the user wanted
	jrst unbind		;and go back to normal context
	
	


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  These are the UCI Lisp stack mungers, for wizards only
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

adjust==0
;The second argument to GETSTK indicates what to do when the arg
;is out of range.  There are two choices:
;  ADJUST - adjust to be in range
;  address - go there

define getstk(ac,stkerr)	;convert AC from INUM to stack addr
	posnum ac		;convert to bare number
	lsh ac,1		;to offset
	add ac,[basesp-1]	;to address
ife stkerr,[
	camge ac,[basesp-1]	;if impossible
	move ac,[basesp-1]
	camle ac,sp
	move ac,sp
] ;ife stkerr
ifn stkerr,[
	caml ac,[basesp+1]	;if impossible
	camle ac,sp
	jrst stkerr		;then go here
] ;ifn stkerr
	termin

;spdlpt - return top of stack as INUM
spdlpt:	move w2,sp		;top of stack
	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2
	move o1,w2
	ret

;stkptr(i) - return pseudo-pointer to stack
stkptr:	getstk o1,retnil	;convert to address
	subi o1,1		;pointer to CAR
	tlo o1,(object ty%ccn,0) ;call it constant so not GC'ed
	ret

;spdlft(i) - return ith "CAR" from stack
spdlft:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
	move o1,-1(w2)		;CAR of stack pair
	ret

;spdlrt(i) - return ith "CDR" from stack
spdlrt:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
	move o1,(w2)		;CDR of stack pair
	ret

;nextev(i) - return INUM for next eval blip (entry with NIL CAR)
nextev:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
nxtev1:	camge w2,[basesp+1]	;below base?
	jrst retnil		;yes - failed
	skipn -1(w2)		;is it eval blip?
	jrst nxtev2		;yes - done
	subi w2,2		;no - try next
	jrst nxtev1
nxtev2:	sub w2,[basesp-1]	;convert to offset from start
	lsh w2,-1		;divide by two - two words per "cell"
	maknum w2
	move o1,w2
	ret

;internal form of NEXTEV - returns stack addr in W2, addr of CDR (top word)
inextv:	move w2,o1
	getstk w2,retnil	;convert arg to stack addr
inxtv1:	camge w2,[basesp+1]	;below base?
	jrst retnil		;yes - failed
	skipn -1(w2)		;is it eval blip?
	ret			;yes - done
	subi w2,2		;no - try next
	jrst inxtv1

evalv:	move w2,o2		;stack arg in in o2
	getstk w2,adjust
;w2 - copy of SP, used for search
;o1 - variable
evalv1:	caml w2,sp
	jrst evalv2		;done, failed
	camn o1,1(w2)		;is this what we want?
	jrst evalv3		;done, success
	adjsp w2,2		;next
	jrst evalv1

evalv2:	getval o1,o1		;not on stack - use current
	ret

evalv3:	move o1,2(w2)		;on stack - use value from stack
	ret
	
;;TY%ATM ;;AT%VAL - we use the fact that value cell is offset 0
;(SETV ATOM STACKPTR VALUE)
;  used to set an atom in a stack context
setv:	move w2,o2		;stack arg in in o2
	getstk w2,adjust
;w2 - copy of SP, used for search
;o1 - variable
setv1:	caml w2,sp
	jrst setv2		;done, failed
	camn o1,1(w2)		;is this what we want?
	jrst setv3		;done, success
	adjsp w2,2		;next
	jrst setv1

setv2:	setval o1,o3		;not on stack - use current
	move o1,o3
	ret

setv3:	movem o3,2(w2)		;on stack - use value from stack
	move o1,o3
	ret

;go to specified context and return with given value (value in O2)
outval:	move o6,o2		;save value to return
	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
	addi w2,2		;unbind all up to saved P
	move o1,[%OUTVAL]	;This is one Interlisp doesn't do
	movem o1,@[.unwpro]
	call cubin1		;unbind to W2, closing files we pass
	pop sp,w2		;W2 is now saved P (with TY%ADR set)
	tlz w2,770000		;clear ty%ADR
	pop sp,o1		;dummy
	pop sp,o1		;expression being eval'ed
	move p,w2
	pop p,q			;restore the rest from saved info
	pop p,sp
	move o1,o6		;get back thing to return
	ret			;and do so

;go to specified context and try given form (form in O2)
sprevl:	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
	movem o2,(w2)		;save form in SPDL place
	jrst spred1		;and let spredo finish

;go to specified context and try again
spredo:	call inextv		;adjust to eval blip, new SP in W2
	jumpe o1,cpopj		;if fails, return nil
spred1:	addi w2,2		;unbind all up to saved P
	move o1,[%SPREDO]	;This is one Interlisp doesn't do
	movem o1,@[.unwpro]
	call cubin1		;unbind to W2, closing files we pass
	pop sp,w2		;W2 is now saved P (with TY%ADR set)
	tlz w2,770000		;clear ty%ADR
	pop sp,o1		;dummy
	pop sp,o1		;expression being eval'ed
	move p,w2
	pop p,q			;restore the rest from saved info
	pop p,sp
	jrst eval		;now go try again


;upstack(i) - internal routine that moves us up the stack to position i
;the caller should do
;  push p,sp
;  call upstak
;  do your thing
;  jrst unbind
upstak:	move w2,o1		;w2 - his stack index
	getstk w2,adjust	;convert to actual SP index
	move w3,sp		;save current sp as stopping point
;loop over sp, restoring bindings
upst1:	caml w2,w3		;still in the past?
	jrst upst2		;no - done
	pop w3,o3		;value
	pop w3,o4		;var
	jumpe o4,upst1		;is eval blip
	push sp,o4		;restore binding
	push sp,at%val(o4)	;  (save current)
	setval o4,o3		;  (restore old)
	jrst upst1
upst2:	ret


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The JSYS interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;code still being designed


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The rest of this stuff should be done in Lisp and compiled.
;; It will be eventually.  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;COND - arg is CDR FORM - this is the normal form
docond:	push q,o1		;cond so far
  ;loop over conditions
docnlp:	jumpe o1,docon1		;no possibilities left, return nil
	docar o1,o1		;now find test
	docar o1,o1
	call eval		;do test
	jumpe o1,docnnx		;failed, try next
	move o2,(q)		;cond tail
	docar o2,o2		;this clause
docnl2:	docdr o2,o2		;the rest of the clause
	jumpe o2,docon1		;nothing else - return what we have (in o1)
	movem o2,(q)		;save clause tail for next time
	docar o1,o2
	call eval		;next item - result in o1 - returned if last
	move o2,(q)		;get back tail
	jrst docnl2		;and see if any more to do

;here to advance to next clause
docnnx:	move o1,(q)
	docdr o1,o1
	movem o1,(q)
	jrst docnlp

docon1:	adjsp q,-1		;throw away saved part of form
	ret

;COND - this is the optimized form, called directly from eval
evcond:	docdr o1,o1		;o1 has the COND in it
	push q,o1		;cond so far
  ;loop over conditions
evcnlp:	jumpe o1,evcon1		;no possibilities left, return nil
	docar o1,o1		;now find test
	docar o1,o1
	call eval		;do test
	jumpe o1,evcnnx		;failed, try next
	move o2,(q)		;cond tail
	docar o2,o2		;this clause
evcnl2:	docdr o2,o2		;the rest of the clause
	jumpe o2,evcon1		;nothing else - return what we have (in o1)
	movem o2,(q)		;save clause tail for next time
	docar o1,o2
	call eval		;next item - result in o1 - returned if last
	move o2,(q)		;get back tail
	jrst evcnl2		;and see if any more to do

;here to advance to next clause
evcnnx:	move o1,(q)
	docdr o1,o1
	movem o1,(q)
	jrst evcnlp

evcon1:	adjsp p,-2
	adjsp sp,-4
	adjsp q,-1		;throw away saved part of form
	ret


;QUOTE - stack is cdr form
evalqu:	docar o1,o1
	ret

;optimized form of QUOTE
evquot:	docdr o1,o1
	docar o1,o1
	adjsp sp,-4
	adjsp p,-2
	ret

;FUNCTION 
;stack is cdr form, alist.
;functi:push q,[%FUNARG]	;cdr form, alist,  FUNARG
;	err /FUNARG not implemented/

;;TY%ATM
;ALIAS(atom,defn)
;o1 - atom, o2 - defn
;defn is one of (LAMBDA ...), (FEXPR LAMBDA ...), (MACRO LAMBDA ...),
;   (SUBR ADDR #),  (FSUBR ADDR . want-BPC?), (MSUBR ADDR).  ALIAS is
;   reponsible for setting up AT%FEV, the special evaluator word.  Take a
;   look at EVAL for an explanation of it.  There are two major
;   possibilities: if the form is a simple one that we have optimized code 
;   for, we analyze it and put the special evaluator address in.  Otherwise
;   we put in the address of code in slow EVAL that handles that
;   binding type (i.e. EXPR/SUBR,  FEXPR/FSUBR, MACRO/MSUBR).
alias:	satom o1
	jrst [perr /Attempt to ALIAS something that is not an atom/]
	jumpe o1,[err /Attempt to ALIAS NIL/]
	jumpe o2,alnil
	snatom o2
	jrst aliasa
	scons o2
	jrst illftn
	move o6,[object ty%iadr,<codsec,,calund>]
	docar o4,o2		;get keyword
	camn o4,[%SUBR]
	jrst alsubr
	camn o4,[%LSUBR]
	jrst allsub
	camn o4,[%FSUBR]
	jrst alfsub
	camn o4,[%EXPR]
	jrst alexpr
	camn o4,[%FEXPR]
	jrst alfexp
	camn o4,[%MACRO]
	jrst almacr
	camn o4,[%MSUBR]
	jrst almsub
	jrst illftn
;arg is atom, just copy all cells
aliasa:	move o6,at%dsp(o2)	;get dispatch from old atom
	gettyp o6		;see what it is
	cain w2,ty%lpi		;if integer, it is address block
	move o6,fa%adr(o6)	;so get it from block
	move o3,at%fev(o2)
	move o2,at%fun(o2)
	;jrst alexit
alexit:	tlz o6,770000		;change type code to TY%ADR
	tlo o6,(object(ty%iadr,0))
	movem o3,at%fev(o1)	;evaluator
	movem o2,at%fun(o1)
	move w3,at%dsp(o1)	;see whether we have an address bloc yet
	gettyp w3		;what did we get?
	caie w2,ty%lpi		;yes - we have one
	jrst alex1		;no
;if there is a function address block, have to fill both words
	movem o6,fa%adr(w3)	;address field
	caml o6,[object ty%iadr,<codsec,,cmfnst>] ;see if in special range
	caml o6,[object ty%iadr,<codsec,,cmfnen>]
	jrst .+2
	subi o6,3		;yes - alternate entry is -3
	movem o6,fa%adx(w3)	;put in alternate entry
	move o1,o2		;value to return
	ret

;if there is not function address block, just put the address in AT%DSP
alex1:	movem o6,at%dsp(o1)
	move o1,o2		;value to return
	ret

;here if we have the address block for this function.  It is in O1
aladbl:	pop q,o2		;don't need this now
	pop q,o2		;new address
	movem o2,(o1)		;put it in the block
	pop q,o1		;value to be returned
	ret

alnil:  move o2,nil		;at%fun - no ftn defn
	move o3,[object ty%adr,<codsec,,evund>] ;at%fev - no ftn defn
	move o6,[object ty%iadr,<codsec,,calund>] ;at%dsp - no ftn defn
	jrst alexit

illftn:	err /Ill-formed function/

illarg:	move o1,o5
	perr /Formal parameter not an atom, or is NIL or T/

;argval - validates the formal arguments.  I.e. makes sure they are
;all legal atoms.  This lets us use FASBIND in fast eval.
argval:	docdr o4,o2		;(lambda ...
	docdr o4,o4		;((x y) ...
	docar o4,o4		;(x y) ...
argvll:	scons o4
	jrst alexit		;done if no args or lexpr
	docar o5,o4		;x
	satom o5
	jrst illarg		;must be atom
	jumpe o5,illarg		;non-nil
	camn o5,[%t]		;and not t
	jrst illarg
	docdr o4,o4		;next arg
	jrst argvll

;fsubr - always fast
alfsub:	move o3,[object ty%adr,<codsec,,evfsub>]
alfsb1:	docdr o6,o2		;cdr
	scons o6
	jrst illftn
	docar o6,o6		;cadr, i.e. jump address
	gettyp o6
	cain w2,ty%adr		;ok if addr
	jrst alexit
	cain w2,ty%lpi		;or integer
	jrst alexit
	jrst illftn

;lsubr - always fast
allsub: move o3,[object ty%adr,<codsec,,evlsub>]
	jrst alfsb1		;process same as LSUBR

;msubr - always fast
almsub:	move o3,[object ty%adr,<codsec,,evmsub>]
	jrst alfsb1		;process same as FSUBR

;fexpr - fast if it is a lambda
alfexp:	docdr o4,o2
	scons o4
	jrst slfexp		;atom - slow fexpr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slfexp
	move o6,[object ty%iadr,<codsec,,calfex>] ;here from compiled code
	move o3,[object ty%adr,<codsec,,evfexp>] ;fast
	jrst argval		;exit validating args

;here if fexpr turns out to be slow
slfexp:	move o3,[object ty%adr,<codsec,,evsfex>] ;slow fexpr
	jrst alexit

;macro - fast if it is a lambda
almacr:	docdr o4,o2
	scons o4
	jrst slmacr		;atom - slow fexpr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slmacr
	move o3,[object ty%adr,<codsec,,evmacr>] ;fast
	jrst argval		;exit validating args

;here if macro turns out to be slow
slmacr:	move o3,[object ty%adr,<codsec,,evsmac>] ;slow fexpr
	jrst alexit

;exprs's are special because they may be lexprs
;a normal expr is fast if it is a lambda
alexpr:	docdr o4,o2
	scons o4
	jrst slexpr		;atom - slow expr
	docar o5,o4
	came o5,[%LAMBDA]
	jrst slexpr
;we now know it is fast, but is it an expr or lexpr?
	move o6,[object ty%iadr,<codsec,,calexp>] ;here from compiled code
	docdr o4,o4
	docar o5,o4
	jumpe o5,alexp0		;nil is atom but still not lexpr
	scons o5		;is it atom?
	jrst allexp		;yes - lexpr
;now we have normal expr.  We check the number of args, as 0, 1, and
;2 have optimized code
	move o3,[object ty%iadr,<codsec,,evexpr>] ;default if not lexpr
	docdr o5,o5		;already checked for nil, which is 0
	jumpe o5,alexp1		;if cdr is nil, 1 arg
	docdr o5,o5
	jumpe o5,alexp2		;2 args
	move o3,[object ty%adr,<codsec,,evexpr>] ;normal fast expr
	jrst argval		;exit validating args

;here for exprs with known numbers of args
alexp0:	move o3,[object ty%adr,<codsec,,evexp0>]
	jrst argval
alexp1:	move o3,[object ty%adr,<codsec,,evexp1>]
	jrst argval
alexp2:	move o3,[object ty%adr,<codsec,,evexp2>]
	jrst argval

;here if expr turns out to be lexpr
allexp:	move o6,[object ty%iadr,<codsec,,callex>]
	move o3,[object ty%adr,<codsec,,evlexp>]
	jrst alexit

;here if expr turns out to be slow.  Slow eval will figure out whether
;it is lexpr or not.
slexpr:	move o3,[object ty%adr,<codsec,,evsexp>] ;slow expr
	jrst alexit

;subrs are special because we have special code depending upon the
;number of args
alsubr:	docdr o4,o2		;addr
	scons o4
	jrst illftn
	docar o6,o4		;the address itself
	gettyp o6		;make sure it is an address
	cain w2,ty%lpi
	jrst .+3
	caie w2,ty%adr
	jrst illftn
	docdr o4,o4		;number of args
	docar o4,o4		;the number itself
	move o3,[object ty%adr,<codsec,,evsubr>] ;the default subr evaluator
	camn o4,[object(ty%lpi,0)]
	move o3,[object ty%adr,<codsec,,evsub0>]
	camn o4,[object(ty%lpi,1)]
	move o3,[object ty%adr,<codsec,,evsub1>]
	camn o4,[object(ty%lpi,2)]
	move o3,[object ty%adr,<codsec,,evsub2>]
	jrst alexit
	

;;TY%ATM
;FUNDEF(atom)
fundef:	satom o1
	jrst retnil
	skipe o1		;NIL can't be defined
	move o1,at%fun(o1)
	ret

;SETQ - quote first arg and call set
;o1 is cdr form
setq:	pushcar q,o1		;save variable to bind to
	docdr o1,o1
	docar o1,o1		;now have form for value. eval it
	call eval		;o1 is now value
	pop q,o2		;o2 is variable
	skipe o2		;don't let him bind t or nil
	camn o2,[%T]
	jrst illrb2
	satom o2		;better be an atom
	jrst illvr2
	setval o2,o1
	ret			;return value set returned

;EVSETQ - direct call version
;o1 is cdr form
evsetq:	docdr o1,o1
	pushcar q,o1		;save variable to bind to
	docdr o1,o1
	docar o1,o1		;now have form for value. eval it
	call eval		;o1 is now value
	pop q,o2		;o2 is variable
	skipe o2		;don't let him bind t or nil
	camn o2,[%T]
	jrst illrb2
	satom o2		;better be an atom
	jrst illvr2
	setval o2,o1
	adjsp sp,-4
	adjsp p,-2
	ret			;return value set returned

illvr2:	move o1,o2
illvar:	perr /Only atoms may be used as variables/

illrb2:	move o1,o2
illrb1:	perr /Trying to set T, NIL, or something that isn't a variable/
illreb:	err /Trying to set T, NIL, or something that isn't a variable/


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Here is the kludge of the year: PROG and all its friends.
;; GO and RETURN do non-local things to the interpretation of
;; PROG.  I implement this by special variables that GO and
;; RETURN can use to communicate with PROG.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;PROG - cdr form
;1 - loop over all variables
;2 - make up the golist from all tags
;3 - set up funny variables for GO and RETURN
;4 - interpret the PROG
prog:	push q,o1		;save the form
	docar o1,o1		;get the start of the prog - the var list
	jumpe o1,progg2
;1 - loop over all variables, setting up bindings on the alist
progg1:	docar o2,o1		;first var
	bind o2,nil		;bind it to nil
	docdr o1,o1
	jumpn o1,progg1
progg2:	
;2 - make up the golist from all tags
	move o1,(q)		;o1 - tail into code
	move o3,nil		;o3 - list of tags
progg3:	docdr o1,o1		;loop over code searching for atoms
	jumpe o1,progg4		;see if done
	docar o2,o1		;get car of the tail we are looking at
	satom o2		;better be an atom
	jrst progg3		;no - look again
	docdr o1,o1		;yes - cdr of the tail is the code the tag
				;  refers to
	docons o4,o2,o1		;o4 - (atom . tail)
	docons o2,o4,o3		;o2 - ((atom.tail) old list)
	move o3,o2		;o3 - now updated
	skipe o1		;check for null tail (label at end of prog)
	jrst progg3		;search on
progg4:	
;3 - set up funny variables for GO and RETURN
	push p,sp		;save stack values for nonlocal exit
	push p,q
  ;GOLIST
	move o1,@[datsec,,.GOLIST]
	push sp,[%GOLIST]
	push sp,o1		;save old value
	movem o3,@[datsec,,.GOLIST]  ;now new value
  ;similar for return.  This is a kludge giving stack values for
  ;RETURN to use to do a non-local exit
	move o1,@[datsec,,.PRET]
	push sp,[%PRET]
	push sp,o1		;save old value
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.PRET]
  ;now for NEXT.  This is use to implement GO.
	move o1,@[datsec,,.PNEXT]
	push sp,[%PNEXT]
	push sp,o1		;save old value
;4 - interpret the PROG
  ;make up the "PC", i.e. the place in the form where we are interpreting
	move o1,(q)
	docdr o1,o1		;get to code (car is the vars)
	movem o1,@[datsec,,.PNEXT] ;and put it into PC
  ;construct saved environment for GO
	push p,sp
	push p,q
	move o1,@[datsec,,.PTOP]
	push sp,[%PTOP]
	push sp,o1
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.PTOP]
  ;main loop
progg5:	move o1,@[datsec,,.PNEXT] ;get next thing to interpret
	jumpe o1,progg6		;exit if end
	docdr o2,o1		;save next for later
	movem o2,@[datsec,,.PNEXT];cdr the pc
	docar o1,o1		;get the thing to execute
	xtype o1		;if atom, ignore it
	cain w2,ty%xat
	jrst progg5
	call eval		;eval the thing
	jrst progg5		;and continue at new PC
progg6:	adjsp p,-3		;undo saved Q and SP
	adjsp q,-1		;undo saved form
	move o1,nil		;always return nil
	jrst unbind

;Now here are the things that only work inside PROG's
;GO tag - looks up the tag in GOLIST, sets NEXT to it, and returns
; to top level of PROG interpreter
go:	
  ;get tag atom
	docar o1,o1		;o1 - tag

;this is essentially a loop that continues EVAL'ing things until it
;finds a tag.  However the top level of the loop has to treat atoms
;differently from non-atoms.  This is because there is no point in
;checking non-atoms to see if they are tags.  Also because we don't
;want to call EVAL for an atom, but do GETVAL ourselves.  That is
;because EVAL would say "unbound atom" if it is undefined, but we want
;to say "no such tag".
go1:	xtype o1		;if it is an atom, use it
	cain w2,ty%xat
	jrst go2		;here if atom, atom in o1
;Non-atoms - just EVAL them
	call eval		;else eval it - result back in o1
	jrst go1

;Atoms - see if they are tags, and EVAL them if not
go2:	move o2,@[datsec,,.GOLIST] ;tag is already in o1
	move o6,o1		;save 
	call assoc		;returns pair
	jumpn o1,go3		;found something, do it
	getval o1,o6		;nope - EVAL it
	came o1,[%.UNBOUND]	;find something?
	jrst go1		;yes - try it out

;Failure - here when we an atom isn't a tag and isn't bound
	move o1,o6		;final failure
	perr /GO - unknown tag/

;Success - here if we have at tag - go do it.
go3:	docdr o1,o1		;value of tag
  ;put the place into the PC for next PROG cycle
	movem o1,@[datsec,,.PNEXT] ;put it in PC
  ;return to top level of PROG
	move w2,@[datsec,,.PTOP] ;P
	tlz w2,770000		;make real address
	move p,w2		;restore saved P - Q and SP are there
	pop w2,q		;restore saved Q
	pop w2,w3		;restore save SP
	addi w3,2		;make sure we don't unbind PTOP
	push p,[codsec,,progg5]	;place to go - top of PROG
	push p,w3		;unbind SP to here - saved SP
	jrst cubind

;RETURN - do a non-local return from anywhere inside a prog.
;PROG sets up the variables PRET with the stack values to use.
;return value
;O1 has user's value.  This routine doesn't need to touch it
return:	move w2,@[datsec,,.PRET] ;P
	tlz w2,770000		;make real address
	jumpe w2,[err /Return when not inside PROG/]
	move p,w2		;restore saved P - Q and SP are there
	pop p,q			;restore saved Q
	adjsp q,-1		;forget saved form
	jrst cubind		;unbind, closing files

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Some nicer control constructs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;cdr form
progn:	jumpe o1,prognx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
prognl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o2,prognl		;if more to do, do it
prognx:	ret			;returned value is in o1

;AND - like progn but return as soon as false
mand:	jumpe o1,mandx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
mandl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpe o1,mandx		;if nil, return now
	jumpn o2,mandl		;if more to do, do it
mandx:	ret			;returned value is in o1

;version of and for direct dispatch
evand:	docdr o1,o1
	jumpe o1,evandx		;if nothing to do, return nothing
	move o2,o1		;use o2 for list of forms
evandl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpe o1,evandx		;if nil, return now
	jumpn o2,evandl		;if more to do, do it
evandx:	adjsp sp,-4
	adjsp p,-2
	ret			;returned value is in o1


;OR - like progn but return as soon as true
mor:	jumpe o1,rett		;if nothing to do, return T
	move o2,o1		;use o2 for list of forms
morl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o1,morx		;if non-nil, return now
	jumpn o2,morl		;if more to do, do it
morx:	ret			;returned value is in o1

;direct call version of or
evor:	docdr o1,o1
	jumpe o1,evrett		;if nothing to do, return T
	move o2,o1		;use o2 for list of forms
evorl:	pushcdr q,o2		;advance for next time
	docar o1,o2		;now the first thing to do is..
	call eval		;do it - result back in o1
	pop q,o2		;get back rest of progn
	jumpn o1,evorx		;if non-nil, return now
	jumpn o2,evorl		;if more to do, do it
evorx:	adjsp sp,-4
	adjsp p,-2
	ret			;returned value is in o1

evrett:	move o1,[%t]
	adjsp sp,-4
	adjsp p,-2
	ret


;not = null
not:	tdzn o1,o1		;negate O1
	move o1,[%T]
	ret

;evnot - direct call version of above
evnot:	docdr o1,o1
	docar o1,o1		;get arg
	call eval
	tdzn o1,o1
	move o1,[%T]
	adjsp sp,-4
	adjsp p,-2
	ret

;atom
atomp:	scons o1
	skipa o1,[%T]		;if not cons, is atom
	move o1,nil
	ret

;evatom - direct call version of above
evatom:	docdr o1,o1
	docar o1,o1
	call eval
	scons o1
	skipa o1,[%T]
	move o1,nil
	adjsp sp,-4
	adjsp p,-2
	ret

;stringp
strp:	xtype o1
	caie w2,ty%xst
	jrst retnil
	jrst rett

;consp
consp:	scons o1
	move o1,nil		;isn't a cons
	ret

;litatom
litat:	snatom o1
	skipa o1,[%T]		;is an atom
	move o1,nil		;isn't
	ret

;boundp - say whether we are bound
boundp:	satom o1		;better be an atom
	jrst retnil
	getval o2,o1
	came o2,[%.UNBOUND]
	jrst rett
	jrst retnil

;unbound - return the thing that unbound atoms are [un]bound to
unbnd:	move o1,[%.UNBOUND]
	ret

;domap - execute map function.  call by
;  push p,[car or not]
;  push p,[applier]
;  call domap
;car or not is either DOCAR O5,O1 or MOVE O5,O1, depending upon
;  whether we are passing CAR's to the function.
;applier is a code that takes the function being mapped in o1 and
;  applies it to an arg list in o2.  It takes the returned value
;  and updates O4.
;in order to get clean semantics, here is what we do:
;  the list tails or CAR's are set to var's O1 to O5
;  the expression to be done inside the loop is (EVAL '(FTN O1 O2 ...))
;Here is stack usage

;P:	old Q
;	old SP
;	ret addr
;	applier	;-3
;	car?	;-4

;Q:	expr to be evaled, i.e. (FTN O1 O2 ..)
;	global for arg n
;	arg n
;	...
;	global for arg 2
;	arg 2
;	global for arg 1
;	arg 1
;	nil
;	ftn
;(P)-->	

;Because we are going to call APPLY, we have to make up a list of arguments.
;At the same time we bind the O1 .. O5, and make up (FN O1 O2 ..)

domap:	push p,sp
	push p,q		;save pointer to bottom of stack frame
	move o3,nil		;o3 - template.  We just build up list with
				;  NIL's in it.
	jumpn o1,map1en		;if there are args, go to entrance of loop
tfa:	err /Too few arguments supplied/

;This loops over all the args, pushing values onto the Q stack.
;Note that the first arg is the ftn.
;  o1 - car, first arg
;  o2 - rest of arg lit
;  o4 - tail of MAPTAB
map1en:	move o4,[%MAPTAB]	;(NIL (O1.(O1))  (O2.(O1 O2)) ...)
map1lp:	jumpe o4,[err /Too many args to MAPxxx function/]
	doboth o1,o1		;o1 - car, first arg; o2 - rest of arg list
	push q,o2		;arg value will go here, now saved CDR list
	push q,o4		;save maptab tail
	call eval
	pop q,o3		;get back maptab tail
	exch o1,(q)		;put value into stack, get back CDR arg list
	doboth o3,o3		;o3 - current MAPTAB entry, o4 - cdr MAPTAB
	docar o5,o3		;need caar - var to bind to
	push q,o5		;push var to bind it to
	push sp,o5		;save old value
	push sp,at%val(o3)
	jumpn o1,map1lp		;more args
;here when all args done.  Better have at least one arg
	skipn (q)
	jrst tfa		;make sure we saw one real arg
	move w3,(p)		;get ftn from bottom of stack
	move o1,1(w3)		;and make up form to eval
	docdr o5,o3		;o5 - (O1 O2 ...)
	docons o2,o1,o5		;o2 - form to eval
	push q,o2
;Now the stacks are set as documented at the beginning.  Start the actual
;mapping.

;outer loop - loop down args until the first one runs out
; init for inner loop which loops over the args for one call
map2lp:	move w3,(p)		;addr of bottom of arg stack
	addi w3,5		;choose offset so = Q when done
;inner loop - loop over the args, setting them into the var's
map3lp:	move o2,-2(w3)		;o1 - next arg
	scons o2
	jrst map2ex		;done when first arg is exhausted
	xct -4(p)		;move o2 or car(o2) to o5
	movem o5,@-1(w3)	;store into value cell of right var
;this is a horrible hack, but SOME and SUBSET look at the value of
;O2 and O5 respectively.  So nothing should interfere with them
;between here and the CALL at MAP3EX+1
	docdr o1,o2		;cdr the arg for next time
	movem o1,-2(w3)
	caml w3,q		;see if done
	jrst map3ex		;yes
	addi w3,2		;no, next arg
	jrst map3lp

map3ex:	move o1,(q)		;get the arg to EVAL
	call @-3(p)		;call the EVAL routine
	jrst map2lp		;try CDR of all the args

map2ex:	pop p,q			;kill Q list
	jrst unbind		;caller will adjust P and supply ret val

;  push p,[car or not]
;  push p,[evaller]
;  call domap


;maplist - this one returns cons'ed list of the results
maplis:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[move o5,o2]	;pass tails, not car
	push p,[codsec,,domlis] ;cons the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;mapcar - this one returns cons'ed list of the results, passing CAR of args
mapcar:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domlis] ;cons the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;this is the applier when results must be consed
domlis:	call eval
	docons o2,o1,nil	;new cell for returned list
	move w3,-1(p)		;pointer to results end
	move o3,(w3)		;old end
	dorpd o3,o2		;put new cell onto list
	movem o2,(w3)		;and make it new end
	ret

;subset - this one returns cons'ed list of the list elements for which
;  the ftn returned T
subset:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domsel] ;cons the items, selectively
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret

;this is the applier for select - cons's the O1 values if return is T
domsel:	push q,o5		;save value to CONS if return is T
	call eval
	pop q,o5
	jumpe o1,cpopj		;nothing if returned false
	docons o2,o5,nil	;new cell for returned list
	move w3,-1(p)		;pointer to results end
	move o3,(w3)		;old end
	dorpd o3,o2		;put new cell onto list
	movem o2,(w3)		;and make it new end
	ret

;mapcon - this one returns nconc'ed results
mapcon:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[move o5,o2]	;not car
	push p,[codsec,,domcon] ;nconc the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret
	
;mapcan - this one returns nconc'ed results, taking CAR of args
mapcan:	docons o2,nil,nil
	push q,o2		;results st, results end
	push q,o2
	push p,[docar o5,o2]	;car
	push p,[codsec,,domcon] ;nconc the results
	call domap
	adjsp p,-2
	pop q,o1		;end of result list - ignore
	pop q,o1		;start of results - cdr is the real start
	docdr o1,o1		;real results
	ret
	
domcon:	call eval
	jumpe o1,cpopj		;nul - leave result alone
;here to nconc new results on.  This would be easy if we wanted to keep
;nconcing the new stuff to the whole list.  But we prefer to remember the
;tail as the current place to nconc to.  This is why we have to treat nil
;specially, because we can't use it, since nconc doesn't really do anything
;to nil
	move w3,-1(p)		;get Q as left by mapcon
	move o2,o1		;new value
	exch o1,(w3)		;end, saving new as new end
	call nconc		;
	ret

;map - this one returns NIL
mapnul:	push p,[move o5,o2]	;not car
	push p,[codsec,,eval] 
	call domap
	adjsp p,-2
	move o1,nil
	ret

;mapc - this one returns nil, and uses the car's
mapc:	push p,[docar o5,o2]	;car
	push p,[codsec,,eval]
	call domap
	adjsp p,-2
	move o1,nil
	ret

;some - this one returns the list 
;  the ftn returned T
some:	push q,nil		;return NIL if all else fails
	push p,[docar o5,o2]	;car
	push p,[codsec,,domsom] ;stop when non-NIL return
	call domap
	adjsp p,-2
	pop q,o1		;results
	ret

;this is the applier for SOME
domsom:	push q,o2		;save value to return if return is T
	call eval
	pop q,o5
	jumpe o1,cpopj		;nothing if returned false
	move w3,-1(p)		;pointer to results end
	movem o5,(w3)		;return this
	setzm -2(q)		;and cause the loop to stop
	ret

;every - this one returns T or NIL
every:	push q,[%T]		;return NIL if all work
	push p,[docar o5,o2]	;car
	push p,[codsec,,domeve] ;stop when NIL return
	call domap
	adjsp p,-2
	pop q,o1		;results
	ret

;this is the applier for EVERY
domeve:	call eval
	jumpn o1,cpopj		;continue if returned T
 ;returned false - stop
	move w3,-1(p)		;pointer to results end
	setzm (w3)		;return NIL
	setzm -2(q)		;and cause the loop to stop
	ret

;UNWIND-PROTECT
;this one is for interpreted code
;  O1 - CDR form.  First is body, others cleanup
unwpro:	push sp,[%UNWCLE]	;rebind cleanup form
	push sp,@[datsec,,.unwcle]
	doboth o1,o1		;body to O1; cleanup forms to O2
	movem o2,@[datsec,,.unwcle] ;save away cleanup forms
	call cunwpr		;form for compiled code
	 jrst cpopj		;exit
	 jrst unwprc		;cleanup
	jrst eval		;body

unwprc:	move o1,@[datsec,,.unwcle] ;get back cleanups
	jrst progn		;treat as progn

;CUNWIND-PROTECT
;special entry for compiled code
;  call cunwpr
;   jrst done
;   jrst cleanup
;  ... body ..., leaving value in O1
;   ret
;cleanup:
;  ... cleanup forms
;  ret
;done:

cunwpr:	move w2,(p)		;get return addr
	xmovei w3,1(w2)		;ret+1 is where to go for cleanup
	tlo w3,(<object ty%adr,0>)
	push sp,[%UNWIND]	;set up unwind trap for it
	push sp,w3
	pushj p,2(w2)		;now call body
	push q,o1		;save return value
	move w2,(p)		;get ret addr again
	setzm @[.unwpro] ;say this is a normal case
	pushj p,1(w2)		;call cleanup code
	adjsp sp,-2		;cancel trap
	ret			;returns to JRST DONE

;CERRSET
;special entry for compiled code
;  move o1,tag
;  call w2,cerrset
;  jrst addr after RET
;  ..code within errset..
;  ret
cerrse:	
  ;construct saved environment for ERRSET
	move w4,(p)		;get ret addr
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w3,p
	tlo w3,(object(ty%adr),0)
	movem w3,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG] ;save F for ERROR
	movem o1,@[datsec,,.ERRFLAG]
	call 1(w4)		;call internal routine
	docons o2,o1,nil	;make list of it - to o2
	move o1,o2		;return list
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst unbind


;(ERRSET E "F")
;if all goes well, return (LIST E)
;ERR and the system error handler return to here
;o1 is cdr form
errset:	
  ;construct saved environment for ERRSET
	docdr o2,o1
	camn o2,nil		;if flag not specified
	skipa o2,[%t]		;then default  o2 _ T
	 docar o2,o2		;else o2 _ F
	push p,sp
	push p,q
	push sp,[%TOPERR]
	push sp,@[datsec,,.TOPERR]
	move w2,p
	tlo w2,(object(ty%adr),0)
	movem w2,@[datsec,,.TOPERR]
	push sp,[%ERRFLAG]
	push sp,@[datsec,,.ERRFLAG]	;save F for ERROR
	movem o2,@[datsec,,.ERRFLAG]
	docar o1,o1		;o1 _ E
	call eval		;result of expr to o1
	docons o2,o1,nil	;make list of it - to o2
	move o1,o2		;return list
	adjsp p,-1		;kill saved Q. saved SP still there
	jrst unbind		;restores old TOPERR

;(ERR code)
;causes most recent ERRSET to return code, except if code = ERRORX,
;  goes to most recent one for which the flag was ERRORX
;code in o1
uerr:	move o2,[%ERR]		;say any unwind is due to error
	movem o2,@[.unwpro]
	camn o1,[%ERRORX]
	jrst uerrx
	move w2,@[datsec,,.TOPERR] ;saved p
	jumpe w2,restc1		;if none saved, just go to top level
	tlz w2,770000		;turn into bare address
	move p,w2		;restore it
	pop p,q			;p now has SP, Q - get back Q
	jrst cubind		;unbind, closing files

;uerrx - search for ERRORX
uerrx:	move w2,@[datsec,,.TOPERR] ;saved p
	jumpe w2,restc1		;if none saved, just go to top level
	tlz w2,770000		;turn into bare address
	move p,w2		;restore it
	pop p,q			;p now has SP, Q - get back Q
	move o2,@[datsec,,.ERRFLAG] ;check most recent errset flag
	camn o2,[%ERRORX]	;if it is ERRORX
	jrst cubind		;unbind, closing files
	pop p,w2		;not done, try again
	call cubin1		;special bind that returns, closing files
	jrst uerrx



;Real Lisp errors, user and system versions.  Break.

;*rset
rset:	exch o1,@[datsec,,rsetf]
	ret

;perror - internal error printer when there is a Lisp object to print
;  in this case the regular arg is in O6 and the Lisp thing in O1
perror:	move w4,[codsec,,errprb] ;routine to print ASCIZ from o6 and thing O1
	jrst errr1

;uerror - error for user. PRINT's its arg
uerror:	skipa w4,[codsec,,uerrpr] ;routine to print error

;error - internal error printer
error:	move w4,[codsec,,errprt] ;special routine for ASCIZ strings
errr1:	move w2,@[datsec,,.TOPERR] ;saved p
	setzb nil,nil1		;in case of funny context
	move o3,[%UEROR]
	movem o3,@[.unwpro]
;if most recent ERRSET is NIL, then ERR NIL [not possible if no ERRSET]
	move o2,nil		;pretend flag is NIL if no ERRSET
	jumpn w2,error2		;it's there - use ERRSET if it is NIL
;if no errset, or not NIL, then probably print message.  Flag from
;errset is in O2.
error1:	
   ;*RSET=ERRORX means no print
	move o3,@[datsec,,rsetf] ;*RSET
	camn o3,[%ERRORX]
	jrst error3
   ;ERRSET flag = 0 means use selected channel
	camn o2,[inum0]
	jrst error4
   ;print on tty
	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push q,o1
	push p,w4
	push q,o6
	call terpri
	pop q,o6
	pop p,w4
	pop q,o1
	call (w4)		;print the thing
	pop sp,@[datsec,,.curout] ;put back I/O channel
	adjsp sp,-1
	jrst error3
   ;print on selected output
error4:	push q,o1
	push p,w4
	push q,o6
	call terpri
	pop q,o6
	pop p,w4
	pop q,o1
	call (w4)
   ;print is done, now break if *RSET is on
error3:	move o1,nil		;for err NIL
	skipn o3,@[datsec,,rsetf] ;*RSET
	jrst uerr		;*RSET is off, ERR NIL
;;;;;;now the break
	push sp,[%%HOOKSTACK]
	push sp,@[datsec,,.%hookstack]
	push sp,[object ty%adr,evhook]
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[%RDTOP]	;save status of RDTOP kludge and clear it
	push sp,@[datsec,,.RDTOP]
	setzm @[datsec,,.RDTOP]
	call clrin		;clear input buffer, just in case
	move o3,[%t]		;turn back on interning
	movem o3,@[datsec,,.dointern] ;in case inside maknam
	docons o2,o3,nil	;(NIL)
	move o3,[%errorx]
	docons o1,o3,o2		;(errorx nil)
	call eval
	jrst restc1

;o1 - thing to eval
hook:	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	call clrin
	push q,o1		;save thing
	docons o2,o1,nil	;now call hook 1 on it
	move o1,[%HOOK1]
	call apply
	move w2,o1		;result is number - get it
	posnum w2
	caig w2,3
	caige w2,0
	movei w2,0
	jrst @[	codsec,,hooks
		codsec,,hookx
		codsec,,hookg
		codsec,,hookb](w2)

hooks:	setz nil1,
	move o1,(q)		;get back thing
	adjsp sp,-2		;skip hook
	move w2,[call delhok]
	movem w2,evhook
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-5		;%CUROUT + eval blip
	adjsp p,-3		;saved sp and q, plus our ret addr
	call eval
	pop q,o2		;original to o2
	jrst stpdis		;show results

;execute
hookx:	setz nil1,
	move o1,(q)		;get back thing
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-5
	adjsp p,-3		;saved sp and q, plus our ret addr
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	call eval
	pop q,o2		;original to o2
	pop sp,evhook		;put back hook
	adjsp sp,-1
	jrst stpdis		;show results

;go
hookg:	setz nil1,
	pop q,o1		;get back thing
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	move w2,[jfcl]
	movem w2,evhook
	ret

hookb:	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	err /Break from single stepper/
	
;stpdis - display results
;o1 - results
;o2 - original
stpdis:	push sp,[%CUROUT]	;save current channel
	push sp,@[datsec,,.curout]
	move o4,@[datsec,,priout] ;and reset to terminal
	movem o4,@[datsec,,.curout]
	push sp,[%CURIN]	;save current channel
	push sp,@[datsec,,.curin]
	move o4,@[datsec,,priin] ;and reset to terminal
	movem o4,@[datsec,,.curin]
	push sp,[object ty%adr,<codsec,,evhook>] ;save and clear hook
	push sp,evhook
	move w2,[jfcl]
	movem w2,evhook
	push q,o1
	docons o3,o2,nil
	docons o2,o1,o3		;now call hook 1 on it
	move o1,[%HOOK2]
	call apply
	pop sp,evhook		;put back hook
	adjsp sp,-1
	pop sp,@[datsec,,.curin]
	adjsp sp,-1
	pop sp,@[datsec,,.curout]
	adjsp sp,-1		;%CUROUT
	pop q,o1
	ret

;DELHOK - set up hook that triggers next time
delhok:	move w2,[call hook]
	movem w2,evhook
	ret

;SSTEP
sstep:	setzm @[datsec,,.%HOOKSTACK]	;start fresh stack
	push sp,[object ty%adr,evhook]
	push sp,evhook
	move w2,[call hook]
	movem w2,evhook
	docar o1,o1
	call eval
	pop sp,evhook		;put back hook
	adjsp sp,-1
	ret

;uerrpr - printer for ERROR.  Uses PRINC
uerrpr:	scons o1		;if cons
	jrst princ		;not - just do princ
;(mapc 'printc o1)
uerrpl:	jumpe o1,retnil		;nothing left to do, done
	pushcdr q,o1
	docar o1,o1		;and do this
	move w4,[%PRINTC]	;yes - call his PRINTC
	call calatm
	pop q,o1
	jrst uerrpl

;errset - If most recent flag was NIL, just do ERR NIL
;if not, leaves the flag in O2 and go to ERROR1
error2:	tlz w2,770000		;turn into bare address - W2 is P
	pop w2,w3		;w3 _ q
	move o2,@[datsec,,.ERRFLAG] ;get most recent flag
	jumpn o2,error1		;if non-NIL flag, ignore errset
	move p,w2		;restore P - SP still on P
	move q,w3		;restore Q	
	move o1,nil		;now return NIL
	jrst cubind		;unbind, closing files

;error printer that first prints a thing in O1
errprb:	push q,o6
	push q,o1
	move o1,[object ty%cst,<codsec,,[asciz /? /]-1>]
	call princ		;without " "
	pop q,o1
	call prin1
	call terpri
	pop q,o1

;special error printer for ASCIZ strings
errprt:	push q,o1		;print ?
	move o1,[object ty%cst,<codsec,,[asciz /? /]-1>]
	call princ		;without " "
	pop q,o1		;now make original arg into string
	hrli o1,(object ty%cst,<codsec,,0>) ;make string ptr
	subi o1,1
	call princ		;and print without " "	
	ret

;This page is functions that could be produced by the compiler,
;and do not depend upon any representations.

copy:	scons o1
	ret			;if not cons cell, then same
;copy car and cdr recursively
	push q,o1		;save original
	docar o1,o1
	call copy		;copy car recursively
	exch o1,(q)		;save copy, get back original
	docdr o1,o1		;copy cdr recursively
	call copy		;copy cdr recursively
	pop q,o2		;back back copy of car to o2
	docons o3,o2,o1		;cons the copies
	move o1,o3		;and return copy
	ret

; COPYLIST -- copy only the top level of a list
coplis:	scons o1
	 ret			;if not cons cell, then same
	pushcar q,o1		;save car
	docdr o1,o1		;copy cdr recursively
	call coplis
	pop q,o2		;get back copy of car to o2
	docons o3,o2,o1		;cons the copies
	move o1,o3		;and return copy
	ret


;The EMACS interface

.scalar edfork,edpc
.vector edacs(20)

;offsets into the editor's (teco's) buffer block
;  all values are byte offsets from the begining of the section unless 
;  otherwise noted. (see INFO:TECORD.INFO for more information)
bufbeg==0			;BEG - start of the buffer
bufbgv==1			;BEGV - virtual start of buffer
bufpt==2			;PT - point in this buffer
bufgpt==3			;GPT - start of gap
bufvz==4			;VZ - virtual end of buffer
bufz==5				;Z - end of buffer
bufext==6			;EXTRAC - size of gap
bufcal==7			; - routine to call for protocol service
bufarg==10			; - argument for above routine
				;   if arg >= 0  then
				;	buffer must be at least that large
				;   else teco will do a jcl read
bufmod=11			;MODIFF - if the buffer was modified
bufrdo=12			;RDONLY - if the buffer is read only


;edkill - kill the current editor fork if it exists
edkill:	skipn nil1,edfork	;is there one?
	 ret			;no, just return
	kfork			;kill it
	rfrkh			;release it's handle
	erjmp .+1		;ignore errors
	setzm edfork		;clear these
	setzm edpc
	setzb nil1,o1
	ret			;end of edkill

;gedfrk - make sure we have an editor fork.  Creating it if needed.
gedfrk:	skipe edfork		;have one already?
	jrst gedfrx		;yes - just return its number
	setzm edpc		;say fork not started
	movsi nil1,(cr%cap)	;pass cap's (mostly ^C)
	cfork
	 jrst [err /Can't create editor fork/]
	movem nil1,edfork	;save fork handle
	movei w2,edsec		;make section for him
	call maksec
	 jrst [err /Can't make section for editor/]
	hrlz nil1,edfork	;fork,,0
	move w2,[.fhslf,,edsec*1000] ;self,,editor section
	move w3,[pm%cnt\pm%rwx\1000] ;the whole section, r/w/x
	pmap
	move nil1,[gj%old\gj%sht]
	hrroi w2,[asciz /SYS:EMACS.EXE/]
	gtjfn
	 jrst [err /Can't open SYS:EMACS.EXE/]
	hrl nil1,edfork		;fork,,jfn
	get			;get EMACS into memory
	setz nil1,
gedfrx:	move w2,edfork		;return the editor's fork handle
	maknum w2		;as a legit number
	move o1,w2
	ret			;end of gedfrk

;edcall - call the editor's FS Superior handler with an arg of O1.
edcall:	skipn edpc		;has editor been run already?
	 jrst [	push q,o1	;no, run then stop the editor
		call edcret
		pop q,o1
		jrst .+1 ]
	call edregs		;get the editor's ACs
	move w4,w2		;save the address of the buffer block
	call get1nt		;get the word integer form of the arg	
	hrli w4,edsec		;create an extended addressing pointer
	movem w2,bufarg(w4)	;save the argument for FS Superior
	push p,edpc		;save the old pc
	movei w3,bufcal(w4)	;get the address of  FS Superior
	movem w3,edpc
	setz o1,
	call edrun		;run it
	pop p,edpc
	ret			;end of edcall

;edjcl - pass some jcl (a string in O1) to the editor
; returns the string
edjcl:	xtype o1
	caie w2,ty%xst		;is arg a string
	 jrst [perr /Not string/]
	move nil1,[<440700,,0>+<1(o1)>]	;point to the user's string
	rscan
	 jrst [err /Can't do RSCAN/]
	setz nil1,
	ret			;end of edjcl

;edregs - read the editor's registers into edacs
; and return the address of the editor's buffer block
edregs:	move nil1,edfork
	move w2,[codsec,,edacs]	;where to put them acs
	rfacs			;get the acs
	setz nil1,
	move w2,edacs+2		;return address of editor's buffer block
	hrli w2,edsec
	ret			;end of edregs

;edrun - start or continue the editor.
; If O1 is non-NIL start the editor, else if it is NIL continue the
; editor unless it wasn't started
edrun:	movei w4,ourtym		;save current terminal status
	call gettym
	skipe edpc		;if editor not started,
	skipe o1		; and start wanted
	 skipa			;then start the editor
	 jrst [	xmovei w4,edtym	;else continue editor
		call settym	;set up EMACS's
		move nil1,edfork
		move w2,edpc
		sfork
		jumpa edwait ]	;and wait for the return
	move nil1,edfork	;start emacs
	setzb w2,edpc		;normal start by default, signal a start
	sfrkv
edwait:	wfork			;wait for it to get back to us
	call edchex		;check for ^C (must be right after wfork)
	xmovei w4,edtym		;get status from editor
	call gettym
	move nil1,edfork
	rfsts
	movem w2,edpc		;save PC for continue
	xmovei w4,ourtym	;and put back ours
	call settym
	setz nil1,		;fix nil
	call edregs		;get the registers of the editor
	move w2,edacs+3		;return the number arg from the FS EXIT
	jrst ret1nt		;end of edrun

;EDCHEX - check exit from editor.  This is to be called
; immediately after each WFORK.  It checks to see if the editor was
; ^C'ed.  If so, it does HALTF, and continues the editor when it is
; continued.  It returns to the instruction before its call, so that
; had better be a wfork.
edchex:	push p,nil1		;save AC1, the fork
	rwm			;look at interrupts
	tlne w2,(1_34.)		;level 1 in progress?
	 jrst edchcc		;yes - ^C
	pop p,nil1		;no, continue normally
	ret			;end of edchex

edchcc:	movei w4,edtym		;save editor terminal status
	call gettym
	movei w4,ourtym		;restore out terminal status
	call settym
	haltf
	movei w4,edtym		;restore editor terminal status
	call settym
	pop p,nil1
	tlo nil1,(sf%con)	;continue fork
	sfork
	tlz nil1,(sf%con)
	sos (p)			;return to WFORK
	sos (p)
	ret			;end of edchcc


tymlen==5		;length of block used to save term params

	.vector ourtym(tymlen),edtym(tymlen)

;gettym - move current terminal parameters into block whose addr is in W4
gettym:	movei nil1,.fhjob	;get job's interrupt word
	rtiw
	dmovem w2,3(w4)
	movei nil1,.priou
	rfmod
	movem w2,0(w4)
	rfcoc
	dmovem w2,1(w4)
	setz nil1,
	ret			;end of gettym

;settym - set terminal parameters from block whose addr is in W4
settym:	movei nil1,.fhjob
	dmove w2,3(w4)
	stiw
	 erjmp .+1
	movei nil1,.priou
	move w2,0(w4)
	sfmod
	stpar
	dmove w2,1(w4)
	sfcoc
	setz nil1,
	ret			;end of settym

;edput - low-level I/O routine
;o2 - channel
;w2 - char
edput:	sosge ch%dat(o2)	;any space left?
	jrst [ 	push p,w2	;make sure these are preserved
		push p,w3
		move o1,o2	;use current channel
		aos ch%dat(o2)	;undo failing SOS
		call edclip	;account for use so far
	       	move o1,[inum 5620.]	;make gap 1K words
		call gedbuf	;try to expand the buffer
		move w2,edacs+2	;see what we got
		hrli w2,edsec
		move w3,bufext(w2)
		movem w3,ch%dat(o2)	;remeber new buffer space
		pop p,w3
		pop p,w2
		jrst edput]	;and try again
	movsi w3,edsec		;byte pointer is indexed off here
	idpb w2,ch%jfn(o2)
	ret			;end of edput

;edget - low-level I/O routine
;o2 - channel
;w2 - char or $eof$ error on end of buffer
edget:	sosge ch%dat(o2)	;any chars left?
	jrst edeof		;no, throw EOF
	hrlzi w3,edsec		;byte pointer is indexed off section
	ildb w2,ch%jfn(o2)
	ret			;end of edget

edeof:	move w2,ch%dat(o2)	;how bad is it?
	came w2,[-1]		;one overrun
	jrst eofbad		;too many - EOF error
	movei w2,33		;at end, give him an ESC
	ret

;errio - low-level I/O routine for an error caused by an illegal
; use of a channel
errio:	err /Illegal use of channel/

;edclrb - clear the buffer
edclrb:	call edcret		;make sure we have a valid buffer
	call edregs		;get editor ACs
	move w3,bufz(w2)	;compute physical size
	sub w3,bufbeg(w2)
	add w3,bufext(w2)
	movem w3,bufext(w2)	;now call it all gap
	move w3,bufbeg(w2)	;everything else at start
	movem w3,bufbgv(w2)
	movem w3,bufpt(w2)
	movem w3,bufgpt(w2)
	movem w3,bufvz(w2)
	movem w3,bufz(w2)
	move w2,bufext(w2)	;return size
	jrst ret1nt

;edwrit - return a channel for writing into a buffer at point
edwrit:	call edcret		;make sure we have a valid buffer
	move o1,[inum 5620.]
	call gedbuf
	call makchn		;returns a new channel object in o1
	move w2,[codsec,,edput] ;use special output routine that puts into buf
	movem w2,ch%put(o1)
  ; now adjust the buffer so there is a reasonable size gap
	move w2,edacs+2
	hrli w2,edsec
	move w3,bufext(w2)	;tell EDGET the gap size
	movem w3,ch%dat(o1)
	move w3,bufpt(w2)	;get start of insert
	adjbp w3,[440703,,0]	;build a byte pointer to it
	movem w3,ch%jfn(o1)	;save it in channel control block
	ret			;end of getbuf

;edgap - ask the editor to move the gap to the end
edgap:	setz o1,		;don't kill currect editor
	skipe edfork		;has the editor been run?
	skipn edpc
	 jrst [	err /Editor has'nt been run/]
	call edregs		;get address of editor's buffer block
	push p,bufpt(w2)	;save old point
	move w3,bufz(w2)	;put point at end
	movem w3,bufpt(w2)
	setzm bufarg(w2)	;ask for the gap to be closed
	push p,edpc		;save old pc
	movei w2,bufcal(w2)	;get FS Superior address
	movem w2,edpc		;and start there
	setz o1,
	call edrun
	move w2,edacs+2
	hrli w2,edsec
	pop p,edpc		;restore old pc
	pop p,bufpt(w2)		;restore point
	ret			;end of edgap

;edread - return a channel for reading from the buffer
edread:	call edgap		;close the gap
	call makchn		;returns a new channel object in o1
	move w2,[codsec,,edget] ;use special input routine that read fr list
	movem w2,ch%get(o1)
	call edregs		;get address of editor's buffer block
	move w3,bufbgv(w2)	;begin of buffer (bytes from start of section)
	adjbp w3,[440703,,0]	;w3 gets byte pointer relative to section
	movem w3,ch%jfn(o1)
	move w3,bufvz(w2)	;end
	sub w3,bufbgv(w2)	;- begin
	movem w3,ch%dat(o1)	;--> length
	ret			;end of edread

;edcret - make sure the editor has a valid buffer
;  run the editor (and tell it to stop) if needed
edcret:	call gedfrk		;make sure we have an editor	
	skipe edpc		;has the editor been run?
	 ret			;yes, done
	move o1,[makstr /ELISP 0FSEXIT/] ;tell him to return
	call edjcl
	call edrun		;start it
	ret			;end of edcret

;gedbuf - make the gap O1 bytes at point
;  returns  the size of the buffer.
gedbuf:	move w2,o1		;get the real size
	posnum w2
	push p,w2		;save the size
	call edcret		;make sure we have a buffer in the editor fork
	call edregs		;get address of editor's buffer block
	move w3,bufpt(w2)	;is it in right place?
	came w3,bufgpt(w2)
	 jrst gedbu0		;no
	move w3,bufext(w2)	;gap size
	caml w3,0(p)		;is it big enough?
	 jrst gedbu1		;yes - nothing to do
;here if we need to ask for more space
gedbu0:	move w3,0(p)		;total buffer size we need (in chars)
	movem w3,bufarg(w2)
	push p,bufpt(w2)	;this is going to move PT to after new space
	push p,edpc		;save old editor pc
	movei w2,bufcal(w2)	;addr to start him at
	movem w2,edpc		;start editor here
	setz o1,
	call edrun
	pop p,edpc		;restore original editor pc
	call edregs		;get the editor's buffer block again
	pop p,w3		;old PT
	sub w3,bufpt(w2)	;old - new PT (negative)
	addm w3,bufpt(w2)	;adjust things to move point back
	addm w3,bufgpt(w2)
	addm w3,bufvz(w2)
	addm w3,bufz(w2)
	movn w3,w3		;now add this garbage into gap
	addb w3,bufext(w2)	;w3 also gets gap size
	camge w3,0(p)		;is it big enough?
	jrst [err /EMACS couldn't make big enough buffer/]	;no
gedbu1:	pop p,w2		;cleanup wanted size
	move w2,w3		;return the buffer size
	jrst ret1nt		;end of gedbuf


;edclip chan - call after done writing - updates point, etc.
edclip:	skipn o1		;if channel =  nil
	 move o1,@[datsec,,.curou]	;use the current output channel
	move w3,ch%put(o1)	;is this an editor channel
	came w3,[codsec,,edput]
	 jrst [ perr /not an editor channel/]	;no, die
	call edregs		;get the address of the editor's buffer block
	move w3,bufext(w2)	;gap when we started
	sub w3,ch%dat(o1)	;- gap now - this is number of char's written
	addm w3,bufz(w2)	;adjust everything
	addm w3,bufvz(w2)
	addm w3,bufgpt(w2)
	addm w3,bufpt(w2)
	movn w3,w3
	addm w3,bufext(w2)
	setzm ch%dat(o1)	;say there is no more space in the buffer
	ret			;end of edclip

;The LINK interface

;LINK does all the work for LOADREL.  We look at BPSEND to find where
;the load should start, and tell LINK by /SET:.LOW:nnn.  We load
;the files the user asked for into section LNKSEC, and then XBLT
;them to the final place in section CODSEC.  Symbols are slightly
;hairy.  The startup code writes out a file ELISP.REL that has all the
;symbols the user is likely to need.  So we tell LINK to look at that
;file.  The bigger problem is getting symbols back.  We have to do that
;because that is the only way to get the entry points.  We can't
;just take back the whole symbol table from the load, because most
;of it will be from ELISP.REL, which is just a copy of symbols we
;already have.  Also, JOBDAT will be there, and we don't really need
;a copy of it either.  Fortunately ELISP and JOBDAT are at the end
;of the load, so what we do is simply stop copying when we get to
;ELISP or JOBDAT.  Another problem is where to put the symbols that
;we get from the load.  My first thought was to reserve a section for
;symbols, and just copy them there.  Alas, DDT is only capable of
;understanding symbols in the section it is running in.  So the
;symbols have to be in CODSEC.  It is nearly impossible to get a
;discontiguous piece for them, since DDT is at the top of the section.
;So I just leave them where they lie, namely at the end of each load.
;I.e. the symbols for this core image are at the end of the original
;code, and each time we do LOADREL, symbols will be at the end of the
;section loaded.  I construct a linked list of symbol blocks,
;pointed to by SYMLST.  This is used by GETSYM.  Alas, DDT doesn't
;understand, so DDT will only see the initial symbols.  Another
;reasonable approach would be to put the symbols right below DDT
;and work down until you meet the code.  I'll let that wait for
;another day...  Note that the block of code loaded by LOADREL
;must be protected by a TY%SPC word, so the GC doesn't try to SCAN it!!
	
.scalar lnkfrk,symlst
		;symlst is the head of a linked list of symbol tables.
		;It points to a block that looks like
		;  ptr to next block
		;  aobjn word for symbol table

lnknam:	asciz /000LNK.TMP;T/

;LOADREL - takes commands to LINK on O1, returns NIL
loadr:	call getstr		;validate the string
	push q,o1		;save string until we have a place to put it
  ;make up .TMP file name
	gjinf			;job number to W3
	move w2,w3		;job number in W2
	setz w4,		;build up in W4
	idivi w2,10.		;low digit to W3
	lshc w3,-7		;shift to W4
	idivi w2,10.
	lshc w3,-7
	idivi w2,10.
	lshc w3,-7		;now have all 3 digits at top end of W4
	add w4,[ascii /000LN/]	;turn into ASCII
	movem w4,lnknam		;and make up full file spec
	movsi nil1,(gj%fou\gj%sht) ;now open it
	hrroi w2,lnknam
  ;open the .TMP file
	gtjfn
	 erjmp [err /Can't create nnnLNK.TMP/]
	move w2,[<7_30.>\of%wr]	;open for text output
	openf
	 erjmp [err /Can't create nnnLNK.TMP/]
  ;now write the LINK command.  Also leaves 1 word for the GC skip pointer
  ;/START:START/PATCHS:0/SEG:LOW/SET:.LOW.:nnn  ELISP:ELISP.REL, user string
	hrroi w2,[asciz \/start:start/patchs:1/seg:low/set:.low.:\]
	setz w3,
	sout
	aos w2,bpsend		;advance past skip pointer
	move w3,[object(ty%spc,0)]
	movem w3,-1(w2)		;put in dummy skip pointer (don't know size)
	tlz w2,777777
	movei w3,8.
	nout
	 jfcl
	hrroi w2,[asciz \ elisp:elisp.rel, \]
	setz w3,
	sout
	pop q,o1		;get back user string
	move w2,[<440700,,0>+<1(o1)>] ;
	sout
	closf	
	 erjmp [err /Can't close nnnLNK.TMP/]
 ;now creat subfork
	skipe lnkfrk		;if already have fork
	jrst loadr1		;don't need to create section again
	movei w2,lnksec		;make section for him
	call maksec
	 jrst [err /Can't make section for LINK/]
loadr1:	skipn nil1,lnkfrk	;if already have fork
	jrst loadr2
	kfork			;kill it
loadr2:	movsi nil1,(cr%cap)	;pass cap's (mostly ^C)
	cfork
	 jrst [err /Can't create LINK fork/]
	movem nil1,lnkfrk	;save fork handle
	hrlz nil1,lnkfrk	;fork,,0
	move w2,[.fhslf,,lnksec*1000] ;self,,link section
	move w3,[pm%cnt\pm%rwx\1000] ;the whole section, r/w/x
	pmap
	move nil1,[gj%old\gj%sht]
	hrroi w2,[asciz /SYS:LINK.EXE/]
	gtjfn
	 jrst [err /Can't open SYS:LINK.EXE/]
	hrl nil1,lnkfrk		;fork,,jfn
	get			;get LINK into memory
	move nil1,lnkfrk	;start LINK
	hrlzi w2,1		;CCL start
	sfrkv
	wfork			;wait for it to get back to us
	call edchex		;check for ^C
  ;now remove ELISP module from symbol table, as we already have it
	move w2,@[lnksec,,116]	;aobjn word for symbol table
	hlre w3,w2		;W3 - neg count
	hrli w2,lnksec		;W2 - address
   ;set W4 to last PNAME except the ELISP one.  Since the ELISP table
   ;is last in memory, we use this as the real end of symbol table, and
   ;thus save all the space taken up by the ELISP table
loadr4:	move nil1,(w2)		;get symbol
	tlne nil1,740000	;ignore if not PNAME
	jrst loadr3
	came nil1,[.rsqz 0,JOBDAT] ;ignore JOBDAT
	camn nil1,[.rsqz 0,ELISP] ;and ELISP
	jrst loadr3		;no
	move w4,w2		;yes - we have a PNAME
loadr3:	addi w3,2
	addi w2,2
	jumpl w3,loadr4
  ;now W4 is address of last PNAME symbol
	addi w4,2		;count the PNAME
	hrrm w4,@[lnksec,,121]	;this is revised .JBFF
	hll w4,@[lnksec,,116]
	sub w4,@[lnksec,,116]	;now have size of symbol table
	movn w4,w4		;negate
	hrlm w4,@[lnksec,,116]	;and revise the magic word
  ;now copy the thing into our address space
	move w2,@[lnksec,,121]	;.JBFF in core image we just loaded
	hll w2,bpsend
	sub w2,bpsend		;compute size of thing loaded
	move w3,bpsend		;place we loaded it
	hrli w3,lnksec
	move w4,bpsend		;place it should go
	addm w2,-1(w4)		;fill in count in GC skip pointer
	aos -1(w4)		;plus 2 for SYMLST entry
	aos -1(w4)
	xblt w2,		;now copy from LNKSEC to final place
  ;now link the symbol table from this piece into the list
	move w2,@[lnksec,,121]	;.JBFF again
	hrli w2,codsec		;in code section this time
	subi w2,1		;last loc used
	push w2,symlst		;next in list
	movem w2,symlst		;this one is now first
	push w2,@[lnksec,,116]	;AOBJN word for this one
	addi w2,1		;first beyond
	movem w2,bpsend		;update BPSEND
	setzb nil1,o1		;return NIL
	ret

;GETSYM - atom or string, returns value, looking up in DDT symbol table
; If more than one value, uses global if possible
getsym:	call getstr		;validate as string
	move w2,[<440700,,0>+<1(o1)>] ;one-word byte pointer to string
	setz w4,		;result will go in W4
	movei w3,6		;maximum of 6 chars
gets0:	ildb nil1,w2
	jumpe nil1,gets1	;done at null
	cain nil1,44		;convert specials
	jrst [movei nil1,46
	      jrst gets2]
	cain nil1,45
	jrst [movei nil1,47
	      jrst gets2]
	cain nil1,56
	jrst [movei nil1,45
	      jrst gets2]
	cail nil1,60		;convert numbers
	caile nil1,71
	jrst gets3		;not number
	subi nil1,60-1
	jrst gets2
gets3:	cail nil1,140		;upper case
	subi nil1,40
	cail nil1,101		;if letter
	caile nil1,132
	jrst gets4		;not
	subi nil1,101-13
	jrst gets2
gets4:	movei nil1,0		;all other - blank
gets2:	imuli w4,50		;shift to accept new char
	add w4,nil1
	sojg w3,gets0		;loop if more char's
  ;all char's done - W4 now has the symbol
gets1:	push p,[0]		;-1(p) - flags
	push p,[0]		;(p) - value
	move w2,symlst		;address of first symbol table
getsnt:	move w3,1(w2)		;AOBJN pointer
getslp:	move nil1,(w3)		;first symbol
	tlce nil1,740000	;if PNAME
	tlcn nil1,740000	;or block name
	jrst getsig		;ignore it
	xor nil1,w4		;else test
	tdne nil1,[037777,,777777] ;any signif bits different?
	jrst getsig		;yes - ignore it
	tlne nil1,040000	;if global, use it and return
	jrst getsgl
	skipe -1(p)		;else use only if nothing there already
	jrst getsig		;something there, ignore new one
	movem nil1,-1(p)	;use new value: save flags
	move nil1,1(w3)		;value
	movem nil1,(p)		;save it
	jrst getsig		;now continue
;here if we find a global - use it now
getsgl:	move w2,1(w3)		;value
	setz nil1,
	adjsp p,-2
	jrst ret1nt

;here to continue search
getsig:	aobjp w3,getsen		;proceed to next symbol
	aobjn w3,getslp
;here if run out for this table
getsen:	move w2,(w2)		;next table
	jumpn w2,getsnt		;process next table
;here when run out of tables to search
	pop p,w2		;value (if any)
	pop p,w3		;flags
	setz nil1,
	tlnn w3,740000		;found anything?
	jrst retnil		;no
	jrst ret1nt		;yes - return integer


	consta			;make sure all pure stuff is down

	variab			;then all variables

inprch:	asciz /*/		;initial prompt

erchin:	"G"-100,,3		;initial ATI specification for ERRCH

rdtab:	rd%nul			;null - should never get through
	rd%let			;^A
	rd%let			;^B
	rd%let			;^C
	rd%let			;^D
	rd%let			;^E
	rd%let			;^F
	rd%eol			;^G - eol
	rd%let			;^H
	rd%sp			;^I - spacing
	rd%eol			;^J - lf
	rd%eol			;^K - vert tab
	rd%eol			;^L - form feed
	rd%eol			;^M - cr
	rd%let			;^N
	rd%let			;^O
	rd%let			;^P
	rd%let			;^Q
	rd%let			;^R
	rd%let			;^S
	rd%let			;^T
	rd%let			;^U
	rd%let			;^V
	rd%let			;^W
	rd%let			;^X
	rd%cmt			;^Y - comment
	rd%cmt			;^Z - comment
	rd%esc			;esc
	rd%let			;^\
	rd%let			;^]
	rd%let			;^^
	rd%let			;^_
	rd%sp			;40 - space
	rd%let			;!
	rd%sq			;"
	rd%let			;#
	rd%let			;$
	rd%let			;%
	rd%let			;&
	rd%drm\rd%let		;'
	rd%lp			;(
	rd%rp			;)
	rd%let			;*
	rd%sgn			;+
	rd%com			;,
	rd%sgn			;-
	rd%per			;.
	rd%sl			;/
	repeat 10.,rd%dig	;0 - 9
	rd%let			;:
	rd%let			;;
	rd%let			;<
	rd%let			;=
	rd%let			;>
	rd%let			;?
	rd%let			;@
	repeat 26.,rd%let	;A - Z
	rd%lb			;[
	rd%let			;\
	rd%rb			;]
	rd%let			;^
	rd%let			;_
	rd%let			;`
	repeat 26.,rd%lc	;a - z
	rd%let			;{
	rd%let			;|
	rd%let			;}
	rd%let			;~
	rd%let			;delete

chntab:	<2_30.>\<codsec,,cncint>	;0 - ^C
	<2_30.>\<codsec,,cndint>	;1 - ^D
	<2_30.>\<codsec,,cneint>	;2 - ^E
	<2_30.>\<codsec,,cngint>	;3 - ^G
	<2_30.>\<codsec,,cnhint>	;4 - ^H
	<2_30.>\<codsec,,cnbint>	;5 - ^B
	0	;6
	0	;7
	0	;8
	<2_30.>\<codsec,,pdlovr>	;9 - PDL overflow (impossible)
	0	;10
	<2_30.>\<codsec,,illins>	;11 - file data error
	0	;12 - disk full
	0	;13
	0	;14
	<2_30.>\<codsec,,illins>	;15 - ill instruction
	<2_30.>\<codsec,,illmem>	;16 - ill mem read
	<2_30.>\<codsec,,illmem>	;17 - ill mem write
	0	;18
	0	;19
	<2_30.>\<codsec,,sysres>	;20 - system resources
	0	;21
	0	;22
	0	;23
	<1_30.>\<codsec,,cnyint>	;24 - ^Y
	<3_30.>\<codsec,,clkint>	;25 - clock
repeat 12.,[0]

clkcnt:	0			;how many times the clock has gone off
clkinc:	0			;how many msec to reset it for (0=don't)
clkfns:	0			;size of table clocker is keeping

gnum:	ascii /G0000/

rerdch:	32		;^Z

fixch:	6		;^F

fremap:	-1		;64 bits
	777777777400

;Start of OBLIST.  This has to go up in the section where garbage
;collection is done.

	normal==.	

	loc 400000	;stay out of the AC's

nbuck==907.		;at the moment the initial core image has 1186
			;atoms.  Might as well use a fairly big table.

;clear bk0 to bk126 to nil

bk0==0 	;don't know why the repeat won't do this

define clrbuk(#buk)
bk!buk==0
termin

repeat nbuck,[
clrbuk .rpcnt]

define getbuk(#buk)
bk!buk
termin

define setbuk(#buk,val)
bk!buk==<object ty%ccn,<datsec,,val>>
termin

define buklnk(atname)
bucket==<.1stwd asciz /atname/>_<-1>
zz==bucket/nbuck
zz==zz*nbuck
bucket==bucket-zz

getbuk bucket
setbuk bucket,.-2
termin

define buknum(atname)
bucket==<atname>_<28.>
zz==bucket/nbuck
zz==zz*nbuck
bucket==bucket-zz

getbuk bucket
setbuk bucket,.-2
termin

define declad(addr)	;declare address block
	object ty%lpi,<codsec,,normal>	;put in pointer to it
highadr==.
	loc normal
	object ty%iadr,<codsec,,addr>
	object ty%cat,<datsec,,highadr-6>
	object ty%iadr,<codsec,,addr>
normal==.
	loc highadr
	termin

;macros for defining atoms

;a simple atom

define declat(atname,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;a simple atom for the character table - its name is one character,
;which is specified as a number.

define declch(#atname,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buknum atname

ch!atname=object ty%cat,<datsec,,.>


;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	atname_29.
nxtent::
termin

;an atom with SUBR property


define declsu(atname,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+12>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsubr>
]
	declad addr
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;DECLLS - LSUBR

define declls(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evlsub>
	declad addr
;ftn defn
	%LSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;DECLSL - LSUBR with funny name

define declsl(atname,lab,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evlsub>
	declad addr
;ftn defn
	%LSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;special version of DECLSU for subr's with special routines designed
;to be called directly from EVAL

define declxs(atname,addr,numarg,evaddr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+12>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evaddr>
	declad addr
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;special version of DECLSU that lets the user supply the name for generated
;symbols, in case of things no unique to 6 char's

define declss(atname,lab,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+12>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsubr>
]
	declad addr
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with SUBR property, atom name starts with *


define starsu(atname,addr,numarg,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+12>
ifle numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsub!numarg>
]
ifg numarg-2,[
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evsubr>
]
	declad addr
;ftn defn
	%SUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,numarg
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;an atom with FSUBR property

define declfs(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evfsub>
	declad addr
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;special version of DECLFS that lets the user supply the name for generated
;symbols, in case of things no unique to 6 char's

define declsf(atname,lab,addr,\nxtent)
object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evfsub>
	declad addr
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;declsp - for special forms that dispatch directly to code

define declxf(atname,addr,evaddr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evaddr>
	declad addr
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with FSUBR property, name starting with *

define starfs(atname,addr,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evfsub>
	declad addr
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;an atom with a value



define declva(atname,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: value
	nil
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

define declsv(atname,prefix,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!prefix=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!prefix:: value
	nil
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;an atom with a value, that begins with a *.  The * is not part of atname

define starva(atname,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk *!atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: value
	nil
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /*!atname/
nxtent::
termin

;This one is defined for MACROEXPANSION.  It has
;FSUBR prop
;VALUE
;an extra argument giving the suffix for the generated labels
;   (since MACROEXPANSION will conflict with MACRO)

define declfv(atname,lab,addr,value,\nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!lab=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!lab::	value
	nil
	object ty%cst,<datsec,,.+10>
	object ty%ccn,<datsec,,.+3>
	object ty%adr,<codsec,,evfsub>
	declad addr
;ftn defn
	%FSUBR
	object ty%ccn,<datsec,,.+1>
	object ty%adr,<codsec,,addr>
	nil
;PNAME - this is a string
	object ty%spc,<nxtent-.-1>
	asciz /atname/
nxtent::
termin

;declbn - this is designed for LAMBDABIND and UNBIND, which LAP
; uses to get at LB1, LB2, ... LB5.  The idea is that
; (GET 'LAMBDABIND 3) should be LB3.

define labnam(prefix,#n)
	 prefix!n termin

define declbn(atname,prefix,howmany,\nxtent,plis)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
	%.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
;property list
plis::
zzz==howmany
repeat howmany-1,[
	object ty%lpi,zzz
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,<labnam prefix,zzz>
	object ty%ccn,<datsec,,.+1>
zzz==zzz-1
]
	object ty%lpi,1
	object ty%ccn,<datsec,,.+1>
	object ty%lpi,prefix!1
	nil
nxtent::
termin

;DECLSY - an atom with a SYM property

define declsy(atname,value,\plis,nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!atname=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!atname:: %.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
plis::
	%SYM
	object ty%ccn,<datsec,,.+1>
	value
	nil
nxtent::
termin

;DECSSY - an atom with a SYM property, with your own prefix

define decssy(atname,prefix,value,\plis,nxtent)
;cons cell in oblist - car is this atom, cdr points to next oblist entry

object ty%cat,<datsec,,.+2>
buklnk atname

%!prefix=object ty%cat,<datsec,,.>
;beginning of atom - value, prop list, pname, ftn def
.!prefix:: %.UNBOUND
	object ty%ccn,<datsec,,plis>
	object ty%cst,<datsec,,.+4>
	nil	
	object ty%adr,<codsec,,evund>
	object ty%iadr,<codsec,,calund>
;PNAME - this is a string
	object ty%spc,<plis-.-1>
	asciz /atname/
plis::
	%SYM
	object ty%ccn,<datsec,,.+1>
	value
	nil
nxtent::
termin



;Here is the oblist, the list of all atoms.  Note that the space used by
;the atoms and their property lists is not in free space.  so if they are
;changed, the GC won't recover the space.

stadrs=normal	;start of area in low seg with addresses

declsu ABS,absf,1
declsu ADD1,add1,1
declsu AEXPLODE,aexplo,1
declss AEXPLODEC,aexpc,aexplc,1
declsu ALIAS,alias,2
declss %ALLOCATE-BPS,albps,albps,2
declxf AND,mand,evand
declsu ANTHCHAR,anthch,2
starsu APPEND,app,2
declls APPEND,uapp
declss APPLY,uapply,uapply,3
starsu APPLY,apply,2
declsu ARG,lxarg,1
declsu ASCII,mascii,1
declsu ASSOC,assoc,2
declxs ATOM,atomp,1,evatom
declsy %ATOM,<object ty%lpi,atomp>
declva BASE,<object ty%lpi,10.>
declsu %BFLAP,%bflap,5
declat BIGNUM
declsu BINOHW,binohw,2
declsu BINOUT,binout,1
declsu BININ,binin,0
declsv #%BKSAVE,bksave,nil
declsy BNDERR,<object ty%lpi,bnderr>
starsu BOOLE,sboole,3
declls BOOLE,boole
declsu BOUNDP,boundp,1
declxs CAR,car,1,evcar
declxs CDR,cdr,1,evcdr
declsu CHRCT,chrct,0
declsu CHRPOS,chrpos,0
declsu CHRVAL,chrval,1
declsu CLOSEF,closef,2
declsu CLOSEIO,xclose,1
declsu CLRBFI,clrbfi,0
declsu CLRHASH,clrhsh,1
declxf COND,docond,evcond
declxs CONS,cons,2,evcons
declsy %CONS,<object ty%lpi,cons>
declsu CONSP,consp,1
declss %CONSTANT-ATOMP,catmp,catmp,1
declat CONTINUOUS
declsu COPY,copy,1
declsu COPYLIST,coplis,1
declfs CSYM,csym
declsu CURPOS,curpos,1
declsu CURRENTIN,inch,0
declss CURRENTOUT,outch,outch,0
declsu DATE,date,0
declsu DEBUGINT,debint,1
declsu DELETEF,delete,2
declss %DEPOSIT-CONSTANT,dconst,dconst,2
declss %DEPOSIT-INSTRUCTION,dinst,dinst,4
declss %DEPOSIT-OBJECT-POINTER,dobj,dobj,2
declss %DEPOSIT-VALUE-REFERENCE,dvalr,dvalr,2
declat DISPATCHADDRESS
declsu DDT,calddt,0
declsu DDTIN,ddtin,1
starsu DIF,diff,2
declsu DIVIDE,divid,2
declsu DOUBLE,double,1
declsu DTIME,dtime,0
declsu EDITCH,setedc,1
declss %EDITOR-BUFFER-SIZE,gedbuf,gedbuf,1
declss %EDITOR-CALL-FORK,edcall,edcall,1
declss %EDITOR-CLEAR-BUFFER,edclrb,edclrb,0
declss %EDITOR-CLIP-BUFFER,edclip,edclip,1
declss %EDITOR-CREATE-FORK,edcret,edcret,0
declss %EDITOR-GET-FORK,gedfrk,gedfrk,0
declss %EDITOR-KILL-FORK,edkill,edkill,0
declss %EDITOR-READ-CHANNEL,edread,edread,0
declss %EDITOR-RUN-FORK,edrun,edrun,1
declss %EDITOR-SET-JCL,edjcl,edjcl,1
declss %EDITOR-WRITE-CHANNEL,edwrit,edwrit,0
declsu ERR,uerr,1
declsu ERRCH,errch,1
declss ERROR,ueror,uerror,1
declat ERRORX
declfs ERRSET,errset
declsy %ERRSET,<object ty%lpi,cerrse>
declxs EQ,eq,2,eveq
declsu EQSTR,eqstr,2
declsu EQUAL,equal,2
declsu EQUALT,equalt,2
declss EVAL,ueval,ueval,2
starsu EVAL,eval,1
declsu EVALV,evalv,2
declfs EVERY,every
declsu EXIT,exit,2
declsu EXPLODE,explod,1
declss EXPLODEC,expc,exploc,1
declat EXPR
declat FEXPR
declsu FIX,fixf,1
declat FIXFN
declat FIXNUM
declsu FLATSIZE,flats,1
declss FLATSIZEC,fltsc,flatsc,1
declsu FLONUM,flonum,1
declsu FNTH,fnth,2
declsy FREE,<object ty%lpi,free>
declat FSUBR
declat FUNARG
declss %FUNCTION-ADDRESS-BLOCK,fadrbl,fadrbl,1
declsu FUNDEF,fundef,1
declsu GC,ugc,0
declsu GCD,gcd,2
declsu GCGAG,xgcgag,1
declsu GCLEFT,gcleft,0
declsu GCTIME,gctime,0
declva GCTRIGGER,nil
declsu GENSYM,gensym,0
declsu GET,xget,2
declsy GETBAR,<object ty%lpi,getbar>
declsu GETBARRAY,getbar,3
declsu GETHASH,gethsh,3
declsu GETSTRING,ugtstr,1
starsu GETSYM,getsym,1
declsu GTFDB,xgtfdb,2
declsu GETIARRAY,getiar,2
declsy GETINT,<object ty%lpi,get1nt>
declsy GETREA,<object ty%lpi,getrea>
declsu GETRARRAY,getrar,2
declsu GETL,getl,2
declsu GETVECTOR,getvec,2
declfs GO,go
starsu GREAT,greatp,2
declat HOOK1
declat HOOK2
declva %HOOKSTACK,nil
declva IBASE,<object ty%lpi,10.>
declat IN
declsv #%INDENT,indent,nil
declat INFIXMACRO
declsu INITPROMPT,iniprm,1
declsu INITFN,initfn,1
declsu INSTRING,instrg,1
declsu INTERN,intern,1
declsu INTLEN,intlen,1
declat INUM
declsu INUMP,inump,1
declsu JFNS,xjfns,2
declat LABEL
declbn %LAMBDABIND,lb,5
declat LAMBDA
declsu LASTC,lastc,1
starsu LESS,lessp,2
declsu LENGTH,length,1
declsu LEXORDER,lexord,2
decssy %LEXPR-ENTRY,lexent,<object ty%lpi,lexent>
declsu LINELENGTH,lineln,1
declsu LINES,lines,1
declls LIST,dolist
declsu LIST1,list1,1
declsu LIST2,list2,2
declsu LIST3,list3,3
declsu LIST4,list4,4
declsu LIST5,list5,5
declsu LITATOM,litat,1
declsy %LITATOM,<object ty%lpi,litat>
declsu LOADREL,loadr,1
declsu LSH,lshf,2
declat LSUBR
declat MACRO
declfv MACROEXPANSION,mexp,mexp,%t
declsu MAKNAM,maknam,1
declsu MAKEARRAY,makary,1
declsu MAKECARRAY,makcar,1
declss MAKE-EQ-HASH-TABLE,mhasht,mhasht,3
declss MAKE-EQL-HASH-TABLE,m1ht,m1ht,3
declss MAKE-EQUALT-HASH-TABLE,m2ht,m2ht,3
declss MAKE-HASH-TABLE,mhasht,mhasht,3
declsu MAKEVECTOR,makvec,1
declfs MAP,mapnul
declfs MAPC,mapc
declfs MAPCAR,mapcar
declfs MAPCAN,mapcan
declfs MAPCON,mapcon
declsu MAPHASH,maphsh,2
declfs MAPLIST,maplis
declsu MEMBERT,memeql,2
declsu METER,umeter,1
declsu MINUS,minus,1
declsu MINUSP,minusp,1
declsu MKATOM,mkatom,1
declsu MKSTRING,mkstr,1
declsu MODCHR,modchr,2
declat MSUBR
declsu MYDIR,mydir,0
declsu MYUSER,myuser,0
declsy N,<object ty%lpi,n>
starsu NCONC,nconc,2
declls NCONC,unconc
declsu NCONS,ncons,1
declsy %NCONS,<object ty%lpi,ncons>
declat NEW
declat NEWVERSION
declsu NUMTYPE,numtyp,1
declsu NEXTEV,nextev,1
declsu NEXTF,nextf,1
declsy NIL1,<object ty%lpi,nil1>
declxs NOT,not,1,evnot
declsu NTHCHAR,nthchr,2
declxs NULL,not,1,evnot
declsu NUMBERP,nump,1
declsy O1,<object ty%lpi,o1>
declsy O2,<object ty%lpi,o2>
declsy O3,<object ty%lpi,o3>
declsy O4,<object ty%lpi,o4>
declsy O5,<object ty%lpi,o5>
declsy O6,<object ty%lpi,o6>
declva OBLIST,<object ty%ccn,<datsec,,obarr>>
declat OLD
declsu OPENF,xopenf,2
declfs OPENIN,xinput
declfs OPENOUT,xoutput
declxf OR,mor,evor
declat OUT
declsu OUTSTRING,oustrg,1
declsu OUTVAL,outval,2
declsy P,<object ty%lpi,p>
declsu PACK,pack,1
declsu PACKC,packc,1
declsl PACK*,packs,packs
declsu PLIST,plist,1
starsu PLUS,plus,2
declat PNAME
declsu %PRIME,prime,1
declsu %PRIMEP,primep,1
declsu PRIN1,prin1,1
declsu PRINC,princ,1
declat %PRINFNTOP
declat PRINLEV
declss PRINT,prin,print,1
declat PRINTC
declfs PROG,prog
declfs PROGN,progn
declsu PROMPT,prompt,1
declsu PUTHASH,puthsh,3
declsu PUTPROP,putp,3
declsy Q,<object ty%lpi,q>
declxf QUOTE,evalqu,evquot
starsu QUO,quot,2
starva RAISE,nil
declat RATIO
declsu RDNAM,rdnam,0
declsu READ,read,0
declsu READCH,readch,0
declfs READCONTEXT,rdcntx
decssy %READCONTEXT,rdctx,<object ty%lpi,crdctx>
declsu READLIST,readls,1
declat READMACRO
declsu READP,readp,0
declsu REMAINDER,rem,2
declsu REMHASH,remhsh,2
declfs REMOB,remob
declsu REMPROP,remp,2
declsu RENAMEF,rename,3
declsu RPLSTRING,rplstr,3
declsu REREADCH,setrrd,1
declsy RETINT,<object ty%lpi,ret1nt>
declsy RETREA,<object ty%lpi,retflo>
declsu RETURN,return,1
declsu ROUND,round,1
declsu RPLACA,rplaca,2
declsu RPLACD,rplacd,2
declsu RPLACPLIST,rplacp,2
starsu RSET,rset,1
declsu SASSOC,sassoc,3
declfs SAVEIMAGE,xsave
declsu SELECTIN,inc,2
declss SELECTOUT,outc,outc,2
declsu SET,set,2
declsu SETARG,lxsarg,2
declsy SETBAR,<object ty%lpi,setbar>
declsu SETBARRAY,setbar,4
declsu SETCHR,setchr,2
decssy %SET-BCP,setbcp,<object ty%lpi,setfsp>
declss %SET-FUNCTION-ENTRY,sftne,sftne,4
declsu SETIARRAY,setiar,3
declxf SETQ,setq,evsetq
declsu SETPOS,setpos,2
declsu SETRARRAY,setrar,3
declsu SETV,setv,3
declsu SETVECTOR,setvec,3
declva %SLASH,<char "/">
declfs SOME,some
declsy SP,<object ty%lpi,sp>
declsu SPDLFT,spdlft,1
declsu SPDLPT,spdlpt,0
declsu SPDLRT,spdlrt,1
declsu SPEAK,speak,0
declsu SPREDO,spredo,1
declsu SPREVAL,sprevl,2
declat SPLICEMACRO
declat SPRINT
declfs SSTEP,sstep
declsu STARTCLOCK,stclk,2
starsu STCONCAT,concat,2
declva %%STKLIM,nil
declsu STLENGTH,stlen,1
declsu STNTH,stnth,2
declsu STOPCLOCK,stpclk,0
declsu STRINGP,strp,1
declsu STKPTR,stkptr,1
declsu SUB1,sub1,1
declat SUBR
declfs SUBSET,subset
declsu SXHASH,sxhash,1
declat SYM
declva T,%t
declsu TALK,talk,0
declsu TERPRI,terpri,1
declsu TIME,runtim,0
starsu TIMES,times,2
declss **TOP**,top,restar,0
declsu TTYECHO,ttecho,0
declsu TTYPAUSE,ttpaus,1
declsu TYI,tyi,0
declsu TYO,tyo,1
declbn %UNBIND,ub,5
declsu UNBOUND,unbnd,0
declsy %UNDEFLABEL,<object ty%lpi,udflab>
declsu UNTYI,xuntyi,1
declsf UNWIND-PROTECT,unwpro,unwpro
 .unwpro=<addbts&%unwpro>
decssy %UNWIND-PROTECT,uwpr,<object ty%lpi,cunwpr>
declsu UPTIME,uptime,0
declsu VECTORBLT,vecblt,5
declsu VECTORLENGTH,veclen,1
declsu VECTORP,vecp,1
declat WILD
declfs WITHIN,within
decssy %WITHIN,wthin,<object ty%lpi,cwthin>
declfs WITHOUT,withou
decssy %WITHOUT,wthou,<object ty%lpi,cwthou>
declsy W2,<object ty%lpi,w2>
declsy W3,<object ty%lpi,w3>
declsy W4,<object ty%lpi,w4>
declsu XCONS,xcons,2
declsy %XCONS,<object ty%lpi,xcons>
declsu ZEROP,zerop,1
declat $EOF$
starva NOPOINT,%t
declsy NIL,<object ty%lpi,nil>

;now atoms for character mapping

chval==0

repeat 200,[
ifn chval-"T",[ifn chval-"N",[ifn chval-"Q",[ifn chval-"P",[declch chval]]]]
chval==chval+1]

obarr:

;now deposit the buckets here

define defbuk(#buk)
bk!buk
termin

repeat nbuck-1,[
defbuk .rpcnt
object ty%ccn,<datsec,,.+1>]

defbuk nbuck-1
nil

;array to go from integer character's to char atoms

define defchr(#chr)
ifn chr-"T",[ifn chr-"N",[ifn chr-"Q",[ifn chr-"P",[ch!chr]]]]
ife chr-"T",%T
ife chr-"N",%N
ife chr-"Q",%Q
ife chr-"P",%P
termin

chval==0

charar:	
repeat 200,[
defchr chval
chval==chval+1]


;everything below here is not on the oblist, but will be translated by the
;GC.  This is the place to put variables that you want the GC to look at.

;first we have a list of values used internally.  These are required to
;be atoms, but we don't want the user using them.  So we keep them off
;the OBLIST.

declat .UNBOUND

enadrs=normal	;end of area in section 1 with address blocks

;;TY%ATM - the usefulness of this depends upon at%val=0.
;DECLFU for declaring funny things.  These are repositories for storing
;values that must be stacked and restored.  They differ from atoms only
;in that 

define declfu(obj,val)
%!obj=object ty%adr,<datsec,,.>
.!obj:	val
termin

declfu GOLIST,nil		;goto list for prog
declfu PRET,nil			;saved context to RETURN out of prog
declfu PNEXT,nil		;PC for prog interpreter
declfu PTOP,nil			;saved context in prog interpreter for GO
declfu TOPERR,nil		;saved context for ERRSET/ERR
declfu ERRFLAG,nil		;saved flag for ERRSET/ERR
declfu CURIN,nil		;current input channel
declfu CUROUT,nil		;current output channel
declfu DOINTERN,%t		;flag controlling whether READ calls INTERN
declfu SAVEP,nil		;used to flag saved P for eval blip
declfu LXVARS,nil		;addr of base of variables for LEXPR
declfu LXNUM,nil		;number of variables
declfu RDTOP,nil		;saved context for aborting READ
declfu CFILES,nil		;file to close in WITHIN/WITHOUT
declfu UNWIND,nil		;dummy - used by unwind trap
declfu UNWCLE,nil		;cleanup form for UNWIND-PROTECT
declfu GCGAG,nil		;print message at GC
declfu DEBIOK,%t		;OK to interrupt on ^E, ^Y, etc.
  ;cfiles contains alternate saved SP, channel.  The idea is that if
  ;SP is ever restored to less than the saved value, that channel
  ;should be closed, and the entry popped off CFILES.

;initfi is ("file"), i.e. arg for XINPUT, which is FEXPR
initfi:	object ty%cst,<datsec,,.+2>
	0
	object ty%spc,<infien-initfi-3>
	asciz /BOOT.INIT/
infien:

;(NIL (O1.(O1)) (O2.(O1 O2))  (O3.(O1 O2 O3)) ... O5)
;used in DOMAP

%maptab=object ty%ccn,<datsec,,.>
maptab:	nil
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt1>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt2>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt3>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt4>
	object ty%ccn,<datsec,,.+1>
	object ty%ccn,<datsec,,mapt5>
	nil

mapt1:	%o1
	object ty%ccn,<datsec,,maptl1>

mapt2:	%o2
	object ty%ccn,<datsec,,maptl2>

mapt3:	%o3
	object ty%ccn,<datsec,,maptl3>

mapt4:	%o4
	object ty%ccn,<datsec,,maptl4>

mapt5:	%o5
	object ty%ccn,<datsec,,maptl5>

maptl1:	%o1
	nil

maptl2:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	nil

maptl3:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	nil

maptl4:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	object ty%ccn,<datsec,,.+1>
	%o4
	nil

maptl5:	%o1
	object ty%ccn,<datsec,,.+1>
	%o2
	object ty%ccn,<datsec,,.+1>
	%o3
	object ty%ccn,<datsec,,.+1>
	%o4
	object ty%ccn,<datsec,,.+1>
	%o5
	nil

tail==ch%666-5

;;TY%CHN
binchn:	object ty%spc,ch%666
	0
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

.binchn==<object ty%cch,<datsec,,binchn>>

;;TY%CHN
inchn:	object ty%spc,ch%666
	.priin
	72.
	72.
	codsec,,trmget
	codsec,,norput
	block tail

;;TY%CHN
outchn:	object ty%spc,ch%666
	.priou
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

;DUMCHN is a dummy channel for use by EXPLODE and similars.  Note
;that this makes all such routines non-reentrant.
;;TY%CHN
dumchn:	object ty%spc,ch%666
	0
	72.
	72.
	codsec,,norget
	codsec,,norput
	block tail

oldopt:	%OLD
	object ty%ccn,<datsec,,.+1>
	%UEROR
	nil

.dumchn==<object ty%cch,<datsec,,dumchn>>

clktab:	nil			;fn call histogram table for CLOCK fns
rsetf:	nil		;*rset value
initf:	nil		;init function
priin:	object ty%cch,<datsec,,inchn> ;initial value for curin
priout:	object ty%cch,<datsec,,outchn> ;initial value for curout

endobl:

	loc normal

	end start
   