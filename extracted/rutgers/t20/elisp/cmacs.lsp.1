
| Define Compiler Action for a function.  
|  eff = t if function has side effects.
|  args = number of args if fixed, (low . opt) bounds if some optional,
|    f and f2 are for fsubrs
|    l is for Lexpr's
|    w and z are for (+ a (+ b (+ c d))) type expansions
|    cmacro is a direct substitution form
|    xmacro is a normal type macro for within the compiler use
|    macro means the function has a normal macro defn to be used as xmacro
|  def (if present) depends on args:
|    for w and z it is the internal fn to be used in the expansion
|    for cmacro it is the substitution form (car = "variables", cadr = form)
|    for xmacro it's the macro function
|  note that these macros are used in pass one of the compiler (&pa1).
|  it is assumed that &pa1 calls itself recursively on the result of
|  the expansion. (eg, the w & z macros don't recurse themselves.)

(df dca (foo)
    (let (((fun eff args def) foo))
	 (put fun eff 'fxp)
	 (selectq args
	  [l (put fun '(lexpr) 'cfntype)]
	  [f (put fun '(fexpr 1) 'cfntype)]
	  [f2 (put fun '(fexpr 2) 'cfntype)]
	  [w (put fun `(lambda (x) (cond [(null (cdddr x))
					  (cons ',def (cdr x))]
					 [t (list ',def (cadr x)
						  (cons (car x) (cddr x)))]))
		  'xmacro)]
	  [z (put fun `(lambda (x)
			(cond [(null (cdddr x)) (cons ',def (cdr x))]
			      [t (mcons (car x) (list ',def (cadr x)
						      (caddr x))
					(cdddr x))]))
		  'xmacro)]
	  [& (put fun `(lambda (x)
			(cond [(null (cdddr x)) (cons ',def (cdr x))]
			      [t (list 'and (list ',def (cadr x) (caddr x))
				            (cons (car x) (cddr x)))]))
		  'xmacro)]
	  [(cmacro xmacro) (put fun def args)]
	  [macro (cond ((memq (car (fundef fun)) '(subr fsubr msubr))
			(put fun (fundef fun) 'xmacro))
		       (t (put fun (cdr (fundef fun)) 'xmacro)))]
	  (put fun (list 'expr args) 'cfntype))
	 ()))

(deflist (oblist throw catch rptn) fluid)
| make all the vars documented in the manual SPECIAL
(deflist (Allfns ; ;; Allvals Allstrs Allfiles Base Commentstr Ibase /#%Indent
	 Membfn Noprettyprops Oblist Ppmaxlen Prettyflg Prettyprops 
	 %Prinfn %Prinfntop *Raise *Nopoint *Raisedsk *Nopointdsk
	 Macroexpansion %Slash)
 fluid)
(dca /#/# nil f)
(dca $$ nil f)
(dca %allocate-bps t 2)
(dca %constant-atomp nil 1)
(dca %deposit-function-linkage t 2)
(dca %deposit-instruction t 4)
(dca %deposit-object-pointer t 2)
(dca %deposit-value-reference t 2)
(dca %editor-buffer-size t 1)
(dca %editor-call-fork t 1)
(dca %editor-clear-buffer t 0)
(dca %editor-clip-buffer t 1)
(dca %editor-create-fork t 0)
(dca %editor-get-fork t 0)
(dca %editor-kill-fork t 0)
(dca %editor-read-channel t 0)
(dca %editor-run-fork t 1)
(dca %editor-set-jcl t 1)
(dca %editor-write-channel t 0)
(dca %set-function-entry t 4)
(dca * nil 2)
(dca **top** t 0)
(dca *append nil 2)
(dca *apply t 2)
(dca *bexpand nil 2)
(dca *bexpand1 nil 3)
(dca *boole nil 3)
(dca *dif nil 2)
(dca *edit t 1)
(dca *eval t 1)
(dca *expand nil 2)
(dca *expand1 nil 2)
(dca *expand2 nil 2)
(dca *function nil spec)
(dca *getsym nil 1)
(dca *great nil 2)
(dca *less nil 2)
(dca *max nil 2)
(dca *min nil 2)
(dca *nconc t 2)
(dca *pg* t 0)
(dca *plus nil 2)
(dca *quo nil 2)
(dca *rset t 1)
(dca *rseterx t 1)
(dca *stconcat nil 2)
(dca *times nil 2)
(dca + nil 2)
(dca +i nil 1)
(dca - nil 2)
(dca -i nil 1)
(dca // nil 2)
(dca ; nil cmacro (u ()))
(dca ;; nil cmacro (u ()))
(dca = nil 2 equal)
(dca =0 nil 1 zerop)
(dca ?= t 1)
(dca abs nil 1)
(dca add1 nil 1)
(dca addprop t 3)
(dca aexplode nil 1)
(dca aexplodec nil 1)
(dca alias t 2)
(dca and nil spec)
(dca anthchar nil 2)
(dca append nil w *append)
(dca apply t ((3 . apply) (2 . *apply)))
(dca *apply t 2)
(dca apply/# t 2)
(dca aremove t 2)
(dca arg nil 1)
(dca array t f)
(dca ascii nil 1)
(dca assoc nil 2)
(dca assoc/# nil 2)
(dca assoc-equal nil 2)
(dca atom nil 1)
(dca attach t 2)
(dca back-quote t macro)
(dca binin t 0)
(dca binout t 1)
(dca boole nil xmacro boomac)
(de boomac (form)
    (cond [(cddddr form) `(*boole ,(cadr form) ,(caddr form)
				  ,(boomac (cons nil (cons (cadr form)
						  (cdddr form))))]
	  [t `(*boole ,(cadr form) ,(caddr form) ,(cadddr form))]))
(dca boundp nil 1)
(dca break t f)
(dca break0 t 3)
(dca break0a t 4)
(dca break1 t 5)
(dca breakin t f)
(dca caaaar nil cmacro ((u) (car (car (car (car u))))))
(dca caaadr nil cmacro ((u) (car (car (car (cdr u))))))
(dca caaar nil cmacro ((u) (car (car (car u)))))
(dca caadar nil cmacro ((u) (car (car (cdr (car u))))))
(dca caaddr nil cmacro ((u) (car (car (cdr (cdr u))))))
(dca caadr nil cmacro ((u) (car (car (cdr u)))))
(dca caar nil cmacro ((u) (car (car u))))
(dca cadaar nil cmacro ((u) (car (cdr (car (car u))))))
(dca cadadr nil cmacro ((u) (car (cdr (car (cdr u))))))
(dca cadar nil cmacro ((u) (car (cdr (car u)))))
(dca caddar nil cmacro ((u) (car (cdr (cdr (car u))))))
(dca cadddr nil cmacro ((u) (car (cdr (cdr (cdr u))))))
(dca caddr nil cmacro ((u) (car (cdr (cdr u)))))
(dca cadr nil cmacro ((u) (car (cdr u))))
(dca car nil 1)
(dca catch t xmacro catchmac)

(DE CATCHMAC (L)
 (COND [(NULL (CDDR L))
	(LIST 'PROGN (LIST '%CATCH (LIST 'ERRSET (CADR L))) 'THROW)]
       [(ATOM (CADDR L))
	(LIST 'COND
	      (LIST (LIST '%CATCH (LIST 'ERRSET (CADR L))) 'THROW)
	      (LIST (LIST 'EQ 'CATCH (LIST 'QUOTE (CADDR L))) 'THROW)
	      (LIST (LIST 'ERR (LIST 'QUOTE 'THROW))))]
       [T (LIST 'COND
		(LIST (LIST '%CATCH (LIST 'ERRSET (CADR L))) 'THROW)
		(LIST 'T
		      (MCONS 'SELECTQ 'CATCH (APPEND (CDDR L) '((ERR 'THROW)))))
	   )]))

(dca %catch t 1)
(dca cdaaar nil cmacro ((u) (cdr (car (car (car u))))))
(dca cdaadr nil cmacro ((u) (cdr (car (car (cdr u))))))
(dca cdaar nil cmacro ((u) (cdr (car (car u)))))
(dca cdadar nil cmacro ((u) (cdr (car (cdr (car u))))))
(dca cdaddr nil cmacro ((u) (cdr (car (cdr (cdr u))))))
(dca cdadr nil cmacro ((u) (cdr (car (cdr u)))))
(dca cdar nil cmacro ((u) (cdr (car u))))
(dca cddaar nil cmacro ((u) (cdr (cdr (car (car u))))))
(dca cddadr nil cmacro ((u) (cdr (cdr (car (cdr u))))))
(dca cddar nil cmacro ((u) (cdr (cdr (car u)))))
(dca cdddar nil cmacro ((u) (cdr (cdr (cdr (car u))))))
(dca cddddr nil cmacro ((u) (cdr (cdr (cdr (cdr u))))))
(dca cdddr nil cmacro ((u) (cdr (cdr (cdr u)))))
(dca cddr nil cmacro ((u) (cdr (cdr u))))
(dca cdr nil 1)
(dca chrct nil 0)
(dca chrpos nil 0)
(dca chrval nil 1)
(dca clock t f)
(dca closef t 2)
(dca closeio t 1)
(dca clrbfi t 0)
(dca cond t spec)
(dca concat nil 2)
(dca cons nil 2)
(dca consp nil 1)
(dca copy nil 1)
(dca create-structure t 2)
(dca csym t f)
(dca curpos nil 1)
(dca currentin nil 0)
(dca currentout nil 0)
(dca date nil 0)
(dca ddt t 0)
(dca ddtin t 1)
(dca de t f)
(dca debugint t 1)
(dca declare nil cmacro (u (progn . u)))
(dca decr t macro)
(dca deflist t f)
(dca defp t f)
(dca defprop t f)
(dca defv t f)
(dca deletef t 2)
(dca delim nil 1)
(dca df t f)
(dca difference nil z *dif)
(dca dir nil 1)
(dca divide nil 2)
(dca dm t f)
(dca do t macro)
(dca double nil 1)
(dca dremove t 2)
(dca dreverse t 1)
(dca drm t f)
(dca ds t f)
(dca dskin t f)
(dca dskout t f)
(dca dsm t f)
(dca dsubst t 3)
(dca dtime nil 0)
(dca dv t f)
(dca edit t f)
(dca edite t 3)
(dca editexpr t 1)
(dca editf t f)
(dca editfindp t 3)
(dca editfns t f)
(dca editfpat t 1)
(dca edith t 1)
(dca editl t 5)
(dca editp t f)
(dca editv t f)
(dca elisp: nil cmacro (u (progn . u)))
(dca enter t 2)
(dca eq nil 2)
(dca eqp nil 2)
(dca eqstr nil 2)
(dca equal nil 2)
(dca equalt nil 2)
(dca err t 1)
(dca errch t 1)
(dca error t 1)
(dca errorx t 1)
(dca errset t f)
(dca eval t ((2 . eval) (1 . *eval)))
(dca evalv nil 2)
(dca every t f)
(dca exit t 2)
(dca explode nil 1)
(dca explodec nil 1)
(dca f: t f)
(dca f:l t cmacro (u (function (lambda . u))))
(dca fix nil 1)
(dca flap t 1)
(dca flatsize nil 1)
(dca flatsizec nil 1)
(dca flonum nil 1)
(dca fnth nil 2)
(dca forms: t f)
(dca free t 1)
(dca freelist t 1)
(dca from?= t 1)
(dca function nil spec)
(dca fundef nil 1)
(dca gc t 0)
(dca gcd nil 2)
(dca gcgag nil 1)
(dca gctime nil 0)
(dca ge nil 2)
(dca gensym t 0)
(dca get nil 2)
(dca getall nil 2)
(dca getbarray nil 3)
(dca getdef t f)
(dca getiarray nil 2)
(dca getl nil 2)
(dca getlall nil 2)
(dca getrarray nil 2)
(dca getsym nil f)
(dca getvector nil 2)
(dca go t spec)
(dca greaterp nil & *great)
(dca gt nil 2)
(dca gtfdb nil 2)
(dca hook1 nil 1)
(dca hook2 nil 2)
(dca iascii nil 1)
(dca inc t 2)
(dca inch nil 0)
(dca incr t macro)
(dca initfn t 1)
(dca initprompt t 1)
(dca inp nil 2)
(dca input t f)
(dca insert t 4)
(dca intern t 1)
(dca intersection nil 2)
(dca inump nil 1)
(dca jfns nil 2)
(dca last nil 1)
(dca lconc t 2)
(dca ldiff nil 2)
(dca le nil 2)
(dca length nil 1)
(dca lessp nil & *less)
(dca lexorder nil 2)
(dca linelength nil 1)
(dca lineread t 1)
(dca lines t 1)
(dca list nil l)
(dca list1 nil 1)
(dca list2 nil 2)
(dca list3 nil 3)
(dca list4 nil 4)
(dca list5 nil 5)
(dca litatom nil 1)
(dca lookup nil 2)
(dca lsh nil 2)
(dca lsubst nil 3)
(dca lt nil 2)
(dca macroexpansion t cmacro ((x y) x))
(dca makearray t 1)
(dca makecarray t 1)
(dca makevector t 1)
(dca maknam nil 1)
(dca map t f)
(dca mapatoms t cmacro ((u) (mapc (function (lambda (%mapatoms%arg%)
					  (mapc u %mapatoms%arg%))) oblist)))
(dca mapc t f)
(dca mapcan t f)
(dca mapcar t f)
(dca mapcl t cmacro (u (mapcar . u)))
(dca mapcon t f)
(dca mapconc t cmacro (u (mapcan . u)))
(dca mapl t cmacro (u (maplist . u)))
(dca maplist t f)
(dca max nil w *max)
(dca mbd: t f)
(dca mcons nil w cons)
(dca memb nil 2)
(dca member nil 2)
(dca membert nil 2)
(dca memcdr nil 2)
(dca memq nil 2)
(dca merge nil 4)
(dca meter nil 1)
(dca min nil w *min)
(dca minus nil 1)
(dca minusp nil 1)
(dca mkatom nil 1)
(dca mkstring nil 1)
(dca modchr t 2)
(dca msg t xmacro msgmac)
(de msgmac (form)
    (append '(progn) (mapcar (function (lambda (x)
			  (cond [(eq x t) '(terpri)]
				[(stringp x) `(prinac ,x)]
				[(numberp x) (if (gt x 0) `(spaces ,x)
						 `(lines ,(- 0 x)))]
				[(atom x) `(prina ,x)]
				[(eq t (car x)) `(tab ,(cadr x))]
				[(eq 'e (car x)) (cadr x)]
			        [(eq 'c (car x)) (list 'princ (cadr x))]
				[t `(prin1 ,x)])))
			 (cdr form))
	    '(nil)))
(dca mydir nil 0)
(dca myuser nil 0)
(dca nconc t w *nconc)
(dca nconc1 t cmacro ((u v) (*nconc u (ncons v))))
(dca ncons nil 1)
(dca ne nil 2)
(dca neq nil cmacro ((x y) (not (eq x y))))
(dca nextev nil 1)
(dca nextf nil 1)
(dca nill nil cmacro (u ()))
(dca nocall nil cmacro (u ()))
(dca nocompile nil cmacro (u ()))
(dca not nil 1)
(dca notany nil macro)
(dca notevery nil macro)
(dca nouuo t 1)
(dca nth nil 2)
(dca nthchar nil 2)
(dca null nil 1)
(dca numberp nil 1)
(dca numtype nil 1)
(dca openf t 2)
(dca openin t f)
(dca openout t f)
(dca or nil spec)
(dca outc t 2)
(dca outch nil 0)
(dca output t f)
(dca outval t 2)
(dca p: t f)
(dca pack nil 1)
(dca pack* nil l)
(dca packc nil 1)
(dca patom nil 1)
(dca peekc t 0)
(dca plev t 1)
(dca plist nil 1)
(dca plus nil w *plus)
(dca pop t macro)
(dca pp t f)
(dca pp-comment t 1)
(dca pp-do t 1)
(dca pp-format t 3)
(dca pp-function t 3)
(dca pp-labels t 1)
(dca pp-lseg t 4)
(dca pp-miser t 1)
(dca pp-rmacs t 3)
(dca pp-special t 1)
(dca pp-struct t 3)
(dca pp-value t 3)
(dca pp; t f)
(dca ppl t f)
(dca ppl; t f)
(dca prevev nil 1)
(dca prin t 1)
(dca prin1 t 1)
(dca prina t 2)
(dca prinac t 2)
(dca princ t 1)
(dca prinl t 2)
(dca prinlc t 2)
(dca prinlev t 2)
(dca print t 1)
(dca printc t 1)
(dca printlev t 2)
(dca prog t spec)
(dca prog1 nil spec)
(dca prog2 nil spec)
(dca progn nil spec)
(dca prompt t 1)
(dca push t macro)
(dca put t 3)
(dca putlist t 3)
(dca putprop t 3)
(dca quote nil spec)
(dca quotient nil w *quo)
(dca rdnam t 0)
(dca read t 0)
(dca readch t 0)
(dca readcontext t f)
(dca readl t 1)
(dca readlist t 1)
(dca readp nil 0)
(dca remainder nil 2)
(dca remlist t 2)
(dca remob t f)
(dca remove nil 2)
(dca remprop t 2)
(dca remprops t 2)
(dca renamef t 3)
(dca retfrom t 2)
(dca return t 1)
(dca reverse nil 1)
(dca round nil 1)
(dca rplaca t 2)
(dca rplacd t 2)
(dca rplacplist t 2)
(dca rplstring t 3)
(dca rptq t cmacro ((u . v) (prog (rptn rpt%limit)
				  (setq rpt%limit u)
				  (setq rptn 1)
			     loop (and (gt rptn rpt%limit) (return ()))
			          (progn . v)
				  (setq rptn (add1 rptn))
				  (go loop))))			          
(dca sassoc t 3)
(dca save t f)
(dca saveimage t f)
(dca selectin t 2)
(dca selectout t 2)
(dca selectq t xmacro selmac)
(de selmac (x)
    `((lambda (%selectq)
	      (cond ,,(maplist
		       (function (lambda (y) (cond [(cdr y)
				       (cond [(atom (caar y))
					      `[(eq %selectq ',(caar y))
						,,(cdar y)]]
					     [t `[(memq %selectq ',(caar y))
						  ,,(cdar y)]])]
				      [t `[t ,(car y)]])))
		       (cddr x))))
      ,(cadr x)))
(dca set t 2)
(dca setarg t spec)
(dca setbarray t 4)
(dca setchr t 2)
(dca setiarray t 3)
(dca setpos t 2)
(dca setq t spec)
(dca setrarray t 3)
(dca setv t 3)
(dca setvector t 3)
(dca some t f)
(dca sort nil 3)
(dca spaces t 2)
(dca spdlft nil 1)
(dca spdlpt nil 0)
(dca spdlrt nil 1)
(dca speak nil 0)
(dca spredo t 1)
(dca spreval t 2)
(dca sprint t 2)
(dca sstep t f)
(dca st: t f)
(dca startclock t 2)
(dca stconcat nil w *stconcat)
(dca stkcount nil 3)
(dca stkname nil 1)
(dca stknth nil 2)
(dca stkptr nil 1)
(dca stksrch nil 3)
(dca stlength nil 1)
(dca stnth nil 2)
(dca stopclock t 0)
(dca store t xmacro storemac)
(DE STOREMAC (L)
  (COND ((GET (READLIST (APPEND (EXPLODEC "STORE-") (EXPLODE (CAADR L))))
	      'XMACRO) {;; structure}
	 (LIST (READLIST (APPEND (EXPLODEC "STORE-") (EXPLODE (CAADR L))))
	       (CADADR L)
	       (CADDR L)))
	(T {;; array}
         (LIST (READLIST (APPEND (EXPLODE (CAADR L)) (EXPLODEC "~STORE")))
               (CONS (READLIST (APPEND (EXPLODE (CAADR L)) (EXPLODEC "~SUBS")))
	             (CDADR L))
               (CADDR L)))))
(dca stringp nil 1)
(dca structurep nil 1)
(dca sub1 nil 1)
(dca sublis nil 2)
(dca subpair nil 3)
(dca subpr nil 3)
(dca subset t f)
(dca subst nil 3)
(dca substring nil 3)
(dca tab t 1)
(dca tailp nil 2)
(dca talk t 0)
(dca tconc t 2)
(dca terpri t 1)
(dca throw t xmacro throwmac)
(DE THROWMAC (L)
 (LIST 'PROGN
       (LIST 'SETQ 'THROW (CADR L))
       (LIST 'SETQ 'CATCH (AND [CDDR L] [LIST 'QUOTE (CADDR L)]))
       '(ERR 'THROW)))
(dca time nil 0)
(dca timer t f)
(dca times nil w *times)
(dca trace t f)
(dca tracev t f)
(dca ttyecho t 0)
(dca ttyin t macro)
(dca ttymsg t cmacro (u (without nil (msg . u))))
(dca ttyout t macro)
(dca ttypause t 1)
(dca tyi t 0)
(dca tyo t 1)
(dca tyoa t 2)
(dca type t f)
(dca ucilisp: cmacro (u ()))
(dca ugeti nil 0)
(dca ugeto nil 0)
(dca unbound nil 0)
(dca unbreak t f)
(dca unbreakin t 1)
(dca until nil macro)
(dca union nil 2)
(dca unmacexpand nil 1)
(dca unsave t f)
(dca untrace t f)
(dca untracev t f)
(dca untyi t 1)
(dca unwind-protect t f)
(dca uptime nil 0)
(dca useti t 1)
(dca v: t f)
(dca vectorblt t 5)
(dca vectorlength nil 1)
(dca vectorp nil 1)
(dca while nil macro)
(dca with t xmacro withmac)
(DE WITHMAC (L)
 (CONS (CONS 'LAMBDA
	      (CONS (MAPCAR (FUNCTION (LAMBDA (V)
                      (COND [(ATOM V) V] [T (CAR V)]))) (CADR L))
	      (CDDR L)))
       (MAPCAR (FUNCTION (LAMBDA (V) (COND [(ATOM V) NIL] [T (CADR V)])))
		 (CADR L))))
(dca within t f)
(dca without t f)
(dca xcons nil 2)
(dca zerop nil 1)





    